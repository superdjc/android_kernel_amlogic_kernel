block/partition-generic.c:	pdev->class = &block_class;
block/partition-generic.c:	pdev->type = &part_type;
block/partition-generic.c:	pdev->parent = ddev;
block/partition-generic.c:	pdev->devt = devt;
block/partition-generic.c:	p->holder_dir = kobject_create_and_add("holders", &pdev->kobj);
block/partition-generic.c:		kobject_uevent(&pdev->kobj, KOBJ_ADD);
fs/pstore/ram.c:	struct device *dev = &pdev->dev;
fs/pstore/ram.c:	struct ramoops_platform_data *pdata = pdev->dev.platform_data;
fs/nfs/nfs4filelayoutdev.c:	xdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);
fs/nfs/nfs4filelayoutdev.c:				&pdev->dev_id);
fs/nfs/nfs4filelayoutdev.c:	memcpy(&pdev->dev_id, dev_id, sizeof(*dev_id));
fs/nfs/nfs4filelayoutdev.c:	pdev->layout_type = LAYOUT_NFSV4_1_FILES;
fs/nfs/nfs4filelayoutdev.c:	pdev->pages = pages;
fs/nfs/nfs4filelayoutdev.c:	pdev->pgbase = 0;
fs/nfs/nfs4filelayoutdev.c:	pdev->pglen = max_resp_sz;
fs/nfs/nfs4filelayoutdev.c:	pdev->mincount = 0;
fs/nfs/nfs4xdr.c:	p = xdr_encode_opaque_fixed(p, args->pdev->dev_id.data,
fs/nfs/nfs4xdr.c:	*p++ = cpu_to_be32(args->pdev->layout_type);
fs/nfs/nfs4xdr.c:	*p++ = cpu_to_be32(args->pdev->pglen);		/* gdia_maxcount */
fs/nfs/nfs4xdr.c:			 args->pdev->pages, args->pdev->pgbase,
fs/nfs/nfs4xdr.c:			 args->pdev->pglen);
fs/nfs/nfs4xdr.c:			pdev->mincount = be32_to_cpup(p);
fs/nfs/nfs4xdr.c:				__func__, pdev->mincount);
fs/nfs/nfs4xdr.c:	if (type != pdev->layout_type) {
fs/nfs/nfs4xdr.c:			__func__, pdev->layout_type, type);
fs/nfs/nfs4xdr.c:	pdev->mincount = be32_to_cpup(p);
fs/nfs/nfs4xdr.c:	if (xdr_read_pages(xdr, pdev->mincount) != pdev->mincount)
fs/cifs/dir.c:		memcpy(pdev->type, "IntxCHR", 8);
fs/cifs/dir.c:		pdev->major =
fs/cifs/dir.c:		pdev->minor =
fs/cifs/dir.c:		memcpy(pdev->type, "IntxBLK", 8);
fs/cifs/dir.c:		pdev->major =
fs/cifs/dir.c:		pdev->minor =
net/core/dev.c:			if (!pdev->dma_mask || addr + PAGE_SIZE - 1 > *pdev->dma_mask)
net/tipc/eth_media.c:		if (!strncmp(pdev->name, driver_name, IFNAMSIZ)) {
net/tipc/ib_media.c:		if (!strncmp(pdev->name, driver_name, IFNAMSIZ)) {
net/dsa/dsa.c:	struct device_node *np = pdev->dev.of_node;
net/dsa/dsa.c:	pdev->dev.platform_data = pd;
net/dsa/dsa.c:	pdev->dev.platform_data = NULL;
net/dsa/dsa.c:	struct dsa_platform_data *pd = pdev->dev.platform_data;
net/dsa/dsa.c:	if (!pdev->dev.of_node)
net/dsa/dsa.c:	struct dsa_platform_data *pd = pdev->dev.platform_data;
net/dsa/dsa.c:	if (pdev->dev.of_node) {
net/dsa/dsa.c:		pd = pdev->dev.platform_data;
net/dsa/dsa.c:		ds = dsa_switch_setup(dst, i, &pdev->dev, bus);
net/rfkill/rfkill-regulator.c:	struct rfkill_regulator_platform_data *pdata = pdev->dev.platform_data;
net/rfkill/rfkill-regulator.c:		dev_err(&pdev->dev, "no platform data\n");
net/rfkill/rfkill-regulator.c:		dev_err(&pdev->dev, "invalid name or type in platform data\n");
net/rfkill/rfkill-regulator.c:	vcc = regulator_get_exclusive(&pdev->dev, "vrfkill");
net/rfkill/rfkill-regulator.c:		dev_err(&pdev->dev, "Cannot get vcc for %s\n", pdata->name);
net/rfkill/rfkill-regulator.c:	rf_kill = rfkill_alloc(pdata->name, &pdev->dev,
net/rfkill/rfkill-regulator.c:		dev_dbg(&pdev->dev, "Regulator already enabled\n");
net/rfkill/rfkill-regulator.c:		dev_err(&pdev->dev, "Cannot register rfkill device\n");
net/rfkill/rfkill-regulator.c:	dev_info(&pdev->dev, "%s initialized\n", pdata->name);
net/rfkill/rfkill-gpio.c:	struct rfkill_gpio_platform_data *pdata = pdev->dev.platform_data;
net/rfkill/rfkill-gpio.c:		rfkill->pwr_clk = clk_get(&pdev->dev, pdata->power_clk_name);
net/rfkill/rfkill-gpio.c:	rfkill->rfkill_dev = rfkill_alloc(pdata->name, &pdev->dev, pdata->type,
net/rfkill/rfkill-gpio.c:	dev_info(&pdev->dev, "%s device registered.\n", pdata->name);
net/rfkill/rfkill-gpio.c:	struct rfkill_gpio_platform_data *pdata = pdev->dev.platform_data;
net/wireless/reg.c:	return kobject_uevent(&reg_pdev->dev.kobj, KOBJ_CHANGE);
net/wireless/reg.c:	reg_pdev->dev.type = &reg_device_type;
net/wireless/reg.c:	dev_set_uevent_suppress(&reg_pdev->dev, true);
virt/kvm/iommu.c:	r = iommu_attach_device(domain, &pdev->dev);
virt/kvm/iommu.c:		dev_err(&pdev->dev, "kvm assign device failed ret %d", r);
virt/kvm/iommu.c:	pdev->dev_flags |= PCI_DEV_FLAGS_ASSIGNED;
virt/kvm/iommu.c:	iommu_detach_device(domain, &pdev->dev);
virt/kvm/iommu.c:	pdev->dev_flags &= ~PCI_DEV_FLAGS_ASSIGNED;
include/asm-generic/pci-dma-compat.h:	return dma_mapping_error(&pdev->dev, dma_addr);
include/linux/pci-acpi.h:	struct pci_bus *pbus = pdev->bus;
include/linux/pnp.h:	return dev_get_drvdata(&pdev->dev);
include/linux/pnp.h:	dev_set_drvdata(&pdev->dev, data);
include/linux/mmc/sdhci-spear.h:/* This function is used to set platform_data field of pdev->dev */
include/linux/mmc/sdhci-spear.h:	pdev->dev.platform_data = data;
include/linux/pci.h:	return (pdev->error_state != pci_channel_io_normal);
include/linux/pci.h:	return (atomic_read(&pdev->enable_cnt) > 0);
include/linux/pci.h:	return pdev->is_managed;
include/linux/pci.h:		dma_pool_create(name, &pdev->dev, size, align, allocation)
include/linux/pci.h:	return dev_get_drvdata(&pdev->dev);
include/linux/pci.h:	dev_set_drvdata(&pdev->dev, data);
include/linux/pci.h:	return dev_name(&pdev->dev);
include/linux/pci.h:	return pdev ? pdev->dev.of_node : NULL;
include/linux/pci.h:	return pdev->dev.archdata.edev;
include/linux/pata_arasan_cf_data.h:	pdev->dev.platform_data = data;
include/linux/rpmsg.h:	u32 src = rpdev->src, dst = rpdev->dst;
include/linux/rpmsg.h:	u32 src = rpdev->src;
include/linux/rpmsg.h:	u32 src = rpdev->src, dst = rpdev->dst;
include/linux/rpmsg.h:	u32 src = rpdev->src;
include/linux/platform_device.h:	return dev_get_drvdata(&pdev->dev);
include/linux/platform_device.h:	dev_set_drvdata(&pdev->dev, data);
include/linux/platform_device.h:	return !pdev->dev.driver;
include/linux/cb710.h:	return &chip->pdev->dev;
include/linux/mfd/intel_msic.h:#define pdev_to_intel_msic(pdev)	(dev_get_drvdata(pdev->dev.parent))
include/linux/mfd/core.h:	return pdev->mfd_cell;
include/linux/mfd/88pm80x.h:	struct pm80x_chip *chip = dev_get_drvdata(pdev->dev.parent);
include/linux/mfd/88pm80x.h:	struct pm80x_chip *chip = dev_get_drvdata(pdev->dev.parent);
include/linux/ssb/ssb_driver_gige.h:	return container_of(pdev->bus->ops, struct ssb_gige, pci_ops);
drivers/gpio/gpio-rcar.c:	dev_dbg(&p->pdev->dev, "sense irq = %d, type = %d\n", hwirq, type);
drivers/gpio/gpio-rcar.c:	dev_dbg(&p->pdev->dev, "map hw irq = %d, virq = %d\n", (int)hw, virq);
drivers/gpio/gpio-rcar.c:	struct gpio_rcar_config *pdata = pdev->dev.platform_data;
drivers/gpio/gpio-rcar.c:	const char *name = dev_name(&pdev->dev);
drivers/gpio/gpio-rcar.c:	p = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);
drivers/gpio/gpio-rcar.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/gpio/gpio-rcar.c:		dev_err(&pdev->dev, "missing IRQ or IOMEM\n");
drivers/gpio/gpio-rcar.c:	p->base = devm_ioremap_nocache(&pdev->dev, io->start,
drivers/gpio/gpio-rcar.c:		dev_err(&pdev->dev, "failed to remap I/O memory\n");
drivers/gpio/gpio-rcar.c:	p->irq_domain = irq_domain_add_simple(pdev->dev.of_node,
drivers/gpio/gpio-rcar.c:		dev_err(&pdev->dev, "cannot initialize irq domain\n");
drivers/gpio/gpio-rcar.c:	if (devm_request_irq(&pdev->dev, irq->start,
drivers/gpio/gpio-rcar.c:		dev_err(&pdev->dev, "failed to request IRQ\n");
drivers/gpio/gpio-rcar.c:		dev_err(&pdev->dev, "failed to add GPIO controller\n");
drivers/gpio/gpio-rcar.c:	dev_info(&pdev->dev, "driving %d GPIOs\n", p->config.number_of_pins);
drivers/gpio/gpio-rcar.c:			dev_warn(&pdev->dev, "irq base mismatch (%u/%u)\n",
drivers/gpio/gpio-rcar.c:		dev_warn(&pdev->dev, "failed to add pin range\n");
drivers/gpio/gpio-clps711x.c:	gpio = devm_kzalloc(&pdev->dev, sizeof(struct clps711x_gpio),
drivers/gpio/gpio-clps711x.c:		dev_err(&pdev->dev, "GPIO allocating memory error\n");
drivers/gpio/gpio-clps711x.c:		gpio->chip[i].dev		= &pdev->dev;
drivers/gpio/gpio-clps711x.c:	dev_info(&pdev->dev, "GPIO driver initialized\n");
drivers/gpio/gpio-vx855.c:	dev_info(&pdev->dev, "found VX855 GPIO controller\n");
drivers/gpio/gpio-vx855.c:		dev_warn(&pdev->dev,
drivers/gpio/gpio-vx855.c:		dev_warn(&pdev->dev,
drivers/gpio/gpio-vx855.c:		dev_err(&pdev->dev, "failed to register GPIOs\n");
drivers/gpio/gpio-vx855.c:		dev_err(&pdev->dev, "unable to remove gpio_chip?\n");
drivers/gpio/gpio-tps6586x.c:	pdata = dev_get_platdata(pdev->dev.parent);
drivers/gpio/gpio-tps6586x.c:	tps6586x_gpio = devm_kzalloc(&pdev->dev,
drivers/gpio/gpio-tps6586x.c:		dev_err(&pdev->dev, "Could not allocate tps6586x_gpio\n");
drivers/gpio/gpio-tps6586x.c:	tps6586x_gpio->parent = pdev->dev.parent;
drivers/gpio/gpio-tps6586x.c:	tps6586x_gpio->gpio_chip.label = pdev->name;
drivers/gpio/gpio-tps6586x.c:	tps6586x_gpio->gpio_chip.dev = &pdev->dev;
drivers/gpio/gpio-tps6586x.c:	tps6586x_gpio->gpio_chip.of_node = pdev->dev.parent->of_node;
drivers/gpio/gpio-tps6586x.c:		dev_err(&pdev->dev, "Could not register gpiochip, %d\n", ret);
drivers/gpio/gpio-adp5520.c:	struct adp5520_gpio_platform_data *pdata = pdev->dev.platform_data;
drivers/gpio/gpio-adp5520.c:		dev_err(&pdev->dev, "missing platform data\n");
drivers/gpio/gpio-adp5520.c:	if (pdev->id != ID_ADP5520) {
drivers/gpio/gpio-adp5520.c:		dev_err(&pdev->dev, "only ADP5520 supports GPIO\n");
drivers/gpio/gpio-adp5520.c:	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
drivers/gpio/gpio-adp5520.c:		dev_err(&pdev->dev, "failed to alloc memory\n");
drivers/gpio/gpio-adp5520.c:	dev->master = pdev->dev.parent;
drivers/gpio/gpio-adp5520.c:	gc->label = pdev->name;
drivers/gpio/gpio-adp5520.c:		dev_err(&pdev->dev, "failed to write\n");
drivers/gpio/gpio-adp5520.c:		dev_err(&pdev->dev, "%s failed, %d\n",
drivers/gpio/gpio-em.c:	struct gpio_em_config *pdata = pdev->dev.platform_data;
drivers/gpio/gpio-em.c:	const char *name = dev_name(&pdev->dev);
drivers/gpio/gpio-em.c:	p = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);
drivers/gpio/gpio-em.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/gpio/gpio-em.c:		dev_err(&pdev->dev, "missing IRQ or IOMEM\n");
drivers/gpio/gpio-em.c:	p->base0 = devm_ioremap_nocache(&pdev->dev, io[0]->start,
drivers/gpio/gpio-em.c:		dev_err(&pdev->dev, "failed to remap low I/O memory\n");
drivers/gpio/gpio-em.c:	p->base1 = devm_ioremap_nocache(&pdev->dev, io[1]->start,
drivers/gpio/gpio-em.c:		dev_err(&pdev->dev, "failed to remap high I/O memory\n");
drivers/gpio/gpio-em.c:		if (of_property_read_u32(pdev->dev.of_node, "ngpios",
drivers/gpio/gpio-em.c:			dev_err(&pdev->dev, "Missing ngpios OF property\n");
drivers/gpio/gpio-em.c:		ret = of_alias_get_id(pdev->dev.of_node, "gpio");
drivers/gpio/gpio-em.c:			dev_err(&pdev->dev, "Couldn't get OF id\n");
drivers/gpio/gpio-em.c:	p->irq_domain = irq_domain_add_simple(pdev->dev.of_node,
drivers/gpio/gpio-em.c:		dev_err(&pdev->dev, "cannot initialize irq domain\n");
drivers/gpio/gpio-em.c:	if (devm_request_irq(&pdev->dev, irq[0]->start,
drivers/gpio/gpio-em.c:		dev_err(&pdev->dev, "failed to request low IRQ\n");
drivers/gpio/gpio-em.c:	if (devm_request_irq(&pdev->dev, irq[1]->start,
drivers/gpio/gpio-em.c:		dev_err(&pdev->dev, "failed to request high IRQ\n");
drivers/gpio/gpio-em.c:		dev_err(&pdev->dev, "failed to add GPIO controller\n");
drivers/gpio/gpio-wm8350.c:	struct wm8350 *wm8350 = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-wm8350.c:	wm8350_gpio = devm_kzalloc(&pdev->dev, sizeof(*wm8350_gpio),
drivers/gpio/gpio-wm8350.c:	wm8350_gpio->gpio_chip.dev = &pdev->dev;
drivers/gpio/gpio-wm8350.c:		dev_err(&pdev->dev, "Could not register gpiochip, %d\n", ret);
drivers/gpio/gpio-lynxpoint.c:	pm_runtime_get(&lg->pdev->dev); /* should we put if failed */
drivers/gpio/gpio-lynxpoint.c:		dev_err(&lg->pdev->dev, "gpio %d reserved for ACPI\n", offset);
drivers/gpio/gpio-lynxpoint.c:	pm_runtime_put(&lg->pdev->dev);
drivers/gpio/gpio-lynxpoint.c:	struct device *dev = &pdev->dev;
drivers/gpio/gpio-lynxpoint.c:		dev_warn(&pdev->dev, "failed to remove gpio_chip.\n");
drivers/gpio/gpio-cs5535.c:		dev_info(&chip->pdev->dev,
drivers/gpio/gpio-cs5535.c:		dev_err(&pdev->dev, "can't fetch device resource info\n");
drivers/gpio/gpio-cs5535.c:	if (!request_region(res->start, resource_size(res), pdev->name)) {
drivers/gpio/gpio-cs5535.c:		dev_err(&pdev->dev, "can't request region\n");
drivers/gpio/gpio-cs5535.c:	dev_info(&pdev->dev, "reserved resource region %pR\n", res);
drivers/gpio/gpio-cs5535.c:		dev_info(&pdev->dev, "mask changed from 0x%08lX to 0x%08lX\n",
drivers/gpio/gpio-cs5535.c:		dev_err(&pdev->dev, "unable to remove gpio_chip?\n");
drivers/gpio/gpio-msm-v1.c:	base1 = devm_request_and_ioremap(&pdev->dev, res);
drivers/gpio/gpio-msm-v1.c:	base2 = devm_request_and_ioremap(&pdev->dev, res);
drivers/gpio/gpio-amd8111.c:	dev_dbg(&agp->pdev->dev, "Requested gpio %d, data %x\n", offset, agp->orig[offset]);
drivers/gpio/gpio-amd8111.c:	dev_dbg(&agp->pdev->dev, "Freed gpio %d, data %x\n", offset, agp->orig[offset]);
drivers/gpio/gpio-amd8111.c:	dev_dbg(&agp->pdev->dev, "Setting gpio %d, value %d, reg=%02x\n", offset, !!value, temp);
drivers/gpio/gpio-amd8111.c:	dev_dbg(&agp->pdev->dev, "Getting gpio %d, reg=%02x\n", offset, temp);
drivers/gpio/gpio-amd8111.c:	dev_dbg(&agp->pdev->dev, "Dirout gpio %d, value %d, reg=%02x\n", offset, !!value, temp);
drivers/gpio/gpio-amd8111.c:	dev_dbg(&agp->pdev->dev, "Dirin gpio %d, reg=%02x\n", offset, temp);
drivers/gpio/gpio-amd8111.c:		dev_err(&pdev->dev, "AMD GPIO region 0x%x already in use!\n",
drivers/gpio/gpio-amd8111.c:	gp.chip.dev = &pdev->dev;
drivers/gpio/gpio-rc5t583.c:	struct rc5t583 *rc5t583 = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-rc5t583.c:	rc5t583_gpio = devm_kzalloc(&pdev->dev, sizeof(*rc5t583_gpio),
drivers/gpio/gpio-rc5t583.c:		dev_warn(&pdev->dev, "Mem allocation for rc5t583_gpio failed");
drivers/gpio/gpio-rc5t583.c:	rc5t583_gpio->gpio_chip.dev = &pdev->dev;
drivers/gpio/gpio-langwell.c:		pm_runtime_get(&lnw->pdev->dev);
drivers/gpio/gpio-langwell.c:		pm_runtime_put(&lnw->pdev->dev);
drivers/gpio/gpio-langwell.c:		pm_runtime_get(&lnw->pdev->dev);
drivers/gpio/gpio-langwell.c:		pm_runtime_put(&lnw->pdev->dev);
drivers/gpio/gpio-langwell.c:		pm_runtime_get(&lnw->pdev->dev);
drivers/gpio/gpio-langwell.c:		pm_runtime_put(&lnw->pdev->dev);
drivers/gpio/gpio-langwell.c:		dev_err(&pdev->dev, "error requesting resources\n");
drivers/gpio/gpio-langwell.c:		dev_err(&pdev->dev, "error mapping bar1\n");
drivers/gpio/gpio-langwell.c:	base = devm_ioremap_nocache(&pdev->dev, start, len);
drivers/gpio/gpio-langwell.c:		dev_err(&pdev->dev, "error mapping bar0\n");
drivers/gpio/gpio-langwell.c:	lnw = devm_kzalloc(&pdev->dev, sizeof(*lnw), GFP_KERNEL);
drivers/gpio/gpio-langwell.c:		dev_err(&pdev->dev, "can't allocate langwell_gpio chip data\n");
drivers/gpio/gpio-langwell.c:	lnw->chip.label = dev_name(&pdev->dev);
drivers/gpio/gpio-langwell.c:	lnw->domain = irq_domain_add_simple(pdev->dev.of_node, ngpio, irq_base,
drivers/gpio/gpio-langwell.c:		dev_err(&pdev->dev, "langwell gpiochip_add error %d\n", retval);
drivers/gpio/gpio-langwell.c:	irq_set_handler_data(pdev->irq, lnw);
drivers/gpio/gpio-langwell.c:	irq_set_chained_handler(pdev->irq, lnw_irq_handler);
drivers/gpio/gpio-langwell.c:	pm_runtime_put_noidle(&pdev->dev);
drivers/gpio/gpio-langwell.c:	pm_runtime_allow(&pdev->dev);
drivers/gpio/gpio-langwell.c:		dev_err(&pdev->dev,
drivers/gpio/gpio-langwell.c:	gc->label = dev_name(&pdev->dev);
drivers/gpio/gpio-langwell.c:		dev_err(&pdev->dev, "whitneypoint gpiochip_add error %d\n",
drivers/gpio/gpio-langwell.c:		dev_err(&pdev->dev, "failed to remove gpio_chip.\n");
drivers/gpio/gpio-palmas.c:	struct palmas *palmas = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-palmas.c:	palmas_gpio = devm_kzalloc(&pdev->dev,
drivers/gpio/gpio-palmas.c:		dev_err(&pdev->dev, "Could not allocate palmas_gpio\n");
drivers/gpio/gpio-palmas.c:	palmas_gpio->gpio_chip.label = dev_name(&pdev->dev);
drivers/gpio/gpio-palmas.c:	palmas_gpio->gpio_chip.dev = &pdev->dev;
drivers/gpio/gpio-palmas.c:		dev_err(&pdev->dev, "Could not register gpiochip, %d\n", ret);
drivers/gpio/gpio-pch.c:	chip->dev = &pdev->dev;
drivers/gpio/gpio-pch.c:		dev_err(&pdev->dev, "%s : pci_enable_device FAILED", __func__);
drivers/gpio/gpio-pch.c:		dev_err(&pdev->dev, "pci_request_regions FAILED-%d", ret);
drivers/gpio/gpio-pch.c:		dev_err(&pdev->dev, "%s : pci_iomap FAILED", __func__);
drivers/gpio/gpio-pch.c:	if (pdev->device == 0x8803)
drivers/gpio/gpio-pch.c:	else if (pdev->device == 0x8014)
drivers/gpio/gpio-pch.c:	else if (pdev->device == 0x8043)
drivers/gpio/gpio-pch.c:		dev_err(&pdev->dev, "PCH gpio: Failed to register GPIO\n");
drivers/gpio/gpio-pch.c:		dev_warn(&pdev->dev, "PCH gpio: Failed to get IRQ base num\n");
drivers/gpio/gpio-pch.c:	ret = request_irq(pdev->irq, pch_gpio_handler,
drivers/gpio/gpio-pch.c:		dev_err(&pdev->dev,
drivers/gpio/gpio-pch.c:		dev_err(&pdev->dev, "%s gpiochip_remove failed\n", __func__);
drivers/gpio/gpio-pch.c:	dev_err(&pdev->dev, "%s Failed returns %d\n", __func__, ret);
drivers/gpio/gpio-pch.c:		free_irq(pdev->irq, chip);
drivers/gpio/gpio-pch.c:		dev_err(&pdev->dev, "Failed gpiochip_remove\n");
drivers/gpio/gpio-pch.c:		dev_err(&pdev->dev, "pci_save_state Failed-%d\n", ret);
drivers/gpio/gpio-pch.c:		dev_err(&pdev->dev, "pci_enable_wake Failed -%d\n", ret);
drivers/gpio/gpio-pch.c:		dev_err(&pdev->dev, "pci_enable_device Failed-%d ", ret);
drivers/gpio/gpio-mvebu.c:	struct device_node *np = pdev->dev.of_node;
drivers/gpio/gpio-mvebu.c:	match = of_match_device(mvebu_gpio_of_match, &pdev->dev);
drivers/gpio/gpio-mvebu.c:		dev_err(&pdev->dev, "Cannot get memory resource\n");
drivers/gpio/gpio-mvebu.c:	mvchip = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_gpio_chip), GFP_KERNEL);
drivers/gpio/gpio-mvebu.c:		dev_err(&pdev->dev, "Cannot allocate memory\n");
drivers/gpio/gpio-mvebu.c:	if (of_property_read_u32(pdev->dev.of_node, "ngpios", &ngpios)) {
drivers/gpio/gpio-mvebu.c:		dev_err(&pdev->dev, "Missing ngpios OF property\n");
drivers/gpio/gpio-mvebu.c:	id = of_alias_get_id(pdev->dev.of_node, "gpio");
drivers/gpio/gpio-mvebu.c:		dev_err(&pdev->dev, "Couldn't get OF id\n");
drivers/gpio/gpio-mvebu.c:	clk = devm_clk_get(&pdev->dev, NULL);
drivers/gpio/gpio-mvebu.c:	mvchip->chip.label = dev_name(&pdev->dev);
drivers/gpio/gpio-mvebu.c:	mvchip->chip.dev = &pdev->dev;
drivers/gpio/gpio-mvebu.c:	mvchip->membase = devm_ioremap_resource(&pdev->dev, res);
drivers/gpio/gpio-mvebu.c:		mvchip->percpu_membase = devm_ioremap_resource(&pdev->dev,
drivers/gpio/gpio-mvebu.c:		dev_err(&pdev->dev, "no irqs\n");
drivers/gpio/gpio-mvebu.c:		dev_err(&pdev->dev, "Cannot allocate generic irq_chip\n");
drivers/gpio/gpio-mvebu.c:		dev_err(&pdev->dev, "couldn't allocate irq domain %s (DT).\n",
drivers/gpio/gpio-pxa.c:	struct device_node *prev, *next, *np = pdev->dev.of_node;
drivers/gpio/gpio-pxa.c:				of_match_device(pxa_gpio_dt_ids, &pdev->dev);
drivers/gpio/gpio-pxa.c:		dev_err(&pdev->dev, "Failed to find gpio controller\n");
drivers/gpio/gpio-pxa.c:		dev_err(&pdev->dev, "Failed to find child gpio node\n");
drivers/gpio/gpio-pxa.c:		dev_err(&pdev->dev, "Failed to allocate IRQ numbers\n");
drivers/gpio/gpio-pxa.c:	info = dev_get_platdata(&pdev->dev);
drivers/gpio/gpio-pxa.c:	clk = clk_get(&pdev->dev, NULL);
drivers/gpio/gpio-pxa.c:		dev_err(&pdev->dev, "Error %ld to get gpio clock\n",
drivers/gpio/gpio-mxs.c:			of_match_device(mxs_gpio_dt_ids, &pdev->dev);
drivers/gpio/gpio-mxs.c:	struct device_node *np = pdev->dev.of_node;
drivers/gpio/gpio-mxs.c:	port = devm_kzalloc(&pdev->dev, sizeof(*port), GFP_KERNEL);
drivers/gpio/gpio-mxs.c:		port->id = pdev->id;
drivers/gpio/gpio-mxs.c:		port->devid = pdev->id_entry->driver_data;
drivers/gpio/gpio-mxs.c:			base = devm_ioremap_resource(&pdev->dev, iores);
drivers/gpio/gpio-mxs.c:	err = bgpio_init(&port->bgc, &pdev->dev, 4,
drivers/gpio/gpio-sta2x11.c:	gpio_pdata = dev_get_platdata(&pdev->dev);
drivers/gpio/gpio-sta2x11.c:	err = request_irq(pdev->irq, gsta_gpio_handler,
drivers/gpio/gpio-sta2x11.c:	free_irq(pdev->irq, chip);
drivers/gpio/gpio-wm831x.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-wm831x.c:	wm831x_gpio = devm_kzalloc(&pdev->dev, sizeof(*wm831x_gpio),
drivers/gpio/gpio-wm831x.c:	wm831x_gpio->gpio_chip.dev = &pdev->dev;
drivers/gpio/gpio-wm831x.c:		dev_err(&pdev->dev, "Could not register gpiochip, %d\n", ret);
drivers/gpio/gpio-twl6040.c:	struct twl6040_gpo_data *pdata = pdev->dev.platform_data;
drivers/gpio/gpio-twl6040.c:	struct device *twl6040_core_dev = pdev->dev.parent;
drivers/gpio/gpio-twl6040.c:	twl6040gpo_chip.dev = &pdev->dev;
drivers/gpio/gpio-twl6040.c:		dev_err(&pdev->dev, "could not register gpiochip, %d\n", ret);
drivers/gpio/gpio-mxc.c:			of_match_device(mxc_gpio_dt_ids, &pdev->dev);
drivers/gpio/gpio-mxc.c:		pdev->id_entry = of_id->data;
drivers/gpio/gpio-mxc.c:	hwtype = pdev->id_entry->driver_data;
drivers/gpio/gpio-mxc.c:	struct device_node *np = pdev->dev.of_node;
drivers/gpio/gpio-mxc.c:				pdev->name)) {
drivers/gpio/gpio-mxc.c:	err = bgpio_init(&port->bgc, &pdev->dev, 4,
drivers/gpio/gpio-mxc.c:	port->bgc.gc.base = (pdev->id < 0) ? of_alias_get_id(np, "gpio") * 32 :
drivers/gpio/gpio-mxc.c:					     pdev->id * 32;
drivers/gpio/gpio-mxc.c:	dev_info(&pdev->dev, "%s failed with errno %d\n", __func__, err);
drivers/gpio/gpio-stp-xway.c:		dev_err(&pdev->dev, "failed to request STP resource\n");
drivers/gpio/gpio-stp-xway.c:	chip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);
drivers/gpio/gpio-stp-xway.c:	chip->virt = devm_ioremap_resource(&pdev->dev, res);
drivers/gpio/gpio-stp-xway.c:	chip->gc.dev = &pdev->dev;
drivers/gpio/gpio-stp-xway.c:	shadow = of_get_property(pdev->dev.of_node, "lantiq,shadow", NULL);
drivers/gpio/gpio-stp-xway.c:	groups = of_get_property(pdev->dev.of_node, "lantiq,groups", NULL);
drivers/gpio/gpio-stp-xway.c:	dsl = of_get_property(pdev->dev.of_node, "lantiq,dsl", NULL);
drivers/gpio/gpio-stp-xway.c:		phy = of_get_property(pdev->dev.of_node, "lantiq,phy1", NULL);
drivers/gpio/gpio-stp-xway.c:		phy = of_get_property(pdev->dev.of_node, "lantiq,phy2", NULL);
drivers/gpio/gpio-stp-xway.c:	if (!of_find_property(pdev->dev.of_node, "lantiq,rising", NULL))
drivers/gpio/gpio-stp-xway.c:	clk = clk_get(&pdev->dev, NULL);
drivers/gpio/gpio-stp-xway.c:		dev_err(&pdev->dev, "Failed to get clock\n");
drivers/gpio/gpio-stp-xway.c:		dev_info(&pdev->dev, "Init done\n");
drivers/gpio/gpio-tegra.c:	match = of_match_device(tegra_gpio_of_match, &pdev->dev);
drivers/gpio/gpio-tegra.c:		dev_err(&pdev->dev, "Error: No device match found\n");
drivers/gpio/gpio-tegra.c:		dev_err(&pdev->dev, "Missing IRQ resource\n");
drivers/gpio/gpio-tegra.c:	tegra_gpio_banks = devm_kzalloc(&pdev->dev,
drivers/gpio/gpio-tegra.c:		dev_err(&pdev->dev, "Couldn't allocate bank structure\n");
drivers/gpio/gpio-tegra.c:	irq_domain = irq_domain_add_linear(pdev->dev.of_node,
drivers/gpio/gpio-tegra.c:			dev_err(&pdev->dev, "Missing IRQ resource\n");
drivers/gpio/gpio-tegra.c:	regs = devm_ioremap_resource(&pdev->dev, res);
drivers/gpio/gpio-tegra.c:	tegra_gpio_chip.of_node = pdev->dev.of_node;
drivers/gpio/gpio-arizona.c:	struct arizona *arizona = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-arizona.c:	arizona_gpio = devm_kzalloc(&pdev->dev, sizeof(*arizona_gpio),
drivers/gpio/gpio-arizona.c:	arizona_gpio->gpio_chip.dev = &pdev->dev;
drivers/gpio/gpio-arizona.c:		dev_err(&pdev->dev, "Unknown chip variant %d\n",
drivers/gpio/gpio-arizona.c:		dev_err(&pdev->dev, "Could not register gpiochip, %d\n",
drivers/gpio/gpio-lpc32xx.c:		if (pdev->dev.of_node) {
drivers/gpio/gpio-lpc32xx.c:			lpc32xx_gpiochip[i].chip.of_node = pdev->dev.of_node;
drivers/gpio/gpio-wm8994.c:	struct wm8994 *wm8994 = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-wm8994.c:	wm8994_gpio = devm_kzalloc(&pdev->dev, sizeof(*wm8994_gpio),
drivers/gpio/gpio-wm8994.c:	wm8994_gpio->gpio_chip.dev = &pdev->dev;
drivers/gpio/gpio-wm8994.c:		dev_err(&pdev->dev, "Could not register gpiochip, %d\n",
drivers/gpio/gpio-spear-spics.c:	struct device_node *np = pdev->dev.of_node;
drivers/gpio/gpio-spear-spics.c:		dev_err(&pdev->dev, "invalid IORESOURCE_MEM\n");
drivers/gpio/gpio-spear-spics.c:	spics = devm_kzalloc(&pdev->dev, sizeof(*spics), GFP_KERNEL);
drivers/gpio/gpio-spear-spics.c:		dev_err(&pdev->dev, "memory allocation fail\n");
drivers/gpio/gpio-spear-spics.c:	spics->base = devm_ioremap_resource(&pdev->dev, res);
drivers/gpio/gpio-spear-spics.c:	spics->chip.label = dev_name(&pdev->dev);
drivers/gpio/gpio-spear-spics.c:	spics->chip.dev = &pdev->dev;
drivers/gpio/gpio-spear-spics.c:		dev_err(&pdev->dev, "unable to add gpio chip\n");
drivers/gpio/gpio-spear-spics.c:	dev_info(&pdev->dev, "spear spics registered\n");
drivers/gpio/gpio-spear-spics.c:	dev_err(&pdev->dev, "DT probe failed\n");
drivers/gpio/gpio-generic.c:	struct device *dev = &pdev->dev;
drivers/gpio/gpio-generic.c:	struct device *dev = &pdev->dev;
drivers/gpio/gpio-generic.c:	bgc = devm_kzalloc(&pdev->dev, sizeof(*bgc), GFP_KERNEL);
drivers/gpio/gpio-da9055.c:	gpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);
drivers/gpio/gpio-da9055.c:	gpio->da9055 = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-da9055.c:		dev_err(&pdev->dev, "Could not register gpiochip, %d\n", ret);
drivers/gpio/gpio-tps65910.c:	struct tps65910 *tps65910 = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-tps65910.c:	tps65910_gpio = devm_kzalloc(&pdev->dev,
drivers/gpio/gpio-tps65910.c:		dev_err(&pdev->dev, "Could not allocate tps65910_gpio\n");
drivers/gpio/gpio-tps65910.c:	tps65910_gpio->gpio_chip.dev = &pdev->dev;
drivers/gpio/gpio-tps65910.c:		pdata = tps65910_parse_dt_for_gpio(&pdev->dev, tps65910,
drivers/gpio/gpio-tps65910.c:		dev_err(&pdev->dev, "Could not register gpiochip, %d\n", ret);
drivers/gpio/gpio-omap.c:	struct device *dev = &pdev->dev;
drivers/gpio/gpio-omap.c:				     pdev->name)) {
drivers/gpio/gpio-twl4030.c:	struct twl4030_gpio_platform_data *pdata = pdev->dev.platform_data;
drivers/gpio/gpio-twl4030.c:	struct device_node *node = pdev->dev.of_node;
drivers/gpio/gpio-twl4030.c:	priv = devm_kzalloc(&pdev->dev, sizeof(struct gpio_twl4030_priv),
drivers/gpio/gpio-twl4030.c:		dev_err(&pdev->dev, "can't dispatch IRQs from modules\n");
drivers/gpio/gpio-twl4030.c:		dev_err(&pdev->dev, "Failed to alloc irq_descs\n");
drivers/gpio/gpio-twl4030.c:	ret = twl4030_sih_setup(&pdev->dev, TWL4030_MODULE_GPIO, irq_base);
drivers/gpio/gpio-twl4030.c:	priv->gpio_chip.dev = &pdev->dev;
drivers/gpio/gpio-twl4030.c:		pdata = of_gpio_twl4030(&pdev->dev);
drivers/gpio/gpio-twl4030.c:		dev_err(&pdev->dev, "Platform data is missing\n");
drivers/gpio/gpio-twl4030.c:		dev_dbg(&pdev->dev, "pullups %.05x %.05x --> %d\n",
drivers/gpio/gpio-twl4030.c:		dev_dbg(&pdev->dev, "debounce %.03x %.01x --> %d\n",
drivers/gpio/gpio-twl4030.c:		dev_err(&pdev->dev, "could not register gpiochip, %d\n", ret);
drivers/gpio/gpio-twl4030.c:		status = pdata->setup(&pdev->dev, priv->gpio_chip.base,
drivers/gpio/gpio-twl4030.c:			dev_dbg(&pdev->dev, "setup --> %d\n", status);
drivers/gpio/gpio-twl4030.c:	struct twl4030_gpio_platform_data *pdata = pdev->dev.platform_data;
drivers/gpio/gpio-twl4030.c:		status = pdata->teardown(&pdev->dev, priv->gpio_chip.base,
drivers/gpio/gpio-twl4030.c:			dev_dbg(&pdev->dev, "teardown --> %d\n", status);
drivers/gpio/gpio-rdc321x.c:	pdata = pdev->dev.platform_data;
drivers/gpio/gpio-rdc321x.c:		dev_err(&pdev->dev, "no platform data supplied\n");
drivers/gpio/gpio-rdc321x.c:		dev_err(&pdev->dev, "failed to allocate private data\n");
drivers/gpio/gpio-rdc321x.c:		dev_err(&pdev->dev, "failed to get gpio-reg1 resource\n");
drivers/gpio/gpio-rdc321x.c:		dev_err(&pdev->dev, "failed to get gpio-reg2 resource\n");
drivers/gpio/gpio-rdc321x.c:	dev_info(&pdev->dev, "registering %d GPIOs\n",
drivers/gpio/gpio-rdc321x.c:		dev_err(&pdev->dev, "failed to unregister chip\n");
drivers/gpio/gpio-ml-ioh.c:		dev_err(&pdev->dev, "%s : pci_enable_device failed", __func__);
drivers/gpio/gpio-ml-ioh.c:		dev_err(&pdev->dev, "pci_request_regions failed-%d", ret);
drivers/gpio/gpio-ml-ioh.c:		dev_err(&pdev->dev, "%s : pci_iomap failed", __func__);
drivers/gpio/gpio-ml-ioh.c:		dev_err(&pdev->dev, "%s : kzalloc failed", __func__);
drivers/gpio/gpio-ml-ioh.c:		chip->dev = &pdev->dev;
drivers/gpio/gpio-ml-ioh.c:			dev_err(&pdev->dev, "IOH gpio: Failed to register GPIO\n");
drivers/gpio/gpio-ml-ioh.c:			dev_warn(&pdev->dev,
drivers/gpio/gpio-ml-ioh.c:	ret = request_irq(pdev->irq, ioh_gpio_handler,
drivers/gpio/gpio-ml-ioh.c:		dev_err(&pdev->dev,
drivers/gpio/gpio-ml-ioh.c:			dev_err(&pdev->dev, "Failed gpiochip_remove(%d)\n", i);
drivers/gpio/gpio-ml-ioh.c:	dev_err(&pdev->dev, "%s Failed returns %d\n", __func__, ret);
drivers/gpio/gpio-ml-ioh.c:	free_irq(pdev->irq, chip);
drivers/gpio/gpio-ml-ioh.c:			dev_err(&pdev->dev, "Failed gpiochip_remove\n");
drivers/gpio/gpio-ml-ioh.c:		dev_err(&pdev->dev, "pci_save_state Failed-%d\n", ret);
drivers/gpio/gpio-ml-ioh.c:		dev_err(&pdev->dev, "pci_enable_wake Failed -%d\n", ret);
drivers/gpio/gpio-ml-ioh.c:		dev_err(&pdev->dev, "pci_enable_device Failed-%d ", ret);
drivers/gpio/gpio-ep93xx.c:	if (!request_mem_region(res->start, resource_size(res), pdev->name)) {
drivers/gpio/gpio-ep93xx.c:		if (ep93xx_gpio_add_bank(bgc, &pdev->dev, mmio, bank))
drivers/gpio/gpio-ep93xx.c:			dev_warn(&pdev->dev, "Unable to add gpio bank %s\n",
drivers/gpio/gpio-ep93xx.c:	dev_info(&pdev->dev, "%s failed with errno %d\n", __func__, ret);
drivers/gpio/gpio-sch.c:	id = pdev->id;
drivers/gpio/gpio-sch.c:	if (!request_region(res->start, resource_size(res), pdev->name))
drivers/gpio/gpio-sch.c:	sch_gpio_core.dev = &pdev->dev;
drivers/gpio/gpio-sch.c:	sch_gpio_resume.dev = &pdev->dev;
drivers/gpio/gpio-sch.c:		dev_err(&pdev->dev, "%s gpiochip_remove failed\n", __func__);
drivers/gpio/gpio-sch.c:			dev_err(&pdev->dev, "%s failed, %d\n",
drivers/gpio/gpio-sch.c:			dev_err(&pdev->dev, "%s failed, %d\n",
drivers/gpio/gpio-ts5500.c:	struct ts5500_dio_platform_data *pdata = pdev->dev.platform_data;
drivers/gpio/gpio-ts5500.c:	struct device *dev = &pdev->dev;
drivers/gpio/gpio-mm-lantiq.c:		dev_err(&pdev->dev, "failed to get memory resource\n");
drivers/gpio/gpio-mm-lantiq.c:	shadow = of_get_property(pdev->dev.of_node, "lantiq,shadow", NULL);
drivers/gpio/gpio-mm-lantiq.c:	ret = of_mm_gpiochip_add(pdev->dev.of_node, &chip->mmchip);
drivers/gpio/gpio-ich.c:	struct lpc_ich_info *ich_info = pdev->dev.platform_data;
drivers/gpio/gpio-ich.c:	err = ichx_gpio_request_regions(res_base, pdev->name,
drivers/gpio/gpio-ich.c:			pdev->name)) {
drivers/gpio/gpio-ich.c:		dev_err(&pdev->dev, "%s failed, %d\n",
drivers/gpio/gpio-janz-ttl.c:	struct device *dev = &pdev->dev;
drivers/gpio/gpio-janz-ttl.c:	pdata = pdev->dev.platform_data;
drivers/gpio/gpio-janz-ttl.c:	gpio->dev = &pdev->dev;
drivers/gpio/gpio-janz-ttl.c:	gpio->label = pdev->name;
drivers/gpio/gpio-janz-ttl.c:	struct device *dev = &pdev->dev;
drivers/gpio/gpio-vr41xx.c:	switch (pdev->id) {
drivers/gpio/gpio-vr41xx.c:		dev_err(&pdev->dev, "GIU: unknown ID %d\n", pdev->id);
drivers/gpio/gpio-vr41xx.c:	vr41xx_gpio_chip.dev = &pdev->dev;
drivers/gpio/gpio-timberdale.c:	struct timbgpio_platform_data *pdata = pdev->dev.platform_data;
drivers/gpio/gpio-timberdale.c:	gc->label = dev_name(&pdev->dev);
drivers/gpio/gpio-timberdale.c:	gc->dev = &pdev->dev;
drivers/gpio/gpio-timberdale.c:	struct timbgpio_platform_data *pdata = pdev->dev.platform_data;
drivers/gpio/gpio-stmpe.c:	struct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-stmpe.c:	struct device_node *np = pdev->dev.of_node;
drivers/gpio/gpio-stmpe.c:	stmpe_gpio->dev = &pdev->dev;
drivers/gpio/gpio-stmpe.c:	stmpe_gpio->chip.dev = &pdev->dev;
drivers/gpio/gpio-stmpe.c:		dev_info(&pdev->dev,
drivers/gpio/gpio-stmpe.c:			dev_err(&pdev->dev, "unable to get irq: %d\n", ret);
drivers/gpio/gpio-stmpe.c:		dev_err(&pdev->dev, "unable to add gpiochip: %d\n", ret);
drivers/gpio/gpio-da9052.c:	gpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);
drivers/gpio/gpio-da9052.c:	gpio->da9052 = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-da9052.c:		dev_err(&pdev->dev, "Could not register gpiochip, %d\n", ret);
drivers/gpio/gpio-msic.c:	struct device *dev = &pdev->dev;
drivers/gpio/gpio-viperboard.c:	struct vprbrd *vb = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-viperboard.c:	vb_gpio = devm_kzalloc(&pdev->dev, sizeof(*vb_gpio), GFP_KERNEL);
drivers/gpio/gpio-viperboard.c:	vb_gpio->gpioa.dev = &pdev->dev;
drivers/gpio/gpio-viperboard.c:	vb_gpio->gpiob.dev = &pdev->dev;
drivers/gpio/gpio-viperboard.c:		dev_err(&pdev->dev, "%s gpiochip_remove failed\n", __func__);
drivers/gpio/gpio-tps65912.c:	struct tps65912 *tps65912 = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-tps65912.c:	tps65912_gpio = devm_kzalloc(&pdev->dev, sizeof(*tps65912_gpio),
drivers/gpio/gpio-tps65912.c:	tps65912_gpio->gpio_chip.dev = &pdev->dev;
drivers/gpio/gpio-tps65912.c:		dev_err(&pdev->dev, "Failed to register gpiochip, %d\n", ret);
drivers/gpio/gpio-tc3589x.c:	struct tc3589x *tc3589x = dev_get_drvdata(pdev->dev.parent);
drivers/gpio/gpio-tc3589x.c:	struct device_node *np = pdev->dev.of_node;
drivers/gpio/gpio-tc3589x.c:		dev_err(&pdev->dev, "No platform data or Device Tree found\n");
drivers/gpio/gpio-tc3589x.c:	tc3589x_gpio->dev = &pdev->dev;
drivers/gpio/gpio-tc3589x.c:	tc3589x_gpio->chip.dev = &pdev->dev;
drivers/gpio/gpio-tc3589x.c:		dev_err(&pdev->dev, "unable to get irq: %d\n", ret);
drivers/gpio/gpio-tc3589x.c:		dev_err(&pdev->dev, "unable to add gpiochip: %d\n", ret);
drivers/gpio/gpio-bt8xx.c:	c->label = dev_name(&bg->pdev->dev);
drivers/gpio/gpio-sodaville.c:	ret = request_irq(pdev->irq, sdv_gpio_pub_irq_handler, IRQF_SHARED,
drivers/gpio/gpio-sodaville.c:	sd->id = irq_domain_add_legacy(pdev->dev.of_node, SDV_NUM_PUB_GPIOS,
drivers/gpio/gpio-sodaville.c:	free_irq(pdev->irq, sd);
drivers/gpio/gpio-sodaville.c:		dev_err(&pdev->dev, "can't enable device.\n");
drivers/gpio/gpio-sodaville.c:		dev_err(&pdev->dev, "can't alloc PCI BAR #%d\n", GPIO_BAR);
drivers/gpio/gpio-sodaville.c:	prop = of_get_property(pdev->dev.of_node, "intel,muxctl", &len);
drivers/gpio/gpio-sodaville.c:	ret = bgpio_init(&sd->bgpio, &pdev->dev, 4,
drivers/gpio/gpio-sodaville.c:		dev_err(&pdev->dev, "gpiochip_add() failed.\n");
drivers/gpio/gpio-sodaville.c:	dev_info(&pdev->dev, "Sodaville GPIO driver registered.\n");
drivers/gpio/gpio-sodaville.c:	free_irq(pdev->irq, sd);
drivers/gpio/gpio-sodaville.c:		dev_err(&pdev->dev, "gpiochip_remove() failed.\n");
drivers/pnp/pnpacpi/core.c: * pnpdev->dev.archdata.acpi_handle point to its ACPI sibling.
drivers/pnp/quirks.c:					 pci_name(pdev), i, &pdev->resource[i]);
drivers/hwspinlock/omap_hwspinlock.c:	struct hwspinlock_pdata *pdata = pdev->dev.platform_data;
drivers/hwspinlock/omap_hwspinlock.c:	pm_runtime_enable(&pdev->dev);
drivers/hwspinlock/omap_hwspinlock.c:	ret = hwspin_lock_register(bank, &pdev->dev, &omap_hwspinlock_ops,
drivers/hwspinlock/omap_hwspinlock.c:	pm_runtime_disable(&pdev->dev);
drivers/hwspinlock/omap_hwspinlock.c:		dev_err(&pdev->dev, "%s failed: %d\n", __func__, ret);
drivers/hwspinlock/omap_hwspinlock.c:	pm_runtime_disable(&pdev->dev);
drivers/hwspinlock/u8500_hsem.c:	struct hwspinlock_pdata *pdata = pdev->dev.platform_data;
drivers/hwspinlock/u8500_hsem.c:	pm_runtime_enable(&pdev->dev);
drivers/hwspinlock/u8500_hsem.c:	ret = hwspin_lock_register(bank, &pdev->dev, &u8500_hwspinlock_ops,
drivers/hwspinlock/u8500_hsem.c:	pm_runtime_disable(&pdev->dev);
drivers/hwspinlock/u8500_hsem.c:		dev_err(&pdev->dev, "%s failed: %d\n", __func__, ret);
drivers/hwspinlock/u8500_hsem.c:	pm_runtime_disable(&pdev->dev);
drivers/crypto/omap-aes.c:	struct device *dev = &pdev->dev;
drivers/crypto/omap-aes.c:	struct device *dev = &pdev->dev;
drivers/crypto/atmel-sha.c:	struct device *dev = &pdev->dev;
drivers/crypto/atmel-sha.c:	sha_dd->iclk = clk_get(&pdev->dev, "sha_clk");
drivers/crypto/atmel-sha.c:		pdata = pdev->dev.platform_data;
drivers/crypto/atmel-sha.c:			dev_err(&pdev->dev, "platform data not available\n");
drivers/crypto/bfin_crc.c:	struct device *dev = &pdev->dev;
drivers/crypto/bfin_crc.c:		dev_err(&pdev->dev, "fail to malloc bfin_crypto_crc\n");
drivers/crypto/bfin_crc.c:		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
drivers/crypto/bfin_crc.c:		dev_err(&pdev->dev, "Cannot map CRC IO\n");
drivers/crypto/bfin_crc.c:		dev_err(&pdev->dev, "No CRC DCNTEXP IRQ specified\n");
drivers/crypto/bfin_crc.c:		dev_err(&pdev->dev, "Unable to request blackfin crc irq\n");
drivers/crypto/bfin_crc.c:		dev_err(&pdev->dev, "No CRC DMA channel specified\n");
drivers/crypto/bfin_crc.c:		dev_err(&pdev->dev, "Unable to attach Blackfin CRC DMA channel\n");
drivers/crypto/bfin_crc.c:	crc->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE, &crc->sg_dma, GFP_KERNEL);
drivers/crypto/bfin_crc.c:	crc->regs->poly = crc->poly = (u32)pdev->dev.platform_data;
drivers/crypto/bfin_crc.c:		dev_info(&pdev->dev, "init crc poly timeout\n");
drivers/crypto/bfin_crc.c:		dev_err(&pdev->dev, "Cann't register crypto ahash device\n");
drivers/crypto/bfin_crc.c:	dev_info(&pdev->dev, "initialized\n");
drivers/crypto/bfin_crc.c:		dma_free_coherent(&pdev->dev, PAGE_SIZE, crc->sg_cpu, crc->sg_dma);
drivers/crypto/ux500/hash/hash_core.c:	struct device		*dev = &pdev->dev;
drivers/crypto/ux500/hash/hash_core.c:	res = request_mem_region(res->start, resource_size(res), pdev->name);
drivers/crypto/ux500/hash/hash_core.c:	struct device		*dev = &pdev->dev;
drivers/crypto/ux500/hash/hash_core.c:		dev_err(&pdev->dev, "[%s] platform_get_drvdata() failed!",
drivers/crypto/ux500/hash/hash_core.c:			dev_dbg(&pdev->dev, "[%s]: Cryp still in use!"
drivers/crypto/ux500/hash/hash_core.c:		dev_err(&pdev->dev, "[%s] hash_disable_power() failed",
drivers/crypto/ux500/cryp/cryp_core.c:	struct device *dev = &pdev->dev;
drivers/crypto/ux500/cryp/cryp_core.c:	res = request_mem_region(res->start, resource_size(res), pdev->name);
drivers/crypto/ux500/cryp/cryp_core.c:	device_data->pwr_regulator = regulator_get(&pdev->dev, "v-ape");
drivers/crypto/ux500/cryp/cryp_core.c:	device_data->clk = clk_get(&pdev->dev, NULL);
drivers/crypto/ux500/cryp/cryp_core.c:	dev_dbg(&pdev->dev, "[%s]", __func__);
drivers/crypto/ux500/cryp/cryp_core.c:		dev_err(&pdev->dev, "[%s]: platform_get_drvdata() failed!",
drivers/crypto/ux500/cryp/cryp_core.c:		dev_err(&pdev->dev, "[%s]: IORESOURCE_IRQ, unavailable",
drivers/crypto/ux500/cryp/cryp_core.c:	if (cryp_disable_power(&pdev->dev, device_data, false))
drivers/crypto/ux500/cryp/cryp_core.c:		dev_err(&pdev->dev, "[%s]: cryp_disable_power() failed",
drivers/crypto/ux500/cryp/cryp_core.c:	dev_dbg(&pdev->dev, "[%s]", __func__);
drivers/crypto/ux500/cryp/cryp_core.c:		dev_err(&pdev->dev, "[%s]: platform_get_drvdata() failed!",
drivers/crypto/ux500/cryp/cryp_core.c:			dev_dbg(&pdev->dev, "[%s]: Cryp still in use!"
drivers/crypto/ux500/cryp/cryp_core.c:		dev_err(&pdev->dev, "[%s]: IORESOURCE_IRQ, unavailable",
drivers/crypto/ux500/cryp/cryp_core.c:	if (cryp_disable_power(&pdev->dev, device_data, false))
drivers/crypto/ux500/cryp/cryp_core.c:		dev_err(&pdev->dev, "[%s]: cryp_disable_power() failed",
drivers/crypto/tegra-aes.c:	struct device *dev = &pdev->dev;
drivers/crypto/tegra-aes.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
drivers/crypto/tegra-aes.c:				     dev_name(&pdev->dev))) {
drivers/crypto/tegra-aes.c:		dev_err(&pdev->dev, "Couldn't request MEM resource\n");
drivers/crypto/tegra-aes.c:	struct device *dev = &pdev->dev;
drivers/crypto/picoxcell_crypto.c:	if (of_device_is_compatible(pdev->dev.of_node, spacc_type))
drivers/crypto/picoxcell_crypto.c:	struct spacc_engine *engine = devm_kzalloc(&pdev->dev, sizeof(*engine),
drivers/crypto/picoxcell_crypto.c:	engine->name = dev_name(&pdev->dev);
drivers/crypto/picoxcell_crypto.c:		dev_err(&pdev->dev, "no memory/irq resource for engine\n");
drivers/crypto/picoxcell_crypto.c:	if (!devm_request_mem_region(&pdev->dev, mem->start, resource_size(mem),
drivers/crypto/picoxcell_crypto.c:	engine->regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
drivers/crypto/picoxcell_crypto.c:		dev_err(&pdev->dev, "memory map failed\n");
drivers/crypto/picoxcell_crypto.c:	if (devm_request_irq(&pdev->dev, irq->start, spacc_spacc_irq, 0,
drivers/crypto/picoxcell_crypto.c:	engine->dev		= &pdev->dev;
drivers/crypto/picoxcell_crypto.c:	engine->clk = clk_get(&pdev->dev, "ref");
drivers/crypto/picoxcell_crypto.c:		dev_info(&pdev->dev, "clk unavailable\n");
drivers/crypto/picoxcell_crypto.c:		device_remove_file(&pdev->dev, &dev_attr_stat_irq_thresh);
drivers/crypto/picoxcell_crypto.c:		dev_info(&pdev->dev, "unable to enable clk\n");
drivers/crypto/picoxcell_crypto.c:	err = device_create_file(&pdev->dev, &dev_attr_stat_irq_thresh);
drivers/crypto/picoxcell_crypto.c:	device_remove_file(&pdev->dev, &dev_attr_stat_irq_thresh);
drivers/crypto/s5p-sss.c:	struct device      *dev = &pdev->dev;
drivers/crypto/s5p-sss.c:				     resource_size(res), pdev->name))
drivers/crypto/s5p-sss.c:			       IRQF_SHARED, pdev->name, pdev);
drivers/crypto/s5p-sss.c:			       IRQF_SHARED, pdev->name, pdev);
drivers/crypto/sahara.c:	dev = devm_kzalloc(&pdev->dev, sizeof(struct sahara_dev), GFP_KERNEL);
drivers/crypto/sahara.c:		dev_err(&pdev->dev, "unable to alloc data struct.\n");
drivers/crypto/sahara.c:	dev->device = &pdev->dev;
drivers/crypto/sahara.c:		dev_err(&pdev->dev, "failed to get memory region resource\n");
drivers/crypto/sahara.c:	if (devm_request_mem_region(&pdev->dev, res->start,
drivers/crypto/sahara.c:		dev_err(&pdev->dev, "failed to request memory region\n");
drivers/crypto/sahara.c:	dev->regs_base = devm_ioremap(&pdev->dev, res->start,
drivers/crypto/sahara.c:		dev_err(&pdev->dev, "failed to ioremap address region\n");
drivers/crypto/sahara.c:		dev_err(&pdev->dev, "failed to get irq resource\n");
drivers/crypto/sahara.c:	if (devm_request_irq(&pdev->dev, irq, sahara_irq_handler,
drivers/crypto/sahara.c:		dev_err(&pdev->dev, "failed to request irq\n");
drivers/crypto/sahara.c:	dev->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
drivers/crypto/sahara.c:		dev_err(&pdev->dev, "Could not get ipg clock\n");
drivers/crypto/sahara.c:	dev->clk_ahb = devm_clk_get(&pdev->dev, "ahb");
drivers/crypto/sahara.c:		dev_err(&pdev->dev, "Could not get ahb clock\n");
drivers/crypto/sahara.c:	dev->hw_desc[0] = dma_alloc_coherent(&pdev->dev,
drivers/crypto/sahara.c:		dev_err(&pdev->dev, "Could not allocate hw descriptors\n");
drivers/crypto/sahara.c:	dev->key_base = dma_alloc_coherent(&pdev->dev, 2 * AES_KEYSIZE_128,
drivers/crypto/sahara.c:		dev_err(&pdev->dev, "Could not allocate memory for key\n");
drivers/crypto/sahara.c:	dev->hw_link[0] = dma_alloc_coherent(&pdev->dev,
drivers/crypto/sahara.c:		dev_err(&pdev->dev, "Could not allocate hw links\n");
drivers/crypto/sahara.c:		dev_err(&pdev->dev, "SAHARA version %d not supported\n",
drivers/crypto/sahara.c:	dev_info(&pdev->dev, "SAHARA version %d initialized\n", version);
drivers/crypto/sahara.c:	dma_free_coherent(&pdev->dev,
drivers/crypto/sahara.c:	dma_free_coherent(&pdev->dev,
drivers/crypto/sahara.c:	dma_free_coherent(&pdev->dev,
drivers/crypto/sahara.c:	dma_free_coherent(&pdev->dev,
drivers/crypto/sahara.c:	dma_free_coherent(&pdev->dev,
drivers/crypto/sahara.c:	dma_free_coherent(&pdev->dev,
drivers/crypto/atmel-aes.c:	struct device *dev = &pdev->dev;
drivers/crypto/atmel-aes.c:	pdata = pdev->dev.platform_data;
drivers/crypto/atmel-aes.c:	aes_dd->iclk = clk_get(&pdev->dev, "aes_clk");
drivers/crypto/hifn_795x.c:		if (pci2id[i].pci_vendor == dev->pdev->vendor &&
drivers/crypto/hifn_795x.c:				pci2id[i].pci_prod == dev->pdev->device) {
drivers/crypto/hifn_795x.c:	dev->irq = pdev->irq;
drivers/crypto/mv_cesa.c:	if (pdev->dev.of_node)
drivers/crypto/mv_cesa.c:		irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
drivers/crypto/mv_cesa.c:	ret = request_irq(irq, crypto_int, IRQF_DISABLED, dev_name(&pdev->dev),
drivers/crypto/mv_cesa.c:	cp->clk = clk_get(&pdev->dev, NULL);
drivers/crypto/omap-sham.c:	struct device *dev = &pdev->dev;
drivers/crypto/omap-sham.c:	struct device *dev = &pdev->dev;
drivers/crypto/omap-sham.c:	pm_runtime_put_sync(&pdev->dev);
drivers/crypto/omap-sham.c:	pm_runtime_disable(&pdev->dev);
drivers/crypto/atmel-tdes.c:	struct device *dev = &pdev->dev;
drivers/crypto/atmel-tdes.c:	tdes_dd->iclk = clk_get(&pdev->dev, "tdes_clk");
drivers/crypto/atmel-tdes.c:		pdata = pdev->dev.platform_data;
drivers/crypto/atmel-tdes.c:			dev_err(&pdev->dev, "platform data not available\n");
drivers/crypto/caam/caamhash.c:	ctrldev = &pdev->dev;
drivers/crypto/caam/caamhash.c:	ctrldev = &pdev->dev;
drivers/crypto/caam/caamalg.c:	ctrldev = &pdev->dev;
drivers/crypto/caam/caamalg.c:	ctrldev = &pdev->dev;
drivers/crypto/caam/jr.c:	ctrldev = &pdev->dev;
drivers/crypto/caam/jr.c:	jrdev = &jr_pdev->dev;
drivers/crypto/caam/ctrl.c:	ctrldev = &pdev->dev;
drivers/crypto/caam/ctrl.c:	struct device *ctrldev = &pdev->dev;
drivers/crypto/caam/ctrl.c:	dev = &pdev->dev;
drivers/crypto/caam/ctrl.c:	nprop = pdev->dev.of_node;
drivers/crypto/caam/caamrng.c:	ctrldev = &pdev->dev;
drivers/iommu/omap-iommu.c:	struct iommu_platform_data *pdata = pdev->dev.platform_data;
drivers/iommu/omap-iommu.c:	struct iommu_platform_data *pdata = pdev->dev.platform_data;
drivers/iommu/omap-iommu.c:	struct iommu_platform_data *pdata = pdev->dev.platform_data;
drivers/iommu/omap-iommu.c:	obj->dev = &pdev->dev;
drivers/iommu/omap-iommu.c:				 dev_name(&pdev->dev));
drivers/iommu/omap-iommu.c:			  dev_name(&pdev->dev), obj);
drivers/iommu/omap-iommu.c:	dev_info(&pdev->dev, "%s registered\n", obj->name);
drivers/iommu/omap-iommu.c:	dev_info(&pdev->dev, "%s removed\n", obj->name);
drivers/iommu/msm_iommu.c:		if (!ctx_drvdata->pdev || !ctx_drvdata->pdev->dev.parent)
drivers/iommu/msm_iommu.c:		iommu_drvdata = dev_get_drvdata(ctx_drvdata->pdev->dev.parent);
drivers/iommu/msm_iommu.c:	iommu_drvdata = dev_get_drvdata(ctx_drvdata->pdev->dev.parent);
drivers/iommu/exynos-iommu.c:	for (i = 0; i < (pdev->num_resources / 2); i++) {
drivers/iommu/exynos-iommu.c:	if (i == pdev->num_resources) {
drivers/iommu/exynos-iommu.c:	dev = &pdev->dev;
drivers/iommu/exynos-iommu.c:	data->nsfrs = pdev->num_resources / 2;
drivers/iommu/msm_iommu_dev.c:	struct msm_iommu_dev *iommu_dev = pdev->dev.platform_data;
drivers/iommu/msm_iommu_dev.c:	if (pdev->id == -1) {
drivers/iommu/msm_iommu_dev.c:	iommu_clk = clk_get(&pdev->dev, "iommu_clk");
drivers/iommu/msm_iommu_dev.c:	struct msm_iommu_ctx_dev *c = pdev->dev.platform_data;
drivers/iommu/msm_iommu_dev.c:	if (!c || !pdev->dev.parent) {
drivers/iommu/msm_iommu_dev.c:	drvdata = dev_get_drvdata(pdev->dev.parent);
drivers/iommu/msm_iommu_dev.c:	dev_info(&pdev->dev, "context %s using bank %d\n", c->name, c->num);
drivers/iommu/intel-iommu.c:#define IS_GFX_DEVICE(pdev) ((pdev->class >> 16) == PCI_BASE_CLASS_DISPLAY)
drivers/iommu/intel-iommu.c:#define IS_ISA_DEVICE(pdev) ((pdev->class >> 8) == PCI_CLASS_BRIDGE_ISA)
drivers/iommu/intel-iommu.c:			r = &pdev->resource[i];
drivers/iommu/intel-iommu.c:	ret = domain_context_mapping_one(domain, pci_domain_nr(pdev->bus),
drivers/iommu/intel-iommu.c:					 pdev->bus->number, pdev->devfn,
drivers/iommu/intel-iommu.c:	parent = pdev->bus->self;
drivers/iommu/intel-iommu.c:	iommu = device_to_iommu(pci_domain_nr(pdev->bus), pdev->bus->number,
drivers/iommu/intel-iommu.c:				pdev->devfn);
drivers/iommu/intel-iommu.c:	ret = device_context_mapped(iommu, pdev->bus->number, pdev->devfn);
drivers/iommu/intel-iommu.c:	parent = pdev->bus->self;
drivers/iommu/intel-iommu.c:	info = pdev->dev.archdata.iommu;
drivers/iommu/intel-iommu.c:	segment = pci_domain_nr(pdev->bus);
drivers/iommu/intel-iommu.c:	info->bus = pdev->bus->number;
drivers/iommu/intel-iommu.c:	info->devfn = pdev->devfn;
drivers/iommu/intel-iommu.c:	pdev->dev.archdata.iommu = info;
drivers/iommu/intel-iommu.c:	if (pdev->dev.archdata.iommu == DUMMY_DEVICE_DOMAIN_INFO)
drivers/iommu/intel-iommu.c:	info = pdev->dev.archdata.iommu;
drivers/iommu/intel-iommu.c:	info->segment = pci_domain_nr(pdev->bus);
drivers/iommu/intel-iommu.c:	info->bus = pdev->bus->number;
drivers/iommu/intel-iommu.c:	info->devfn = pdev->devfn;
drivers/iommu/intel-iommu.c:	pdev->dev.archdata.iommu = info;
drivers/iommu/intel-iommu.c:	    (pdev->class >> 8) != PCI_CLASS_SERIAL_USB)
drivers/iommu/intel-iommu.c:		if (!pci_is_root_bus(pdev->bus))
drivers/iommu/intel-iommu.c:		if (pdev->class >> 8 == PCI_CLASS_BRIDGE_PCI)
drivers/iommu/intel-iommu.c:		u64 dma_mask = pdev->dma_mask;
drivers/iommu/intel-iommu.c:		if (pdev->dev.coherent_dma_mask &&
drivers/iommu/intel-iommu.c:		    pdev->dev.coherent_dma_mask < dma_mask)
drivers/iommu/intel-iommu.c:			dma_mask = pdev->dev.coherent_dma_mask;
drivers/iommu/intel-iommu.c:		return dma_mask >= dma_get_required_mask(&pdev->dev);
drivers/iommu/intel-iommu.c:	return pdev->dev.archdata.iommu == DUMMY_DEVICE_DOMAIN_INFO;
drivers/iommu/intel-iommu.c:				pdev->dma_mask);
drivers/iommu/intel-iommu.c:	rc = pci_bus_read_config_dword(pdev->bus, PCI_DEVFN(0, 0), 0xb0, &vtbar);
drivers/iommu/intel-iommu.c:		dev_info(&pdev->dev, "failed to run vt-d quirk\n");
drivers/iommu/intel-iommu.c:		pdev->dev.archdata.iommu = DUMMY_DEVICE_DOMAIN_INFO;
drivers/iommu/intel-iommu.c:		parent = pdev->bus->self;
drivers/iommu/intel-iommu.c:	iommu = device_to_iommu(pci_domain_nr(pdev->bus), pdev->bus->number,
drivers/iommu/intel-iommu.c:				pdev->devfn);
drivers/iommu/intel-iommu.c:		if (info->segment == pci_domain_nr(pdev->bus) &&
drivers/iommu/intel-iommu.c:		    info->bus == pdev->bus->number &&
drivers/iommu/intel-iommu.c:		    info->devfn == pdev->devfn) {
drivers/iommu/intel-iommu.c:	iommu = device_to_iommu(pci_domain_nr(pdev->bus), pdev->bus->number,
drivers/iommu/intel-iommu.c:				pdev->devfn);
drivers/iommu/intel-iommu.c:	if (!device_to_iommu(pci_domain_nr(pdev->bus),
drivers/iommu/intel-iommu.c:			     pdev->bus->number, pdev->devfn))
drivers/iommu/intel-iommu.c:						pci_domain_nr(pdev->bus),
drivers/iommu/intel-iommu.c:	if (dma_pdev->multifunction &&
drivers/iommu/intel-iommu.c:			     pci_get_slot(dma_pdev->bus,
drivers/iommu/intel-iommu.c:					  PCI_DEVFN(PCI_SLOT(dma_pdev->devfn),
drivers/iommu/intel-iommu.c:	while (!pci_is_root_bus(dma_pdev->bus)) {
drivers/iommu/intel-iommu.c:		struct pci_bus *bus = dma_pdev->bus;
drivers/iommu/intel-iommu.c:	group = iommu_group_get(&dma_pdev->dev);
drivers/iommu/amd_iommu.c:	return PCI_DEVID(pdev->bus->number, pdev->devfn);
drivers/iommu/amd_iommu.c:	dev_data = get_dev_data(&pdev->dev);
drivers/iommu/amd_iommu.c:	if (dma_pdev->multifunction &&
drivers/iommu/amd_iommu.c:			     pci_get_slot(dma_pdev->bus,
drivers/iommu/amd_iommu.c:					  PCI_DEVFN(PCI_SLOT(dma_pdev->devfn),
drivers/iommu/amd_iommu.c:	while (!pci_is_root_bus(dma_pdev->bus)) {
drivers/iommu/amd_iommu.c:		struct pci_bus *bus = find_hosted_bus(dma_pdev->bus);
drivers/iommu/amd_iommu.c:	struct iommu_group *group = iommu_group_get(&pdev->dev);
drivers/iommu/amd_iommu.c:		WARN_ON(&pdev->dev != dev);
drivers/iommu/amd_iommu.c:		if (dma_pdev != bus->self || (dma_pdev->multifunction &&
drivers/iommu/amd_iommu.c:		if (!check_device(&pdev->dev))
drivers/iommu/amd_iommu.c:		iommu_uninit_device(&pdev->dev);
drivers/iommu/amd_iommu.c:		if (!check_device(&pdev->dev))
drivers/iommu/amd_iommu.c:		ret = iommu_init_device(&pdev->dev);
drivers/iommu/amd_iommu.c:			iommu_ignore_device(&pdev->dev);
drivers/iommu/amd_iommu.c:		if (!check_device(&pdev->dev)) {
drivers/iommu/amd_iommu.c:			iommu_ignore_device(&pdev->dev);
drivers/iommu/amd_iommu.c:		dev_data = get_dev_data(&pdev->dev);
drivers/iommu/amd_iommu.c:			pdev->dev.archdata.dma_ops = &amd_iommu_dma_ops;
drivers/iommu/amd_iommu.c:			pdev->dev.archdata.dma_ops = &nommu_dma_ops;
drivers/iommu/amd_iommu.c:	dev_data = get_dev_data(&pdev->dev);
drivers/iommu/amd_iommu.c:	domain = get_domain(&pdev->dev);
drivers/iommu/amd_iommu.c:	dev_data = get_dev_data(&pdev->dev);
drivers/iommu/amd_iommu.c:	devid = get_device_id(&pdev->dev);
drivers/iommu/amd_iommu.c:	devid		= get_device_id(&pdev->dev);
drivers/iommu/tegra-gart.c:	struct device *dev = &pdev->dev;
drivers/iommu/tegra-gart.c:	gart->dev = &pdev->dev;
drivers/iommu/amd_iommu_v2.c:	devid = pdev->bus->number;
drivers/iommu/amd_iommu_v2.c:	devid = (devid << 8) | pdev->devfn;
drivers/iommu/amd_iommu_v2.c:	iommu_detach_device(dev_state->domain, &dev_state->pdev->dev);
drivers/iommu/amd_iommu_v2.c:	ret = iommu_attach_device(dev_state->domain, &pdev->dev);
drivers/iommu/dmar.c:		bus = pdev->subordinate;
drivers/iommu/dmar.c:			pdev->subordinate) || (scope->entry_type == \
drivers/iommu/dmar.c:			ACPI_DMAR_SCOPE_TYPE_BRIDGE && !pdev->subordinate)) {
drivers/iommu/amd_iommu_proto.h:	return (pdev->vendor == PCI_VENDOR_ID_ATI) &&
drivers/iommu/amd_iommu_proto.h:	       (pdev->device == PCI_DEVICE_ID_RD890_IOMMU);
drivers/iommu/shmobile-ipmmu.c:	struct shmobile_ipmmu_platform_data *pdata = pdev->dev.platform_data;
drivers/iommu/shmobile-ipmmu.c:		dev_err(&pdev->dev, "cannot get platform resources\n");
drivers/iommu/shmobile-ipmmu.c:	ipmmu = devm_kzalloc(&pdev->dev, sizeof(*ipmmu), GFP_KERNEL);
drivers/iommu/shmobile-ipmmu.c:		dev_err(&pdev->dev, "cannot allocate device data\n");
drivers/iommu/shmobile-ipmmu.c:	ipmmu->dev = &pdev->dev;
drivers/iommu/shmobile-ipmmu.c:	ipmmu->ipmmu_base = devm_ioremap_nocache(&pdev->dev, res->start,
drivers/iommu/shmobile-ipmmu.c:		dev_err(&pdev->dev, "ioremap_nocache failed\n");
drivers/iommu/tegra-smmu.c:	struct device *dev = &pdev->dev;
drivers/iommu/tegra-smmu.c:	smmu->nregs = pdev->num_resources;
drivers/iommu/tegra-smmu.c:		smmu->regs[i] = devm_ioremap_resource(&pdev->dev, res);
drivers/parport/parport_ax88796.c:	struct device *_dev = &pdev->dev;
drivers/parport/parport_ax88796.c:	dd->io = request_mem_region(res->start, size, pdev->name);
drivers/parport/parport_ax88796.c:				  IRQF_TRIGGER_FALLING, pdev->name, pp);
drivers/parport/parport_pc.c:		dev = &pdev->dev;
drivers/parport/parport_pc.c:				   irq, PARPORT_DMA_NONE, &pdev->dev, 0)) {
drivers/parport/parport_pc.c:	if (parport_pc_probe_port(port1, port2, irq, dma, &pdev->dev, 0)) {
drivers/thermal/kirkwood_thermal.c:		dev_err(&pdev->dev, "Failed to get platform resource\n");
drivers/thermal/kirkwood_thermal.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
drivers/thermal/kirkwood_thermal.c:	priv->sensor = devm_ioremap_resource(&pdev->dev, res);
drivers/thermal/kirkwood_thermal.c:		dev_err(&pdev->dev,
drivers/thermal/db8500_thermal.c:	struct device_node *np = pdev->dev.of_node;
drivers/thermal/db8500_thermal.c:	ptrips = devm_kzalloc(&pdev->dev, sizeof(*ptrips), GFP_KERNEL);
drivers/thermal/db8500_thermal.c:	dev_err(&pdev->dev, "Parsing device tree data error.\n");
drivers/thermal/db8500_thermal.c:	struct device_node *np = pdev->dev.of_node;
drivers/thermal/db8500_thermal.c:		ptrips = dev_get_platdata(&pdev->dev);
drivers/thermal/db8500_thermal.c:	pzone = devm_kzalloc(&pdev->dev, sizeof(*pzone), GFP_KERNEL);
drivers/thermal/db8500_thermal.c:		dev_err(&pdev->dev, "Get IRQ_HOTMON_LOW failed.\n");
drivers/thermal/db8500_thermal.c:	ret = devm_request_threaded_irq(&pdev->dev, low_irq, NULL,
drivers/thermal/db8500_thermal.c:		dev_err(&pdev->dev, "Failed to allocate temp low irq.\n");
drivers/thermal/db8500_thermal.c:		dev_err(&pdev->dev, "Get IRQ_HOTMON_HIGH failed.\n");
drivers/thermal/db8500_thermal.c:	ret = devm_request_threaded_irq(&pdev->dev, high_irq, NULL,
drivers/thermal/db8500_thermal.c:		dev_err(&pdev->dev, "Failed to allocate temp high irq.\n");
drivers/thermal/db8500_thermal.c:		dev_err(&pdev->dev, "Register thermal zone device failed.\n");
drivers/thermal/db8500_thermal.c:	dev_info(&pdev->dev, "Thermal zone device registered.\n");
drivers/thermal/armada_thermal.c:	match = of_match_device(armada_thermal_id_table, &pdev->dev);
drivers/thermal/armada_thermal.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
drivers/thermal/armada_thermal.c:	priv->sensor = devm_ioremap_resource(&pdev->dev, res);
drivers/thermal/armada_thermal.c:	priv->control = devm_ioremap_resource(&pdev->dev, res);
drivers/thermal/armada_thermal.c:		dev_err(&pdev->dev,
drivers/thermal/rcar_thermal.c:	struct device *dev = &pdev->dev;
drivers/thermal/rcar_thermal.c:	struct device *dev = &pdev->dev;
drivers/thermal/db8500_cpufreq_cooling.c:		dev_err(&pdev->dev, "Failed to register cooling device\n");
drivers/thermal/db8500_cpufreq_cooling.c:	dev_info(&pdev->dev, "Cooling device registered: %s\n",	cdev->type);
drivers/thermal/dove_thermal.c:		dev_err(&pdev->dev, "Failed to get platform resource\n");
drivers/thermal/dove_thermal.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
drivers/thermal/dove_thermal.c:	priv->sensor = devm_ioremap_resource(&pdev->dev, res);
drivers/thermal/dove_thermal.c:	priv->control = devm_ioremap_resource(&pdev->dev, res);
drivers/thermal/dove_thermal.c:		dev_err(&pdev->dev, "Failed to initialize sensor\n");
drivers/thermal/dove_thermal.c:		dev_err(&pdev->dev,
drivers/thermal/spear_thermal.c:		dev_err(&pdev->dev, "Can't enable clock\n");
drivers/thermal/spear_thermal.c:	struct device_node *np = pdev->dev.of_node;
drivers/thermal/spear_thermal.c:		dev_err(&pdev->dev, "Failed: DT Pdata not passed\n");
drivers/thermal/spear_thermal.c:		dev_err(&pdev->dev, "memory resource missing\n");
drivers/thermal/spear_thermal.c:	stdev = devm_kzalloc(&pdev->dev, sizeof(*stdev), GFP_KERNEL);
drivers/thermal/spear_thermal.c:		dev_err(&pdev->dev, "kzalloc fail\n");
drivers/thermal/spear_thermal.c:	stdev->thermal_base = devm_ioremap(&pdev->dev, stres->start,
drivers/thermal/spear_thermal.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/thermal/spear_thermal.c:	stdev->clk = devm_clk_get(&pdev->dev, NULL);
drivers/thermal/spear_thermal.c:		dev_err(&pdev->dev, "Can't get clock\n");
drivers/thermal/spear_thermal.c:		dev_err(&pdev->dev, "Can't enable clock\n");
drivers/thermal/spear_thermal.c:		dev_err(&pdev->dev, "thermal zone device is NULL\n");
drivers/thermal/exynos_thermal.c:	if (pdev->dev.of_node) {
drivers/thermal/exynos_thermal.c:		match = of_match_node(exynos_tmu_match, pdev->dev.of_node);
drivers/thermal/exynos_thermal.c:	struct exynos_tmu_platform_data *pdata = pdev->dev.platform_data;
drivers/thermal/exynos_thermal.c:		dev_err(&pdev->dev, "No platform init data supplied.\n");
drivers/thermal/exynos_thermal.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct exynos_tmu_data),
drivers/thermal/exynos_thermal.c:		dev_err(&pdev->dev, "Failed to allocate driver structure\n");
drivers/thermal/exynos_thermal.c:		dev_err(&pdev->dev, "Failed to get platform irq\n");
drivers/thermal/exynos_thermal.c:	data->base = devm_ioremap_resource(&pdev->dev, data->mem);
drivers/thermal/exynos_thermal.c:	ret = devm_request_irq(&pdev->dev, data->irq, exynos_tmu_irq,
drivers/thermal/exynos_thermal.c:		dev_err(&pdev->dev, "Failed to request irq: %d\n", data->irq);
drivers/thermal/exynos_thermal.c:	data->clk = devm_clk_get(&pdev->dev, "tmu_apbif");
drivers/thermal/exynos_thermal.c:		dev_err(&pdev->dev, "Failed to get clock\n");
drivers/thermal/exynos_thermal.c:		dev_err(&pdev->dev, "Platform not supported\n");
drivers/thermal/exynos_thermal.c:		dev_err(&pdev->dev, "Failed to initialize TMU\n");
drivers/thermal/exynos_thermal.c:		dev_err(&pdev->dev, "Failed to register thermal interface\n");
drivers/remoteproc/da8xx_remoteproc.c:	struct device *dev = &pdev->dev;
drivers/remoteproc/da8xx_remoteproc.c:	struct device *dev = &pdev->dev;
drivers/remoteproc/omap_remoteproc.c:	struct omap_rproc_pdata *pdata = pdev->dev.platform_data;
drivers/remoteproc/omap_remoteproc.c:	struct omap_rproc_pdata *pdata = pdev->dev.platform_data;
drivers/remoteproc/omap_remoteproc.c:	struct omap_rproc_pdata *pdata = pdev->dev.platform_data;
drivers/remoteproc/omap_remoteproc.c:	ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/remoteproc/omap_remoteproc.c:		dev_err(&pdev->dev, "dma_set_coherent_mask: %d\n", ret);
drivers/remoteproc/omap_remoteproc.c:	rproc = rproc_alloc(&pdev->dev, pdata->name, &omap_rproc_ops,
drivers/virtio/virtio_mmio.c:	return vm_dev->pdev->name;
drivers/virtio/virtio_mmio.c:	if (!devm_request_mem_region(&pdev->dev, mem->start,
drivers/virtio/virtio_mmio.c:			resource_size(mem), pdev->name))
drivers/virtio/virtio_mmio.c:	vm_dev = devm_kzalloc(&pdev->dev, sizeof(*vm_dev), GFP_KERNEL);
drivers/virtio/virtio_mmio.c:	vm_dev->vdev.dev.parent = &pdev->dev;
drivers/virtio/virtio_mmio.c:	vm_dev->base = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
drivers/virtio/virtio_mmio.c:		dev_warn(&pdev->dev, "Wrong magic value 0x%08lx!\n", magic);
drivers/virtio/virtio_mmio.c:		dev_err(&pdev->dev, "Version %ld not supported!\n",
drivers/virtio/virtio_mmio.c:			pdev->resource[0].end - pdev->resource[0].start + 1ULL,
drivers/virtio/virtio_mmio.c:			(unsigned long long)pdev->resource[0].start,
drivers/virtio/virtio_mmio.c:			(unsigned long long)pdev->resource[1].start,
drivers/virtio/virtio_mmio.c:			pdev->id);
drivers/clocksource/sh_mtu2.c:	struct sh_timer_config *cfg = p->pdev->dev.platform_data;
drivers/clocksource/sh_mtu2.c:	struct sh_timer_config *cfg = p->pdev->dev.platform_data;
drivers/clocksource/sh_mtu2.c:	struct sh_timer_config *cfg = p->pdev->dev.platform_data;
drivers/clocksource/sh_mtu2.c:	pm_runtime_get_sync(&p->pdev->dev);
drivers/clocksource/sh_mtu2.c:	dev_pm_syscore_device(&p->pdev->dev, true);
drivers/clocksource/sh_mtu2.c:		dev_err(&p->pdev->dev, "cannot enable clock\n");
drivers/clocksource/sh_mtu2.c:	dev_pm_syscore_device(&p->pdev->dev, false);
drivers/clocksource/sh_mtu2.c:	pm_runtime_put(&p->pdev->dev);
drivers/clocksource/sh_mtu2.c:		dev_info(&p->pdev->dev, "used for periodic clock events\n");
drivers/clocksource/sh_mtu2.c:	pm_genpd_syscore_poweroff(&ced_to_sh_mtu2(ced)->pdev->dev);
drivers/clocksource/sh_mtu2.c:	pm_genpd_syscore_poweron(&ced_to_sh_mtu2(ced)->pdev->dev);
drivers/clocksource/sh_mtu2.c:	dev_info(&p->pdev->dev, "used for clock events\n");
drivers/clocksource/sh_mtu2.c:		dev_err(&p->pdev->dev, "failed to request irq %d\n",
drivers/clocksource/sh_mtu2.c:	struct sh_timer_config *cfg = pdev->dev.platform_data;
drivers/clocksource/sh_mtu2.c:		dev_err(&p->pdev->dev, "missing platform data\n");
drivers/clocksource/sh_mtu2.c:		dev_err(&p->pdev->dev, "failed to get I/O memory\n");
drivers/clocksource/sh_mtu2.c:		dev_err(&p->pdev->dev, "failed to get irq\n");
drivers/clocksource/sh_mtu2.c:		dev_err(&p->pdev->dev, "failed to remap I/O memory\n");
drivers/clocksource/sh_mtu2.c:	p->irqaction.name = dev_name(&p->pdev->dev);
drivers/clocksource/sh_mtu2.c:	p->clk = clk_get(&p->pdev->dev, "mtu2_fck");
drivers/clocksource/sh_mtu2.c:		dev_err(&p->pdev->dev, "cannot get clock\n");
drivers/clocksource/sh_mtu2.c:	return sh_mtu2_register(p, (char *)dev_name(&p->pdev->dev),
drivers/clocksource/sh_mtu2.c:	struct sh_timer_config *cfg = pdev->dev.platform_data;
drivers/clocksource/sh_mtu2.c:		pm_runtime_set_active(&pdev->dev);
drivers/clocksource/sh_mtu2.c:		pm_runtime_enable(&pdev->dev);
drivers/clocksource/sh_mtu2.c:		dev_info(&pdev->dev, "kept as earlytimer\n");
drivers/clocksource/sh_mtu2.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/clocksource/sh_mtu2.c:		pm_runtime_idle(&pdev->dev);
drivers/clocksource/sh_mtu2.c:		pm_runtime_irq_safe(&pdev->dev);
drivers/clocksource/sh_mtu2.c:		pm_runtime_idle(&pdev->dev);
drivers/clocksource/sh_cmt.c:	struct sh_timer_config *cfg = p->pdev->dev.platform_data;
drivers/clocksource/sh_cmt.c:	struct sh_timer_config *cfg = p->pdev->dev.platform_data;
drivers/clocksource/sh_cmt.c:	struct sh_timer_config *cfg = p->pdev->dev.platform_data;
drivers/clocksource/sh_cmt.c:	pm_runtime_get_sync(&p->pdev->dev);
drivers/clocksource/sh_cmt.c:	dev_pm_syscore_device(&p->pdev->dev, true);
drivers/clocksource/sh_cmt.c:		dev_err(&p->pdev->dev, "cannot enable clock\n");
drivers/clocksource/sh_cmt.c:		dev_err(&p->pdev->dev, "cannot clear CMCNT\n");
drivers/clocksource/sh_cmt.c:	dev_pm_syscore_device(&p->pdev->dev, false);
drivers/clocksource/sh_cmt.c:	pm_runtime_put(&p->pdev->dev);
drivers/clocksource/sh_cmt.c:			dev_warn(&p->pdev->dev, "too long delay\n");
drivers/clocksource/sh_cmt.c:		dev_warn(&p->pdev->dev, "delta out of range\n");
drivers/clocksource/sh_cmt.c:	pm_genpd_syscore_poweroff(&p->pdev->dev);
drivers/clocksource/sh_cmt.c:	pm_genpd_syscore_poweron(&p->pdev->dev);
drivers/clocksource/sh_cmt.c:	dev_info(&p->pdev->dev, "used as clock source\n");
drivers/clocksource/sh_cmt.c:		dev_info(&p->pdev->dev, "used for periodic clock events\n");
drivers/clocksource/sh_cmt.c:		dev_info(&p->pdev->dev, "used for oneshot clock events\n");
drivers/clocksource/sh_cmt.c:	pm_genpd_syscore_poweroff(&ced_to_sh_cmt(ced)->pdev->dev);
drivers/clocksource/sh_cmt.c:	pm_genpd_syscore_poweron(&ced_to_sh_cmt(ced)->pdev->dev);
drivers/clocksource/sh_cmt.c:	dev_info(&p->pdev->dev, "used for clock events\n");
drivers/clocksource/sh_cmt.c:	struct sh_timer_config *cfg = pdev->dev.platform_data;
drivers/clocksource/sh_cmt.c:		dev_err(&p->pdev->dev, "missing platform data\n");
drivers/clocksource/sh_cmt.c:		dev_err(&p->pdev->dev, "failed to get I/O memory\n");
drivers/clocksource/sh_cmt.c:		dev_err(&p->pdev->dev, "failed to get irq\n");
drivers/clocksource/sh_cmt.c:		dev_err(&p->pdev->dev, "failed to remap I/O memory\n");
drivers/clocksource/sh_cmt.c:	p->irqaction.name = dev_name(&p->pdev->dev);
drivers/clocksource/sh_cmt.c:	p->clk = clk_get(&p->pdev->dev, "cmt_fck");
drivers/clocksource/sh_cmt.c:		dev_err(&p->pdev->dev, "cannot get clock\n");
drivers/clocksource/sh_cmt.c:	ret = sh_cmt_register(p, (char *)dev_name(&p->pdev->dev),
drivers/clocksource/sh_cmt.c:		dev_err(&p->pdev->dev, "registration failed\n");
drivers/clocksource/sh_cmt.c:		dev_err(&p->pdev->dev, "failed to request irq %d\n", irq);
drivers/clocksource/sh_cmt.c:	struct sh_timer_config *cfg = pdev->dev.platform_data;
drivers/clocksource/sh_cmt.c:		pm_runtime_set_active(&pdev->dev);
drivers/clocksource/sh_cmt.c:		pm_runtime_enable(&pdev->dev);
drivers/clocksource/sh_cmt.c:		dev_info(&pdev->dev, "kept as earlytimer\n");
drivers/clocksource/sh_cmt.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/clocksource/sh_cmt.c:		pm_runtime_idle(&pdev->dev);
drivers/clocksource/sh_cmt.c:		pm_runtime_irq_safe(&pdev->dev);
drivers/clocksource/sh_cmt.c:		pm_runtime_idle(&pdev->dev);
drivers/clocksource/sh_tmu.c:	struct sh_timer_config *cfg = p->pdev->dev.platform_data;
drivers/clocksource/sh_tmu.c:	struct sh_timer_config *cfg = p->pdev->dev.platform_data;
drivers/clocksource/sh_tmu.c:	struct sh_timer_config *cfg = p->pdev->dev.platform_data;
drivers/clocksource/sh_tmu.c:		dev_err(&p->pdev->dev, "cannot enable clock\n");
drivers/clocksource/sh_tmu.c:	pm_runtime_get_sync(&p->pdev->dev);
drivers/clocksource/sh_tmu.c:	dev_pm_syscore_device(&p->pdev->dev, true);
drivers/clocksource/sh_tmu.c:	dev_pm_syscore_device(&p->pdev->dev, false);
drivers/clocksource/sh_tmu.c:	pm_runtime_put(&p->pdev->dev);
drivers/clocksource/sh_tmu.c:		pm_genpd_syscore_poweroff(&p->pdev->dev);
drivers/clocksource/sh_tmu.c:		pm_genpd_syscore_poweron(&p->pdev->dev);
drivers/clocksource/sh_tmu.c:	dev_info(&p->pdev->dev, "used as clock source\n");
drivers/clocksource/sh_tmu.c:		dev_info(&p->pdev->dev, "used for periodic clock events\n");
drivers/clocksource/sh_tmu.c:		dev_info(&p->pdev->dev, "used for oneshot clock events\n");
drivers/clocksource/sh_tmu.c:	pm_genpd_syscore_poweroff(&ced_to_sh_tmu(ced)->pdev->dev);
drivers/clocksource/sh_tmu.c:	pm_genpd_syscore_poweron(&ced_to_sh_tmu(ced)->pdev->dev);
drivers/clocksource/sh_tmu.c:	dev_info(&p->pdev->dev, "used for clock events\n");
drivers/clocksource/sh_tmu.c:		dev_err(&p->pdev->dev, "failed to request irq %d\n",
drivers/clocksource/sh_tmu.c:	struct sh_timer_config *cfg = pdev->dev.platform_data;
drivers/clocksource/sh_tmu.c:		dev_err(&p->pdev->dev, "missing platform data\n");
drivers/clocksource/sh_tmu.c:		dev_err(&p->pdev->dev, "failed to get I/O memory\n");
drivers/clocksource/sh_tmu.c:		dev_err(&p->pdev->dev, "failed to get irq\n");
drivers/clocksource/sh_tmu.c:		dev_err(&p->pdev->dev, "failed to remap I/O memory\n");
drivers/clocksource/sh_tmu.c:	p->irqaction.name = dev_name(&p->pdev->dev);
drivers/clocksource/sh_tmu.c:	p->clk = clk_get(&p->pdev->dev, "tmu_fck");
drivers/clocksource/sh_tmu.c:		dev_err(&p->pdev->dev, "cannot get clock\n");
drivers/clocksource/sh_tmu.c:	return sh_tmu_register(p, (char *)dev_name(&p->pdev->dev),
drivers/clocksource/sh_tmu.c:	struct sh_timer_config *cfg = pdev->dev.platform_data;
drivers/clocksource/sh_tmu.c:		pm_runtime_set_active(&pdev->dev);
drivers/clocksource/sh_tmu.c:		pm_runtime_enable(&pdev->dev);
drivers/clocksource/sh_tmu.c:		dev_info(&pdev->dev, "kept as earlytimer\n");
drivers/clocksource/sh_tmu.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/clocksource/sh_tmu.c:		pm_runtime_idle(&pdev->dev);
drivers/clocksource/sh_tmu.c:		pm_runtime_irq_safe(&pdev->dev);
drivers/clocksource/sh_tmu.c:		pm_runtime_idle(&pdev->dev);
drivers/clocksource/em_sti.c:		dev_err(&p->pdev->dev, "cannot enable clock\n");
drivers/clocksource/em_sti.c:	cs->name = dev_name(&p->pdev->dev);
drivers/clocksource/em_sti.c:	dev_info(&p->pdev->dev, "used as clock source\n");
drivers/clocksource/em_sti.c:		dev_info(&p->pdev->dev, "used for oneshot clock events\n");
drivers/clocksource/em_sti.c:	ced->name = dev_name(&p->pdev->dev);
drivers/clocksource/em_sti.c:	dev_info(&p->pdev->dev, "used for clock events\n");
drivers/clocksource/em_sti.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/clocksource/em_sti.c:		dev_err(&pdev->dev, "failed to get I/O memory\n");
drivers/clocksource/em_sti.c:		dev_err(&pdev->dev, "failed to get irq\n");
drivers/clocksource/em_sti.c:		dev_err(&pdev->dev, "failed to remap I/O memory\n");
drivers/clocksource/em_sti.c:	p->clk = clk_get(&pdev->dev, "sclk");
drivers/clocksource/em_sti.c:		dev_err(&pdev->dev, "cannot get clock\n");
drivers/clocksource/em_sti.c:			dev_name(&pdev->dev), p)) {
drivers/clocksource/em_sti.c:		dev_err(&pdev->dev, "failed to request low IRQ\n");
drivers/vme/bridges/vme_ca91cx42.c:	result = request_irq(pdev->irq, ca91cx42_irqhandler, IRQF_SHARED,
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "Can't get assigned pci irq vector %02X\n",
drivers/vme/bridges/vme_ca91cx42.c:		       pdev->irq);
drivers/vme/bridges/vme_ca91cx42.c:	free_irq(pdev->irq, pdev);
drivers/vme/bridges/vme_ca91cx42.c:		synchronize_irq(pdev->irq);
drivers/vme/bridges/vme_ca91cx42.c:	retval = pci_bus_alloc_resource(pdev->bus,
drivers/vme/bridges/vme_ca91cx42.c:	dev_info(&pdev->dev, "CR/CSR Offset: %d\n", slot);
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "Slot number is unset, not configuring "
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "Failed to allocate memory for CR/CSR "
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "Failed to allocate memory for device "
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "Failed to allocate memory for device "
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "Unable to enable device\n");
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "Unable to reserve resources\n");
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "Unable to remap CRG region\n");
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "PCI_ID check failed\n");
drivers/vme/bridges/vme_ca91cx42.c:	ca91cx42_bridge->parent = &pdev->dev;
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "Chip Initialization failed.\n");
drivers/vme/bridges/vme_ca91cx42.c:			dev_err(&pdev->dev, "Failed to allocate memory for "
drivers/vme/bridges/vme_ca91cx42.c:			dev_err(&pdev->dev, "Failed to allocate memory for "
drivers/vme/bridges/vme_ca91cx42.c:			dev_err(&pdev->dev, "Failed to allocate memory for "
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "Failed to allocate memory for "
drivers/vme/bridges/vme_ca91cx42.c:	dev_info(&pdev->dev, "Board is%s the VME system controller\n",
drivers/vme/bridges/vme_ca91cx42.c:	dev_info(&pdev->dev, "Slot ID is %d\n",
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "CR/CSR configuration failed.\n");
drivers/vme/bridges/vme_ca91cx42.c:		dev_err(&pdev->dev, "Chip Registration failed.\n");
drivers/vme/bridges/vme_tsi148.c:	result = request_irq(pdev->irq,
drivers/vme/bridges/vme_tsi148.c:			"vector %02X\n", pdev->irq);
drivers/vme/bridges/vme_tsi148.c:	free_irq(pdev->irq, tsi148_bridge);
drivers/vme/bridges/vme_tsi148.c:			synchronize_irq(pdev->irq);
drivers/vme/bridges/vme_tsi148.c:	retval = pci_bus_alloc_resource(pdev->bus,
drivers/vme/bridges/vme_tsi148.c:		dev_err(&pdev->dev, "Failed to allocate memory for device "
drivers/vme/bridges/vme_tsi148.c:		dev_err(&pdev->dev, "Failed to allocate memory for device "
drivers/vme/bridges/vme_tsi148.c:		dev_err(&pdev->dev, "Unable to enable device\n");
drivers/vme/bridges/vme_tsi148.c:		dev_err(&pdev->dev, "Unable to reserve resources\n");
drivers/vme/bridges/vme_tsi148.c:		dev_err(&pdev->dev, "Unable to remap CRG region\n");
drivers/vme/bridges/vme_tsi148.c:		dev_err(&pdev->dev, "CRG region check failed\n");
drivers/vme/bridges/vme_tsi148.c:	tsi148_bridge->parent = &pdev->dev;
drivers/vme/bridges/vme_tsi148.c:		dev_err(&pdev->dev, "Chip Initialization failed.\n");
drivers/vme/bridges/vme_tsi148.c:			dev_err(&pdev->dev, "Failed to allocate memory for "
drivers/vme/bridges/vme_tsi148.c:			dev_err(&pdev->dev, "Failed to allocate memory for "
drivers/vme/bridges/vme_tsi148.c:			dev_err(&pdev->dev, "Failed to allocate memory for "
drivers/vme/bridges/vme_tsi148.c:			dev_err(&pdev->dev, "Failed to allocate memory for "
drivers/vme/bridges/vme_tsi148.c:		dev_err(&pdev->dev, "Failed to allocate memory for "
drivers/vme/bridges/vme_tsi148.c:	dev_info(&pdev->dev, "Board is%s the VME system controller\n",
drivers/vme/bridges/vme_tsi148.c:		dev_info(&pdev->dev, "VME geographical address is %d\n",
drivers/vme/bridges/vme_tsi148.c:		dev_info(&pdev->dev, "VME geographical address is set to %d\n",
drivers/vme/bridges/vme_tsi148.c:	dev_info(&pdev->dev, "VME Write and flush and error check is %s\n",
drivers/vme/bridges/vme_tsi148.c:		dev_err(&pdev->dev, "CR/CSR configuration failed.\n");
drivers/vme/bridges/vme_tsi148.c:		dev_err(&pdev->dev, "Chip Registration failed.\n");
drivers/vme/bridges/vme_tsi148.c:	dev_dbg(&pdev->dev, "Driver is being unloaded.\n");
drivers/vme/vme_bridge.h:	struct device *parent;	/* Parent device (eg. pdev->dev for PCI) */
drivers/vme/boards/vme_vmivme7805.c:		dev_err(&pdev->dev, "Unable to enable device\n");
drivers/vme/boards/vme_vmivme7805.c:		dev_err(&pdev->dev, "Unable to reserve resources\n");
drivers/vme/boards/vme_vmivme7805.c:		dev_err(&pdev->dev, "Unable to remap CRG region\n");
drivers/staging/sm7xxfb/sm7xxfb.c:	dev_dbg(&sfb->pdev->dev,
drivers/staging/sm7xxfb/sm7xxfb.c:			dev_dbg(&sfb->pdev->dev,
drivers/staging/sm7xxfb/sm7xxfb.c:			dev_dbg(&sfb->pdev->dev, "VGAMode index=%d\n", j);
drivers/staging/sm7xxfb/sm7xxfb.c:		dev_err(&pdev->dev,
drivers/staging/sm7xxfb/sm7xxfb.c:	dev_info(&pdev->dev, "Silicon Motion display driver.");
drivers/staging/sm7xxfb/sm7xxfb.c:			dev_info(&pdev->dev, "sfb->lfb=%p", sfb->lfb);
drivers/staging/sm7xxfb/sm7xxfb.c:			dev_err(&pdev->dev,
drivers/staging/sm7xxfb/sm7xxfb.c:		dev_err(&pdev->dev,
drivers/staging/sm7xxfb/sm7xxfb.c:	dev_info(&pdev->dev,
drivers/staging/sm7xxfb/sm7xxfb.c:	dev_err(&pdev->dev, "Silicon Motion, Inc. primary display init fail.");
drivers/staging/vt6655/hostap.c:	memcpy(pDevice->apdev->dev_addr, dev->dev_addr, ETH_ALEN);
drivers/staging/vt6655/hostap.c:	pDevice->apdev->netdev_ops = &apdev_netdev_ops;
drivers/staging/vt6655/hostap.c:	pDevice->apdev->type = ARPHRD_IEEE80211;
drivers/staging/vt6655/hostap.c:	pDevice->apdev->base_addr = dev->base_addr;
drivers/staging/vt6655/hostap.c:	pDevice->apdev->irq = dev->irq;
drivers/staging/vt6655/hostap.c:	pDevice->apdev->mem_start = dev->mem_start;
drivers/staging/vt6655/hostap.c:	pDevice->apdev->mem_end = dev->mem_end;
drivers/staging/vt6655/hostap.c:	sprintf(pDevice->apdev->name, "%sap", dev->name);
drivers/staging/vt6655/hostap.c:		dev->name, pDevice->apdev->name);
drivers/staging/vt6655/hostap.c:	if (pDevice->apdev && pDevice->apdev->name && pDevice->apdev->name[0]) {
drivers/staging/vt6655/hostap.c:			pDevice->dev->name, pDevice->apdev->name);
drivers/staging/sep/sep_crypto.c:	dev_dbg(&sep->pdev->dev, "sep alloc sg buf\n");
drivers/staging/sep/sep_crypto.c:			dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&sep->pdev->dev, "sep copy sg\n");
drivers/staging/sep/sep_crypto.c:	dev_dbg(&sep->pdev->dev, "sep copy sg not null\n");
drivers/staging/sep/sep_crypto.c:	dev_dbg(&sep->pdev->dev, "sep oddball\n");
drivers/staging/sep/sep_crypto.c:	dev_dbg(&sep->pdev->dev, "sep oddball not null\n");
drivers/staging/sep/sep_crypto.c:		dev_dbg(&sep->pdev->dev, "sep oddball processing\n");
drivers/staging/sep/sep_crypto.c:			dev_warn(&sep->pdev->dev, "cannot allocate new sg\n");
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "IV DUMP - %s\n", reason);
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&sep->pdev->dev, "dumping return message\n");
drivers/staging/sep/sep_crypto.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_crypto.c:		pm_runtime_mark_last_busy(&ta_ctx->sep_used->pdev->dev);
drivers/staging/sep/sep_crypto.c:		pm_runtime_put_autosuspend(&ta_ctx->sep_used->pdev->dev);
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:				dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_crypto.c:		pm_runtime_get_sync(&sep_dev->pdev->dev);
drivers/staging/sep/sep_crypto.c:	dev_dbg(&sep->pdev->dev, "[PID%d]: sending command to the sep\n",
drivers/staging/sep/sep_crypto.c:		dev_dbg(&sep->pdev->dev, "[PID%d]: command sent okay\n",
drivers/staging/sep/sep_crypto.c:		dev_dbg(&sep->pdev->dev, "[PID%d]: cant send command\n",
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "sep crypto block data size of %x\n",
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev, "walk phys error %x\n",
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev, "oddball page error\n");
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev, "walk phys error %x\n",
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "sending data\n");
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "sending key\n");
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev, "walk phys error %x\n",
drivers/staging/sep/sep_crypto.c:			dev_warn(&ta_ctx->sep_used->pdev->dev, "no iv found\n");
drivers/staging/sep/sep_crypto.c:			dev_warn(&ta_ctx->sep_used->pdev->dev, "no iv found\n");
drivers/staging/sep/sep_crypto.c:			dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "crypto post_op\n");
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "crypto post_op message dump\n");
drivers/staging/sep/sep_crypto.c:			dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:				dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:					dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev, "hash init error %x\n",
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "hash init post op done\n");
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev, "hash init error %x\n",
drivers/staging/sep/sep_crypto.c:			dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "hash update post op done\n");
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev, "hash finish error %x\n",
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "hash finish post op done\n");
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&sep_dev->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&sep_dev->pdev->dev, "[PID%d] sendmsg not called\n",
drivers/staging/sep/sep_crypto.c:		dev_warn(&sep_dev->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&sep_dev->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&sep_dev->pdev->dev, "[PID%d] GPR2 at crypto finish is %x\n",
drivers/staging/sep/sep_crypto.c:		dev_dbg(&sep_dev->pdev->dev, "[PID%d] sep print req\n",
drivers/staging/sep/sep_crypto.c:		dev_dbg(&sep_dev->pdev->dev, "[PID%d] contents: %s\n",
drivers/staging/sep/sep_crypto.c:		dev_dbg(&sep_dev->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&sep_dev->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "length is %x\n", len);
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "block_size is %x\n", block_size);
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "tail len is %x\n", tail_len);
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "length is %x\n", req->nbytes);
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "block_size is %x\n", block_size);
drivers/staging/sep/sep_crypto.c:	dev_dbg(&ta_ctx->sep_used->pdev->dev, "tail len is %x\n", tail_len);
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:			dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_dbg(&ta_ctx->sep_used->pdev->dev,
drivers/staging/sep/sep_crypto.c:		dev_warn(&sep_dev->pdev->dev, "cant create workqueue\n");
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] sep_queue_status_remove\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "PID%d %s null\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] sep_queue_status_remove return\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] kzalloc ok\n", current->pid);
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] dma_ctx = 0x%p\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] dmatables_region = 0x%p\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] newlen = 0x%08zX\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] oldlen = 0x%08X\n", current->pid,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] woken up\n", current->pid);
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev, "[PID%d] received signal\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] transaction pid = %d\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	sep->shared_addr = dma_alloc_coherent(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dma_free_coherent(&sep->pdev->dev, sep->shared_size,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep_dev->pdev->dev, "[PID%d] open\n", current->pid);
drivers/staging/sep/sep_main.c:	dev_dbg(&sep_dev->pdev->dev, "[PID%d] priv is 0x%p\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] (*dma_ctx)->nr_dcb_creat 0x%x\n",
drivers/staging/sep/sep_main.c:				dma_unmap_page(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:				dma_unmap_page(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dma_unmap_sg(&sep->pdev->dev, dma->src_sg,
drivers/staging/sep/sep_main.c:			dma_unmap_sg(&sep->pdev->dev, dma->dst_sg,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] ending transaction\n", current->pid);
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] not transaction owner\n",
drivers/staging/sep/sep_main.c:		pm_runtime_mark_last_busy(&sep->pdev->dev);
drivers/staging/sep/sep_main.c:		pm_runtime_put_autosuspend(&sep->pdev->dev);
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] waking up next transaction\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] release\n", current->pid);
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] sep_mmap\n", current->pid);
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] shared_addr is %p\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] remap_pfn_range failed\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] poll pid not owner\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "[PID%d] sendmsg not called\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] poll: calling wait sep_event\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] poll; poll error %x\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] time.tv_sec is %lu\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] time_addr is %p\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] sep->shared_addr is %p\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "start message token not present\n");
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "invalid message size\n");
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "invalid message opcode\n");
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] before pm sync status 0x%X\n",
drivers/staging/sep/sep_main.c:					sep->pdev->dev.power.runtime_status);
drivers/staging/sep/sep_main.c:	pm_runtime_get_sync(&sep->pdev->dev);
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	count_mapped = dma_map_sg(&sep->pdev->dev, sg,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "Cannot dma_map_sg\n");
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "Cannot allocate dma_maps\n");
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "(all hex) map %x dma %lx len %lx\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "crypto_dma failed %x\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "Cannot allocate lli_maps\n");
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "sep_crypto_lli returned error %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] data_size is (hex) %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] start_page is (hex) %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] end_page is (hex) %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] num_pages is (hex) %x\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] get_user_pages succeeded\n",
drivers/staging/sep/sep_main.c:			dma_map_page(&sep->pdev->dev, page_array[count],
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] data_size is (hex) %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] start_page is (hex) %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] end_page is (hex) %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] num_pages is (hex) %x\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] sh virt to phys v %p\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] sh virt to phys p %08lx\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] shared bus to virt b=%lx v=%lx\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] sep_debug_print_lli_tables start\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] no table to print\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] sep_debug_print_lli_tables end\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] block_size is (hex) %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "DMA context uninitialized\n");
drivers/staging/sep/sep_main.c:			dev_warn(&sep->pdev->dev, "dma table limit overrun\n");
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] Locking kernel input pages\n",
drivers/staging/sep/sep_main.c:			dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] Locking kernel output pages\n",
drivers/staging/sep/sep_main.c:			dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] Locking user input pages\n",
drivers/staging/sep/sep_main.c:			dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev, "[PID%d] in secure_dma\n",
drivers/staging/sep/sep_main.c:				dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev, "[PID%d] not in secure_dma\n",
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:				dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] sep_out_num_pages is (hex) %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] calling create table from lli\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] app_in_address %lx\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] app_out_address %lx\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] data_in_size %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] block_size %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] tail_block_size %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] isapplet %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] is_kva %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] src_sg %p\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] dst_sg %p\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "[PID%d] no DMA context pointer\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] DMA context already set\n",
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] no more DCBs available\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] sep_free_dma_tables_and_dcb\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] handling applet\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] sep_free_dma_tables_and_dcb end\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] free dcbs num of DCBs %x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] ioctl cmd 0x%x\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] dma context addr 0x%p\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] ioctl pid is not owner\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] dcb's end\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] SEP_IOCFREEDCB start\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] SEP_IOCFREEDCB end\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] default end\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] ioctl end\n", current->pid);
drivers/staging/sep/sep_main.c:	if (sep->pdev->dev.power.runtime_status != RPM_ACTIVE) {
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "interrupt during pwr save\n");
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "interrupt while nobody using sep\n");
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "sep int: IRR REG val: %x\n", reg_val);
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "sep int: send_ct %lx reply_ct %lx\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev, "int: printf request\n");
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev, "int: daemon request\n");
drivers/staging/sep/sep_main.c:			dev_dbg(&sep->pdev->dev, "int: SEP reply\n");
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "int: not SEP interrupt\n");
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "reconfig shared; sending %08llx to sep\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "could not reconfig shared area\n");
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "result was %x\n", ret_val);
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "reconfig shared area end\n");
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] activating dcb/dma region\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "activate: input table\n");
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "activate: output table\n");
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] creating dcb/dma region\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:			dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] creating dcb/dma region\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] num_dcbs is %d\n",
drivers/staging/sep/sep_main.c:			dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] activating msg region\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] creating msg region\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] read pid is not owner\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] count_user = 0x%08zX\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] read succeeded\n", current->pid);
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "[PID%d] dcb free failed\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] fastcall hdr num of DCBs 0x%08X\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] fastcall hdr msg len 0x%08X\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] sep dev is 0x%p\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] private_data is 0x%p\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] double buffering region start\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] updating queue status\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_dbg(&sep->pdev->dev, "[PID%d] interrupted by signal\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] saving queue element\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] double buffering region end\n",
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "[PID%d] double buffering region end\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "misc reg fails for SEP %x\n",
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "sysfs attribute1 fails for SEP %x\n",
drivers/staging/sep/sep_main.c:		dev_dbg(&pdev->dev, "only one SEP supported.\n");
drivers/staging/sep/sep_main.c:		dev_warn(&pdev->dev, "error enabling pci device\n");
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "Error getting register start\n");
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "Error getting register end\n");
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "Error getting register virtual\n");
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	error = request_irq(pdev->irq, sep_inthandler, IRQF_SHARED,
drivers/staging/sep/sep_main.c:		dev_err(&sep->pdev->dev, "error registering dev file\n");
drivers/staging/sep/sep_main.c:	pm_runtime_put_noidle(&sep->pdev->dev);
drivers/staging/sep/sep_main.c:	pm_runtime_allow(&sep->pdev->dev);
drivers/staging/sep/sep_main.c:	pm_runtime_set_autosuspend_delay(&sep->pdev->dev,
drivers/staging/sep/sep_main.c:	pm_runtime_use_autosuspend(&sep->pdev->dev);
drivers/staging/sep/sep_main.c:	pm_runtime_mark_last_busy(&sep->pdev->dev);
drivers/staging/sep/sep_main.c:		dev_err(&sep->pdev->dev, "crypto setup failed\n");
drivers/staging/sep/sep_main.c:	free_irq(pdev->irq, sep);
drivers/staging/sep/sep_main.c:	free_irq(sep->pdev->irq, sep);
drivers/staging/sep/sep_main.c:		pm_runtime_forbid(&sep->pdev->dev);
drivers/staging/sep/sep_main.c:		pm_runtime_get_noresume(&sep->pdev->dev);
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "pci resume called\n");
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "pci suspend called\n");
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "pm runtime resume called\n");
drivers/staging/sep/sep_main.c:		dev_warn(&sep->pdev->dev, "scu boot bit not set at resume\n");
drivers/staging/sep/sep_main.c:	dev_dbg(&sep->pdev->dev, "pm runtime suspend called\n");
drivers/staging/vt6656/hostap.c:	memcpy(pDevice->apdev->dev_addr, dev->dev_addr, ETH_ALEN);
drivers/staging/vt6656/hostap.c:	pDevice->apdev->netdev_ops = &apdev_netdev_ops;
drivers/staging/vt6656/hostap.c:	pDevice->apdev->type = ARPHRD_IEEE80211;
drivers/staging/vt6656/hostap.c:	pDevice->apdev->base_addr = dev->base_addr;
drivers/staging/vt6656/hostap.c:	pDevice->apdev->irq = dev->irq;
drivers/staging/vt6656/hostap.c:	pDevice->apdev->mem_start = dev->mem_start;
drivers/staging/vt6656/hostap.c:	pDevice->apdev->mem_end = dev->mem_end;
drivers/staging/vt6656/hostap.c:	sprintf(pDevice->apdev->name, "%sap", dev->name);
drivers/staging/vt6656/hostap.c:	       dev->name, pDevice->apdev->name);
drivers/staging/vt6656/hostap.c:    if (pDevice->apdev && pDevice->apdev->name && pDevice->apdev->name[0]) {
drivers/staging/vt6656/hostap.c:		       pDevice->dev->name, pDevice->apdev->name);
drivers/staging/rtl8192e/rtl8192e/r8192E_firmware.c:					 fw_name[init_step], &priv->pdev->dev);
drivers/staging/rtl8192e/rtl8192e/rtl_pci.c:	VenderID = pdev->vendor;
drivers/staging/rtl8192e/rtl8192e/rtl_pci.c:	DeviceID = pdev->device;
drivers/staging/rtl8192e/rtl8192e/rtl_pci.c:	RevisionID = pdev->revision;
drivers/staging/rtl8192e/rtl8192e/rtl_pci.c:			       pdev->vendor, pdev->device);
drivers/staging/rtl8192e/rtl8192e/rtl_core.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/staging/rtl8192e/rtl8192e/rtl_core.c:	if ((pdev->subsystem_vendor == PCI_VENDOR_ID_DLINK) &&
drivers/staging/rtl8192e/rtl8192e/rtl_core.c:	    (pdev->subsystem_device == 0x3304))
drivers/staging/rtl8192e/rtl8192e/rtl_core.c:	if (pdev->device == 0x8192 && revision_id == 0x10)
drivers/staging/rtl8192e/rtl8192e/rtl_core.c:	dev->irq = pdev->irq;
drivers/staging/rtl8187se/r8180_core.c:		dev_err(&pdev->dev, "pci_enable_device failed on resume\n");
drivers/staging/rtl8187se/r8180_core.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/staging/rtl8187se/r8180_core.c:	dev->irq = pdev->irq;
drivers/staging/imx-drm/parallel-display.c:	struct device_node *np = pdev->dev.of_node;
drivers/staging/imx-drm/parallel-display.c:	imxpd = devm_kzalloc(&pdev->dev, sizeof(*imxpd), GFP_KERNEL);
drivers/staging/imx-drm/parallel-display.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/staging/imx-drm/parallel-display.c:		dev_warn(&pdev->dev, "pinctrl_get_select_default failed with %d",
drivers/staging/imx-drm/parallel-display.c:	imxpd->dev = &pdev->dev;
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	struct device *dev = &pdev->dev;
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_err(&pdev->dev, "init %s failed with %d\n", unit, ret);
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	device_for_each_child(&pdev->dev, NULL, platform_remove_devices_fn);
drivers/staging/imx-drm/ipu-v3/ipu-common.c:			of_match_device(imx_ipu_dt_ids, &pdev->dev);
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_dbg(&pdev->dev, "irq_sync: %d irq_err: %d\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	ipu = devm_kzalloc(&pdev->dev, sizeof(*ipu), GFP_KERNEL);
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_dbg(&pdev->dev, "cm_reg:   0x%08lx\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_dbg(&pdev->dev, "idmac:    0x%08lx\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_dbg(&pdev->dev, "cpmem:    0x%08lx\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_dbg(&pdev->dev, "disp0:    0x%08lx\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_dbg(&pdev->dev, "disp1:    0x%08lx\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_dbg(&pdev->dev, "srm:      0x%08lx\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_dbg(&pdev->dev, "tpm:      0x%08lx\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_dbg(&pdev->dev, "dc:       0x%08lx\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_dbg(&pdev->dev, "ic:       0x%08lx\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_dbg(&pdev->dev, "dmfc:     0x%08lx\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_dbg(&pdev->dev, "vdi:      0x%08lx\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	ipu->cm_reg = devm_ioremap(&pdev->dev,
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	ipu->idmac_reg = devm_ioremap(&pdev->dev,
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	ipu->cpmem_base = devm_ioremap(&pdev->dev,
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	ipu->clk = devm_clk_get(&pdev->dev, "bus");
drivers/staging/imx-drm/ipu-v3/ipu-common.c:		dev_err(&pdev->dev, "clk_get failed with %d", ret);
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	ipu->dev = &pdev->dev;
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	ret = device_reset(&pdev->dev);
drivers/staging/imx-drm/ipu-v3/ipu-common.c:		dev_err(&pdev->dev, "failed to reset: %d\n", ret);
drivers/staging/imx-drm/ipu-v3/ipu-common.c:		dev_err(&pdev->dev, "adding client devices failed with %d\n",
drivers/staging/imx-drm/ipu-v3/ipu-common.c:	dev_info(&pdev->dev, "%s probed\n", devtype->name);
drivers/staging/imx-drm/imx-drm-core.c:	imx_drm_device->dev = &pdev->dev;
drivers/staging/imx-drm/imx-drm-core.c:	imx_drm_pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32),
drivers/staging/imx-drm/ipuv3-crtc.c:	struct ipu_client_platformdata *pdata = pdev->dev.platform_data;
drivers/staging/imx-drm/ipuv3-crtc.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/staging/imx-drm/ipuv3-crtc.c:	ipu_crtc = devm_kzalloc(&pdev->dev, sizeof(*ipu_crtc), GFP_KERNEL);
drivers/staging/imx-drm/ipuv3-crtc.c:	ipu_crtc->dev = &pdev->dev;
drivers/staging/imx-drm/imx-tve.c:	struct device_node *np = pdev->dev.of_node;
drivers/staging/imx-drm/imx-tve.c:	tve = devm_kzalloc(&pdev->dev, sizeof(*tve), GFP_KERNEL);
drivers/staging/imx-drm/imx-tve.c:	tve->dev = &pdev->dev;
drivers/staging/imx-drm/imx-tve.c:		dev_err(&pdev->dev, "only VGA mode supported, currently\n");
drivers/staging/imx-drm/imx-tve.c:		pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/staging/imx-drm/imx-tve.c:			dev_warn(&pdev->dev, "failed to setup pinctrl: %d", ret);
drivers/staging/imx-drm/imx-tve.c:			dev_err(&pdev->dev, "failed to get vsync pin\n");
drivers/staging/imx-drm/imx-tve.c:			dev_err(&pdev->dev, "failed to get vsync pin\n");
drivers/staging/imx-drm/imx-tve.c:		dev_err(&pdev->dev, "failed to get memory region\n");
drivers/staging/imx-drm/imx-tve.c:	base = devm_request_and_ioremap(&pdev->dev, res);
drivers/staging/imx-drm/imx-tve.c:		dev_err(&pdev->dev, "failed to remap memory region\n");
drivers/staging/imx-drm/imx-tve.c:	tve->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "tve", base,
drivers/staging/imx-drm/imx-tve.c:		dev_err(&pdev->dev, "failed to init regmap: %ld\n",
drivers/staging/imx-drm/imx-tve.c:		dev_err(&pdev->dev, "failed to get irq\n");
drivers/staging/imx-drm/imx-tve.c:	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
drivers/staging/imx-drm/imx-tve.c:		dev_err(&pdev->dev, "failed to request irq: %d\n", ret);
drivers/staging/imx-drm/imx-tve.c:	tve->dac_reg = devm_regulator_get(&pdev->dev, "dac");
drivers/staging/imx-drm/imx-tve.c:	tve->clk = devm_clk_get(&pdev->dev, "tve");
drivers/staging/imx-drm/imx-tve.c:		dev_err(&pdev->dev, "failed to get high speed tve clock: %ld\n",
drivers/staging/imx-drm/imx-tve.c:	tve->di_sel_clk = devm_clk_get(&pdev->dev, "di_sel");
drivers/staging/imx-drm/imx-tve.c:		dev_err(&pdev->dev, "failed to get ipu di mux clock: %ld\n",
drivers/staging/imx-drm/imx-tve.c:		dev_err(&pdev->dev, "failed to read configuration register: %d\n", ret);
drivers/staging/imx-drm/imx-tve.c:		dev_err(&pdev->dev, "configuration register default value indicates this is not a TVEv2\n");
drivers/staging/cxt1e1/hwprobe.c:            hi->pci_busno, (u_int8_t) PCI_SLOT (pdev->devfn),
drivers/staging/cxt1e1/hwprobe.c:            (u_int8_t) PCI_FUNC (pdev->devfn), pdev->irq);
drivers/staging/cxt1e1/hwprobe.c:            hi->pci_busno, (u_int8_t) PCI_SLOT (pdev->devfn),
drivers/staging/cxt1e1/hwprobe.c:            (u_int8_t) PCI_FUNC (pdev->devfn), pdev->irq);
drivers/staging/cxt1e1/hwprobe.c:    if ((fun = PCI_FUNC (pdev->devfn)) > 1)
drivers/staging/cxt1e1/hwprobe.c:        pr_warning("unexpected devfun: 0x%x\n", pdev->devfn);
drivers/staging/cxt1e1/hwprobe.c:    if (pdev->bus)                  /* obtain bus number */
drivers/staging/cxt1e1/hwprobe.c:        busno = pdev->bus->number;
drivers/staging/cxt1e1/hwprobe.c:    slot = pdev->devfn & ~0x07;
drivers/staging/cxt1e1/hwprobe.c:            ((hi->pci_slot == slot) && (hi->bus == pdev->bus)))
drivers/staging/cxt1e1/hwprobe.c:    if (pdev->bus)
drivers/staging/cxt1e1/hwprobe.c:        hi->pci_busno = pdev->bus->number;
drivers/staging/cxt1e1/hwprobe.c:    hi->bus = pdev->bus;
drivers/staging/sbe-2t3e3/module.c:	if (pdev->subsystem_device == PCI_SUBDEVICE_ID_SBE_2T3E3_P1)
drivers/staging/sbe-2t3e3/module.c:			if (pdev1->bus == pdev->bus &&
drivers/staging/sbe-2t3e3/module.c:			    pdev1->devfn == pdev->devfn + 8 /* next device on the same bus */)
drivers/staging/sbe-2t3e3/module.c:			dev_err(&pdev->dev, "Can't find the second channel\n");
drivers/staging/sbe-2t3e3/cpld.c:		dev_info(&sc->pdev->dev, "SBE 2T3E3: LOS status: %s\n",
drivers/staging/sbe-2t3e3/dc.c:		dev_dbg(&sc->pdev->dev, "Start Framer Rx Status = %02X\n", val);
drivers/staging/sbe-2t3e3/dc.c:		dev_dbg(&sc->pdev->dev, "Start Framer Rx Status = %02X\n", val);
drivers/staging/sbe-2t3e3/dc.c:		dev_warn(&sc->pdev->dev, "SBE 2T3E3: Interrupt active too long\n");
drivers/staging/sbe-2t3e3/dc.c:				dev_warn(&sc->pdev->dev, "SBE 2T3E3: Rx failed to stop\n");
drivers/staging/sbe-2t3e3/dc.c:				dev_info(&sc->pdev->dev, "SBE 2T3E3: Rx off\n");
drivers/staging/sbe-2t3e3/dc.c:				dev_warn(&sc->pdev->dev, "SBE 2T3E3: Tx failed to stop\n");
drivers/staging/sbe-2t3e3/dc.c:				dev_err(&sc->pdev->dev, "SBE 2T3E3: token_alloc err:"
drivers/staging/sbe-2t3e3/dc.c:	dev_warn(&sc->pdev->dev, "SBE 2T3E3: 21143 restart\n");
drivers/staging/sbe-2t3e3/2t3e3.h:	return pdev->subsystem_device == PCI_SUBDEVICE_ID_SBE_2T3E3_P0;
drivers/staging/sbe-2t3e3/netdev.c:	dev->irq = sc->pdev->irq;
drivers/staging/sbe-2t3e3/netdev.c:		dev_err(&sc->pdev->dev, "error registering HDLC device\n");
drivers/staging/sbe-2t3e3/ctrl.c:		dev_err(&sc->pdev->dev, "SBE 2T3E3: changing frame type during active connection\n");
drivers/staging/sbe-2t3e3/main.c:		dev_dbg(&sc->pdev->dev, "SBE 2T3E3: out of descriptors\n");
drivers/staging/sbe-2t3e3/main.c:	dev_dbg(&sc->pdev->dev, "sending mbuf (current_write = %d)\n",
drivers/staging/sbe-2t3e3/main.c:			dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/main.c:	dev_dbg(&sc->pdev->dev, "txput: tdes0 = %08X        tdes1 = %08X\n",
drivers/staging/sbe-2t3e3/intr.c:		dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:		dev_dbg(&sc->pdev->dev, "SBE 2T3E3: Ethernet controller interrupt! (CSR5 = %08X)\n",
drivers/staging/sbe-2t3e3/intr.c:				dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:				dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:				dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:			dev_dbg(&sc->pdev->dev, "Transmit underflow\n");
drivers/staging/sbe-2t3e3/intr.c:				dev_dbg(&sc->pdev->dev, "Transmit interrupt\n");
drivers/staging/sbe-2t3e3/intr.c:				dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:				dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:	dev_dbg(&sc->pdev->dev, "intr_rx current_read = %d\n", current_read);
drivers/staging/sbe-2t3e3/intr.c:		dev_dbg(&sc->pdev->dev, "rdes0: %08X        rdes1: %08X\n",
drivers/staging/sbe-2t3e3/intr.c:		dev_dbg(&sc->pdev->dev, "mbuf was received (mbuf len = %d)\n",
drivers/staging/sbe-2t3e3/intr.c:				dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:						dev_err(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:						dev_err(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:							dev_err(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:							dev_err(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:						dev_err(&sc->pdev->dev, "SBE 2T3E3: mii error\n");
drivers/staging/sbe-2t3e3/intr.c:				dev_err(&sc->pdev->dev, "SBE 2T3E3: oversized rx: rdes0 = %08X\n",
drivers/staging/sbe-2t3e3/intr.c:					dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:		dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:				dev_err(&sc->pdev->dev, "SBE 2T3E3: transmit jabber timeout\n");
drivers/staging/sbe-2t3e3/intr.c:					dev_err(&sc->pdev->dev, "SBE 2T3E3: loss of carrier\n");
drivers/staging/sbe-2t3e3/intr.c:					dev_err(&sc->pdev->dev, "SBE 2T3E3: no carrier\n");
drivers/staging/sbe-2t3e3/intr.c:				dev_err(&sc->pdev->dev, "SBE 2T3E3: link fail report\n");
drivers/staging/sbe-2t3e3/intr.c:				dev_err(&sc->pdev->dev, "SBE 2T3E3:"
drivers/staging/sbe-2t3e3/intr.c:				dev_err(&sc->pdev->dev, "SBE 2T3E3: transmission deferred\n");
drivers/staging/sbe-2t3e3/intr.c:	dev_dbg(&sc->pdev->dev, "SBE 2T3E3: Framer interrupt! (REG[0x05] = %02X)\n", status);
drivers/staging/sbe-2t3e3/intr.c:				dev_dbg(&sc->pdev->dev, "SBE 2T3E3: Disabling eth interrupts\n");
drivers/staging/sbe-2t3e3/intr.c:			dev_dbg(&sc->pdev->dev, "SBE 2T3E3: Enabling eth interrupts\n");
drivers/staging/sbe-2t3e3/intr.c:			dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:				dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:			dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:			dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:		dev_dbg(&sc->pdev->dev, "SBE 2T3E3: Framer interrupt T3 TX (REG[0x31] = %02X)\n",
drivers/staging/sbe-2t3e3/intr.c:		dev_dbg(&sc->pdev->dev, "SBE 2T3E3: Framer interrupt T3 TX (REG[0x34] = %02X)\n",
drivers/staging/sbe-2t3e3/intr.c:			dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:				dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:			dev_dbg(&sc->pdev->dev,
drivers/staging/sbe-2t3e3/intr.c:		dev_dbg(&sc->pdev->dev, "SBE 2T3E3: Framer interrupt E3 TX (REG[0x34] = %02X)\n",
drivers/staging/crystalhd/crystalhd_lnx.c:	if (adp->pdev->msi_enabled)
drivers/staging/crystalhd/crystalhd_lnx.c:	rc = request_irq(adp->pdev->irq, chd_dec_isr, IRQF_SHARED,
drivers/staging/crystalhd/crystalhd_lnx.c:	free_irq(adp->pdev->irq, adp);
drivers/staging/crystalhd/crystalhd_lnx.c:	       pdev->vendor, pdev->device, pdev->subsystem_vendor,
drivers/staging/crystalhd/crystalhd_lnx.c:	       pdev->subsystem_device);
drivers/staging/crystalhd/crystalhd_lnx.c:		 pdev->bus->number, PCI_SLOT(pdev->devfn),
drivers/staging/crystalhd/crystalhd_lnx.c:		 PCI_FUNC(pdev->devfn));
drivers/staging/ti-soc-thermal/ti-bandgap.c:		dev_err(&pdev->dev, "get_irq failed\n");
drivers/staging/ti-soc-thermal/ti-bandgap.c:		dev_err(&pdev->dev, "Request threaded irq failed.\n");
drivers/staging/ti-soc-thermal/ti-bandgap.c:	struct device_node *node = pdev->dev.of_node;
drivers/staging/ti-soc-thermal/ti-bandgap.c:		dev_err(&pdev->dev, "no platform information available\n");
drivers/staging/ti-soc-thermal/ti-bandgap.c:	bgp = devm_kzalloc(&pdev->dev, sizeof(*bgp), GFP_KERNEL);
drivers/staging/ti-soc-thermal/ti-bandgap.c:		dev_err(&pdev->dev, "Unable to allocate mem for driver ref\n");
drivers/staging/ti-soc-thermal/ti-bandgap.c:	of_id = of_match_device(of_ti_bandgap_match, &pdev->dev);
drivers/staging/ti-soc-thermal/ti-bandgap.c:	bgp->regval = devm_kzalloc(&pdev->dev, sizeof(*bgp->regval) *
drivers/staging/ti-soc-thermal/ti-bandgap.c:		dev_err(&pdev->dev, "Unable to allocate mem for driver ref\n");
drivers/staging/ti-soc-thermal/ti-bandgap.c:		chunk = devm_ioremap_resource(&pdev->dev, res);
drivers/staging/ti-soc-thermal/ti-bandgap.c:			dev_err(&pdev->dev, "missing tshut gpio in device tree\n");
drivers/staging/ti-soc-thermal/ti-bandgap.c:			dev_err(&pdev->dev, "invalid gpio for tshut (%d)\n",
drivers/staging/ti-soc-thermal/ti-bandgap.c:		dev_err(&pdev->dev, "failed to fetch platform data\n");
drivers/staging/ti-soc-thermal/ti-bandgap.c:	bgp->dev = &pdev->dev;
drivers/staging/ti-soc-thermal/ti-bandgap.c:			dev_err(&pdev->dev,
drivers/staging/ti-soc-thermal/ti-bandgap.c:		dev_err(&pdev->dev, "failed to request fclock reference\n");
drivers/staging/ti-soc-thermal/ti-bandgap.c:		dev_err(&pdev->dev,
drivers/staging/ti-soc-thermal/ti-bandgap.c:			dev_info(&pdev->dev,
drivers/staging/ti-soc-thermal/ti-bandgap.c:		dev_err(&pdev->dev, "wrong clock rate (%d)\n", clk_rate);
drivers/staging/ti-soc-thermal/ti-bandgap.c:		dev_err(&pdev->dev, "Cannot re-set clock rate. Continuing\n");
drivers/staging/ti-soc-thermal/ti-bandgap.c:	bgp->dev = &pdev->dev;
drivers/staging/ti-soc-thermal/ti-bandgap.c:			dev_err(&pdev->dev, "failed to initialize Talert IRQ\n");
drivers/staging/android/timed_gpio.c:	struct timed_gpio_platform_data *pdata = pdev->dev.platform_data;
drivers/staging/android/timed_gpio.c:	struct timed_gpio_platform_data *pdata = pdev->dev.platform_data;
drivers/staging/media/lirc/lirc_bt829.c:	atir_driver.dev         = &pdev->dev;
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:	v4l2_info(vpfe_dev->pdev->driver, "vpfe capture clocks disabled\n");
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:		v4l2_err(vpfe_dev->pdev->driver, "Memory allocation failed\n");
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:			v4l2_err(vpfe_dev->pdev->driver,
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:			v4l2_err(vpfe_dev->pdev->driver,
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:			v4l2_err(vpfe_dev->pdev->driver,
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:		v4l2_info(vpfe_dev->pdev->driver, "vpss clock %s enabled",
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:	v4l2_err(vpfe_dev->pdev->driver, "Failed to enable clocks\n");
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:		v4l2_err(pdev->dev.driver,
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:	if (pdev->dev.platform_data == NULL) {
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:		v4l2_err(pdev->dev.driver, "Unable to get vpfe config\n");
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:	vpfe_dev->cfg = pdev->dev.platform_data;
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:		v4l2_err(pdev->dev.driver, "null ptr in vpfe_cfg\n");
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:		v4l2_err(pdev->dev.driver,
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:		v4l2_err(pdev->dev.driver,
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:		v4l2_err(pdev->dev.driver,
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:	vpfe_dev->pdev = &pdev->dev;
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:		v4l2_err(pdev->dev.driver,
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:	ret = v4l2_device_register(&pdev->dev, &vpfe_dev->v4l2_dev);
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:		v4l2_err(pdev->dev.driver, "Unable to register v4l2 device.\n");
drivers/staging/media/davinci_vpfe/vpfe_mc_capture.c:	v4l2_info(pdev->dev.driver, "vpfe_remove\n");
drivers/staging/media/davinci_vpfe/vpfe_video.c:	vpfe_cfg = vpfe_dev->pdev->platform_data;
drivers/staging/media/dt3155v4l/dt3155v4l.c:	ret = vb2_dma_contig_init_ctx(&pd->pdev->dev);
drivers/staging/media/dt3155v4l/dt3155v4l.c:		ret = request_irq(pd->pdev->irq, dt3155_irq_handler_even,
drivers/staging/media/dt3155v4l/dt3155v4l.c:		free_irq(pd->pdev->irq, pd);
drivers/staging/media/dt3155v4l/dt3155v4l.c:	buf_cpu = dma_alloc_coherent(&pdev->dev, DT3155_BUF_SIZE, &buf_dma,
drivers/staging/media/dt3155v4l/dt3155v4l.c:	dma_free_coherent(&pdev->dev, DT3155_BUF_SIZE, buf_cpu, buf_dma);
drivers/staging/media/dt3155v4l/dt3155v4l.c:	err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/staging/media/dt3155v4l/dt3155v4l.c:	err = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/staging/media/dt3155v4l/dt3155v4l.c:	if (dt3155_alloc_coherent(&pdev->dev, DT3155_CHUNK_SIZE,
drivers/staging/media/dt3155v4l/dt3155v4l.c:		dev_info(&pdev->dev, "preallocated 8 buffers\n");
drivers/staging/media/dt3155v4l/dt3155v4l.c:	dev_info(&pdev->dev, "/dev/video%i is ready\n", pd->vdev->minor);
drivers/staging/media/dt3155v4l/dt3155v4l.c:	dt3155_free_coherent(&pdev->dev);
drivers/staging/media/solo6x10/solo6x10-core.c:		if (pdev->irq)
drivers/staging/media/solo6x10/solo6x10-core.c:			free_irq(pdev->irq, solo_dev);
drivers/staging/media/solo6x10/solo6x10-core.c:	dev->parent = &solo_dev->pdev->dev;
drivers/staging/media/solo6x10/solo6x10-core.c:	set_dev_node(dev, dev_to_node(&solo_dev->pdev->dev));
drivers/staging/media/solo6x10/solo6x10-core.c:		dev_info(&pdev->dev, "Probing Softlogic 6010\n");
drivers/staging/media/solo6x10/solo6x10-core.c:		dev_info(&pdev->dev, "Probing Softlogic 6110\n");
drivers/staging/media/solo6x10/solo6x10-core.c:	ret = v4l2_device_register(&pdev->dev, &solo_dev->v4l2_dev);
drivers/staging/media/solo6x10/solo6x10-core.c:		dev_warn(&pdev->dev, "Invalid chip_id 0x%02x, assuming 4 ch\n",
drivers/staging/media/solo6x10/solo6x10-core.c:	ret = request_irq(pdev->irq, solo_isr, IRQF_SHARED, SOLO6X10_NAME,
drivers/staging/media/solo6x10/solo6x10-g723.c:		pci_name(solo_dev->pdev), solo_dev->pdev->irq);
drivers/staging/media/solo6x10/solo6x10-g723.c:	snd_card_set_dev(card, &solo_dev->pdev->dev);
drivers/staging/media/solo6x10/solo6x10-g723.c:	dev_info(&solo_dev->pdev->dev, "Alsa sound card as %s\n", name);
drivers/staging/media/solo6x10/solo6x10-v4l2-enc.c:	dma_map_sg(&solo_dev->pdev->dev, vbuf->sglist, vbuf->num_pages,
drivers/staging/media/solo6x10/solo6x10-v4l2-enc.c:	dma_unmap_sg(&solo_dev->pdev->dev, vbuf->sglist, vbuf->num_pages,
drivers/staging/media/solo6x10/solo6x10-v4l2-enc.c:	dma_map_sg(&solo_dev->pdev->dev, vbuf->sglist, vbuf->num_pages,
drivers/staging/media/solo6x10/solo6x10-v4l2-enc.c:	dma_unmap_sg(&solo_dev->pdev->dev, vbuf->sglist, vbuf->num_pages,
drivers/staging/media/solo6x10/solo6x10-v4l2-enc.c:			dev_err(&solo_dev->pdev->dev,
drivers/staging/media/solo6x10/solo6x10-v4l2-enc.c:	dev_info(&solo_dev->pdev->dev, "Encoders as /dev/video%d-%d\n",
drivers/staging/media/solo6x10/solo6x10-tw28.c:		dev_err(&solo_dev->pdev->dev,
drivers/staging/media/solo6x10/solo6x10-p2m.c:		dev_err(&solo_dev->pdev->dev, "Error detecting SDRAM size\n");
drivers/staging/media/solo6x10/solo6x10-p2m.c:		dev_err(&solo_dev->pdev->dev,
drivers/staging/media/solo6x10/solo6x10-v4l2.c:	solo_dev->alloc_ctx = vb2_dma_contig_init_ctx(&solo_dev->pdev->dev);
drivers/staging/media/solo6x10/solo6x10-v4l2.c:		dev_err(&solo_dev->pdev->dev, "Can't allocate buffer context");
drivers/staging/media/solo6x10/solo6x10-v4l2.c:	dev_info(&solo_dev->pdev->dev, "Display as /dev/video%d with "
drivers/staging/media/solo6x10/solo6x10-i2c.c:		adap->dev.parent = &solo_dev->pdev->dev;
drivers/staging/goldfish/goldfish_audio.c:		dev_err(&pdev->dev, "platform_get_resource failed\n");
drivers/staging/goldfish/goldfish_audio.c:		dev_err(&pdev->dev, "platform_get_irq failed\n");
drivers/staging/goldfish/goldfish_audio.c:	data->buffer_virt = dma_alloc_coherent(&pdev->dev,
drivers/staging/goldfish/goldfish_audio.c:		dev_err(&pdev->dev, "allocate buffer failed\n");
drivers/staging/goldfish/goldfish_audio.c:					IRQF_SHARED, pdev->name, data);
drivers/staging/goldfish/goldfish_audio.c:		dev_err(&pdev->dev, "request_irq failed\n");
drivers/staging/goldfish/goldfish_audio.c:		dev_err(&pdev->dev,
drivers/staging/goldfish/goldfish_audio.c:	dma_free_coherent(&pdev->dev, COMBINED_BUFFER_SIZE,
drivers/staging/goldfish/goldfish_audio.c:	dma_free_coherent(&pdev->dev, COMBINED_BUFFER_SIZE,
drivers/staging/goldfish/goldfish_nand.c:	nand->cmd_params = devm_kzalloc(&pdev->dev,
drivers/staging/goldfish/goldfish_nand.c:	dev_dbg(&pdev->dev, 
drivers/staging/goldfish/goldfish_nand.c:	mtd->name = name = devm_kzalloc(&pdev->dev, name_len + 1, GFP_KERNEL);
drivers/staging/goldfish/goldfish_nand.c:		dev_err(&pdev->dev, 
drivers/staging/goldfish/goldfish_nand.c:	base = devm_ioremap(&pdev->dev, r->start, PAGE_SIZE);
drivers/staging/goldfish/goldfish_nand.c:		dev_err(&pdev->dev, 
drivers/staging/goldfish/goldfish_nand.c:	nand = devm_kzalloc(&pdev->dev, sizeof(*nand) + 
drivers/staging/phison/phison.c:	dev_dbg(&pdev->dev, "phison_init_one(), ret = %x\n", ret);
drivers/staging/netlogic/xlr_net.c:	priv->mii_bus->parent = &pdev->dev;
drivers/staging/netlogic/xlr_net.c:	mac = pdev->id;
drivers/staging/netlogic/xlr_net.c:	priv->nd = (struct xlr_net_data *)pdev->dev.platform_data;
drivers/staging/netlogic/xlr_net.c:		(&pdev->dev, res);
drivers/staging/netlogic/xlr_net.c:		dev_err(&pdev->dev,
drivers/staging/netlogic/xlr_net.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/staging/tidspbridge/rmgr/drv_interface.c:	struct omap_dsp_platform_data *pdata = pdev->dev.platform_data;
drivers/staging/et131x/et131x.c:			&& adapter->pdev->revision == 0)
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev,
drivers/staging/et131x/et131x.c:		if (pdev->revision == 0x01) {
drivers/staging/et131x/et131x.c:		if (pdev->revision  != 0x01 || write_failed) {
drivers/staging/et131x/et131x.c:			dev_err(&pdev->dev,
drivers/staging/et131x/et131x.c:			dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:			dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_warn(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_warn(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_warn(&adapter->pdev->dev, "status is  0x%08x\n",
drivers/staging/et131x/et131x.c:		dev_warn(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_warn(&adapter->pdev->dev, "status is  0x%08x\n",
drivers/staging/et131x/et131x.c:		dev_warn(&adapter->pdev->dev, "command is  0x%08x\n",
drivers/staging/et131x/et131x.c:				dma_alloc_coherent(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:			dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:					&adapter->pdev->dev, fbr_chunksize,
drivers/staging/et131x/et131x.c:				dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:	rx_ring->ps_ring_virtaddr = dma_alloc_coherent(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:	rx_ring->rx_status_block = dma_alloc_coherent(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:				dma_free_coherent(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dma_free_coherent(&adapter->pdev->dev, bufsize,
drivers/staging/et131x/et131x.c:		dma_free_coherent(&adapter->pdev->dev, pktstat_ringsize,
drivers/staging/et131x/et131x.c:		dma_free_coherent(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev, "Couldn't alloc an SKB for Rx\n");
drivers/staging/et131x/et131x.c:			dev_warn(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:	    (struct tx_desc *) dma_alloc_coherent(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:	tx_ring->tx_status = dma_alloc_coherent(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dma_free_coherent(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dma_free_coherent(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:				dma_addr = dma_map_single(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:				dma_addr = dma_map_single(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:				dma_addr = dma_map_single(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:			dma_addr = skb_frag_dma_map(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:			dma_unmap_single(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:	regs->version = (1 << 24) | (adapter->pdev->revision << 16) |
drivers/staging/et131x/et131x.c:			adapter->pdev->device;
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "Missing PCIe capabilities\n");
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev,
drivers/staging/et131x/et131x.c:			dev_err(&pdev->dev,
drivers/staging/et131x/et131x.c:			dev_err(&pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev,
drivers/staging/et131x/et131x.c:			dev_err(&pdev->dev, "Could not read PCI config space for MAC address\n");
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev, "no PHY found\n");
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev, "Could not attach to PHY\n");
drivers/staging/et131x/et131x.c:	if (adapter->pdev->device != ET131X_PCI_DEVICE_ID_FAST)
drivers/staging/et131x/et131x.c:	dev_info(&adapter->pdev->dev, "attached PHY driver [%s] (mii_bus:phy_addr=%s)\n",
drivers/staging/et131x/et131x.c:		dev_warn(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_warn(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev, "WAKE_ON_LAN interrupt\n");
drivers/staging/et131x/et131x.c:		dev_warn(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_warn(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_warn(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:	unsigned int irq = pdev->irq;
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "could not register IRQ %d\n", irq);
drivers/staging/et131x/et131x.c:	free_irq(adapter->pdev->irq, netdev);
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev, "hardware error - reset\n");
drivers/staging/et131x/et131x.c:			dev_warn(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_warn(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&adapter->pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "pci_enable_device() failed\n");
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "Can't find PCI device's base address\n");
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "Can't get PCI resources\n");
drivers/staging/et131x/et131x.c:	if (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(64))) {
drivers/staging/et131x/et131x.c:		rc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/staging/et131x/et131x.c:			dev_err(&pdev->dev,
drivers/staging/et131x/et131x.c:	} else if (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {
drivers/staging/et131x/et131x.c:		rc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/staging/et131x/et131x.c:			dev_err(&pdev->dev,
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "No usable DMA addressing method\n");
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "Couldn't alloc netdev struct\n");
drivers/staging/et131x/et131x.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "Cannot map device registers\n");
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "Could not alloc adapater memory (DMA)\n");
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "Alloc of mii_bus struct failed\n");
drivers/staging/et131x/et131x.c:		(adapter->pdev->bus->number << 8) | adapter->pdev->devfn);
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "failed to register MII bus\n");
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "failed to probe MII bus\n");
drivers/staging/et131x/et131x.c:		dev_err(&pdev->dev, "register_netdev() failed\n");
drivers/staging/usbip/vhci_hcd.c:	usbip_dbg_vhci_hc("name %s id %d\n", pdev->name, pdev->id);
drivers/staging/usbip/vhci_hcd.c:	if (pdev->dev.dma_mask) {
drivers/staging/usbip/vhci_hcd.c:		dev_info(&pdev->dev, "vhci_hcd DMA not supported\n");
drivers/staging/usbip/vhci_hcd.c:	hcd = usb_create_hcd(&vhci_hc_driver, &pdev->dev, dev_name(&pdev->dev));
drivers/staging/usbip/vhci_hcd.c:		dev_info(&pdev->dev, "We have %d active connection%s. Do not "
drivers/staging/usbip/vhci_hcd.c:		dev_info(&pdev->dev, "suspend vhci_hcd");
drivers/staging/usbip/vhci_hcd.c:	dev_dbg(&pdev->dev, "%s\n", __func__);
drivers/staging/xgifb/vb_init.c:		dev_err(&pdev->dev, "Video BIOS not available\n");
drivers/staging/xgifb/vb_init.c:	dev_err(&pdev->dev, "Video BIOS corrupted\n");
drivers/staging/xgifb/vb_init.c:		dev_dbg(&pdev->dev, "pVBInfo->FBAddr == 0\n");
drivers/staging/xgifb/XGI_main_26.c:	fb_info = framebuffer_alloc(sizeof(*xgifb_info), &pdev->dev);
drivers/staging/xgifb/XGI_main_26.c:	xgifb_info->chip_id = pdev->device;
drivers/staging/xgifb/XGI_main_26.c:	xgifb_info->pcibus = pdev->bus->number;
drivers/staging/xgifb/XGI_main_26.c:	xgifb_info->pcislot = PCI_SLOT(pdev->devfn);
drivers/staging/xgifb/XGI_main_26.c:	xgifb_info->pcifunc = PCI_FUNC(pdev->devfn);
drivers/staging/xgifb/XGI_main_26.c:	xgifb_info->subsysvendor = pdev->subsystem_vendor;
drivers/staging/xgifb/XGI_main_26.c:	xgifb_info->subsysdevice = pdev->subsystem_device;
drivers/staging/xgifb/XGI_main_26.c:	dev_info(&pdev->dev, "Relocate IO address: %Lx [%08lx]\n",
drivers/staging/xgifb/XGI_main_26.c:		dev_err(&pdev->dev, "I/O error\n");
drivers/staging/xgifb/XGI_main_26.c:	dev_info(&pdev->dev, "chipid = %x\n", xgifb_info->chip);
drivers/staging/xgifb/XGI_main_26.c:		dev_err(&pdev->dev, "Unable request memory size %x\n",
drivers/staging/xgifb/XGI_main_26.c:		dev_err(&pdev->dev,
drivers/staging/xgifb/XGI_main_26.c:		dev_err(&pdev->dev,
drivers/staging/xgifb/XGI_main_26.c:	dev_info(&pdev->dev,
drivers/staging/xgifb/XGI_main_26.c:	dev_info(&pdev->dev,
drivers/staging/xgifb/XGI_main_26.c:		dev_err(&pdev->dev, "XGIInitNew() failed!\n");
drivers/staging/xgifb/XGI_main_26.c:			dev_info(&pdev->dev,
drivers/staging/xgifb/XGI_main_26.c:			dev_info(&pdev->dev,
drivers/staging/xgifb/XGI_main_26.c:			dev_info(&pdev->dev, "XGI301 bridge detected\n");
drivers/staging/xgifb/XGI_main_26.c:			dev_info(&pdev->dev,
drivers/staging/xgifb/XGI_main_26.c:			dev_info(&pdev->dev,
drivers/staging/xgifb/XGI_main_26.c:			dev_info(&pdev->dev, "XGI302 bridge detected\n");
drivers/staging/xgifb/XGI_main_26.c:		dev_info(&pdev->dev, "LVDS transmitter detected\n");
drivers/staging/xgifb/XGI_main_26.c:		dev_info(&pdev->dev, "Trumpion Zurac LVDS scaler detected\n");
drivers/staging/xgifb/XGI_main_26.c:		dev_info(&pdev->dev, "Chrontel TV encoder detected\n");
drivers/staging/xgifb/XGI_main_26.c:		dev_info(&pdev->dev,
drivers/staging/xgifb/XGI_main_26.c:		dev_info(&pdev->dev, "No or unknown bridge type detected\n");
drivers/staging/xgifb/XGI_main_26.c:		dev_err(&pdev->dev, "No supported video mode found\n");
drivers/staging/xgifb/XGI_main_26.c:		dev_info(&pdev->dev, "Added MTRR\n");
drivers/staging/nvec/nvec_kbd.c:	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
drivers/staging/nvec/nvec_kbd.c:	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
drivers/staging/nvec/nvec.c:	struct nvec_platform_data *pdata = pdev->dev.platform_data;
drivers/staging/nvec/nvec.c:	nvec = devm_kzalloc(&pdev->dev, sizeof(struct nvec_chip), GFP_KERNEL);
drivers/staging/nvec/nvec.c:		dev_err(&pdev->dev, "failed to reserve memory\n");
drivers/staging/nvec/nvec.c:	nvec->dev = &pdev->dev;
drivers/staging/nvec/nvec.c:			dev_err(&pdev->dev, "no gpio specified");
drivers/staging/nvec/nvec.c:			dev_err(&pdev->dev, "no i2c address specified");
drivers/staging/nvec/nvec.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/staging/nvec/nvec.c:	base = devm_ioremap_resource(&pdev->dev, res);
drivers/staging/nvec/nvec.c:		dev_err(&pdev->dev, "no irq resource?\n");
drivers/staging/nvec/nvec.c:	i2c_clk = devm_clk_get(&pdev->dev, "div-clk");
drivers/staging/nvec/nvec.c:	err = devm_gpio_request_one(&pdev->dev, nvec->gpio, GPIOF_OUT_INIT_HIGH,
drivers/staging/nvec/nvec.c:	err = devm_request_irq(&pdev->dev, nvec->irq, nvec_interrupt, 0,
drivers/staging/nvec/nvec_ps2.c:	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
drivers/staging/nvec/nvec_ps2.c:	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
drivers/staging/nvec/nvec_power.c:	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
drivers/staging/nvec/nvec_power.c:	power = devm_kzalloc(&pdev->dev, sizeof(struct nvec_power), GFP_NOWAIT);
drivers/staging/nvec/nvec_power.c:	dev_set_drvdata(&pdev->dev, power);
drivers/staging/nvec/nvec_power.c:	switch (pdev->id) {
drivers/staging/nvec/nvec_power.c:	if (pdev->id == BAT)
drivers/staging/nvec/nvec_power.c:	return power_supply_register(&pdev->dev, psy);
drivers/staging/nvec/nvec_power.c:	switch (pdev->id) {
drivers/staging/nvec/nvec_paz00.c:	struct nvec_chip *nvec = dev_get_drvdata(pdev->dev.parent);
drivers/staging/nvec/nvec_paz00.c:	led = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);
drivers/staging/nvec/nvec_paz00.c:	ret = led_classdev_register(&pdev->dev, &led->cdev);
drivers/staging/iio/adc/ad7606_par.c:		dev_err(&pdev->dev, "no irq\n");
drivers/staging/iio/adc/ad7606_par.c:	indio_dev = ad7606_probe(&pdev->dev, irq, addr,
drivers/staging/iio/adc/spear_adc.c:	struct device_node *np = pdev->dev.of_node;
drivers/staging/iio/adc/spear_adc.c:	struct device *dev = &pdev->dev;
drivers/staging/iio/adc/lpc32xx_adc.c:		dev_err(&pdev->dev, "failed to get platform I/O memory\n");
drivers/staging/iio/adc/lpc32xx_adc.c:		dev_err(&pdev->dev, "failed allocating iio device\n");
drivers/staging/iio/adc/lpc32xx_adc.c:		dev_err(&pdev->dev, "failed mapping memory\n");
drivers/staging/iio/adc/lpc32xx_adc.c:	info->clk = clk_get(&pdev->dev, NULL);
drivers/staging/iio/adc/lpc32xx_adc.c:		dev_err(&pdev->dev, "failed getting clock\n");
drivers/staging/iio/adc/lpc32xx_adc.c:		dev_err(&pdev->dev, "failed getting interrupt resource\n");
drivers/staging/iio/adc/lpc32xx_adc.c:		dev_err(&pdev->dev, "failed requesting interrupt\n");
drivers/staging/iio/adc/lpc32xx_adc.c:	iodev->dev.parent = &pdev->dev;
drivers/staging/iio/adc/lpc32xx_adc.c:	dev_info(&pdev->dev, "LPC32XX ADC driver loaded, IRQ %d\n", irq);
drivers/staging/iio/adc/mxs-lradc.c:		of_match_device(mxs_lradc_dt_ids, &pdev->dev);
drivers/staging/iio/adc/mxs-lradc.c:	struct device *dev = &pdev->dev;
drivers/staging/iio/adc/mxs-lradc.c:	lradc->dev = &pdev->dev;
drivers/staging/iio/adc/mxs-lradc.c:	iio->name = pdev->name;
drivers/staging/iio/adc/mxs-lradc.c:	iio->dev.parent = &pdev->dev;
drivers/staging/iio/trigger/iio-trig-gpio.c:				dev_err(&pdev->dev, "No GPIO IRQs specified");
drivers/staging/iio/trigger/iio-trig-gpio.c:				dev_err(&pdev->dev,
drivers/staging/iio/trigger/iio-trig-bfin-timer.c:	struct iio_bfin_timer_trigger_pdata *pdata = pdev->dev.platform_data;
drivers/staging/iio/trigger/iio-trig-bfin-timer.c:		dev_err(&pdev->dev, "No IRQs specified");
drivers/staging/iio/trigger/iio-trig-bfin-timer.c:		dev_err(&pdev->dev,
drivers/staging/iio/trigger/iio-trig-bfin-timer.c:	dev_info(&pdev->dev, "iio trigger Blackfin TMR%d, IRQ-%d",
drivers/staging/wlags49_h2/wl_pci.c:    dev->irq = pdev->irq;
drivers/staging/wlags49_h2/wl_pci.c:    DBG_TRACE( DbgInfo, "Device Base Address: %#03lx\n", pdev->resource[0].start );
drivers/staging/wlags49_h2/wl_pci.c:	dev->base_addr = pdev->resource[0].start;
drivers/staging/octeon/ethernet.c:	pip = pdev->dev.of_node;
drivers/staging/silicom/bypasslib/bypass.c:				if ((pdev->vendor == SILICOM_VID) &&
drivers/staging/silicom/bypasslib/bypass.c:				    (pdev->device >= SILICOM_BP_PID_MIN) &&
drivers/staging/silicom/bypasslib/bypass.c:				    (pdev->device <= SILICOM_BP_PID_MAX))
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&info->pdev->dev, "%s: invalid state %d\n", __func__,
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&info->pdev->dev, "%s: invalid state %d\n", __func__,
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&info->pdev->dev, "non-supported command %x\n",
drivers/mtd/nand/pxa3xx_nand.c:			dev_err(&info->pdev->dev, "Wait time out!!!\n");
drivers/mtd/nand/pxa3xx_nand.c:	struct pxa3xx_nand_platform_data *pdata = pdev->dev.platform_data;
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "Current only support 2048 and 512 size\n");
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "Only support 8bit and 16 bit!\n");
drivers/mtd/nand/pxa3xx_nand.c:	info->data_buff = dma_alloc_coherent(&pdev->dev, MAX_BUFF_SIZE,
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "failed to allocate dma buffer\n");
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "failed to request data dma\n");
drivers/mtd/nand/pxa3xx_nand.c:		dma_free_coherent(&pdev->dev, MAX_BUFF_SIZE,
drivers/mtd/nand/pxa3xx_nand.c:	struct pxa3xx_nand_platform_data *pdata = pdev->dev.platform_data;
drivers/mtd/nand/pxa3xx_nand.c:		dev_info(&info->pdev->dev, "There is no chip on cs %d!\n",
drivers/mtd/nand/pxa3xx_nand.c:		dev_info(&info->pdev->dev, "Detect a flash id %x\n", id);
drivers/mtd/nand/pxa3xx_nand.c:		dev_warn(&info->pdev->dev,
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&info->pdev->dev, "ERROR!! flash not defined!!!\n");
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&info->pdev->dev, "ERROR! Configure failed\n");
drivers/mtd/nand/pxa3xx_nand.c:	pdata = pdev->dev.platform_data;
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/mtd/nand/pxa3xx_nand.c:	info->clk = clk_get(&pdev->dev, NULL);
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "failed to get nand clock\n");
drivers/mtd/nand/pxa3xx_nand.c:	if (pdev->dev.of_node && cpu_is_pxa3xx()) {
drivers/mtd/nand/pxa3xx_nand.c:			dev_err(&pdev->dev, "no resource defined for data DMA\n");
drivers/mtd/nand/pxa3xx_nand.c:			dev_err(&pdev->dev, "no resource defined for command DMA\n");
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "no IRQ resource defined\n");
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "no IO memory resource defined\n");
drivers/mtd/nand/pxa3xx_nand.c:	r = request_mem_region(r->start, resource_size(r), pdev->name);
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "failed to request memory resource\n");
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "ioremap() failed\n");
drivers/mtd/nand/pxa3xx_nand.c:			  pdev->name, info);
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "failed to request IRQ\n");
drivers/mtd/nand/pxa3xx_nand.c:		dma_free_coherent(&pdev->dev, MAX_BUFF_SIZE,
drivers/mtd/nand/pxa3xx_nand.c:	pdata = pdev->dev.platform_data;
drivers/mtd/nand/pxa3xx_nand.c:		dma_free_writecombine(&pdev->dev, MAX_BUFF_SIZE,
drivers/mtd/nand/pxa3xx_nand.c:	struct device_node *np = pdev->dev.of_node;
drivers/mtd/nand/pxa3xx_nand.c:			of_match_device(pxa3xx_nand_dt_ids, &pdev->dev);
drivers/mtd/nand/pxa3xx_nand.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/mtd/nand/pxa3xx_nand.c:	pdev->dev.platform_data = pdata;
drivers/mtd/nand/pxa3xx_nand.c:	pdata = pdev->dev.platform_data;
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "no platform data defined\n");
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "alloc nand resource failed\n");
drivers/mtd/nand/pxa3xx_nand.c:			dev_warn(&pdev->dev, "failed to scan nand at cs %d\n",
drivers/mtd/nand/pxa3xx_nand.c:		ppdata.of_node = pdev->dev.of_node;
drivers/mtd/nand/pxa3xx_nand.c:	pdata = pdev->dev.platform_data;
drivers/mtd/nand/pxa3xx_nand.c:		dev_err(&pdev->dev, "driver busy, state = %d\n", info->state);
drivers/mtd/nand/pxa3xx_nand.c:	pdata = pdev->dev.platform_data;
drivers/mtd/nand/ams-delta.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/mtd/nand/au1550nd.c:	pd = pdev->dev.platform_data;
drivers/mtd/nand/au1550nd.c:		dev_err(&pdev->dev, "missing platform data\n");
drivers/mtd/nand/au1550nd.c:		dev_err(&pdev->dev, "no memory for NAND context\n");
drivers/mtd/nand/au1550nd.c:		dev_err(&pdev->dev, "no NAND memory resource\n");
drivers/mtd/nand/au1550nd.c:		dev_err(&pdev->dev, "cannot claim NAND memory area\n");
drivers/mtd/nand/au1550nd.c:		dev_err(&pdev->dev, "cannot remap NAND memory area\n");
drivers/mtd/nand/au1550nd.c:		dev_err(&pdev->dev, "cannot detect NAND chipselect\n");
drivers/mtd/nand/au1550nd.c:		dev_err(&pdev->dev, "NAND scan failed with %d\n", ret);
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:	dma_chan = dma_request_slave_channel(&pdev->dev, "rx-tx");
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:	pinctrl = devm_pinctrl_get_select_default(&this->pdev->dev);
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:	ppdata.of_node = this->pdev->dev.of_node;
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:	of_id = of_match_device(gpmi_nand_id_table, &pdev->dev);
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:		pdev->id_entry = of_id->data;
drivers/mtd/nand/gpmi-nand/gpmi-nand.c:	this->dev   = &pdev->dev;
drivers/mtd/nand/gpmi-nand/gpmi-nand.h:#define GPMI_IS_MX23(x)		((x)->pdev->id_entry->driver_data == IS_MX23)
drivers/mtd/nand/gpmi-nand/gpmi-nand.h:#define GPMI_IS_MX28(x)		((x)->pdev->id_entry->driver_data == IS_MX28)
drivers/mtd/nand/gpmi-nand/gpmi-nand.h:#define GPMI_IS_MX6Q(x)		((x)->pdev->id_entry->driver_data == IS_MX6Q)
drivers/mtd/nand/fsmc_nand.c:	struct fsmc_nand_platform_data *pdata = dev_get_platdata(&pdev->dev);
drivers/mtd/nand/fsmc_nand.c:			dev_err(&pdev->dev, "invalid bank-width %u\n", val);
drivers/mtd/nand/fsmc_nand.c:	struct fsmc_nand_platform_data *pdata = dev_get_platdata(&pdev->dev);
drivers/mtd/nand/fsmc_nand.c:	struct device_node __maybe_unused *np = pdev->dev.of_node;
drivers/mtd/nand/fsmc_nand.c:		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/mtd/nand/fsmc_nand.c:		pdev->dev.platform_data = pdata;
drivers/mtd/nand/fsmc_nand.c:			dev_err(&pdev->dev, "no platform data\n");
drivers/mtd/nand/fsmc_nand.c:		dev_err(&pdev->dev, "platform data is NULL\n");
drivers/mtd/nand/fsmc_nand.c:	host = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);
drivers/mtd/nand/fsmc_nand.c:		dev_err(&pdev->dev, "failed to allocate device structure\n");
drivers/mtd/nand/fsmc_nand.c:	host->data_va = devm_ioremap_resource(&pdev->dev, res);
drivers/mtd/nand/fsmc_nand.c:	host->addr_va = devm_ioremap_resource(&pdev->dev, res);
drivers/mtd/nand/fsmc_nand.c:	host->cmd_va = devm_ioremap_resource(&pdev->dev, res);
drivers/mtd/nand/fsmc_nand.c:	host->regs_va = devm_ioremap_resource(&pdev->dev, res);
drivers/mtd/nand/fsmc_nand.c:	host->clk = clk_get(&pdev->dev, NULL);
drivers/mtd/nand/fsmc_nand.c:		dev_err(&pdev->dev, "failed to fetch block clock\n");
drivers/mtd/nand/fsmc_nand.c:	dev_info(&pdev->dev, "FSMC device partno %03x, manufacturer %02x, "
drivers/mtd/nand/fsmc_nand.c:	host->dev = &pdev->dev;
drivers/mtd/nand/fsmc_nand.c:			dev_err(&pdev->dev, "Unable to get read dma channel\n");
drivers/mtd/nand/fsmc_nand.c:			dev_err(&pdev->dev, "Unable to get write dma channel\n");
drivers/mtd/nand/fsmc_nand.c:		dev_err(&pdev->dev, "No NAND Device found!\n");
drivers/mtd/nand/fsmc_nand.c:	dev_info(&pdev->dev, "FSMC NAND driver registration successful\n");
drivers/mtd/nand/lpc32xx_mlc.c:	host = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);
drivers/mtd/nand/lpc32xx_mlc.c:		dev_err(&pdev->dev, "failed to allocate device structure.\n");
drivers/mtd/nand/lpc32xx_mlc.c:	host->io_base = devm_ioremap_resource(&pdev->dev, rc);
drivers/mtd/nand/lpc32xx_mlc.c:	if (pdev->dev.of_node)
drivers/mtd/nand/lpc32xx_mlc.c:		host->ncfg = lpc32xx_parse_dt(&pdev->dev);
drivers/mtd/nand/lpc32xx_mlc.c:		dev_err(&pdev->dev,
drivers/mtd/nand/lpc32xx_mlc.c:		dev_err(&pdev->dev, "GPIO not available\n");
drivers/mtd/nand/lpc32xx_mlc.c:	host->pdata = pdev->dev.platform_data;
drivers/mtd/nand/lpc32xx_mlc.c:	mtd->dev.parent = &pdev->dev;
drivers/mtd/nand/lpc32xx_mlc.c:	host->clk = clk_get(&pdev->dev, NULL);
drivers/mtd/nand/lpc32xx_mlc.c:		dev_err(&pdev->dev, "Clock initialization failure\n");
drivers/mtd/nand/lpc32xx_mlc.c:	host->dma_buf = devm_kzalloc(&pdev->dev, mtd->writesize, GFP_KERNEL);
drivers/mtd/nand/lpc32xx_mlc.c:		dev_err(&pdev->dev, "Error allocating dma_buf memory\n");
drivers/mtd/nand/lpc32xx_mlc.c:	host->dummy_buf = devm_kzalloc(&pdev->dev, mtd->writesize, GFP_KERNEL);
drivers/mtd/nand/lpc32xx_mlc.c:		dev_err(&pdev->dev, "Error allocating dummy_buf memory\n");
drivers/mtd/nand/lpc32xx_mlc.c:		dev_err(&pdev->dev, "failed to get platform irq\n");
drivers/mtd/nand/lpc32xx_mlc.c:		dev_err(&pdev->dev, "Error requesting NAND IRQ\n");
drivers/mtd/nand/lpc32xx_mlc.c:	ppdata.of_node = pdev->dev.of_node;
drivers/mtd/nand/nuc900_nand.c:	nuc900_nand->clk = clk_get(&pdev->dev, NULL);
drivers/mtd/nand/nuc900_nand.c:	if (!request_mem_region(res->start, resource_size(res), pdev->name)) {
drivers/mtd/nand/lpc32xx_slc.c:		dev_err(&pdev->dev, "No memory resource found for device\n");
drivers/mtd/nand/lpc32xx_slc.c:	host = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);
drivers/mtd/nand/lpc32xx_slc.c:		dev_err(&pdev->dev, "failed to allocate device structure\n");
drivers/mtd/nand/lpc32xx_slc.c:	host->io_base = devm_ioremap_resource(&pdev->dev, rc);
drivers/mtd/nand/lpc32xx_slc.c:	if (pdev->dev.of_node)
drivers/mtd/nand/lpc32xx_slc.c:		host->ncfg = lpc32xx_parse_dt(&pdev->dev);
drivers/mtd/nand/lpc32xx_slc.c:		dev_err(&pdev->dev,
drivers/mtd/nand/lpc32xx_slc.c:		dev_err(&pdev->dev, "GPIO not available\n");
drivers/mtd/nand/lpc32xx_slc.c:	host->pdata = pdev->dev.platform_data;
drivers/mtd/nand/lpc32xx_slc.c:	mtd->dev.parent = &pdev->dev;
drivers/mtd/nand/lpc32xx_slc.c:	host->clk = clk_get(&pdev->dev, NULL);
drivers/mtd/nand/lpc32xx_slc.c:		dev_err(&pdev->dev, "Clock failure\n");
drivers/mtd/nand/lpc32xx_slc.c:	host->data_buf = devm_kzalloc(&pdev->dev, host->dma_buf_len,
drivers/mtd/nand/lpc32xx_slc.c:		dev_err(&pdev->dev, "Error allocating memory\n");
drivers/mtd/nand/lpc32xx_slc.c:			dev_err(&pdev->dev,
drivers/mtd/nand/lpc32xx_slc.c:	ppdata.of_node = pdev->dev.of_node;
drivers/mtd/nand/s3c2410.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
drivers/mtd/nand/s3c2410.c:		dev_err(&pdev->dev, "no memory for flash info\n");
drivers/mtd/nand/s3c2410.c:	info->clk = devm_clk_get(&pdev->dev, "nand");
drivers/mtd/nand/s3c2410.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/mtd/nand/s3c2410.c:	res = pdev->resource;
drivers/mtd/nand/s3c2410.c:	info->device	= &pdev->dev;
drivers/mtd/nand/s3c2410.c:	info->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/mtd/nand/s3c2410.c:	dev_dbg(&pdev->dev, "mapped registers at %p\n", info->regs);
drivers/mtd/nand/s3c2410.c:	info->mtds = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
drivers/mtd/nand/s3c2410.c:		dev_err(&pdev->dev, "failed to allocate mtd storage\n");
drivers/mtd/nand/s3c2410.c:		dev_err(&pdev->dev, "failed to init cpufreq support\n");
drivers/mtd/nand/s3c2410.c:		dev_info(&pdev->dev, "clock idle support enabled\n");
drivers/mtd/nand/docg4.c:	struct device *dev = &pdev->dev;
drivers/mtd/nand/cafe_nand.c:	cafe_dev_dbg(&cafe->pdev->dev, "NAND device is%s ready, IRQ %x (%x) (%x,%x)\n",
drivers/mtd/nand/cafe_nand.c:	cafe_dev_dbg(&cafe->pdev->dev, "Copy 0x%x bytes to write buffer. datalen 0x%x\n",
drivers/mtd/nand/cafe_nand.c:	cafe_dev_dbg(&cafe->pdev->dev, "Copy 0x%x bytes from position 0x%x in read buffer.\n",
drivers/mtd/nand/cafe_nand.c:	cafe_dev_dbg(&cafe->pdev->dev, "Read %02x\n", d);
drivers/mtd/nand/cafe_nand.c:	cafe_dev_dbg(&cafe->pdev->dev, "cmdfunc %02x, 0x%x, 0x%x\n",
drivers/mtd/nand/cafe_nand.c:		cafe_dev_dbg(&cafe->pdev->dev, "Continue command, ctl1 %08x, #data %d\n",
drivers/mtd/nand/cafe_nand.c:		cafe_dev_dbg(&cafe->pdev->dev, "Setup for delayed command, ctl1 %08x, dlen %x\n",
drivers/mtd/nand/cafe_nand.c:	cafe_dev_dbg(&cafe->pdev->dev, "dlen %x, ctl1 %x, ctl2 %x\n",
drivers/mtd/nand/cafe_nand.c:				cafe_dev_dbg(&cafe->pdev->dev, "Wait for ready, IRQ %x\n", irqs);
drivers/mtd/nand/cafe_nand.c:		cafe_dev_dbg(&cafe->pdev->dev, "Command %x completed after %d usec, irqs %x (%x)\n",
drivers/mtd/nand/cafe_nand.c:	cafe_dev_dbg(&cafe->pdev->dev, "select_chip %d\n", chipnr);
drivers/mtd/nand/cafe_nand.c:	cafe_dev_dbg(&cafe->pdev->dev, "irq, bits %x (%x)\n", irqs, cafe_readl(cafe, NAND_IRQ));
drivers/mtd/nand/cafe_nand.c:	cafe_dev_dbg(&cafe->pdev->dev, "ECC result %08x SYN1,2 %08x\n",
drivers/mtd/nand/cafe_nand.c:			dev_dbg(&cafe->pdev->dev, "Failed to correct ECC at %08x\n",
drivers/mtd/nand/cafe_nand.c:			dev_dbg(&cafe->pdev->dev, "Corrected %d symbol errors\n", n);
drivers/mtd/nand/cafe_nand.c:	if ((pdev->class >> 8) != PCI_CLASS_MEMORY_FLASH)
drivers/mtd/nand/cafe_nand.c:		dev_warn(&pdev->dev, "failed to alloc mtd_info\n");
drivers/mtd/nand/cafe_nand.c:	mtd->dev.parent = &pdev->dev;
drivers/mtd/nand/cafe_nand.c:		dev_warn(&pdev->dev, "failed to iomap\n");
drivers/mtd/nand/cafe_nand.c:	cafe->dmabuf = dma_alloc_coherent(&cafe->pdev->dev, 2112 + sizeof(struct nand_buffers),
drivers/mtd/nand/cafe_nand.c:		dev_warn(&cafe->pdev->dev, "%d timing register values ignored; precisely three are required\n", numtimings);
drivers/mtd/nand/cafe_nand.c:		cafe_dev_dbg(&cafe->pdev->dev, "Using provided timings (%08x %08x %08x)\n",
drivers/mtd/nand/cafe_nand.c:			cafe_dev_dbg(&cafe->pdev->dev, "Timing registers already set (%08x %08x %08x)\n",
drivers/mtd/nand/cafe_nand.c:			dev_warn(&cafe->pdev->dev, "Timing registers unset; using most conservative defaults\n");
drivers/mtd/nand/cafe_nand.c:	err = request_irq(pdev->irq, &cafe_nand_interrupt, IRQF_SHARED,
drivers/mtd/nand/cafe_nand.c:		dev_warn(&pdev->dev, "Could not register IRQ %d\n", pdev->irq);
drivers/mtd/nand/cafe_nand.c:	cafe_dev_dbg(&cafe->pdev->dev, "Set DMA address to %x (virt %p)\n",
drivers/mtd/nand/cafe_nand.c:	cafe_dev_dbg(&cafe->pdev->dev, "Control %x, IRQ mask %x\n",
drivers/mtd/nand/cafe_nand.c:	free_irq(pdev->irq, mtd);
drivers/mtd/nand/cafe_nand.c:	dma_free_coherent(&cafe->pdev->dev, 2112, cafe->dmabuf, cafe->dmaaddr);
drivers/mtd/nand/cafe_nand.c:	free_irq(pdev->irq, mtd);
drivers/mtd/nand/cafe_nand.c:	dma_free_coherent(&cafe->pdev->dev, 2112, cafe->dmabuf, cafe->dmaaddr);
drivers/mtd/nand/gpio.c:	struct resource *r = devm_kzalloc(&pdev->dev, sizeof(*r), GFP_KERNEL);
drivers/mtd/nand/gpio.c:	if (!r || of_property_read_u64(pdev->dev.of_node,
drivers/mtd/nand/orion_nand.c:	if (pdev->dev.of_node) {
drivers/mtd/nand/orion_nand.c:		board = devm_kzalloc(&pdev->dev, sizeof(struct orion_nand_data),
drivers/mtd/nand/orion_nand.c:		if (!of_property_read_u32(pdev->dev.of_node, "cle", &val))
drivers/mtd/nand/orion_nand.c:		if (!of_property_read_u32(pdev->dev.of_node, "ale", &val))
drivers/mtd/nand/orion_nand.c:		if (!of_property_read_u32(pdev->dev.of_node,
drivers/mtd/nand/orion_nand.c:		if (!of_property_read_u32(pdev->dev.of_node,
drivers/mtd/nand/orion_nand.c:		board = pdev->dev.platform_data;
drivers/mtd/nand/orion_nand.c:	clk = clk_get(&pdev->dev, NULL);
drivers/mtd/nand/orion_nand.c:	ppdata.of_node = pdev->dev.of_node;
drivers/mtd/nand/orion_nand.c:	clk = clk_get(&pdev->dev, NULL);
drivers/mtd/nand/mxc_nand.c:	host = devm_kzalloc(&pdev->dev, sizeof(struct mxc_nand_host) +
drivers/mtd/nand/mxc_nand.c:	host->dev = &pdev->dev;
drivers/mtd/nand/mxc_nand.c:	mtd->dev.parent = &pdev->dev;
drivers/mtd/nand/mxc_nand.c:	host->clk = devm_clk_get(&pdev->dev, NULL);
drivers/mtd/nand/mxc_nand.c:		struct mxc_nand_platform_data *pdata = pdev->dev.platform_data;
drivers/mtd/nand/mxc_nand.c:						pdev->id_entry->driver_data;
drivers/mtd/nand/mxc_nand.c:		host->regs_ip = devm_ioremap_resource(&pdev->dev, res);
drivers/mtd/nand/mxc_nand.c:	host->base = devm_ioremap_resource(&pdev->dev, res);
drivers/mtd/nand/mxc_nand.c:	err = devm_request_irq(&pdev->dev, host->irq, mxc_nfc_irq,
drivers/mtd/nand/mxc_nand.c:				.of_node = pdev->dev.of_node,
drivers/mtd/nand/fsl_elbc_nand.c:	struct device_node *node = pdev->dev.of_node;
drivers/mtd/nand/fsl_elbc_nand.c:	ppdata.of_node = pdev->dev.of_node;
drivers/mtd/nand/fsl_elbc_nand.c:	priv->dev = &pdev->dev;
drivers/mtd/nand/fsl_elbc_nand.c:	struct fsl_elbc_mtd *priv = dev_get_drvdata(&pdev->dev);
drivers/mtd/nand/sh_flctl.c:	dev_err(&flctl->pdev->dev, "Timeout occurred in %s\n", str);
drivers/mtd/nand/sh_flctl.c:	struct sh_flctl_platform_data *pdata = pdev->dev.platform_data;
drivers/mtd/nand/sh_flctl.c:	dev_dbg(&pdev->dev, "%s: TX: got channel %p\n", __func__,
drivers/mtd/nand/sh_flctl.c:	dev_dbg(&pdev->dev, "%s: RX: got channel %p\n", __func__,
drivers/mtd/nand/sh_flctl.c:				dev_dbg(&flctl->pdev->dev,
drivers/mtd/nand/sh_flctl.c:		dev_warn(&flctl->pdev->dev,
drivers/mtd/nand/sh_flctl.c:		dev_err(&flctl->pdev->dev, "wait_for_completion_timeout\n");
drivers/mtd/nand/sh_flctl.c:			dev_info(&flctl->pdev->dev,
drivers/mtd/nand/sh_flctl.c:			dev_warn(&flctl->pdev->dev,
drivers/mtd/nand/sh_flctl.c:	pm_runtime_get_sync(&flctl->pdev->dev);
drivers/mtd/nand/sh_flctl.c:	pm_runtime_put_sync(&flctl->pdev->dev);
drivers/mtd/nand/sh_flctl.c:		pm_runtime_get_sync(&flctl->pdev->dev);
drivers/mtd/nand/sh_flctl.c:		pm_runtime_put_sync(&flctl->pdev->dev);
drivers/mtd/nand/sh_flctl.c:			ret = dev_pm_qos_add_request(&flctl->pdev->dev,
drivers/mtd/nand/sh_flctl.c:				dev_err(&flctl->pdev->dev,
drivers/mtd/nand/sh_flctl.c:			pm_runtime_get_sync(&flctl->pdev->dev);
drivers/mtd/nand/sh_flctl.c:			pm_runtime_put_sync(&flctl->pdev->dev);
drivers/mtd/nand/sh_flctl.c:	dev_err(&flctl->pdev->dev, "flste irq: %x\n", readl(FLINTDMACR(flctl)));
drivers/mtd/nand/sh_flctl.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/mtd/nand/sh_flctl.c:		dev_err(&pdev->dev, "failed to get I/O memory\n");
drivers/mtd/nand/sh_flctl.c:		dev_err(&pdev->dev, "failed to remap I/O memory\n");
drivers/mtd/nand/sh_flctl.c:		dev_err(&pdev->dev, "failed to get flste irq data\n");
drivers/mtd/nand/sh_flctl.c:		dev_err(&pdev->dev, "request interrupt failed.\n");
drivers/mtd/nand/sh_flctl.c:	if (pdev->dev.of_node)
drivers/mtd/nand/sh_flctl.c:		pdata = flctl_parse_dt(&pdev->dev);
drivers/mtd/nand/sh_flctl.c:		pdata = pdev->dev.platform_data;
drivers/mtd/nand/sh_flctl.c:		dev_err(&pdev->dev, "no setup data defined\n");
drivers/mtd/nand/sh_flctl.c:	pm_runtime_enable(&pdev->dev);
drivers/mtd/nand/sh_flctl.c:	pm_runtime_resume(&pdev->dev);
drivers/mtd/nand/sh_flctl.c:	ppdata.of_node = pdev->dev.of_node;
drivers/mtd/nand/sh_flctl.c:	pm_runtime_disable(&pdev->dev);
drivers/mtd/nand/sh_flctl.c:	pm_runtime_disable(&pdev->dev);
drivers/mtd/nand/plat_nand.c:	struct platform_nand_data *pdata = pdev->dev.platform_data;
drivers/mtd/nand/plat_nand.c:		dev_err(&pdev->dev, "platform_nand_data is missing\n");
drivers/mtd/nand/plat_nand.c:		dev_err(&pdev->dev, "invalid number of chips specified\n");
drivers/mtd/nand/plat_nand.c:		dev_err(&pdev->dev, "failed to allocate device structure.\n");
drivers/mtd/nand/plat_nand.c:				dev_name(&pdev->dev))) {
drivers/mtd/nand/plat_nand.c:		dev_err(&pdev->dev, "request_mem_region failed\n");
drivers/mtd/nand/plat_nand.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/mtd/nand/plat_nand.c:	data->mtd.name = dev_name(&pdev->dev);
drivers/mtd/nand/plat_nand.c:	ppdata.of_node = pdev->dev.of_node;
drivers/mtd/nand/plat_nand.c:	struct platform_nand_data *pdata = pdev->dev.platform_data;
drivers/mtd/nand/bcm47xxnflash/main.c:	struct bcma_nflash *nflash = dev_get_platdata(&pdev->dev);
drivers/mtd/nand/bcm47xxnflash/main.c:	struct bcma_nflash *nflash = dev_get_platdata(&pdev->dev);
drivers/mtd/nand/bf5xx_nand.c:	return pdev->dev.platform_data;
drivers/mtd/nand/bf5xx_nand.c:	dev_dbg(&pdev->dev, "(%p)\n", pdev);
drivers/mtd/nand/bf5xx_nand.c:		dev_err(&pdev->dev, "no platform specific information\n");
drivers/mtd/nand/bf5xx_nand.c:		dev_err(&pdev->dev, "requesting Peripherals failed\n");
drivers/mtd/nand/bf5xx_nand.c:		dev_err(&pdev->dev, "no memory for flash info\n");
drivers/mtd/nand/bf5xx_nand.c:	info->device     = &pdev->dev;
drivers/mtd/nand/bf5xx_nand.c:	dev_dbg(&pdev->dev, "initialised ok\n");
drivers/mtd/nand/sharpsl.c:	struct sharpsl_nand_platform_data *data = pdev->dev.platform_data;
drivers/mtd/nand/sharpsl.c:		dev_err(&pdev->dev, "no platform data!\n");
drivers/mtd/nand/sharpsl.c:		dev_err(&pdev->dev, "no io memory resource defined!\n");
drivers/mtd/nand/jz4740_nand.c:		dev_err(&pdev->dev, "Failed to get platform %s memory\n", name);
drivers/mtd/nand/jz4740_nand.c:				pdev->name);
drivers/mtd/nand/jz4740_nand.c:		dev_err(&pdev->dev, "Failed to request %s memory region\n", name);
drivers/mtd/nand/jz4740_nand.c:		dev_err(&pdev->dev, "Failed to ioremap %s memory region\n", name);
drivers/mtd/nand/jz4740_nand.c:		dev_warn(&pdev->dev,
drivers/mtd/nand/jz4740_nand.c:	dev_info(&pdev->dev, "Found chip %i on bank %i\n", chipnr, bank);
drivers/mtd/nand/jz4740_nand.c:	dev_info(&pdev->dev, "No chip found on bank %i\n", bank);
drivers/mtd/nand/jz4740_nand.c:	struct jz_nand_platform_data *pdata = pdev->dev.platform_data;
drivers/mtd/nand/jz4740_nand.c:		dev_err(&pdev->dev, "Failed to allocate device structure.\n");
drivers/mtd/nand/jz4740_nand.c:			dev_err(&pdev->dev,
drivers/mtd/nand/jz4740_nand.c:			dev_warn(&pdev->dev,
drivers/mtd/nand/jz4740_nand.c:		dev_err(&pdev->dev, "No NAND chips found\n");
drivers/mtd/nand/jz4740_nand.c:		dev_err(&pdev->dev,  "Failed to scan NAND\n");
drivers/mtd/nand/jz4740_nand.c:		dev_err(&pdev->dev, "Failed to add mtd device\n");
drivers/mtd/nand/jz4740_nand.c:	dev_info(&pdev->dev, "Successfully registered JZ4740 NAND driver\n");
drivers/mtd/nand/jz4740_nand.c:	struct jz_nand_platform_data *pdata = pdev->dev.platform_data;
drivers/mtd/nand/xway_nand.c:	const __be32 *cs = of_get_property(pdev->dev.of_node,
drivers/mtd/nand/xway_nand.c:	pdev->dev.platform_data = &xway_nand_data;
drivers/mtd/nand/atmel_nand.c:	host->dev = &pdev->dev;
drivers/mtd/nand/atmel_nand.c:	if (pdev->dev.of_node) {
drivers/mtd/nand/atmel_nand.c:		res = atmel_of_init_port(host, pdev->dev.of_node);
drivers/mtd/nand/atmel_nand.c:		memcpy(&host->board, pdev->dev.platform_data,
drivers/mtd/nand/atmel_nand.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/mtd/nand/atmel_nand.c:			dev_err(&pdev->dev,
drivers/mtd/nand/atmel_nand.c:			dev_err(&pdev->dev,
drivers/mtd/nand/atmel_nand.c:			dev_err(&pdev->dev,
drivers/mtd/nand/atmel_nand.c:			dev_err(&pdev->dev,
drivers/mtd/nand/atmel_nand.c:			dev_err(&pdev->dev,
drivers/mtd/nand/atmel_nand.c:			dev_err(&pdev->dev,
drivers/mtd/nand/atmel_nand.c:	ppdata.of_node = pdev->dev.of_node;
drivers/mtd/nand/davinci_nand.c:	if (!pdev->dev.platform_data && pdev->dev.of_node) {
drivers/mtd/nand/davinci_nand.c:		pdata =  devm_kzalloc(&pdev->dev,
drivers/mtd/nand/davinci_nand.c:		pdev->dev.platform_data = pdata;
drivers/mtd/nand/davinci_nand.c:		if (!of_property_read_u32(pdev->dev.of_node,
drivers/mtd/nand/davinci_nand.c:			pdev->id = prop;
drivers/mtd/nand/davinci_nand.c:		if (!of_property_read_u32(pdev->dev.of_node,
drivers/mtd/nand/davinci_nand.c:		if (!of_property_read_u32(pdev->dev.of_node,
drivers/mtd/nand/davinci_nand.c:		if (!of_property_read_u32(pdev->dev.of_node,
drivers/mtd/nand/davinci_nand.c:		if (!of_property_read_string(pdev->dev.of_node,
drivers/mtd/nand/davinci_nand.c:		if (!of_property_read_u32(pdev->dev.of_node,
drivers/mtd/nand/davinci_nand.c:		if (!of_property_read_u32(pdev->dev.of_node,
drivers/mtd/nand/davinci_nand.c:		if (of_find_property(pdev->dev.of_node,
drivers/mtd/nand/davinci_nand.c:	return pdev->dev.platform_data;
drivers/mtd/nand/davinci_nand.c:	return pdev->dev.platform_data;
drivers/mtd/nand/davinci_nand.c:	if (pdev->id < 0 || pdev->id > 3)
drivers/mtd/nand/davinci_nand.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
drivers/mtd/nand/davinci_nand.c:		dev_err(&pdev->dev, "unable to allocate memory\n");
drivers/mtd/nand/davinci_nand.c:		dev_err(&pdev->dev, "resource missing\n");
drivers/mtd/nand/davinci_nand.c:	vaddr = devm_request_and_ioremap(&pdev->dev, res1);
drivers/mtd/nand/davinci_nand.c:	base = devm_request_and_ioremap(&pdev->dev, res2);
drivers/mtd/nand/davinci_nand.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/mtd/nand/davinci_nand.c:	info->dev		= &pdev->dev;
drivers/mtd/nand/davinci_nand.c:	info->mtd.name		= dev_name(&pdev->dev);
drivers/mtd/nand/davinci_nand.c:	info->mtd.dev.parent	= &pdev->dev;
drivers/mtd/nand/davinci_nand.c:	info->core_chipsel	= pdev->id;
drivers/mtd/nand/davinci_nand.c:	info->clk = devm_clk_get(&pdev->dev, "aemif");
drivers/mtd/nand/davinci_nand.c:		dev_dbg(&pdev->dev, "unable to get AEMIF clock, err %d\n", ret);
drivers/mtd/nand/davinci_nand.c:		dev_dbg(&pdev->dev, "unable to enable AEMIF clock, err %d\n",
drivers/mtd/nand/davinci_nand.c:		dev_dbg(&pdev->dev, "NAND timing values setup fail\n");
drivers/mtd/nand/davinci_nand.c:		dev_dbg(&pdev->dev, "no NAND chip(s) found\n");
drivers/mtd/nand/davinci_nand.c:			dev_dbg(&pdev->dev, "too small\n");
drivers/mtd/nand/davinci_nand.c:		dev_warn(&pdev->dev, "no 4-bit ECC support yet "
drivers/mtd/nand/davinci_nand.c:		ppdata.of_node = pdev->dev.of_node;
drivers/mtd/nand/davinci_nand.c:	dev_info(&pdev->dev, "controller rev. %d.%d\n",
drivers/mtd/nand/omap2.c:		dev_err(&info->pdev->dev,
drivers/mtd/nand/omap2.c:		dev_info(&info->pdev->dev,
drivers/mtd/nand/omap2.c:		info->elm_dev = &pdev->dev;
drivers/mtd/nand/omap2.c:	pdata = pdev->dev.platform_data;
drivers/mtd/nand/omap2.c:		dev_err(&pdev->dev, "platform data missing\n");
drivers/mtd/nand/omap2.c:	info->mtd.name		= dev_name(&pdev->dev);
drivers/mtd/nand/omap2.c:		dev_err(&pdev->dev, "error getting memory resource\n");
drivers/mtd/nand/omap2.c:				pdev->dev.driver->name)) {
drivers/mtd/nand/omap2.c:			dev_err(&pdev->dev, "DMA engine request failed\n");
drivers/mtd/nand/omap2.c:				dev_err(&pdev->dev, "DMA engine slave config failed: %d\n",
drivers/mtd/nand/omap2.c:			dev_err(&pdev->dev, "error getting fifo irq\n");
drivers/mtd/nand/omap2.c:			dev_err(&pdev->dev, "requesting irq(%d) error:%d",
drivers/mtd/nand/omap2.c:			dev_err(&pdev->dev, "error getting count irq\n");
drivers/mtd/nand/omap2.c:			dev_err(&pdev->dev, "requesting irq(%d) error:%d",
drivers/mtd/nand/omap2.c:		dev_err(&pdev->dev,
drivers/mtd/maps/autcpu12-nvram.c:	priv = devm_kzalloc(&pdev->dev,
drivers/mtd/maps/autcpu12-nvram.c:		dev_err(&pdev->dev, "failed to get memory resource\n");
drivers/mtd/maps/autcpu12-nvram.c:	priv->map.virt = devm_ioremap_resource(&pdev->dev, res);
drivers/mtd/maps/autcpu12-nvram.c:		dev_err(&pdev->dev, "probing failed\n");
drivers/mtd/maps/autcpu12-nvram.c:	priv->mtd->dev.parent	= &pdev->dev;
drivers/mtd/maps/autcpu12-nvram.c:		dev_info(&pdev->dev,
drivers/mtd/maps/autcpu12-nvram.c:	dev_err(&pdev->dev, "NV-RAM device addition failed\n");
drivers/mtd/maps/physmap.c:	physmap_data = pdev->dev.platform_data;
drivers/mtd/maps/gpio-addr-flash.c:	pdata = pdev->dev.platform_data;
drivers/mtd/maps/pxa2xx-flash.c:	struct flash_platform_data *flash = pdev->dev.platform_data;
drivers/mtd/maps/plat-ram.c:	dev_dbg(&pdev->dev, "removing device\n");
drivers/mtd/maps/plat-ram.c:	dev_dbg(&pdev->dev, "probe entered\n");
drivers/mtd/maps/plat-ram.c:	if (pdev->dev.platform_data == NULL) {
drivers/mtd/maps/plat-ram.c:		dev_err(&pdev->dev, "no platform data supplied\n");
drivers/mtd/maps/plat-ram.c:	pdata = pdev->dev.platform_data;
drivers/mtd/maps/plat-ram.c:		dev_err(&pdev->dev, "no memory for flash info\n");
drivers/mtd/maps/plat-ram.c:	info->dev = &pdev->dev;
drivers/mtd/maps/plat-ram.c:		dev_err(&pdev->dev, "no memory resource specified\n");
drivers/mtd/maps/plat-ram.c:	dev_dbg(&pdev->dev, "got platform resource %p (0x%llx)\n", res,
drivers/mtd/maps/plat-ram.c:			(char *)pdata->mapname : (char *)pdev->name;
drivers/mtd/maps/plat-ram.c:	info->area = request_mem_region(res->start, info->map.size, pdev->name);
drivers/mtd/maps/plat-ram.c:		dev_err(&pdev->dev, "failed to request memory region\n");
drivers/mtd/maps/plat-ram.c:	dev_dbg(&pdev->dev, "virt %p, %lu bytes\n", info->map.virt, info->map.size);
drivers/mtd/maps/plat-ram.c:		dev_err(&pdev->dev, "failed to ioremap() region\n");
drivers/mtd/maps/plat-ram.c:	dev_dbg(&pdev->dev, "initialised map, probing for mtd\n");
drivers/mtd/maps/plat-ram.c:		dev_err(&pdev->dev, "failed to probe for map_ram\n");
drivers/mtd/maps/plat-ram.c:	info->mtd->dev.parent = &pdev->dev;
drivers/mtd/maps/plat-ram.c:		dev_info(&pdev->dev, "registered mtd device\n");
drivers/mtd/maps/plat-ram.c:			dev_err(&pdev->dev,
drivers/mtd/maps/sa1100-flash.c:	struct flash_platform_data *plat = pdev->dev.platform_data;
drivers/mtd/maps/sa1100-flash.c:	struct flash_platform_data *plat = pdev->dev.platform_data;
drivers/mtd/maps/bfin-async-flash.c:	struct physmap_flash_data *pdata = pdev->dev.platform_data;
drivers/mtd/maps/lantiq-flash.c:		dev_err(&pdev->dev, "invalid bootstrap options\n");
drivers/mtd/maps/lantiq-flash.c:		dev_err(&pdev->dev, "failed to get memory resource\n");
drivers/mtd/maps/lantiq-flash.c:	ltq_mtd->map->virt = devm_ioremap_resource(&pdev->dev, ltq_mtd->res);
drivers/mtd/maps/lantiq-flash.c:		dev_err(&pdev->dev, "probing failed\n");
drivers/mtd/maps/lantiq-flash.c:	ppdata.of_node = pdev->dev.of_node;
drivers/mtd/maps/lantiq-flash.c:		dev_err(&pdev->dev, "failed to add partitions\n");
drivers/mtd/maps/pismo.c:	struct i2c_client *client = to_i2c_client(pdev->dev.parent);
drivers/mtd/devices/spear_smi.c:	dev_err(&dev->pdev->dev, "smi controller is busy, timeout\n");
drivers/mtd/devices/spear_smi.c:		dev_err(&dev->pdev->dev,
drivers/mtd/devices/spear_smi.c:			dev_err(&dev->pdev->dev, "couldn't enable write\n");
drivers/mtd/devices/spear_smi.c:		dev_err(&dev->pdev->dev, "sector erase failed\n");
drivers/mtd/devices/spear_smi.c:		dev_err(&dev->pdev->dev, "Invalid Bank Num");
drivers/mtd/devices/spear_smi.c:		dev_err(&dev->pdev->dev, "Invalid Bank Num");
drivers/mtd/devices/spear_smi.c:		dev_err(&dev->pdev->dev, "Invalid Bank Num");
drivers/mtd/devices/spear_smi.c:	struct spear_smi_plat_data *pdata = dev_get_platdata(&pdev->dev);
drivers/mtd/devices/spear_smi.c:	pdata->board_flash_info = devm_kzalloc(&pdev->dev,
drivers/mtd/devices/spear_smi.c:	pdata = dev_get_platdata(&pdev->dev);
drivers/mtd/devices/spear_smi.c:	flash = devm_kzalloc(&pdev->dev, sizeof(*flash), GFP_ATOMIC);
drivers/mtd/devices/spear_smi.c:		dev_info(&dev->pdev->dev, "smi-nor%d not found\n", bank);
drivers/mtd/devices/spear_smi.c:	flash->base_addr = devm_ioremap(&pdev->dev, flash_info->mem_base,
drivers/mtd/devices/spear_smi.c:	dev_info(&dev->pdev->dev, "mtd .name=%s .size=%llx(%lluM)\n",
drivers/mtd/devices/spear_smi.c:	dev_info(&dev->pdev->dev, ".erasesize = 0x%x(%uK)\n",
drivers/mtd/devices/spear_smi.c:		dev_err(&dev->pdev->dev, "Err MTD partition=%d\n", ret);
drivers/mtd/devices/spear_smi.c:	struct device_node *np = pdev->dev.of_node;
drivers/mtd/devices/spear_smi.c:		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/mtd/devices/spear_smi.c:		pdev->dev.platform_data = pdata;
drivers/mtd/devices/spear_smi.c:			dev_err(&pdev->dev, "no platform data\n");
drivers/mtd/devices/spear_smi.c:		pdata = dev_get_platdata(&pdev->dev);
drivers/mtd/devices/spear_smi.c:			dev_err(&pdev->dev, "no platform data\n");
drivers/mtd/devices/spear_smi.c:		dev_err(&pdev->dev, "invalid smi irq\n");
drivers/mtd/devices/spear_smi.c:	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_ATOMIC);
drivers/mtd/devices/spear_smi.c:		dev_err(&pdev->dev, "mem alloc fail\n");
drivers/mtd/devices/spear_smi.c:	dev->io_base = devm_ioremap_resource(&pdev->dev, smi_base);
drivers/mtd/devices/spear_smi.c:		dev_err(&pdev->dev, "exceeding max number of flashes\n");
drivers/mtd/devices/spear_smi.c:	dev->clk = devm_clk_get(&pdev->dev, NULL);
drivers/mtd/devices/spear_smi.c:	ret = devm_request_irq(&pdev->dev, irq, spear_smi_int_handler, 0,
drivers/mtd/devices/spear_smi.c:			       pdev->name, dev);
drivers/mtd/devices/spear_smi.c:		dev_err(&dev->pdev->dev, "SMI IRQ allocation failed\n");
drivers/mtd/devices/spear_smi.c:			dev_err(&dev->pdev->dev, "bank setup failed\n");
drivers/mtd/devices/spear_smi.c:		dev_err(&pdev->dev, "dev is null\n");
drivers/mtd/devices/spear_smi.c:			dev_err(&pdev->dev, "error removing mtd\n");
drivers/mtd/devices/elm.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
drivers/mtd/devices/elm.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/mtd/devices/elm.c:	info->dev = &pdev->dev;
drivers/mtd/devices/elm.c:		dev_err(&pdev->dev, "no irq resource defined\n");
drivers/mtd/devices/elm.c:		dev_err(&pdev->dev, "no memory resource defined\n");
drivers/mtd/devices/elm.c:	info->elm_base = devm_request_and_ioremap(&pdev->dev, res);
drivers/mtd/devices/elm.c:	ret = devm_request_irq(&pdev->dev, irq->start, elm_isr, 0,
drivers/mtd/devices/elm.c:			pdev->name, info);
drivers/mtd/devices/elm.c:		dev_err(&pdev->dev, "failure requesting irq %i\n", irq->start);
drivers/mtd/devices/elm.c:	pm_runtime_enable(&pdev->dev);
drivers/mtd/devices/elm.c:	if (pm_runtime_get_sync(&pdev->dev)) {
drivers/mtd/devices/elm.c:		pm_runtime_disable(&pdev->dev);
drivers/mtd/devices/elm.c:		dev_err(&pdev->dev, "can't enable clock\n");
drivers/mtd/devices/elm.c:	pm_runtime_put_sync(&pdev->dev);
drivers/mtd/devices/elm.c:	pm_runtime_disable(&pdev->dev);
drivers/mtd/devices/bcm47xxsflash.c:	struct bcma_sflash *sflash = dev_get_platdata(&pdev->dev);
drivers/mtd/devices/bcm47xxsflash.c:	struct bcma_sflash *sflash = dev_get_platdata(&pdev->dev);
drivers/mtd/devices/docg3.c:	struct device *dev = &pdev->dev;
drivers/mtd/devices/docg3.c:	struct device *dev = &pdev->dev;
drivers/mtd/devices/docg3.c:	struct device *dev = &pdev->dev;
drivers/mtd/onenand/samsung.c:	struct device *dev = &onenand->pdev->dev;
drivers/mtd/onenand/samsung.c:	struct device *dev = &onenand->pdev->dev;
drivers/mtd/onenand/samsung.c:	struct device *dev = &onenand->pdev->dev;
drivers/mtd/onenand/samsung.c:	struct device *dev = &onenand->pdev->dev;
drivers/mtd/onenand/samsung.c:	struct device *dev = &onenand->pdev->dev;
drivers/mtd/onenand/samsung.c:	pdata = pdev->dev.platform_data;
drivers/mtd/onenand/samsung.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/mtd/onenand/samsung.c:	mtd->dev.parent = &pdev->dev;
drivers/mtd/onenand/samsung.c:		dev_err(&pdev->dev, "no memory resource defined\n");
drivers/mtd/onenand/samsung.c:					       pdev->name);
drivers/mtd/onenand/samsung.c:		dev_err(&pdev->dev, "failed to request memory resource\n");
drivers/mtd/onenand/samsung.c:		dev_err(&pdev->dev, "failed to map memory resource\n");
drivers/mtd/onenand/samsung.c:			dev_err(&pdev->dev, "no buffer memory resource defined\n");
drivers/mtd/onenand/samsung.c:						      pdev->name);
drivers/mtd/onenand/samsung.c:			dev_err(&pdev->dev, "failed to request buffer memory resource\n");
drivers/mtd/onenand/samsung.c:			dev_err(&pdev->dev, "failed to map buffer memory resource\n");
drivers/mtd/onenand/samsung.c:			dev_err(&pdev->dev, "no dma memory resource defined\n");
drivers/mtd/onenand/samsung.c:						      pdev->name);
drivers/mtd/onenand/samsung.c:			dev_err(&pdev->dev, "failed to request dma memory resource\n");
drivers/mtd/onenand/samsung.c:			dev_err(&pdev->dev, "failed to map dma memory resource\n");
drivers/mtd/onenand/samsung.c:				dev_err(&pdev->dev, "failed to get irq\n");
drivers/mtd/onenand/samsung.c:		dev_info(&onenand->pdev->dev, "OneNAND Sync. Burst Read enabled\n");
drivers/mtd/onenand/generic.c:	struct onenand_platform_data *pdata = pdev->dev.platform_data;
drivers/mtd/onenand/generic.c:	struct resource *res = pdev->resource;
drivers/mtd/onenand/generic.c:	if (!request_mem_region(res->start, size, dev_name(&pdev->dev))) {
drivers/mtd/onenand/generic.c:	info->mtd.name = dev_name(&pdev->dev);
drivers/mtd/onenand/generic.c:	struct resource *res = pdev->resource;
drivers/mtd/onenand/omap2.c:	dma_dst = dma_map_single(&c->pdev->dev, buf, count, DMA_FROM_DEVICE);
drivers/mtd/onenand/omap2.c:	if (dma_mapping_error(&c->pdev->dev, dma_dst)) {
drivers/mtd/onenand/omap2.c:		dev_err(&c->pdev->dev,
drivers/mtd/onenand/omap2.c:	dma_unmap_single(&c->pdev->dev, dma_dst, count, DMA_FROM_DEVICE);
drivers/mtd/onenand/omap2.c:		dev_err(&c->pdev->dev, "timeout waiting for DMA\n");
drivers/mtd/onenand/omap2.c:	dma_src = dma_map_single(&c->pdev->dev, buf, count, DMA_TO_DEVICE);
drivers/mtd/onenand/omap2.c:	if (dma_mapping_error(&c->pdev->dev, dma_src)) {
drivers/mtd/onenand/omap2.c:		dev_err(&c->pdev->dev,
drivers/mtd/onenand/omap2.c:	dma_unmap_single(&c->pdev->dev, dma_src, count, DMA_TO_DEVICE);
drivers/mtd/onenand/omap2.c:		dev_err(&c->pdev->dev, "timeout waiting for DMA\n");
drivers/mtd/onenand/omap2.c:	dma_dst = dma_map_single(&c->pdev->dev, buffer, count,
drivers/mtd/onenand/omap2.c:	if (dma_mapping_error(&c->pdev->dev, dma_dst)) {
drivers/mtd/onenand/omap2.c:		dev_err(&c->pdev->dev,
drivers/mtd/onenand/omap2.c:	dma_unmap_single(&c->pdev->dev, dma_dst, count, DMA_FROM_DEVICE);
drivers/mtd/onenand/omap2.c:	dma_src = dma_map_single(&c->pdev->dev, (void *) buffer, count,
drivers/mtd/onenand/omap2.c:	if (dma_mapping_error(&c->pdev->dev, dma_src)) {
drivers/mtd/onenand/omap2.c:		dev_err(&c->pdev->dev,
drivers/mtd/onenand/omap2.c:	dma_unmap_single(&c->pdev->dev, dma_src, count, DMA_TO_DEVICE);
drivers/mtd/onenand/omap2.c:	struct omap2_onenand *c = dev_get_drvdata(&pdev->dev);
drivers/mtd/onenand/omap2.c:		dev_err(&c->pdev->dev, "can't enable regulator\n");
drivers/mtd/onenand/omap2.c:		dev_err(&c->pdev->dev, "can't disable regulator\n");
drivers/mtd/onenand/omap2.c:	pdata = pdev->dev.platform_data;
drivers/mtd/onenand/omap2.c:		dev_err(&pdev->dev, "platform data missing\n");
drivers/mtd/onenand/omap2.c:		dev_err(&pdev->dev, "error getting memory resource\n");
drivers/mtd/onenand/omap2.c:			       pdev->dev.driver->name) == NULL) {
drivers/mtd/onenand/omap2.c:		dev_err(&pdev->dev, "Cannot reserve memory region at 0x%08lx, size: 0x%x\n",
drivers/mtd/onenand/omap2.c:			dev_err(&pdev->dev, "Onenand platform setup failed: "
drivers/mtd/onenand/omap2.c:			dev_err(&pdev->dev,  "Failed to request GPIO%d for "
drivers/mtd/onenand/omap2.c:			     pdev->dev.driver->name, c)) < 0)
drivers/mtd/onenand/omap2.c:		r = omap_request_dma(0, pdev->dev.driver->name,
drivers/mtd/onenand/omap2.c:			dev_info(&pdev->dev,
drivers/mtd/onenand/omap2.c:	dev_info(&pdev->dev, "initializing on CS%d, phys base 0x%08lx, virtual "
drivers/mtd/onenand/omap2.c:	c->mtd.name = dev_name(&pdev->dev);
drivers/mtd/onenand/omap2.c:	c->mtd.dev.parent = &pdev->dev;
drivers/mtd/onenand/omap2.c:		c->regulator = regulator_get(&pdev->dev, "vonenand");
drivers/mtd/onenand/omap2.c:			dev_err(&pdev->dev,  "Failed to get regulator\n");
drivers/mtd/onenand/omap2.c:	struct omap2_onenand *c = dev_get_drvdata(&pdev->dev);
drivers/switch/switch_gpio.c:	struct gpio_switch_platform_data *pdata = pdev->dev.platform_data;
drivers/switch/switch_gpio.c:	ret = gpio_request(switch_data->gpio, pdev->name);
drivers/switch/switch_gpio.c:			  IRQF_TRIGGER_LOW, pdev->name, switch_data);
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&drv->pdev->dev, "get_bts_file_name entry");
drivers/nfc/nfcwilink.c:		nfc_dev_err(&drv->pdev->dev,
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&drv->pdev->dev, "wait_for_completion_timeout returned %ld",
drivers/nfc/nfcwilink.c:		nfc_dev_err(&drv->pdev->dev,
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&drv->pdev->dev, "nci_vs_nfcc_info_rsp: plen %d, status %d",
drivers/nfc/nfcwilink.c:		nfc_dev_err(&drv->pdev->dev,
drivers/nfc/nfcwilink.c:	nfc_dev_info(&drv->pdev->dev, "nfcwilink FW file name: %s", file_name);
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&drv->pdev->dev, "send_bts_cmd entry");
drivers/nfc/nfcwilink.c:		nfc_dev_err(&drv->pdev->dev,
drivers/nfc/nfcwilink.c:		nfc_dev_err(&drv->pdev->dev, "no memory for bts cmd");
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&drv->pdev->dev, "wait_for_completion_timeout returned %ld",
drivers/nfc/nfcwilink.c:		nfc_dev_err(&drv->pdev->dev,
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&drv->pdev->dev, "download_fw entry");
drivers/nfc/nfcwilink.c:	rc = request_firmware(&fw, file_name, &drv->pdev->dev);
drivers/nfc/nfcwilink.c:		nfc_dev_err(&drv->pdev->dev, "request_firmware failed %d", rc);
drivers/nfc/nfcwilink.c:		nfc_dev_dbg(&drv->pdev->dev,
drivers/nfc/nfcwilink.c:		nfc_dev_err(&drv->pdev->dev, "wrong bts magic number");
drivers/nfc/nfcwilink.c:		nfc_dev_dbg(&drv->pdev->dev, "bts_file_action type %d, len %d",
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&drv->pdev->dev, "register_complete entry");
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&drv->pdev->dev, "receive entry, len %d", skb->len);
drivers/nfc/nfcwilink.c:		nfc_dev_err(&drv->pdev->dev, "nci_recv_frame failed %d", rc);
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&drv->pdev->dev, "open entry");
drivers/nfc/nfcwilink.c:			nfc_dev_dbg(&drv->pdev->dev,
drivers/nfc/nfcwilink.c:				nfc_dev_err(&drv->pdev->dev,
drivers/nfc/nfcwilink.c:			nfc_dev_err(&drv->pdev->dev,
drivers/nfc/nfcwilink.c:		nfc_dev_err(&drv->pdev->dev, "nfcwilink_download_fw failed %d",
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&drv->pdev->dev, "close entry");
drivers/nfc/nfcwilink.c:		nfc_dev_err(&drv->pdev->dev, "st_unregister failed %d", rc);
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&drv->pdev->dev, "send entry, len %d", skb->len);
drivers/nfc/nfcwilink.c:		nfc_dev_err(&drv->pdev->dev, "st_write failed %ld", len);
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&pdev->dev, "probe entry");
drivers/nfc/nfcwilink.c:	drv = devm_kzalloc(&pdev->dev, sizeof(struct nfcwilink), GFP_KERNEL);
drivers/nfc/nfcwilink.c:		nfc_dev_err(&pdev->dev, "nci_allocate_device failed");
drivers/nfc/nfcwilink.c:	nci_set_parent_dev(drv->ndev, &pdev->dev);
drivers/nfc/nfcwilink.c:		nfc_dev_err(&pdev->dev, "nci_register_device failed %d", rc);
drivers/nfc/nfcwilink.c:	dev_set_drvdata(&pdev->dev, drv);
drivers/nfc/nfcwilink.c:	struct nfcwilink *drv = dev_get_drvdata(&pdev->dev);
drivers/nfc/nfcwilink.c:	nfc_dev_dbg(&pdev->dev, "remove entry");
drivers/nfc/nfcwilink.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/bus/omap-ocp2scp.c:	struct device_node *np = pdev->dev.of_node;
drivers/bus/omap-ocp2scp.c:	struct omap_ocp2scp_platform_data *pdata = pdev->dev.platform_data;
drivers/bus/omap-ocp2scp.c:		ret = of_platform_populate(np, NULL, NULL, &pdev->dev);
drivers/bus/omap-ocp2scp.c:			dev_err(&pdev->dev,
drivers/bus/omap-ocp2scp.c:				dev_err(&pdev->dev,
drivers/bus/omap-ocp2scp.c:				dev_err(&pdev->dev,
drivers/bus/omap-ocp2scp.c:			pdev_child->dev.parent	= &pdev->dev;
drivers/bus/omap-ocp2scp.c:				dev_err(&pdev->dev,
drivers/bus/omap-ocp2scp.c:		dev_err(&pdev->dev, "OCP2SCP initialized without plat data\n");
drivers/bus/omap-ocp2scp.c:	pm_runtime_enable(&pdev->dev);
drivers/bus/omap-ocp2scp.c:	device_for_each_child(&pdev->dev, NULL, ocp2scp_remove_devices);
drivers/bus/omap-ocp2scp.c:	pm_runtime_disable(&pdev->dev);
drivers/bus/omap-ocp2scp.c:	device_for_each_child(&pdev->dev, NULL, ocp2scp_remove_devices);
drivers/bus/omap_l3_smx.c:		dev_err(&pdev->dev, "couldn't find resource\n");
drivers/bus/omap_l3_smx.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/bus/omap_l3_smx.c:		dev_err(&pdev->dev, "couldn't request debug irq\n");
drivers/bus/omap_l3_smx.c:		dev_err(&pdev->dev, "couldn't request app irq\n");
drivers/bus/omap_l3_noc.c:		dev_err(&pdev->dev, "couldn't find resource 0\n");
drivers/bus/omap_l3_noc.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/bus/omap_l3_noc.c:		dev_err(&pdev->dev, "couldn't find resource 1\n");
drivers/bus/omap_l3_noc.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/bus/omap_l3_noc.c:		dev_err(&pdev->dev, "couldn't find resource 2\n");
drivers/bus/omap_l3_noc.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/clk/clk-twl6040.c:	struct twl6040 *twl6040 = dev_get_drvdata(pdev->dev.parent);
drivers/clk/clk-twl6040.c:	clkdata = devm_kzalloc(&pdev->dev, sizeof(*clkdata), GFP_KERNEL);
drivers/clk/clk-twl6040.c:	clkdata->dev = &pdev->dev;
drivers/clk/clk-twl6040.c:	clkdata->clk = clk_register(&pdev->dev, &clkdata->mcpdm_fclk);
drivers/clk/clk-twl6040.c:	dev_set_drvdata(&pdev->dev, clkdata);
drivers/clk/clk-twl6040.c:	struct twl6040_clk *clkdata = dev_get_drvdata(&pdev->dev);
drivers/clk/x86/clk-lpt.c:	drvdata = devm_kzalloc(&pdev->dev, sizeof(*drvdata), GFP_KERNEL);
drivers/clk/x86/clk-lpt.c:	clk = clk_register_fixed_rate(&pdev->dev, drvdata->name, NULL,
drivers/clk/ux500/abx500-clk.c:	struct ab8500 *parent = dev_get_drvdata(pdev->dev.parent);
drivers/clk/ux500/abx500-clk.c:		ret = ab8500_reg_clks(&pdev->dev);
drivers/clk/ux500/abx500-clk.c:		ret = ab8540_reg_clks(&pdev->dev);
drivers/clk/ux500/abx500-clk.c:		ret = ab9540_reg_clks(&pdev->dev);
drivers/clk/ux500/abx500-clk.c:		dev_err(&pdev->dev, "non supported plf id\n");
drivers/clk/clk-max77686.c:	struct max77686_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/clk/clk-max77686.c:	max77686_clks = devm_kzalloc(&pdev->dev, sizeof(struct max77686_clk *)
drivers/clk/clk-max77686.c:		max77686_clks[i] = devm_kzalloc(&pdev->dev,
drivers/clk/clk-max77686.c:		ret = max77686_clk_register(&pdev->dev, max77686_clks[i]);
drivers/clk/clk-max77686.c:				dev_err(&pdev->dev, "Fail to register CLK_AP\n");
drivers/clk/clk-max77686.c:				dev_err(&pdev->dev, "Fail to register CLK_CP\n");
drivers/clk/clk-max77686.c:				dev_err(&pdev->dev, "Fail to register CLK_PMIC\n");
drivers/clk/clk-axi-clkgen.c:	axi_clkgen = devm_kzalloc(&pdev->dev, sizeof(*axi_clkgen), GFP_KERNEL);
drivers/clk/clk-axi-clkgen.c:	axi_clkgen->base = devm_ioremap_resource(&pdev->dev, mem);
drivers/clk/clk-axi-clkgen.c:	parent_name = of_clk_get_parent_name(pdev->dev.of_node, 0);
drivers/clk/clk-axi-clkgen.c:	clk_name = pdev->dev.of_node->name;
drivers/clk/clk-axi-clkgen.c:	of_property_read_string(pdev->dev.of_node, "clock-output-names",
drivers/clk/clk-axi-clkgen.c:	clk = devm_clk_register(&pdev->dev, &axi_clkgen->clk_hw);
drivers/clk/clk-axi-clkgen.c:	return of_clk_add_provider(pdev->dev.of_node, of_clk_src_simple_get,
drivers/clk/clk-axi-clkgen.c:	of_clk_del_provider(pdev->dev.of_node);
drivers/clk/clk-wm831x.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/clk/clk-wm831x.c:	clkdata = devm_kzalloc(&pdev->dev, sizeof(*clkdata), GFP_KERNEL);
drivers/clk/clk-wm831x.c:	clkdata->xtal = devm_clk_register(&pdev->dev, &clkdata->xtal_hw);
drivers/clk/clk-wm831x.c:	clkdata->fll = devm_clk_register(&pdev->dev, &clkdata->fll_hw);
drivers/clk/clk-wm831x.c:	clkdata->clkout = devm_clk_register(&pdev->dev, &clkdata->clkout_hw);
drivers/clk/clk-wm831x.c:	dev_set_drvdata(&pdev->dev, clkdata);
drivers/mmc/host/s3cmci.c:		dev_err(&host->pdev->dev, args);  \
drivers/mmc/host/s3cmci.c:		dev_info(&host->pdev->dev, args); \
drivers/mmc/host/s3cmci.c:		dev_dbg(&host->pdev->dev, args);  \
drivers/mmc/host/s3cmci.c:	struct device *dev = &host->pdev->dev;
drivers/mmc/host/s3cmci.c:	mmc = mmc_alloc_host(sizeof(struct s3cmci_host), &pdev->dev);
drivers/mmc/host/s3cmci.c:		ret = gpio_request(i, dev_name(&pdev->dev));
drivers/mmc/host/s3cmci.c:			dev_err(&pdev->dev, "failed to get gpio %d\n", i);
drivers/mmc/host/s3cmci.c:	host->pdata = pdev->dev.platform_data;
drivers/mmc/host/s3cmci.c:		pdev->dev.platform_data = &s3cmci_def_pdata;
drivers/mmc/host/s3cmci.c:		dev_err(&pdev->dev,
drivers/mmc/host/s3cmci.c:				       resource_size(host->mem), pdev->name);
drivers/mmc/host/s3cmci.c:		dev_err(&pdev->dev, "failed to request io memory region.\n");
drivers/mmc/host/s3cmci.c:		dev_err(&pdev->dev, "failed to ioremap() io memory region.\n");
drivers/mmc/host/s3cmci.c:		dev_err(&pdev->dev, "failed to get interrupt resource.\n");
drivers/mmc/host/s3cmci.c:		dev_err(&pdev->dev, "failed to request mci interrupt.\n");
drivers/mmc/host/s3cmci.c:			dev_err(&pdev->dev, "failed to get detect gpio\n");
drivers/mmc/host/s3cmci.c:				dev_err(&pdev->dev,
drivers/mmc/host/s3cmci.c:			dev_warn(&pdev->dev,
drivers/mmc/host/s3cmci.c:			dev_err(&pdev->dev, "failed to get writeprotect\n");
drivers/mmc/host/s3cmci.c:			dev_err(&pdev->dev, "cannot get DMA channel.\n");
drivers/mmc/host/s3cmci.c:				dev_warn(&pdev->dev, "falling back to PIO.\n");
drivers/mmc/host/s3cmci.c:	host->clk = clk_get(&pdev->dev, "sdi");
drivers/mmc/host/s3cmci.c:		dev_err(&pdev->dev, "failed to find clock source.\n");
drivers/mmc/host/s3cmci.c:		dev_err(&pdev->dev, "failed to enable clock source.\n");
drivers/mmc/host/s3cmci.c:		dev_err(&pdev->dev, "failed to register cpufreq\n");
drivers/mmc/host/s3cmci.c:		dev_err(&pdev->dev, "failed to add mmc host.\n");
drivers/mmc/host/s3cmci.c:	dev_info(&pdev->dev, "%s - using %s, %s SDIO IRQ\n", mmc_hostname(mmc),
drivers/mmc/host/sdhci-pci.c:	if (chip->pdev->subsystem_vendor == PCI_VENDOR_ID_SAMSUNG ||
drivers/mmc/host/sdhci-pci.c:	    chip->pdev->subsystem_vendor == PCI_VENDOR_ID_SONY)
drivers/mmc/host/sdhci-pci.c:	dev_warn(&slot->chip->pdev->dev, "failed to setup card detect wake up\n");
drivers/mmc/host/sdhci-pci.c:	switch (chip->pdev->device) {
drivers/mmc/host/sdhci-pci.c:	if (chip->pdev->revision == 0) {
drivers/mmc/host/sdhci-pci.c:	if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_SD)
drivers/mmc/host/sdhci-pci.c:	else if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_SD)
drivers/mmc/host/sdhci-pci.c:			if ((PCI_SLOT(chip->pdev->devfn) ==
drivers/mmc/host/sdhci-pci.c:				(chip->pdev->bus == sd_dev->bus))
drivers/mmc/host/sdhci-pci.c:			dev_info(&chip->pdev->dev, "Refusing to bind to "
drivers/mmc/host/sdhci-pci.c:		dev_err(&chip->pdev->dev, "Failure enabling card power\n");
drivers/mmc/host/sdhci-pci.c:	if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_SD ||
drivers/mmc/host/sdhci-pci.c:	    chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)
drivers/mmc/host/sdhci-pci.c:	if (slot->chip->pdev->revision == 0) {
drivers/mmc/host/sdhci-pci.c:	if (slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD) {
drivers/mmc/host/sdhci-pci.c:	if (slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||
drivers/mmc/host/sdhci-pci.c:	    slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)
drivers/mmc/host/sdhci-pci.c:	if (slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||
drivers/mmc/host/sdhci-pci.c:	    slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)
drivers/mmc/host/sdhci-pci.c:	if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||
drivers/mmc/host/sdhci-pci.c:	    chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD) {
drivers/mmc/host/sdhci-pci.c:	if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||
drivers/mmc/host/sdhci-pci.c:	    chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD) {
drivers/mmc/host/sdhci-pci.c:		dev_err(&chip->pdev->dev, "Failure enabling card power\n");
drivers/mmc/host/sdhci-pci.c:	if ((chip->pdev->class & 0x0000FF) == PCI_SDHCI_IFVENDOR) {
drivers/mmc/host/sdhci-pci.c:		chip->pdev->class &= ~0x0000FF;
drivers/mmc/host/sdhci-pci.c:		chip->pdev->class |= PCI_SDHCI_IFDMA;
drivers/mmc/host/sdhci-pci.c:	dev_info(&slot->chip->pdev->dev, "SysKonnect CardBus2SDIO, "
drivers/mmc/host/sdhci-pci.c:		dev_err(&slot->chip->pdev->dev,
drivers/mmc/host/sdhci-pci.c:	if (chip->pdev->revision == 0x10)
drivers/mmc/host/sdhci-pci.c:	if (((pdev->class & 0xFFFF00) == (PCI_CLASS_SYSTEM_SDHCI << 8)) &&
drivers/mmc/host/sdhci-pci.c:		((pdev->class & 0x0000FF) != PCI_SDHCI_IFDMA) &&
drivers/mmc/host/sdhci-pci.c:		dev_warn(&pdev->dev, "Will use DMA mode even though HW "
drivers/mmc/host/sdhci-pci.c:		dev_err(&pdev->dev, "BAR %d is not iomem. Aborting.\n", bar);
drivers/mmc/host/sdhci-pci.c:		dev_err(&pdev->dev, "Invalid iomem size. You may "
drivers/mmc/host/sdhci-pci.c:	if ((pdev->class & 0x0000FF) == PCI_SDHCI_IFVENDOR) {
drivers/mmc/host/sdhci-pci.c:		dev_err(&pdev->dev, "Vendor specific interface. Aborting.\n");
drivers/mmc/host/sdhci-pci.c:	if ((pdev->class & 0x0000FF) > PCI_SDHCI_IFVENDOR) {
drivers/mmc/host/sdhci-pci.c:		dev_err(&pdev->dev, "Unknown interface. Aborting.\n");
drivers/mmc/host/sdhci-pci.c:	host = sdhci_alloc_host(&pdev->dev, sizeof(struct sdhci_pci_slot));
drivers/mmc/host/sdhci-pci.c:		dev_err(&pdev->dev, "cannot allocate host\n");
drivers/mmc/host/sdhci-pci.c:				dev_err(&pdev->dev, "platform setup failed\n");
drivers/mmc/host/sdhci-pci.c:	host->irq = pdev->irq;
drivers/mmc/host/sdhci-pci.c:		dev_err(&pdev->dev, "cannot request region\n");
drivers/mmc/host/sdhci-pci.c:		dev_err(&pdev->dev, "failed to remap registers\n");
drivers/mmc/host/sdhci-pci.c:			dev_warn(&pdev->dev, "failed to request rst_n_gpio\n");
drivers/mmc/host/sdhci-pci.c:	dev_info(&pdev->dev, "SDHCI controller found [%04x:%04x] (rev %x)\n",
drivers/mmc/host/sdhci-pci.c:		 (int)pdev->vendor, (int)pdev->device, (int)pdev->revision);
drivers/mmc/host/sdhci-pci.c:	dev_dbg(&pdev->dev, "found %d slot(s)\n", slots);
drivers/mmc/host/sdhci-pci.c:		dev_err(&pdev->dev, "Invalid first BAR. Aborting.\n");
drivers/mmc/host/sdhci-pci.c:		sdhci_pci_runtime_pm_allow(&pdev->dev);
drivers/mmc/host/sdhci-pci.c:			sdhci_pci_runtime_pm_forbid(&pdev->dev);
drivers/mmc/host/wmt-sdmmc.c:	struct device_node *np = pdev->dev.of_node;
drivers/mmc/host/wmt-sdmmc.c:		of_match_device(wmt_mci_dt_ids, &pdev->dev);
drivers/mmc/host/wmt-sdmmc.c:		dev_err(&pdev->dev, "Controller capabilities data missing\n");
drivers/mmc/host/wmt-sdmmc.c:		dev_err(&pdev->dev, "Missing SDMMC description in devicetree\n");
drivers/mmc/host/wmt-sdmmc.c:		dev_err(&pdev->dev, "Getting IRQs failed!\n");
drivers/mmc/host/wmt-sdmmc.c:	mmc = mmc_alloc_host(sizeof(struct wmt_mci_priv), &pdev->dev);
drivers/mmc/host/wmt-sdmmc.c:		dev_err(&pdev->dev, "Failed to allocate mmc_host\n");
drivers/mmc/host/wmt-sdmmc.c:	priv->dev = &pdev->dev;
drivers/mmc/host/wmt-sdmmc.c:		dev_err(&pdev->dev, "Failed to map IO space\n");
drivers/mmc/host/wmt-sdmmc.c:		dev_err(&pdev->dev, "Register regular IRQ fail\n");
drivers/mmc/host/wmt-sdmmc.c:		dev_err(&pdev->dev, "Register DMA IRQ fail\n");
drivers/mmc/host/wmt-sdmmc.c:	priv->dma_desc_buffer = dma_alloc_coherent(&pdev->dev,
drivers/mmc/host/wmt-sdmmc.c:		dev_err(&pdev->dev, "DMA alloc fail\n");
drivers/mmc/host/wmt-sdmmc.c:		dev_err(&pdev->dev, "Error getting clock\n");
drivers/mmc/host/wmt-sdmmc.c:	dev_info(&pdev->dev, "WMT SDHC Controller initialized\n");
drivers/mmc/host/wmt-sdmmc.c:	dma_free_coherent(&pdev->dev, priv->mmc->max_blk_count * 16,
drivers/mmc/host/wmt-sdmmc.c:	dev_info(&pdev->dev, "WMT MCI device removed\n");
drivers/mmc/host/sdhci-pxav3.c:	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
drivers/mmc/host/sdhci-pxav3.c:	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
drivers/mmc/host/sdhci-pxav3.c:	struct device *dev = &pdev->dev;
drivers/mmc/host/sdhci-pxav3.c:	match = of_match_device(of_match_ptr(sdhci_pxav3_of_match), &pdev->dev);
drivers/mmc/host/sdhci-pxav3.c:	pm_runtime_set_active(&pdev->dev);
drivers/mmc/host/sdhci-pxav3.c:	pm_runtime_enable(&pdev->dev);
drivers/mmc/host/sdhci-pxav3.c:	pm_runtime_set_autosuspend_delay(&pdev->dev, PXAV3_RPM_DELAY_MS);
drivers/mmc/host/sdhci-pxav3.c:	pm_runtime_use_autosuspend(&pdev->dev);
drivers/mmc/host/sdhci-pxav3.c:	pm_suspend_ignore_children(&pdev->dev, 1);
drivers/mmc/host/sdhci-pxav3.c:	pm_runtime_get_noresume(&pdev->dev);
drivers/mmc/host/sdhci-pxav3.c:		dev_err(&pdev->dev, "failed to add host\n");
drivers/mmc/host/sdhci-pxav3.c:		pm_runtime_forbid(&pdev->dev);
drivers/mmc/host/sdhci-pxav3.c:		pm_runtime_disable(&pdev->dev);
drivers/mmc/host/sdhci-pxav3.c:		device_init_wakeup(&pdev->dev, 1);
drivers/mmc/host/sdhci-pxav3.c:		device_init_wakeup(&pdev->dev, 0);
drivers/mmc/host/sdhci-pxav3.c:	pm_runtime_put_autosuspend(&pdev->dev);
drivers/mmc/host/sdhci-pxav3.c:	pm_runtime_get_sync(&pdev->dev);
drivers/mmc/host/sdhci-pxav3.c:	pm_runtime_disable(&pdev->dev);
drivers/mmc/host/dw_mmc-exynos.c:	match = of_match_node(dw_mci_exynos_match, pdev->dev.of_node);
drivers/mmc/host/sdhci-s3c.c:		dev_dbg(&ourhost->pdev->dev, "restored ctrl2 clock setting\n");
drivers/mmc/host/sdhci-s3c.c:	dev_dbg(&ourhost->pdev->dev, "clk %d: rate %ld, want %d, got %ld\n",
drivers/mmc/host/sdhci-s3c.c:	dev_dbg(&ourhost->pdev->dev,
drivers/mmc/host/sdhci-s3c.c:	struct device *dev = &ourhost->pdev->dev;
drivers/mmc/host/sdhci-s3c.c:	struct device *dev = &sc->pdev->dev;
drivers/mmc/host/sdhci-s3c.c:	if (pdev->dev.of_node) {
drivers/mmc/host/sdhci-s3c.c:		match = of_match_node(sdhci_s3c_dt_match, pdev->dev.of_node);
drivers/mmc/host/sdhci-s3c.c:	struct device *dev = &pdev->dev;
drivers/mmc/host/sdhci-s3c.c:	if (!pdev->dev.platform_data && !pdev->dev.of_node) {
drivers/mmc/host/sdhci-s3c.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/mmc/host/sdhci-s3c.c:	if (pdev->dev.of_node) {
drivers/mmc/host/sdhci-s3c.c:		ret = sdhci_s3c_parse_dt(&pdev->dev, host, pdata);
drivers/mmc/host/sdhci-s3c.c:		memcpy(pdata, pdev->dev.platform_data, sizeof(*pdata));
drivers/mmc/host/sdhci-s3c.c:	host->ioaddr = devm_ioremap_resource(&pdev->dev, res);
drivers/mmc/host/sdhci-s3c.c:	pm_runtime_enable(&pdev->dev);
drivers/mmc/host/sdhci-s3c.c:	pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
drivers/mmc/host/sdhci-s3c.c:	pm_runtime_use_autosuspend(&pdev->dev);
drivers/mmc/host/sdhci-s3c.c:	pm_suspend_ignore_children(&pdev->dev, 1);
drivers/mmc/host/sdhci-s3c.c:		pm_runtime_forbid(&pdev->dev);
drivers/mmc/host/sdhci-s3c.c:		pm_runtime_get_noresume(&pdev->dev);
drivers/mmc/host/sdhci-s3c.c:	pm_runtime_dont_use_autosuspend(&pdev->dev);
drivers/mmc/host/sdhci-s3c.c:	pm_runtime_disable(&pdev->dev);
drivers/mmc/host/mxs-mmc.c:			of_match_device(mxs_mmc_dt_ids, &pdev->dev);
drivers/mmc/host/mxs-mmc.c:	struct device_node *np = pdev->dev.of_node;
drivers/mmc/host/mxs-mmc.c:	mmc = mmc_alloc_host(sizeof(struct mxs_mmc_host), &pdev->dev);
drivers/mmc/host/mxs-mmc.c:	ssp->dev = &pdev->dev;
drivers/mmc/host/mxs-mmc.c:	ssp->base = devm_ioremap_resource(&pdev->dev, iores);
drivers/mmc/host/mxs-mmc.c:	reg_vmmc = devm_regulator_get(&pdev->dev, "vmmc");
drivers/mmc/host/mxs-mmc.c:			dev_err(&pdev->dev,
drivers/mmc/host/mxs-mmc.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/mmc/host/mxs-mmc.c:	ssp->clk = clk_get(&pdev->dev, NULL);
drivers/mmc/host/mxs-mmc.c:	ssp->dmach = dma_request_slave_channel(&pdev->dev, "rx-tx");
drivers/mmc/host/mxs-mmc.c:	ret = devm_request_irq(&pdev->dev, irq_err, mxs_mmc_irq_handler, 0,
drivers/mmc/host/au1xmmc.c:			DBG("RX CRC Error [%d + %d].\n", host->pdev->id,
drivers/mmc/host/au1xmmc.c:			DBG("RX Overrun [%d + %d]\n", host->pdev->id,
drivers/mmc/host/au1xmmc.c:			DBG("RX Underrun [%d + %d]\n", host->pdev->id,
drivers/mmc/host/au1xmmc.c:			DBG("Unhandled status %8.8x\n", host->pdev->id,
drivers/mmc/host/au1xmmc.c:		dev_err(&host->pdev->dev, "cannot allocate TX DMA\n");
drivers/mmc/host/au1xmmc.c:		dev_err(&host->pdev->dev, "cannot allocate RX DMA\n");
drivers/mmc/host/au1xmmc.c:	mmc = mmc_alloc_host(sizeof(struct au1xmmc_host), &pdev->dev);
drivers/mmc/host/au1xmmc.c:		dev_err(&pdev->dev, "no memory for mmc_host\n");
drivers/mmc/host/au1xmmc.c:	host->platdata = pdev->dev.platform_data;
drivers/mmc/host/au1xmmc.c:		dev_err(&pdev->dev, "no mmio defined\n");
drivers/mmc/host/au1xmmc.c:					   pdev->name);
drivers/mmc/host/au1xmmc.c:		dev_err(&pdev->dev, "mmio already in use\n");
drivers/mmc/host/au1xmmc.c:		dev_err(&pdev->dev, "cannot remap mmio\n");
drivers/mmc/host/au1xmmc.c:		dev_err(&pdev->dev, "no IRQ defined\n");
drivers/mmc/host/au1xmmc.c:		dev_err(&pdev->dev, "cannot grab IRQ\n");
drivers/mmc/host/au1xmmc.c:			dev_warn(&pdev->dev, "board CD setup failed\n");
drivers/mmc/host/au1xmmc.c:		dev_err(&pdev->dev, "cannot add mmc host\n");
drivers/mmc/host/au1xmmc.c:		" (mode=%s)\n", pdev->id, host->iobase,
drivers/mmc/host/dw_mmc-pltfm.c:	host = devm_kzalloc(&pdev->dev, sizeof(struct dw_mci), GFP_KERNEL);
drivers/mmc/host/dw_mmc-pltfm.c:	host->dev = &pdev->dev;
drivers/mmc/host/dw_mmc-pltfm.c:	host->pdata = pdev->dev.platform_data;
drivers/mmc/host/dw_mmc-pltfm.c:	host->regs = devm_ioremap_resource(&pdev->dev, regs);
drivers/mmc/host/android-goldfish.c:	mmc = mmc_alloc_host(sizeof(struct goldfish_mmc_host), &pdev->dev);
drivers/mmc/host/android-goldfish.c:	host->virt_base = dma_alloc_coherent(&pdev->dev, BUFFER_SIZE,
drivers/mmc/host/android-goldfish.c:	host->id = pdev->id;
drivers/mmc/host/android-goldfish.c:		dev_err(&pdev->dev, "Failed IRQ Adding goldfish MMC\n");
drivers/mmc/host/android-goldfish.c:	host->dev = &pdev->dev;
drivers/mmc/host/android-goldfish.c:	ret = device_create_file(&pdev->dev, &dev_attr_cover_switch);
drivers/mmc/host/android-goldfish.c:	dma_free_coherent(&pdev->dev, BUFFER_SIZE, host->virt_base,
drivers/mmc/host/android-goldfish.c:	dma_free_coherent(&pdev->dev, BUFFER_SIZE, host->virt_base, host->phys_base);
drivers/mmc/host/jz4740_mmc.c:	struct jz4740_mmc_platform_data *pdata = pdev->dev.platform_data;
drivers/mmc/host/jz4740_mmc.c:	ret = jz4740_mmc_request_gpio(&pdev->dev, pdata->gpio_card_detect,
drivers/mmc/host/jz4740_mmc.c:	ret = jz4740_mmc_request_gpio(&pdev->dev, pdata->gpio_read_only,
drivers/mmc/host/jz4740_mmc.c:	ret = jz4740_mmc_request_gpio(&pdev->dev, pdata->gpio_power,
drivers/mmc/host/jz4740_mmc.c:	struct jz4740_mmc_platform_data *pdata = pdev->dev.platform_data;
drivers/mmc/host/jz4740_mmc.c:		dev_warn(&pdev->dev, "Failed to get card detect irq\n");
drivers/mmc/host/jz4740_mmc.c:	struct jz4740_mmc_platform_data *pdata = pdev->dev.platform_data;
drivers/mmc/host/jz4740_mmc.c:	pdata = pdev->dev.platform_data;
drivers/mmc/host/jz4740_mmc.c:	mmc = mmc_alloc_host(sizeof(struct jz4740_mmc_host), &pdev->dev);
drivers/mmc/host/jz4740_mmc.c:		dev_err(&pdev->dev, "Failed to alloc mmc host structure\n");
drivers/mmc/host/jz4740_mmc.c:		dev_err(&pdev->dev, "Failed to get platform irq: %d\n", ret);
drivers/mmc/host/jz4740_mmc.c:	host->clk = clk_get(&pdev->dev, "mmc");
drivers/mmc/host/jz4740_mmc.c:		dev_err(&pdev->dev, "Failed to get mmc clock\n");
drivers/mmc/host/jz4740_mmc.c:		dev_err(&pdev->dev, "Failed to get base platform memory\n");
drivers/mmc/host/jz4740_mmc.c:					resource_size(host->mem), pdev->name);
drivers/mmc/host/jz4740_mmc.c:		dev_err(&pdev->dev, "Failed to request base memory region\n");
drivers/mmc/host/jz4740_mmc.c:		dev_err(&pdev->dev, "Failed to ioremap base memory\n");
drivers/mmc/host/jz4740_mmc.c:		dev_err(&pdev->dev, "Failed to request mmc pins: %d\n", ret);
drivers/mmc/host/jz4740_mmc.c:		dev_err(&pdev->dev, "Failed to request card detect irq\n");
drivers/mmc/host/jz4740_mmc.c:			dev_name(&pdev->dev), host);
drivers/mmc/host/jz4740_mmc.c:		dev_err(&pdev->dev, "Failed to request irq: %d\n", ret);
drivers/mmc/host/jz4740_mmc.c:		dev_err(&pdev->dev, "Failed to add mmc host: %d\n", ret);
drivers/mmc/host/jz4740_mmc.c:	dev_info(&pdev->dev, "JZ SD/MMC card driver registered\n");
drivers/mmc/host/sdhci-spear.c:	struct spear_sdhci *sdhci = dev_get_platdata(&pdev->dev);
drivers/mmc/host/sdhci-spear.c:	struct device_node *np = pdev->dev.of_node;
drivers/mmc/host/sdhci-spear.c:		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/mmc/host/sdhci-spear.c:			dev_err(&pdev->dev, "DT: kzalloc failed\n");
drivers/mmc/host/sdhci-spear.c:	struct device_node *np = pdev->dev.of_node;
drivers/mmc/host/sdhci-spear.c:		dev_dbg(&pdev->dev, "memory resource not defined\n");
drivers/mmc/host/sdhci-spear.c:	if (!devm_request_mem_region(&pdev->dev, iomem->start,
drivers/mmc/host/sdhci-spear.c:		dev_dbg(&pdev->dev, "cannot request region\n");
drivers/mmc/host/sdhci-spear.c:	sdhci = devm_kzalloc(&pdev->dev, sizeof(*sdhci), GFP_KERNEL);
drivers/mmc/host/sdhci-spear.c:		dev_dbg(&pdev->dev, "cannot allocate memory for sdhci\n");
drivers/mmc/host/sdhci-spear.c:	sdhci->clk = clk_get(&pdev->dev, NULL);
drivers/mmc/host/sdhci-spear.c:		dev_dbg(&pdev->dev, "Error getting clock\n");
drivers/mmc/host/sdhci-spear.c:		dev_dbg(&pdev->dev, "Error enabling clock\n");
drivers/mmc/host/sdhci-spear.c:		dev_dbg(&pdev->dev, "Error setting desired clk, clk=%lu\n",
drivers/mmc/host/sdhci-spear.c:			dev_err(&pdev->dev, "DT: Failed to get pdata\n");
drivers/mmc/host/sdhci-spear.c:		sdhci->data = dev_get_platdata(&pdev->dev);
drivers/mmc/host/sdhci-spear.c:	pdev->dev.platform_data = sdhci;
drivers/mmc/host/sdhci-spear.c:	if (pdev->dev.parent)
drivers/mmc/host/sdhci-spear.c:		host = sdhci_alloc_host(pdev->dev.parent, 0);
drivers/mmc/host/sdhci-spear.c:		host = sdhci_alloc_host(&pdev->dev, 0);
drivers/mmc/host/sdhci-spear.c:		dev_dbg(&pdev->dev, "error allocating host\n");
drivers/mmc/host/sdhci-spear.c:	host->ioaddr = devm_ioremap(&pdev->dev, iomem->start,
drivers/mmc/host/sdhci-spear.c:		dev_dbg(&pdev->dev, "failed to remap registers\n");
drivers/mmc/host/sdhci-spear.c:		dev_dbg(&pdev->dev, "error adding host\n");
drivers/mmc/host/sdhci-spear.c:		ret = devm_gpio_request(&pdev->dev,
drivers/mmc/host/sdhci-spear.c:			dev_dbg(&pdev->dev, "gpio request fail: %d\n",
drivers/mmc/host/sdhci-spear.c:			dev_dbg(&pdev->dev, "gpio set direction fail: %d\n",
drivers/mmc/host/sdhci-spear.c:		ret = devm_gpio_request(&pdev->dev, sdhci->data->card_int_gpio,
drivers/mmc/host/sdhci-spear.c:			dev_dbg(&pdev->dev, "gpio request fail: %d\n",
drivers/mmc/host/sdhci-spear.c:			dev_dbg(&pdev->dev, "gpio set direction fail: %d\n",
drivers/mmc/host/sdhci-spear.c:		ret = devm_request_irq(&pdev->dev,
drivers/mmc/host/sdhci-spear.c:			dev_dbg(&pdev->dev, "gpio request irq fail: %d\n",
drivers/mmc/host/sdhci-spear.c:	dev_err(&pdev->dev, "spear-sdhci probe failed: %d\n", ret);
drivers/mmc/host/sdhci-spear.c:	struct spear_sdhci *sdhci = dev_get_platdata(&pdev->dev);
drivers/mmc/host/sdhci-acpi.c:	struct device *dev = &pdev->dev;
drivers/mmc/host/sdhci-acpi.c:	struct device *dev = &pdev->dev;
drivers/mmc/host/sdhci-bcm2835.c:	bcm2835_host = devm_kzalloc(&pdev->dev, sizeof(*bcm2835_host),
drivers/mmc/host/sdhci-bcm2835.c:	pltfm_host->clk = devm_clk_get(&pdev->dev, NULL);
drivers/mmc/host/sh_mobile_sdhi.c:	struct mmc_host *mmc = dev_get_drvdata(&pdev->dev);
drivers/mmc/host/sh_mobile_sdhi.c:	struct mmc_host *mmc = dev_get_drvdata(&pdev->dev);
drivers/mmc/host/sh_mobile_sdhi.c:	struct sh_mobile_sdhi_info *p = pdev->dev.platform_data;
drivers/mmc/host/sh_mobile_sdhi.c:	struct sh_mobile_sdhi_info *p = pdev->dev.platform_data;
drivers/mmc/host/sh_mobile_sdhi.c:	mmc_detect_change(dev_get_drvdata(&pdev->dev), msecs_to_jiffies(100));
drivers/mmc/host/sh_mobile_sdhi.c:		of_match_device(sh_mobile_sdhi_of_match, &pdev->dev);
drivers/mmc/host/sh_mobile_sdhi.c:	struct sh_mobile_sdhi_info *p = pdev->dev.platform_data;
drivers/mmc/host/sh_mobile_sdhi.c:	priv = devm_kzalloc(&pdev->dev, sizeof(struct sh_mobile_sdhi), GFP_KERNEL);
drivers/mmc/host/sh_mobile_sdhi.c:		dev_err(&pdev->dev, "kzalloc failed\n");
drivers/mmc/host/sh_mobile_sdhi.c:	priv->clk = devm_clk_get(&pdev->dev, NULL);
drivers/mmc/host/sh_mobile_sdhi.c:		dev_err(&pdev->dev, "cannot get clock: %d\n", ret);
drivers/mmc/host/sh_mobile_sdhi.c:		ret = devm_request_irq(&pdev->dev, irq, tmio_mmc_card_detect_irq, 0,
drivers/mmc/host/sh_mobile_sdhi.c:				  dev_name(&pdev->dev), host);
drivers/mmc/host/sh_mobile_sdhi.c:		ret = devm_request_irq(&pdev->dev, irq, tmio_mmc_sdio_irq, 0,
drivers/mmc/host/sh_mobile_sdhi.c:				  dev_name(&pdev->dev), host);
drivers/mmc/host/sh_mobile_sdhi.c:		ret = devm_request_irq(&pdev->dev, irq, tmio_mmc_sdcard_irq, 0,
drivers/mmc/host/sh_mobile_sdhi.c:				  dev_name(&pdev->dev), host);
drivers/mmc/host/sh_mobile_sdhi.c:		dev_err(&pdev->dev,
drivers/mmc/host/sh_mobile_sdhi.c:			ret = devm_request_irq(&pdev->dev, irq, tmio_mmc_irq, 0,
drivers/mmc/host/sh_mobile_sdhi.c:					  dev_name(&pdev->dev), host);
drivers/mmc/host/sh_mobile_sdhi.c:	dev_info(&pdev->dev, "%s base at 0x%08lx clock rate %u MHz\n",
drivers/mmc/host/sh_mobile_sdhi.c:	struct sh_mobile_sdhi_info *p = pdev->dev.platform_data;
drivers/mmc/host/cb710-mmc.c:	dev_set_drvdata(&pdev->dev, mmc);
drivers/mmc/host/atmel-mci.c:	struct device_node *np = pdev->dev.of_node;
drivers/mmc/host/atmel-mci.c:		dev_err(&pdev->dev, "device node not found\n");
drivers/mmc/host/atmel-mci.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/mmc/host/atmel-mci.c:		dev_err(&pdev->dev, "could not allocate memory for pdata\n");
drivers/mmc/host/atmel-mci.c:			dev_warn(&pdev->dev, "reg property is missing for %s\n",
drivers/mmc/host/atmel-mci.c:			dev_warn(&pdev->dev, "can't have more than %d slots\n",
drivers/mmc/host/atmel-mci.c:	dev_dbg(&host->pdev->dev, "software timeout\n");
drivers/mmc/host/atmel-mci.c:	dev_vdbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:	dev_dbg(&host->pdev->dev, "send stop command\n");
drivers/mmc/host/atmel-mci.c:		dma_unmap_sg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:		dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:	dev_vdbg(&host->pdev->dev, "DMA complete\n");
drivers/mmc/host/atmel-mci.c:		dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:	sg_len = dma_map_sg(&host->pdev->dev, data->sg, data->sg_len, dir);
drivers/mmc/host/atmel-mci.c:	dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:		dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:	dev_dbg(&host->pdev->dev, "start request: cmd %u\n", mrq->cmd->opcode);
drivers/mmc/host/atmel-mci.c:		dev_dbg(&host->pdev->dev, "queue request\n");
drivers/mmc/host/atmel-mci.c:	dev_dbg(&host->pdev->dev, "MRQ: cmd %u\n", mrq->cmd->opcode);
drivers/mmc/host/atmel-mci.c:		dev_vdbg(&host->pdev->dev, "list not empty: %s is next\n",
drivers/mmc/host/atmel-mci.c:		dev_vdbg(&host->pdev->dev, "list empty\n");
drivers/mmc/host/atmel-mci.c:	dev_vdbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:		dev_dbg(&host->pdev->dev, "FSM: state=%d\n", state);
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "FSM: cmd ready?\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "set completed cmd ready\n");
drivers/mmc/host/atmel-mci.c:				dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:				dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:				dev_dbg(&host->pdev->dev, "set completed data error\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "FSM: xfer complete?\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "FSM: not busy?\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "set completed not busy\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "FSM: cmd ready?\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "FSM: cmd ready\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "IRQ: data error\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "set pending data error\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "IRQ: tx buffer empty\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "IRQ: end of tx buffer\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "IRQ: rx buffer full\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "IRQ: end of rx buffer\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "IRQ: blke\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "set pending notbusy\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "IRQ: not_busy\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "set pending notbusy\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "IRQ: cmd ready\n");
drivers/mmc/host/atmel-mci.c:			dev_dbg(&host->pdev->dev, "set pending cmd rdy\n");
drivers/mmc/host/atmel-mci.c:	mmc = mmc_alloc_host(sizeof(struct atmel_mci_slot), &host->pdev->dev);
drivers/mmc/host/atmel-mci.c:	pdata = host->pdev->dev.platform_data;
drivers/mmc/host/atmel-mci.c:							  &host->pdev->dev, "rxtx");
drivers/mmc/host/atmel-mci.c:		dev_warn(&host->pdev->dev, "no DMA channel available\n");
drivers/mmc/host/atmel-mci.c:		dev_info(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:	dev_info(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:		dev_warn(&host->pdev->dev,
drivers/mmc/host/atmel-mci.c:	pdata = pdev->dev.platform_data;
drivers/mmc/host/atmel-mci.c:			dev_err(&pdev->dev, "platform data not available\n");
drivers/mmc/host/atmel-mci.c:	host->mck = clk_get(&pdev->dev, "mci_clk");
drivers/mmc/host/atmel-mci.c:	ret = request_irq(irq, atmci_interrupt, 0, dev_name(&pdev->dev), host);
drivers/mmc/host/atmel-mci.c:		dev_info(&pdev->dev, "using PDC\n");
drivers/mmc/host/atmel-mci.c:		dev_info(&pdev->dev, "using PIO\n");
drivers/mmc/host/atmel-mci.c:		dev_err(&pdev->dev, "init failed: no slot defined\n");
drivers/mmc/host/atmel-mci.c:		host->buffer = dma_alloc_coherent(&pdev->dev, host->buf_size,
drivers/mmc/host/atmel-mci.c:			dev_err(&pdev->dev, "buffer allocation failed\n");
drivers/mmc/host/atmel-mci.c:	dev_info(&pdev->dev,
drivers/mmc/host/atmel-mci.c:		dma_free_coherent(&pdev->dev, host->buf_size,
drivers/mmc/host/sdhci-sirf.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/mmc/host/sdhci-sirf.c:		dev_err(&pdev->dev, "unable to get pinmux");
drivers/mmc/host/sdhci-sirf.c:	priv = devm_kzalloc(&pdev->dev, sizeof(struct sdhci_sirf_priv),
drivers/mmc/host/sdhci-sirf.c:		dev_err(&pdev->dev, "unable to allocate private data");
drivers/mmc/host/sdhci-sirf.c:	priv->clk = devm_clk_get(&pdev->dev, NULL);
drivers/mmc/host/sdhci-sirf.c:		dev_err(&pdev->dev, "unable to get clock");
drivers/mmc/host/sdhci-sirf.c:	if (pdev->dev.of_node) {
drivers/mmc/host/sdhci-sirf.c:		priv->gpio_cd = of_get_named_gpio(pdev->dev.of_node,
drivers/mmc/host/sdhci-sirf.c:			dev_err(&pdev->dev, "card detect irq request failed: %d\n",
drivers/mmc/host/pxamci.c:        struct device_node *np = pdev->dev.of_node;
drivers/mmc/host/pxamci.c:        pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/mmc/host/pxamci.c:        pdev->dev.platform_data = pdata;
drivers/mmc/host/pxamci.c:	mmc = mmc_alloc_host(sizeof(struct pxamci_host), &pdev->dev);
drivers/mmc/host/pxamci.c:	host->pdata = pdev->dev.platform_data;
drivers/mmc/host/pxamci.c:	host->clk = clk_get(&pdev->dev, NULL);
drivers/mmc/host/pxamci.c:	host->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE, &host->sg_dma, GFP_KERNEL);
drivers/mmc/host/pxamci.c:			dev_err(&pdev->dev, "Failed requesting gpio_power %d\n", gpio_power);
drivers/mmc/host/pxamci.c:			dev_err(&pdev->dev, "Failed requesting gpio_ro %d\n", gpio_ro);
drivers/mmc/host/pxamci.c:			dev_err(&pdev->dev, "Failed requesting gpio_cd %d\n", gpio_cd);
drivers/mmc/host/pxamci.c:			dev_err(&pdev->dev, "failed to request card detect IRQ\n");
drivers/mmc/host/pxamci.c:		host->pdata->init(&pdev->dev, pxamci_detect_irq, mmc);
drivers/mmc/host/pxamci.c:		dev_warn(&pdev->dev, "gpio_power and setpower() both defined\n");
drivers/mmc/host/pxamci.c:		dev_warn(&pdev->dev, "gpio_ro and get_ro() both defined\n");
drivers/mmc/host/pxamci.c:			dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/pxamci.c:			host->pdata->exit(&pdev->dev, mmc);
drivers/mmc/host/pxamci.c:		dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/tmio_mmc_pio.c:	dev_warn(&host->pdev->dev,
drivers/mmc/host/tmio_mmc_pio.c:		dev_warn(&host->pdev->dev, "Spurious data end IRQ\n");
drivers/mmc/host/tmio_mmc_pio.c:		dev_dbg(&host->pdev->dev, "Complete Rx request %p\n",
drivers/mmc/host/tmio_mmc_pio.c:		dev_dbg(&host->pdev->dev, "Complete Tx request %p\n",
drivers/mmc/host/tmio_mmc_pio.c:	struct device *dev = &host->pdev->dev;
drivers/mmc/host/tmio_mmc_pio.c:		dev_dbg(&host->pdev->dev,
drivers/mmc/host/tmio_mmc_pio.c:	const struct device_node *np = pdev->dev.of_node;
drivers/mmc/host/tmio_mmc_pio.c:	mmc = mmc_alloc_host(sizeof(struct tmio_mmc_host), &pdev->dev);
drivers/mmc/host/tmio_mmc_pio.c:	pdata->dev = &pdev->dev;
drivers/mmc/host/tmio_mmc_pio.c:	pm_runtime_enable(&pdev->dev);
drivers/mmc/host/tmio_mmc_pio.c:	ret = pm_runtime_resume(&pdev->dev);
drivers/mmc/host/tmio_mmc_pio.c:		pm_runtime_get_noresume(&pdev->dev);
drivers/mmc/host/tmio_mmc_pio.c:	dev_pm_qos_expose_latency_limit(&pdev->dev, 100);
drivers/mmc/host/tmio_mmc_pio.c:	pm_runtime_disable(&pdev->dev);
drivers/mmc/host/tmio_mmc_pio.c:		pm_runtime_get_sync(&pdev->dev);
drivers/mmc/host/tmio_mmc_pio.c:	dev_pm_qos_hide_latency_limit(&pdev->dev);
drivers/mmc/host/tmio_mmc_pio.c:	pm_runtime_put_sync(&pdev->dev);
drivers/mmc/host/tmio_mmc_pio.c:	pm_runtime_disable(&pdev->dev);
drivers/mmc/host/omap_hsmmc.c:	struct omap_mmc_platform_data *pdata = pdev->dev.platform_data;
drivers/mmc/host/omap_hsmmc.c:	match = of_match_device(of_match_ptr(omap_mmc_of_match), &pdev->dev);
drivers/mmc/host/omap_hsmmc.c:		pdata = of_get_hsmmc_pdata(&pdev->dev);
drivers/mmc/host/omap_hsmmc.c:		dev_err(&pdev->dev, "Platform Data is missing\n");
drivers/mmc/host/omap_hsmmc.c:		dev_err(&pdev->dev, "No Slots\n");
drivers/mmc/host/omap_hsmmc.c:	res = request_mem_region(res->start, resource_size(res), pdev->name);
drivers/mmc/host/omap_hsmmc.c:	mmc = mmc_alloc_host(sizeof(struct omap_hsmmc_host), &pdev->dev);
drivers/mmc/host/omap_hsmmc.c:	host->dev	= &pdev->dev;
drivers/mmc/host/omap_hsmmc.c:	host->fclk = clk_get(&pdev->dev, "fck");
drivers/mmc/host/omap_hsmmc.c:		dev_info(&pdev->dev, "multiblock reads disabled due to 35xx erratum 2.1.1.128; MMC read performance may suffer\n");
drivers/mmc/host/omap_hsmmc.c:	host->dbclk = clk_get(&pdev->dev, "mmchsdb_fck");
drivers/mmc/host/omap_hsmmc.c:	if (!pdev->dev.of_node) {
drivers/mmc/host/omap_hsmmc.c:						 &rx_req, &pdev->dev, "rx");
drivers/mmc/host/omap_hsmmc.c:						 &tx_req, &pdev->dev, "tx");
drivers/mmc/host/omap_hsmmc.c:		if (pdata->init(&pdev->dev) != 0) {
drivers/mmc/host/omap_hsmmc.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/mmc/host/omap_hsmmc.c:		dev_warn(&pdev->dev,
drivers/mmc/host/omap_hsmmc.c:		host->pdata->cleanup(&pdev->dev);
drivers/mmc/host/omap_hsmmc.c:		host->pdata->cleanup(&pdev->dev);
drivers/mmc/host/rtsx_pci_sdmmc.c:	return &(host->pdev->dev);
drivers/mmc/host/rtsx_pci_sdmmc.c:	struct pcr_handle *handle = pdev->dev.platform_data;
drivers/mmc/host/rtsx_pci_sdmmc.c:	dev_dbg(&(pdev->dev), ": Realtek PCI-E SDMMC controller found\n");
drivers/mmc/host/rtsx_pci_sdmmc.c:	mmc = mmc_alloc_host(sizeof(*host), &pdev->dev);
drivers/mmc/host/rtsx_pci_sdmmc.c:		dev_dbg(&(pdev->dev),
drivers/mmc/host/rtsx_pci_sdmmc.c:	dev_dbg(&(pdev->dev),
drivers/mmc/host/dw_mmc-pci.c:	host->irq = pdev->irq;
drivers/mmc/host/dw_mmc-pci.c:	host->dev = &pdev->dev;
drivers/mmc/host/tmio_mmc_dma.c:	dev_dbg(&host->pdev->dev, "%s(): mapped %d -> %d, cookie %d, rq %p\n",
drivers/mmc/host/tmio_mmc_dma.c:		dev_warn(&host->pdev->dev,
drivers/mmc/host/tmio_mmc_dma.c:	dev_dbg(&host->pdev->dev, "%s(): desc %p, cookie %d, sg[%d]\n", __func__,
drivers/mmc/host/tmio_mmc_dma.c:	dev_dbg(&host->pdev->dev, "%s(): mapped %d -> %d, cookie %d, rq %p\n",
drivers/mmc/host/tmio_mmc_dma.c:		dev_warn(&host->pdev->dev,
drivers/mmc/host/tmio_mmc_dma.c:	dev_dbg(&host->pdev->dev, "%s(): desc %p, cookie %d\n", __func__,
drivers/mmc/host/tmio_mmc_dma.c:		dev_dbg(&host->pdev->dev, "%s: TX: got channel %p\n", __func__,
drivers/mmc/host/tmio_mmc_dma.c:		dev_dbg(&host->pdev->dev, "%s: RX: got channel %p\n", __func__,
drivers/mmc/host/sdhci-dove.c:	priv = devm_kzalloc(&pdev->dev, sizeof(struct sdhci_dove_priv),
drivers/mmc/host/sdhci-dove.c:		dev_err(&pdev->dev, "unable to allocate private data");
drivers/mmc/host/sdhci-dove.c:	priv->clk = devm_clk_get(&pdev->dev, NULL);
drivers/mmc/host/sdhci-dove.c:	if (pdev->dev.of_node) {
drivers/mmc/host/sdhci-dove.c:		priv->gpio_cd = of_get_named_gpio(pdev->dev.of_node,
drivers/mmc/host/sdhci-dove.c:			dev_err(&pdev->dev, "card detect gpio request failed: %d\n",
drivers/mmc/host/sdhci-dove.c:			dev_err(&pdev->dev, "card detect irq request failed: %d\n",
drivers/mmc/host/tmio_mmc.c:	if (pdev->num_resources != 2)
drivers/mmc/host/tmio_mmc.c:	pdata = pdev->dev.platform_data;
drivers/mmc/host/tmio_mmc.c:				dev_name(&pdev->dev), host);
drivers/mmc/host/omap.c:	struct omap_mmc_platform_data *pdata = pdev->dev.platform_data;
drivers/mmc/host/omap.c:		dev_err(&pdev->dev, "platform data missing\n");
drivers/mmc/host/omap.c:		dev_err(&pdev->dev, "no slots\n");
drivers/mmc/host/omap.c:				 pdev->name);
drivers/mmc/host/omap.c:	host->dev = &pdev->dev;
drivers/mmc/host/omap.c:	host->id = pdev->id;
drivers/mmc/host/omap.c:	host->iclk = clk_get(&pdev->dev, "ick");
drivers/mmc/host/omap.c:	host->fclk = clk_get(&pdev->dev, "fck");
drivers/mmc/host/omap.c:		ret = pdata->init(&pdev->dev);
drivers/mmc/host/omap.c:		pdata->cleanup(&pdev->dev);
drivers/mmc/host/omap.c:		host->pdata->cleanup(&pdev->dev);
drivers/mmc/host/omap.c:	release_mem_region(pdev->resource[0].start,
drivers/mmc/host/omap.c:			   pdev->resource[0].end - pdev->resource[0].start + 1);
drivers/mmc/host/davinci_mmc.c:	struct davinci_mmc_config *config = pdev->dev.platform_data;
drivers/mmc/host/davinci_mmc.c:			config->set_power(pdev->id, false);
drivers/mmc/host/davinci_mmc.c:			config->set_power(pdev->id, true);
drivers/mmc/host/davinci_mmc.c:	struct davinci_mmc_config *config = pdev->dev.platform_data;
drivers/mmc/host/davinci_mmc.c:	return config->get_cd(pdev->id);
drivers/mmc/host/davinci_mmc.c:	struct davinci_mmc_config *config = pdev->dev.platform_data;
drivers/mmc/host/davinci_mmc.c:	return config->get_ro(pdev->id);
drivers/mmc/host/davinci_mmc.c:	struct davinci_mmc_config *pdata = pdev->dev.platform_data;
drivers/mmc/host/davinci_mmc.c:		of_match_device(of_match_ptr(davinci_mmc_dt_ids), &pdev->dev);
drivers/mmc/host/davinci_mmc.c:	np = pdev->dev.of_node;
drivers/mmc/host/davinci_mmc.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/mmc/host/davinci_mmc.c:		dev_err(&pdev->dev, "Failed to allocate memory for struct davinci_mmc_config\n");
drivers/mmc/host/davinci_mmc.c:		pdev->id_entry = match->data;
drivers/mmc/host/davinci_mmc.c:		dev_info(&pdev->dev, "'max-frequency' property not specified, defaulting to 25MHz\n");
drivers/mmc/host/davinci_mmc.c:		dev_info(&pdev->dev, "Unsupported buswidth, defaulting to 1 bit\n");
drivers/mmc/host/davinci_mmc.c:		dev_err(&pdev->dev, "Couldn't get platform data\n");
drivers/mmc/host/davinci_mmc.c:	mem = request_mem_region(r->start, mem_size, pdev->name);
drivers/mmc/host/davinci_mmc.c:	mmc = mmc_alloc_host(sizeof(struct mmc_davinci_host), &pdev->dev);
drivers/mmc/host/davinci_mmc.c:		dev_warn(&pdev->dev, "RX DMA resource not specified\n");
drivers/mmc/host/davinci_mmc.c:		dev_warn(&pdev->dev, "TX DMA resource not specified\n");
drivers/mmc/host/davinci_mmc.c:	host->clk = clk_get(&pdev->dev, "MMCSDCLK");
drivers/mmc/host/davinci_mmc.c:		dev_err(&pdev->dev, "failed to register cpufreq\n");
drivers/mmc/host/davinci_mmc.c:	dev_dbg(&pdev->dev, "probe err %d\n", ret);
drivers/mmc/host/sdhci-tegra.c:	match = of_match_device(sdhci_tegra_dt_match, &pdev->dev);
drivers/mmc/host/sdhci-tegra.c:	tegra_host = devm_kzalloc(&pdev->dev, sizeof(*tegra_host), GFP_KERNEL);
drivers/mmc/host/sdhci-tegra.c:	sdhci_tegra_parse_dt(&pdev->dev);
drivers/mmc/host/sdhci-esdhc-imx.c:	struct device_node *np = pdev->dev.of_node;
drivers/mmc/host/sdhci-esdhc-imx.c:			of_match_device(imx_esdhc_dt_ids, &pdev->dev);
drivers/mmc/host/sdhci-esdhc-imx.c:	imx_data = devm_kzalloc(&pdev->dev, sizeof(*imx_data), GFP_KERNEL);
drivers/mmc/host/sdhci-esdhc-imx.c:		pdev->id_entry = of_id->data;
drivers/mmc/host/sdhci-esdhc-imx.c:	imx_data->devtype = pdev->id_entry->driver_data;
drivers/mmc/host/sdhci-esdhc-imx.c:	imx_data->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
drivers/mmc/host/sdhci-esdhc-imx.c:	imx_data->clk_ahb = devm_clk_get(&pdev->dev, "ahb");
drivers/mmc/host/sdhci-esdhc-imx.c:	imx_data->clk_per = devm_clk_get(&pdev->dev, "per");
drivers/mmc/host/sdhci-esdhc-imx.c:	imx_data->pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/mmc/host/msm_sdcc.c:	struct msm_mmc_platform_data *plat = pdev->dev.platform_data;
drivers/mmc/host/msm_sdcc.c:	if (pdev->id < 1 || pdev->id > 4)
drivers/mmc/host/msm_sdcc.c:	if (pdev->resource == NULL || pdev->num_resources < 2) {
drivers/mmc/host/msm_sdcc.c:	mmc = mmc_alloc_host(sizeof(struct msmsdcc_host), &pdev->dev);
drivers/mmc/host/msm_sdcc.c:	host->pdev_id = pdev->id;
drivers/mmc/host/msm_sdcc.c:	host->pclk = clk_get(&pdev->dev, "sdc_pclk");
drivers/mmc/host/msm_sdcc.c:	host->clk = clk_get(&pdev->dev, "sdc_clk");
drivers/mmc/host/mxcmmc.c:	struct imxmmc_platform_data *pdata = pdev->dev.platform_data;
drivers/mmc/host/mxcmmc.c:	of_id = of_match_device(mxcmci_of_match, &pdev->dev);
drivers/mmc/host/mxcmmc.c:	r = request_mem_region(iores->start, resource_size(iores), pdev->name);
drivers/mmc/host/mxcmmc.c:	mmc = mmc_alloc_host(sizeof(struct mxcmci_host), &pdev->dev);
drivers/mmc/host/mxcmmc.c:		host->devtype = pdev->id_entry->driver_data;
drivers/mmc/host/mxcmmc.c:			&& !of_property_read_bool(pdev->dev.of_node, "cd-gpios"))
drivers/mmc/host/mxcmmc.c:	host->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
drivers/mmc/host/mxcmmc.c:	host->clk_per = devm_clk_get(&pdev->dev, "per");
drivers/mmc/host/mxcmmc.c:		host->dma = dma_request_slave_channel(&pdev->dev, "rx-tx");
drivers/mmc/host/mxcmmc.c:		ret = host->pdata->init(&pdev->dev, mxcmci_detect_irq,
drivers/mmc/host/mxcmmc.c:		host->pdata->exit(&pdev->dev, mmc);
drivers/mmc/host/mvsdio.c:	struct device_node *np = pdev->dev.of_node;
drivers/mmc/host/mvsdio.c:	mmc = mmc_alloc_host(sizeof(struct mvsd_host), &pdev->dev);
drivers/mmc/host/mvsdio.c:	host->dev = &pdev->dev;
drivers/mmc/host/mvsdio.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/mmc/host/mvsdio.c:		dev_warn(&pdev->dev, "no pins associated\n");
drivers/mmc/host/mvsdio.c:	host->clk = devm_clk_get(&pdev->dev, NULL);
drivers/mmc/host/mvsdio.c:			dev_err(&pdev->dev, "DT platforms must have a clock associated\n");
drivers/mmc/host/mvsdio.c:		mvsd_data = pdev->dev.platform_data;
drivers/mmc/host/mvsdio.c:	host->base = devm_request_and_ioremap(&pdev->dev, r);
drivers/mmc/host/mvsdio.c:	ret = devm_request_irq(&pdev->dev, irq, mvsd_irq, 0, DRIVER_NAME, host);
drivers/mmc/host/mvsdio.c:		dev_err(&pdev->dev, "cannot assign irq %d\n", irq);
drivers/mmc/host/mvsdio.c:		dev_notice(&pdev->dev, "using GPIO %d for card detection\n",
drivers/mmc/host/mvsdio.c:		dev_notice(&pdev->dev, "lacking card detect (fall back to polling)\n");
drivers/mmc/host/sdhci-pltfm.c:	struct device_node *np = pdev->dev.of_node;
drivers/mmc/host/sdhci-pltfm.c:	struct device_node *np = pdev->dev.of_node;
drivers/mmc/host/sdhci-pltfm.c:		dev_err(&pdev->dev, "Invalid iomem size!\n");
drivers/mmc/host/sdhci-pltfm.c:	if (pdev->dev.parent != &platform_bus && !np)
drivers/mmc/host/sdhci-pltfm.c:		host = sdhci_alloc_host(pdev->dev.parent, sizeof(*pltfm_host));
drivers/mmc/host/sdhci-pltfm.c:		host = sdhci_alloc_host(&pdev->dev, sizeof(*pltfm_host));
drivers/mmc/host/sdhci-pltfm.c:	host->hw_name = dev_name(&pdev->dev);
drivers/mmc/host/sdhci-pltfm.c:		dev_err(&pdev->dev, "cannot request region\n");
drivers/mmc/host/sdhci-pltfm.c:		dev_err(&pdev->dev, "failed to remap registers\n");
drivers/mmc/host/sdhci-pltfm.c:	dev_err(&pdev->dev, "%s failed %d\n", __func__, ret);
drivers/mmc/host/bfin_sdh.c:	return pdev->dev.platform_data;
drivers/mmc/host/bfin_sdh.c:		dev_err(&pdev->dev, "missing platform driver data\n");
drivers/mmc/host/bfin_sdh.c:	mmc = mmc_alloc_host(sizeof(struct sdh_host), &pdev->dev);
drivers/mmc/host/bfin_sdh.c:		dev_err(&pdev->dev, "unable to request DMA channel\n");
drivers/mmc/host/bfin_sdh.c:		dev_err(&pdev->dev, "unable to request DMA irq\n");
drivers/mmc/host/bfin_sdh.c:	host->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE, &host->sg_dma, GFP_KERNEL);
drivers/mmc/host/bfin_sdh.c:		dev_err(&pdev->dev, "unable to request status irq\n");
drivers/mmc/host/bfin_sdh.c:		dev_err(&pdev->dev, "unable to request peripheral pins\n");
drivers/mmc/host/bfin_sdh.c:	dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/bfin_sdh.c:		dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
drivers/mmc/host/wbsd.c:	return wbsd_init(&pnpdev->dev, io, irq, dma, 1);
drivers/mmc/host/sh_mmcif.c:	struct sh_mmcif_plat_data *pd = pdev->dev.platform_data;
drivers/mmc/host/sh_mmcif.c:		dev_err(&pdev->dev, "Get irq error\n");
drivers/mmc/host/sh_mmcif.c:		dev_err(&pdev->dev, "platform_get_resource error.\n");
drivers/mmc/host/sh_mmcif.c:		dev_err(&pdev->dev, "ioremap error.\n");
drivers/mmc/host/sh_mmcif.c:	mmc = mmc_alloc_host(sizeof(struct sh_mmcif_host), &pdev->dev);
drivers/mmc/host/sh_mmcif.c:	pm_runtime_enable(&pdev->dev);
drivers/mmc/host/sh_mmcif.c:	host->hclk = clk_get(&pdev->dev, NULL);
drivers/mmc/host/sh_mmcif.c:		dev_err(&pdev->dev, "cannot get clock: %d\n", ret);
drivers/mmc/host/sh_mmcif.c:	ret = pm_runtime_resume(&pdev->dev);
drivers/mmc/host/sh_mmcif.c:	name = irq[1] < 0 ? dev_name(&pdev->dev) : "sh_mmc:error";
drivers/mmc/host/sh_mmcif.c:		dev_err(&pdev->dev, "request_irq error (%s)\n", name);
drivers/mmc/host/sh_mmcif.c:			dev_err(&pdev->dev, "request_irq error (sh_mmc:int)\n");
drivers/mmc/host/sh_mmcif.c:	dev_pm_qos_expose_latency_limit(&pdev->dev, 100);
drivers/mmc/host/sh_mmcif.c:	dev_info(&pdev->dev, "driver version %s\n", DRIVER_VERSION);
drivers/mmc/host/sh_mmcif.c:	dev_dbg(&pdev->dev, "chip ver H'%04x\n",
drivers/mmc/host/sh_mmcif.c:	pm_runtime_suspend(&pdev->dev);
drivers/mmc/host/sh_mmcif.c:	pm_runtime_disable(&pdev->dev);
drivers/mmc/host/sh_mmcif.c:	pm_runtime_get_sync(&pdev->dev);
drivers/mmc/host/sh_mmcif.c:	dev_pm_qos_hide_latency_limit(&pdev->dev);
drivers/mmc/host/sh_mmcif.c:	pm_runtime_put_sync(&pdev->dev);
drivers/mmc/host/sh_mmcif.c:	pm_runtime_disable(&pdev->dev);
drivers/mmc/host/sdhci-pxav2.c:	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
drivers/mmc/host/sdhci-pxav2.c:	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
drivers/mmc/host/sdhci-pxav2.c:	struct device *dev = &pdev->dev;
drivers/mmc/host/sdhci-pxav2.c:	match = of_match_device(of_match_ptr(sdhci_pxav2_of_match), &pdev->dev);
drivers/mmc/host/sdhci-pxav2.c:		dev_err(&pdev->dev, "failed to add host\n");
drivers/mmc/card/emmc_partitions.c:    pdev->class = &block_class;
drivers/mmc/card/emmc_partitions.c:    pdev->type = &part_type;
drivers/mmc/card/emmc_partitions.c:    pdev->parent = ddev;
drivers/mmc/card/emmc_partitions.c:    pdev->devt = devt;
drivers/mmc/card/emmc_partitions.c:    p->holder_dir = kobject_create_and_add("holders", &pdev->kobj);
drivers/mmc/card/emmc_partitions.c:        kobject_uevent(&pdev->kobj, KOBJ_ADD);
drivers/ssbi/ssbi.c:	struct device_node *np = pdev->dev.of_node;
drivers/ssbi/ssbi.c:	dev_info(&pdev->dev, "SSBI controller type: '%s'\n", type);
drivers/ssbi/ssbi.c:	ret = of_platform_populate(np, NULL, NULL, &pdev->dev);
drivers/w1/masters/mxc_w1.c:	mdev = devm_kzalloc(&pdev->dev, sizeof(struct mxc_w1_device),
drivers/w1/masters/mxc_w1.c:	mdev->clk = devm_clk_get(&pdev->dev, NULL);
drivers/w1/masters/mxc_w1.c:	mdev->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/w1/masters/omap_hdq.c:	struct device *dev = &pdev->dev;
drivers/w1/masters/omap_hdq.c:		dev_dbg(&pdev->dev, "unable to allocate memory\n");
drivers/w1/masters/omap_hdq.c:	pm_runtime_enable(&pdev->dev);
drivers/w1/masters/omap_hdq.c:	pm_runtime_get_sync(&pdev->dev);
drivers/w1/masters/omap_hdq.c:	dev_info(&pdev->dev, "OMAP HDQ Hardware Rev %c.%c. Driver in %s mode\n",
drivers/w1/masters/omap_hdq.c:		dev_dbg(&pdev->dev, "could not request irq\n");
drivers/w1/masters/omap_hdq.c:	pm_runtime_put_sync(&pdev->dev);
drivers/w1/masters/omap_hdq.c:		dev_dbg(&pdev->dev, "Failure in registering w1 master\n");
drivers/w1/masters/omap_hdq.c:	pm_runtime_put_sync(&pdev->dev);
drivers/w1/masters/omap_hdq.c:	pm_runtime_disable(&pdev->dev);
drivers/w1/masters/omap_hdq.c:		dev_dbg(&pdev->dev, "removed when use count is not zero\n");
drivers/w1/masters/omap_hdq.c:	pm_runtime_disable(&pdev->dev);
drivers/w1/masters/matrox_w1.c:	if (pdev->vendor != PCI_VENDOR_ID_MATROX || pdev->device != PCI_DEVICE_ID_MATROX_G400)
drivers/w1/masters/matrox_w1.c:		dev_err(&pdev->dev,
drivers/w1/masters/matrox_w1.c:		dev_err(&pdev->dev, "%s: failed to ioremap(0x%lx, %d).\n",
drivers/w1/masters/matrox_w1.c:	dev_info(&pdev->dev, "Matrox G400 GPIO transport layer for 1-wire.\n");
drivers/w1/masters/ds1wm.c:		dev_err(&ds1wm_data->pdev->dev, "reset failed, timed out\n");
drivers/w1/masters/ds1wm.c:		dev_dbg(&ds1wm_data->pdev->dev, "reset: no devices found\n");
drivers/w1/masters/ds1wm.c:		dev_err(&ds1wm_data->pdev->dev, "write failed, timed out\n");
drivers/w1/masters/ds1wm.c:		dev_err(&ds1wm_data->pdev->dev, "read failed, timed out\n");
drivers/w1/masters/ds1wm.c:	struct ds1wm_driver_data *plat = ds1wm_data->pdev->dev.platform_data;
drivers/w1/masters/ds1wm.c:	dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:		dev_err(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:	dev_dbg(&ds1wm_data->pdev->dev, "search begin\n");
drivers/w1/masters/ds1wm.c:			dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:			dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:		dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:		dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:		dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:				dev_err(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:			dev_err(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:		dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:		dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:		dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:			dev_err(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:		dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:		dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:		dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:	dev_dbg(&ds1wm_data->pdev->dev,
drivers/w1/masters/ds1wm.c:	ds1wm_data = devm_kzalloc(&pdev->dev, sizeof(*ds1wm_data), GFP_KERNEL);
drivers/w1/masters/ds1wm.c:	ds1wm_data->map = devm_ioremap(&pdev->dev, res->start,
drivers/w1/masters/ds1wm.c:	plat = pdev->dev.platform_data;
drivers/w1/masters/ds1wm.c:	ret = devm_request_irq(&pdev->dev, ds1wm_data->irq, ds1wm_isr,
drivers/w1/masters/w1-gpio.c:	struct w1_gpio_platform_data *pdata = pdev->dev.platform_data;
drivers/w1/masters/w1-gpio.c:	struct device_node *np = pdev->dev.of_node;
drivers/w1/masters/w1-gpio.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/w1/masters/w1-gpio.c:	pdev->dev.platform_data = pdata;
drivers/w1/masters/w1-gpio.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/w1/masters/w1-gpio.c:		dev_warn(&pdev->dev, "unable to select pin group\n");
drivers/w1/masters/w1-gpio.c:			dev_err(&pdev->dev, "Failed to parse DT\n");
drivers/w1/masters/w1-gpio.c:	pdata = pdev->dev.platform_data;
drivers/w1/masters/w1-gpio.c:		dev_err(&pdev->dev, "No configuration data\n");
drivers/w1/masters/w1-gpio.c:		dev_err(&pdev->dev, "Out of memory\n");
drivers/w1/masters/w1-gpio.c:		dev_err(&pdev->dev, "gpio_request (pin) failed\n");
drivers/w1/masters/w1-gpio.c:			dev_err(&pdev->dev, "gpio_request_one "
drivers/w1/masters/w1-gpio.c:		dev_err(&pdev->dev, "w1_add_master device failed\n");
drivers/w1/masters/w1-gpio.c:	struct w1_gpio_platform_data *pdata = pdev->dev.platform_data;
drivers/w1/masters/w1-gpio.c:	struct w1_gpio_platform_data *pdata = pdev->dev.platform_data;
drivers/w1/masters/w1-gpio.c:	struct w1_gpio_platform_data *pdata = pdev->dev.platform_data;
drivers/w1/masters/ds2482.c:	if (pdev->read_prt != read_ptr) {
drivers/w1/masters/ds2482.c:		if (i2c_smbus_write_byte_data(pdev->client,
drivers/w1/masters/ds2482.c:		pdev->read_prt = read_ptr;
drivers/w1/masters/ds2482.c:	if (i2c_smbus_write_byte(pdev->client, cmd) < 0)
drivers/w1/masters/ds2482.c:	pdev->read_prt = DS2482_PTR_CODE_STATUS;
drivers/w1/masters/ds2482.c:	if (i2c_smbus_write_byte_data(pdev->client, cmd, byte) < 0)
drivers/w1/masters/ds2482.c:	pdev->read_prt = (cmd != DS2482_CMD_WRITE_CONFIG) ?
drivers/w1/masters/ds2482.c:			temp = i2c_smbus_read_byte(pdev->client);
drivers/w1/masters/ds2482.c:		       __func__, pdev->channel);
drivers/w1/masters/ds2482.c:	if (i2c_smbus_write_byte_data(pdev->client, DS2482_CMD_CHANNEL_SELECT,
drivers/w1/masters/ds2482.c:	pdev->read_prt = DS2482_PTR_CODE_CHANNEL;
drivers/w1/masters/ds2482.c:	pdev->channel = -1;
drivers/w1/masters/ds2482.c:	if (i2c_smbus_read_byte(pdev->client) == ds2482_chan_rd[channel]) {
drivers/w1/masters/ds2482.c:		pdev->channel = channel;
drivers/w1/masters/ds2482.c:	mutex_lock(&pdev->access_lock);
drivers/w1/masters/ds2482.c:	if (pdev->w1_count > 1)
drivers/w1/masters/ds2482.c:	mutex_unlock(&pdev->access_lock);
drivers/w1/masters/ds2482.c:	mutex_lock(&pdev->access_lock);
drivers/w1/masters/ds2482.c:	if (pdev->w1_count > 1)
drivers/w1/masters/ds2482.c:	mutex_unlock(&pdev->access_lock);
drivers/w1/masters/ds2482.c:	mutex_lock(&pdev->access_lock);
drivers/w1/masters/ds2482.c:	if (pdev->w1_count > 1)
drivers/w1/masters/ds2482.c:	mutex_unlock(&pdev->access_lock);
drivers/w1/masters/ds2482.c:	mutex_lock(&pdev->access_lock);
drivers/w1/masters/ds2482.c:	if (pdev->w1_count > 1)
drivers/w1/masters/ds2482.c:	result = i2c_smbus_read_byte(pdev->client);
drivers/w1/masters/ds2482.c:	mutex_unlock(&pdev->access_lock);
drivers/w1/masters/ds2482.c:	mutex_lock(&pdev->access_lock);
drivers/w1/masters/ds2482.c:	if (pdev->w1_count > 1)
drivers/w1/masters/ds2482.c:	mutex_unlock(&pdev->access_lock);
drivers/w1/slaves/w1_ds2781.c:	pdev->dev.parent = &sl->dev;
drivers/w1/slaves/w1_ds2781.c:	int id = pdev->id;
drivers/w1/slaves/w1_bq27000.c:	pdev->dev.parent = &sl->dev;
drivers/w1/slaves/w1_ds2780.c:	pdev->dev.parent = &sl->dev;
drivers/w1/slaves/w1_ds2780.c:	int id = pdev->id;
drivers/w1/slaves/w1_ds2760.c:	pdev->dev.parent = &sl->dev;
drivers/w1/slaves/w1_ds2760.c:	int id = pdev->id;
drivers/zorro/zorro.c:	bus->dev.parent = &pdev->dev;
drivers/irqchip/irq-renesas-intc-irqpin.c:	dev_dbg(&p->pdev->dev, "sense irq = %d, mode = %d\n", irq, value);
drivers/irqchip/irq-renesas-intc-irqpin.c:	dev_dbg(&i->p->pdev->dev, "%s (%d:%d:%d)\n",
drivers/irqchip/irq-renesas-intc-irqpin.c:	struct renesas_intc_irqpin_config *pdata = pdev->dev.platform_data;
drivers/irqchip/irq-renesas-intc-irqpin.c:	const char *name = dev_name(&pdev->dev);
drivers/irqchip/irq-renesas-intc-irqpin.c:	p = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);
drivers/irqchip/irq-renesas-intc-irqpin.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/irqchip/irq-renesas-intc-irqpin.c:			dev_err(&pdev->dev, "not enough IOMEM resources\n");
drivers/irqchip/irq-renesas-intc-irqpin.c:		dev_err(&pdev->dev, "not enough IRQ resources\n");
drivers/irqchip/irq-renesas-intc-irqpin.c:			dev_err(&pdev->dev, "IOMEM size mismatch\n");
drivers/irqchip/irq-renesas-intc-irqpin.c:		i->iomem = devm_ioremap_nocache(&pdev->dev, io[k]->start,
drivers/irqchip/irq-renesas-intc-irqpin.c:			dev_err(&pdev->dev, "failed to remap IOMEM\n");
drivers/irqchip/irq-renesas-intc-irqpin.c:	p->irq_domain = irq_domain_add_simple(pdev->dev.of_node,
drivers/irqchip/irq-renesas-intc-irqpin.c:		dev_err(&pdev->dev, "cannot initialize irq domain\n");
drivers/irqchip/irq-renesas-intc-irqpin.c:		if (devm_request_irq(&pdev->dev, p->irq[0].requested_irq,
drivers/irqchip/irq-renesas-intc-irqpin.c:			dev_err(&pdev->dev, "failed to request low IRQ\n");
drivers/irqchip/irq-renesas-intc-irqpin.c:			if (devm_request_irq(&pdev->dev,
drivers/irqchip/irq-renesas-intc-irqpin.c:				dev_err(&pdev->dev,
drivers/irqchip/irq-renesas-intc-irqpin.c:	dev_info(&pdev->dev, "driving %d irqs\n", p->number_of_irqs);
drivers/irqchip/irq-renesas-intc-irqpin.c:			dev_warn(&pdev->dev, "irq base mismatch (%d/%d)\n",
drivers/irqchip/irq-renesas-irqc.c:	dev_dbg(&i->p->pdev->dev, "%s (%d:%d:%d)\n",
drivers/irqchip/irq-renesas-irqc.c:	struct renesas_irqc_config *pdata = pdev->dev.platform_data;
drivers/irqchip/irq-renesas-irqc.c:	const char *name = dev_name(&pdev->dev);
drivers/irqchip/irq-renesas-irqc.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/irqchip/irq-renesas-irqc.c:		dev_err(&pdev->dev, "not enough IOMEM resources\n");
drivers/irqchip/irq-renesas-irqc.c:		dev_err(&pdev->dev, "not enough IRQ resources\n");
drivers/irqchip/irq-renesas-irqc.c:		dev_err(&pdev->dev, "failed to remap IOMEM\n");
drivers/irqchip/irq-renesas-irqc.c:	p->irq_domain = irq_domain_add_simple(pdev->dev.of_node,
drivers/irqchip/irq-renesas-irqc.c:		dev_err(&pdev->dev, "cannot initialize irq domain\n");
drivers/irqchip/irq-renesas-irqc.c:			dev_err(&pdev->dev, "failed to request IRQ\n");
drivers/irqchip/irq-renesas-irqc.c:	dev_info(&pdev->dev, "driving %d irqs\n", p->number_of_irqs);
drivers/irqchip/irq-renesas-irqc.c:			dev_warn(&pdev->dev, "irq base mismatch (%d/%d)\n",
drivers/block/cciss_scsi.c:		dev_err(&h->pdev->dev,
drivers/block/cciss_scsi.c:		dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:		dev_warn(&h->pdev->dev, "Too many devices, "
drivers/block/cciss_scsi.c:		dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d added.\n",
drivers/block/cciss_scsi.c:	dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d removed.\n",
drivers/block/cciss_scsi.c:		dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:			dev_info(&h->pdev->dev,
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev, "didn't find "
drivers/block/cciss_scsi.c:		dev_warn(&h->pdev->dev, "scsi_add_device "
drivers/block/cciss_scsi.c:				dev_warn(&h->pdev->dev, "%p has"
drivers/block/cciss_scsi.c:				dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:				dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:				dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:				dev_warn(&h->pdev->dev, "%p was aborted\n", c);
drivers/block/cciss_scsi.c:				dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:				dev_warn(&h->pdev->dev, "%p aborted due to an "
drivers/block/cciss_scsi.c:				dev_warn(&h->pdev->dev, "%p timedout\n", c);
drivers/block/cciss_scsi.c:				dev_warn(&h->pdev->dev, "c %p command "
drivers/block/cciss_scsi.c:				dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:	error = scsi_add_host(sh, &h->pdev->dev);
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:				dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:			dev_info(&h->pdev->dev, "UNDERRUN\n");
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev, "%p has"
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev, "%p has protocol error\n", c);
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev, "%p had hardware error\n", c);
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev, "%p had connection lost\n", c);
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev, "%p was aborted\n", c);
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev, "%p timedout\n", c);
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss_scsi.c:		dev_warn(&h->pdev->dev, "scsi_cmd_alloc returned NULL!\n");
drivers/block/cciss_scsi.c:		dev_warn(&h->pdev->dev, "unknown data direction: %d\n",
drivers/block/cciss_scsi.c:		dev_info(&h->pdev->dev, "SCSI subsystem already engaged.\n");
drivers/block/cciss_scsi.c:		dev_warn(&h->pdev->dev, "out of memory in "
drivers/block/cciss_scsi.c:		dev_warn(&h->pdev->dev, "Waiting %d secs "
drivers/block/cciss_scsi.c:		dev_warn(&h->pdev->dev, "giving up on device.\n");
drivers/block/cciss_scsi.c:		dev_warn(&h->pdev->dev, "device is ready.\n");
drivers/block/cciss_scsi.c:	dev_warn(&h->pdev->dev, "resetting tape drive or medium changer.\n");
drivers/block/cciss_scsi.c:	dev_warn(&h->pdev->dev, "resetting device failed.\n");
drivers/block/cciss_scsi.c:	dev_warn(&h->pdev->dev, "aborting tardy SCSI cmd\n");
drivers/block/nvme-core.c:					dev->entry[i].vector = i + pdev->irq;
drivers/block/nvme-core.c:	if (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(64)))
drivers/block/nvme-core.c:		dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/block/nvme-core.c:	else if (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(32)))
drivers/block/nvme-core.c:		dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/block/nvme-core.c:	dev->entry[0].vector = pdev->irq;
drivers/block/nvme-core.c:	dev->miscdev.parent = &pdev->dev;
drivers/block/cciss.c:			dev_err(&h->pdev->dev, "Cannot get memory "
drivers/block/cciss.c:	h->dev.parent = &h->pdev->dev;
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "cciss_open %s\n", bdev->bd_disk->disk_name);
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "cciss_release %s\n", disk->disk_name);
drivers/block/cciss.c:	pciinfo.domain = pci_domain_nr(h->pdev->bus);
drivers/block/cciss.c:	pciinfo.bus = h->pdev->bus->number;
drivers/block/cciss.c:	pciinfo.dev_fn = h->pdev->devfn;
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "cciss_ioctl: Called with cmd=%x %lx\n",
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "Done with %p\n", rq);
drivers/block/cciss.c:	blk_queue_bounce_limit(disk->queue, h->pdev->dma_mask);
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "disk %d has changed.\n", drv_index);
drivers/block/cciss.c:			dev_warn(&h->pdev->dev, "could not update disk %d\n",
drivers/block/cciss.c:	dev_err(&h->pdev->dev, "out of memory\n");
drivers/block/cciss.c:			dev_err(&h->pdev->dev,
drivers/block/cciss.c:	dev_warn(&h->pdev->dev, "could not add disk 0.\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev,
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "more luns configured"
drivers/block/cciss.c:	dev_err(&h->pdev->dev, "out of memory\n");
drivers/block/cciss.c:			dev_warn(&h->pdev->dev, "Unknown Command 0x%c\n", cmd);
drivers/block/cciss.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "unknown command type %d\n", cmd_type);
drivers/block/cciss.c:			dev_warn(&h->pdev->dev, "cmd 0x%02x "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cmd 0x%02x"
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cmd 0x%02x is "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cmd 0x%02x has "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cmd 0x%02x had "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cmd 0x%02x had "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cmd 0x%02x was "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cmd 0x%02x reports "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "unsolicited abort 0x%02x\n",
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cmd unabortable\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cmd 0x%02x returned "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "retrying 0x%02x\n",
drivers/block/cciss.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "reading geometry failed\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "out of memory\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "read capacity failed\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "out of memory\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "read capacity failed\n");
drivers/block/cciss.c:	dev_info(&h->pdev->dev, "      blocks= %llu block_size= %d\n",
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "out of memory\n");
drivers/block/cciss.c:			dev_warn(&h->pdev->dev, "fifo full\n");
drivers/block/cciss.c:			dev_warn(&h->pdev->dev, "cmd %p "
drivers/block/cciss.c:			dev_warn(&h->pdev->dev, "cmd %p has CHECK CONDITION"
drivers/block/cciss.c:			dev_warn(&h->pdev->dev, "cmd %p has"
drivers/block/cciss.c:			dev_warn(&h->pdev->dev, "cciss: cmd %p has"
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cciss: cmd %p is "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cciss: cmd %p has "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cciss: cmd %p had "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cciss: cmd %p had "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cciss: cmd %p was "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cciss: cmd %p reports "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cciss%d: unsolicited "
drivers/block/cciss.c:			dev_warn(&h->pdev->dev, "retrying %p\n", cmd);
drivers/block/cciss.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cmd %p timedout\n", cmd);
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cmd %p unabortable\n", cmd);
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cmd %p returned "
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "sector =%d nr_sectors=%d\n",
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "Submitting %u sectors in %d segments "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "bad request type %d\n",
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "bad tag 0x%08x ignored.\n", raw_tag);
drivers/block/cciss.c:	dev_info(&h->pdev->dev, "Received interrupt while interrupts disabled "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "a state change "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "LUN failure "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "report LUN data changed\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev,
drivers/block/cciss.c:		dev_warn(&h->pdev->dev,
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "unknown unit attention detected\n");
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "Controller Configuration information\n");
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "------------------------------------\n");
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "   Signature = %s\n", temp_name);
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "   Spec Number = %d\n",
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "   Transport methods supported = 0x%x\n",
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "   Transport methods active = 0x%x\n",
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "   Requested transport Method = 0x%x\n",
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "   Coalesce Interrupt Delay = 0x%x\n",
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "   Coalesce Interrupt Count = 0x%x\n",
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "   Max outstanding commands = 0x%d\n",
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "   Bus Types = 0x%x\n",
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "   Server Name = %s\n", temp_name);
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "   Heartbeat Counter = 0x%x\n\n\n",
drivers/block/cciss.c:				dev_warn(&pdev->dev,
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cciss: unable to get board into"
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "Trying to put board into Performant mode\n");
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "Placing controller into performant mode\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "%s %d %s\n",
drivers/block/cciss.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss.c:			dev_warn(&h->pdev->dev,
drivers/block/cciss.c:			dev_warn(&h->pdev->dev, "MSI init failed\n");
drivers/block/cciss.c:	h->intr[h->intr_mode] = h->pdev->irq;
drivers/block/cciss.c:	subsystem_vendor_id = pdev->subsystem_vendor;
drivers/block/cciss.c:	subsystem_device_id = pdev->subsystem_device;
drivers/block/cciss.c:	dev_warn(&pdev->dev, "unrecognized board ID: 0x%08x, ignoring.\n",
drivers/block/cciss.c:			dev_dbg(&pdev->dev, "memory BAR = %lx\n",
drivers/block/cciss.c:	dev_warn(&pdev->dev, "no memory BAR found\n");
drivers/block/cciss.c:	dev_warn(&pdev->dev, "board not ready, timed out.\n");
drivers/block/cciss.c:		dev_warn(&pdev->dev, "cannot find cfg_base_addr_index, "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "Controller reports "
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "not a valid CISS config table\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "controller appears to be disabled\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "Unable to Enable PCI device\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev,
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "irq = %x\n", h->pdev->irq);
drivers/block/cciss.c:	dev_dbg(&h->pdev->dev, "board_id = %x\n", h->board_id);
drivers/block/cciss.c:	dev_warn(&pdev->dev, "This driver supports a maximum"
drivers/block/cciss.c:	dev_warn(&pdev->dev, "out of memory.\n");
drivers/block/cciss.c:		dev_err(&pdev->dev,
drivers/block/cciss.c:		dev_err(&pdev->dev, "controller message %02x:%02x failed\n",
drivers/block/cciss.c:	dev_info(&pdev->dev, "controller message %02x:%02x succeeded\n",
drivers/block/cciss.c:		dev_info(&pdev->dev, "using doorbell to reset controller\n");
drivers/block/cciss.c:			dev_err(&pdev->dev,
drivers/block/cciss.c:		dev_info(&pdev->dev, "using PCI PM to reset controller\n");
drivers/block/cciss.c:		dev_warn(&pdev->dev, "Cannot reset Smart Array 640x "
drivers/block/cciss.c:			dev_warn(&pdev->dev, "Controller claims that "
drivers/block/cciss.c:		dev_warn(&pdev->dev, "failed to enable device.\n");
drivers/block/cciss.c:	dev_info(&pdev->dev, "Waiting for board to reset.\n");
drivers/block/cciss.c:		dev_warn(&pdev->dev, "Failed waiting for board to hard reset."
drivers/block/cciss.c:		dev_warn(&pdev->dev,
drivers/block/cciss.c:		dev_warn(&pdev->dev, "Unable to successfully hard reset "
drivers/block/cciss.c:		dev_info(&pdev->dev, "Board ready after hard reset.\n");
drivers/block/cciss.c:	dev_warn(&pdev->dev, "Waiting for controller to respond to no-op\n");
drivers/block/cciss.c:			dev_warn(&pdev->dev, "no-op failed%s\n",
drivers/block/cciss.c:		dev_err(&h->pdev->dev, "out of memory");
drivers/block/cciss.c:			dev_err(&h->pdev->dev, "could not allocate "
drivers/block/cciss.c:		dev_err(&h->pdev->dev, "Unable to get msi irq %d"
drivers/block/cciss.c:	dev_err(&h->pdev->dev, "Unable to get irq %d for %s\n",
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "Resetting array controller failed.\n");
drivers/block/cciss.c:	dev_info(&h->pdev->dev, "Waiting for board to soft reset.\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "Soft reset had no effect.\n");
drivers/block/cciss.c:	dev_info(&h->pdev->dev, "Board reset, awaiting READY status.\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "Board failed to become ready "
drivers/block/cciss.c:		dev_err(&h->pdev->dev, "no suitable DMA available\n");
drivers/block/cciss.c:		dev_err(&h->pdev->dev,
drivers/block/cciss.c:	dev_info(&h->pdev->dev, "%s: <0x%x> at PCI %s IRQ %d%s using DAC\n",
drivers/block/cciss.c:	       h->devname, pdev->device, pci_name(pdev),
drivers/block/cciss.c:			dev_warn(&h->pdev->dev, "Failed to request_irq after "
drivers/block/cciss.c:			dev_warn(&h->pdev->dev, "Soft reset failed.\n");
drivers/block/cciss.c:		dev_info(&h->pdev->dev, "Board READY.\n");
drivers/block/cciss.c:		dev_info(&h->pdev->dev,
drivers/block/cciss.c:			dev_info(&h->pdev->dev,
drivers/block/cciss.c:		dev_err(&h->pdev->dev, "out of memory\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "unable to determine firmware"
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "cache not flushed, out of memory.\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "Error flushing cache\n");
drivers/block/cciss.c:		dev_warn(&h->pdev->dev, "unable to get board into simple mode\n");
drivers/block/cciss.c:		dev_err(&pdev->dev, "Unable to remove device\n");
drivers/block/cciss.c:		dev_err(&pdev->dev, "device appears to already be removed\n");
drivers/block/cciss.c:			dev_warn(&hba[i]->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dma_unmap_sg(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dev_warn(&port->dd->pdev->dev, "Failed to get a tag.\n");
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_err(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dev_warn(&port->dd->pdev->dev, "Issuing COM reset\n");
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dma_unmap_sg(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dma_unmap_sg(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dev_warn(&dd->pdev->dev, "Taskfile error\n");
drivers/block/mtip32xx/mtip32xx.c:				dev_err(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_info(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_info(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_info(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:					dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_warn(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:				dev_warn(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:				dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&dd->pdev->dev, "SG buffer is not 8 byte aligned\n");
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:				dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:				dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:				dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:				dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:				dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:				dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&port->dd->pdev->dev, "IDENTIFY DATA not valid\n");
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&port->dd->pdev->dev, "SMART not supported\n");
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&port->dd->pdev->dev, "SMART not enabled\n");
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&port->dd->pdev->dev, "Failed to ge SMART data\n");
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	buf = dmam_alloc_coherent(&dd->pdev->dev, ATA_SECT_SIZE, &dma_addr,
drivers/block/mtip32xx/mtip32xx.c:	dmam_free_coherent(&dd->pdev->dev, ATA_SECT_SIZE, buf, dma_addr);
drivers/block/mtip32xx/mtip32xx.c:	dev_info(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dev_info(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dev_info(&port->dd->pdev->dev, "Model: %s\n", cbuf);
drivers/block/mtip32xx/mtip32xx.c:		dev_info(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dev_info(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		buf = dmam_alloc_coherent(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_err(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dmam_free_coherent(&port->dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:				dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	nents = dma_map_sg(&dd->pdev->dev, command->sg, nents, dma_dir);
drivers/block/mtip32xx/mtip32xx.c:					dev_name(&dd->pdev->dev),
drivers/block/mtip32xx/mtip32xx.c:					dev_name(&dd->pdev->dev),
drivers/block/mtip32xx/mtip32xx.c:					dev_name(&dd->pdev->dev),
drivers/block/mtip32xx/mtip32xx.c:					dev_name(&dd->pdev->dev),
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	return (dd->pdev->device == P420M_DEVICE_ID ? 1 : 0);
drivers/block/mtip32xx/mtip32xx.c:		dev_info(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dev_warn(&dd->pdev->dev, "Unrecognized product id\n");
drivers/block/mtip32xx/mtip32xx.c:	dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:				dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dmam_alloc_coherent(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	rv = devm_request_irq(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:				dd->pdev->irq,
drivers/block/mtip32xx/mtip32xx.c:				dev_driver_string(&dd->pdev->dev),
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			"Unable to allocate IRQ %d\n", dd->pdev->irq);
drivers/block/mtip32xx/mtip32xx.c:	irq_set_affinity_hint(dd->pdev->irq, get_cpu_mask(dd->isr_binding));
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_info(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_info(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_info(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_info(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	irq_set_affinity_hint(dd->pdev->irq, NULL);
drivers/block/mtip32xx/mtip32xx.c:	devm_free_irq(&dd->pdev->dev, dd->pdev->irq, dd);
drivers/block/mtip32xx/mtip32xx.c:	dmam_free_coherent(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:				dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	irq_set_affinity_hint(dd->pdev->irq, NULL);
drivers/block/mtip32xx/mtip32xx.c:	devm_free_irq(&dd->pdev->dev, dd->pdev->irq, dd);
drivers/block/mtip32xx/mtip32xx.c:	dmam_free_coherent(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:			dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dd->disk->driverfs_dev	= &dd->pdev->dev;
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&dd->pdev->dev, "service thread failed to start\n");
drivers/block/mtip32xx/mtip32xx.c:		dev_info(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dev_info(&dd->pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:	dev_info(&dd->pdev->dev, "Resuming %s ...\n",
drivers/block/mtip32xx/mtip32xx.c:	my_node = pcibus_to_node(pdev->bus);
drivers/block/mtip32xx/mtip32xx.c:		dev_info(&pdev->dev, "Kernel not reporting proximity, choosing a node\n");
drivers/block/mtip32xx/mtip32xx.c:	dev_info(&pdev->dev, "NUMA node %d (closest: %d,%d, probe on %d:%d)\n",
drivers/block/mtip32xx/mtip32xx.c:		my_node, pcibus_to_node(pdev->bus), dev_to_node(&pdev->dev),
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&pdev->dev, "Unable to enable device\n");
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&pdev->dev, "Unable to map regions\n");
drivers/block/mtip32xx/mtip32xx.c:				dev_warn(&pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&pdev->dev, "Can't create wq %d\n", dd->instance);
drivers/block/mtip32xx/mtip32xx.c:		dev_info(&pdev->dev, "Node %d on package %d has %d cpu(s): %s\n",
drivers/block/mtip32xx/mtip32xx.c:		dev_dbg(&pdev->dev, "mtip32xx: node_mask empty\n");
drivers/block/mtip32xx/mtip32xx.c:	dev_info(&pdev->dev, "Initial IRQ binding node:cpu %d:%d\n",
drivers/block/mtip32xx/mtip32xx.c:			dev_info(&pdev->dev, "CPU %d: WQs %s\n", cpu, cpu_list);
drivers/block/mtip32xx/mtip32xx.c:		dev_warn(&pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&pdev->dev,
drivers/block/mtip32xx/mtip32xx.c:		dev_err(&pdev->dev, "Unable to resume\n");
drivers/block/sx8.c:	rc = request_irq(pdev->irq, carm_interrupt, IRQF_SHARED, DRV_NAME, host);
drivers/block/sx8.c:		   pdev->irq, host->major);
drivers/block/sx8.c:	free_irq(pdev->irq, host);
drivers/block/sx8.c:	free_irq(pdev->irq, host);
drivers/block/cpqarray.c:			pdev->device, pdev->bus->number, PCI_SLOT(pdev->devfn),
drivers/block/cpqarray.c:			PCI_FUNC(pdev->devfn));
drivers/block/cpqarray.c:	vendor_id = pdev->vendor;
drivers/block/cpqarray.c:	device_id = pdev->device;
drivers/block/cpqarray.c:	revision  = pdev->revision;
drivers/block/cpqarray.c:	irq = pdev->irq;
drivers/xen/dbgp.c:		dbgp.u.pci.seg = pci_domain_nr(pdev->bus);
drivers/xen/dbgp.c:		dbgp.u.pci.bus = pdev->bus->number;
drivers/xen/dbgp.c:		dbgp.u.pci.devfn = pdev->devfn;
drivers/xen/xen-pciback/pciback_ops.c:				    pci_name(dev), pdev->xdev->otherend_id,
drivers/xen/xen-pciback/pciback_ops.c:				    pci_name(dev), pdev->xdev->otherend_id,
drivers/xen/xen-pciback/pciback_ops.c:	if (test_bit(_XEN_PCIF_active, (unsigned long *)&pdev->sh_info->flags)
drivers/xen/xen-pciback/pciback_ops.c:	    && !test_and_set_bit(_PDEVF_op_active, &pdev->flags)) {
drivers/xen/xen-pciback/pciback_ops.c:		queue_work(xen_pcibk_wq, &pdev->op_work);
drivers/xen/xen-pciback/pciback_ops.c:	if (!test_bit(_XEN_PCIB_active, (unsigned long *)&pdev->sh_info->flags)
drivers/xen/xen-pciback/pciback_ops.c:	    && test_bit(_PCIB_op_pending, &pdev->flags)) {
drivers/xen/xen-pciback/pciback_ops.c:	struct xen_pci_op *op = &pdev->sh_info->op;
drivers/xen/xen-pciback/pciback_ops.c:	clear_bit(_XEN_PCIF_active, (unsigned long *)&pdev->sh_info->flags);
drivers/xen/xen-pciback/pciback_ops.c:	notify_remote_via_irq(pdev->evtchn_irq);
drivers/xen/xen-pciback/pciback_ops.c:	clear_bit(_PDEVF_op_active, &pdev->flags);
drivers/xen/xen-pciback/pci_stub.c:		psdev->pdev->xdev->otherend_id);
drivers/xen/xen-pciback/pci_stub.c:	aer_op = &(psdev->pdev->sh_info->aer_op);
drivers/xen/xen-pciback/pci_stub.c:	set_bit(_PCIB_op_pending, (unsigned long *)&psdev->pdev->flags);
drivers/xen/xen-pciback/pci_stub.c:		(unsigned long *)&psdev->pdev->sh_info->flags);
drivers/xen/xen-pciback/pci_stub.c:	notify_remote_via_irq(psdev->pdev->evtchn_irq);
drivers/xen/xen-pciback/pci_stub.c:				 &psdev->pdev->sh_info->flags)), 300*HZ);
drivers/xen/xen-pciback/pci_stub.c:			(unsigned long *)&psdev->pdev->sh_info->flags)) {
drivers/xen/xen-pciback/pci_stub.c:			  (unsigned long *)&psdev->pdev->sh_info->flags);
drivers/xen/xen-pciback/pci_stub.c:	clear_bit(_PCIB_op_pending, (unsigned long *)&psdev->pdev->flags);
drivers/xen/xen-pciback/pci_stub.c:		(unsigned long *)&psdev->pdev->sh_info->flags)) {
drivers/xen/xen-pciback/pci_stub.c:	if (!psdev->pdev->sh_info) {
drivers/xen/xen-pciback/pci_stub.c:		(unsigned long *)&psdev->pdev->sh_info->flags)) {
drivers/xen/xen-pciback/pci_stub.c:	if (!psdev->pdev->sh_info) {
drivers/xen/xen-pciback/pci_stub.c:		(unsigned long *)&psdev->pdev->sh_info->flags)) {
drivers/xen/xen-pciback/pci_stub.c:	if (!psdev->pdev->sh_info) {
drivers/xen/xen-pciback/pci_stub.c:		(unsigned long *)&psdev->pdev->sh_info->flags)) {
drivers/xen/xen-pciback/pci_stub.c:	if (!psdev->pdev->sh_info) {
drivers/xen/xen-pciback/pci_stub.c:		(unsigned long *)&psdev->pdev->sh_info->flags)) {
drivers/xen/xen-pciback/pci_stub.c:				   quirk->pdev->bus->number,
drivers/xen/xen-pciback/pci_stub.c:				   PCI_SLOT(quirk->pdev->devfn),
drivers/xen/xen-pciback/pci_stub.c:				   PCI_FUNC(quirk->pdev->devfn),
drivers/xen/xen-pciback/passthrough.c:	struct passthrough_dev_data *dev_data = pdev->pci_dev_data;
drivers/xen/xen-pciback/passthrough.c:	struct passthrough_dev_data *dev_data = pdev->pci_dev_data;
drivers/xen/xen-pciback/passthrough.c:	struct passthrough_dev_data *dev_data = pdev->pci_dev_data;
drivers/xen/xen-pciback/passthrough.c:	pdev->pci_dev_data = dev_data;
drivers/xen/xen-pciback/passthrough.c:	struct passthrough_dev_data *dev_data = pdev->pci_dev_data;
drivers/xen/xen-pciback/passthrough.c:	struct passthrough_dev_data *dev_data = pdev->pci_dev_data;
drivers/xen/xen-pciback/passthrough.c:	pdev->pci_dev_data = NULL;
drivers/xen/xen-pciback/vpci.c:	struct vpci_dev_data *vpci_dev = pdev->pci_dev_data;
drivers/xen/xen-pciback/vpci.c:	struct vpci_dev_data *vpci_dev = pdev->pci_dev_data;
drivers/xen/xen-pciback/vpci.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/vpci.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/vpci.c:	xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/vpci.c:	struct vpci_dev_data *vpci_dev = pdev->pci_dev_data;
drivers/xen/xen-pciback/vpci.c:	pdev->pci_dev_data = vpci_dev;
drivers/xen/xen-pciback/vpci.c:	struct vpci_dev_data *vpci_dev = pdev->pci_dev_data;
drivers/xen/xen-pciback/vpci.c:	pdev->pci_dev_data = NULL;
drivers/xen/xen-pciback/vpci.c:	struct vpci_dev_data *vpci_dev = pdev->pci_dev_data;
drivers/xen/xen-pciback/xenbus.c:	pdev->xdev = xdev;
drivers/xen/xen-pciback/xenbus.c:	mutex_init(&pdev->dev_lock);
drivers/xen/xen-pciback/xenbus.c:	pdev->sh_info = NULL;
drivers/xen/xen-pciback/xenbus.c:	pdev->evtchn_irq = INVALID_EVTCHN_IRQ;
drivers/xen/xen-pciback/xenbus.c:	pdev->be_watching = 0;
drivers/xen/xen-pciback/xenbus.c:	INIT_WORK(&pdev->op_work, xen_pcibk_do_op);
drivers/xen/xen-pciback/xenbus.c:	mutex_lock(&pdev->dev_lock);
drivers/xen/xen-pciback/xenbus.c:	if (pdev->evtchn_irq != INVALID_EVTCHN_IRQ) {
drivers/xen/xen-pciback/xenbus.c:		unbind_from_irqhandler(pdev->evtchn_irq, pdev);
drivers/xen/xen-pciback/xenbus.c:		pdev->evtchn_irq = INVALID_EVTCHN_IRQ;
drivers/xen/xen-pciback/xenbus.c:	if (pdev->sh_info != NULL) {
drivers/xen/xen-pciback/xenbus.c:		xenbus_unmap_ring_vfree(pdev->xdev, pdev->sh_info);
drivers/xen/xen-pciback/xenbus.c:		pdev->sh_info = NULL;
drivers/xen/xen-pciback/xenbus.c:	mutex_unlock(&pdev->dev_lock);
drivers/xen/xen-pciback/xenbus.c:	if (pdev->be_watching) {
drivers/xen/xen-pciback/xenbus.c:		unregister_xenbus_watch(&pdev->be_watch);
drivers/xen/xen-pciback/xenbus.c:		pdev->be_watching = 0;
drivers/xen/xen-pciback/xenbus.c:	dev_set_drvdata(&pdev->xdev->dev, NULL);
drivers/xen/xen-pciback/xenbus.c:	pdev->xdev = NULL;
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&pdev->xdev->dev,
drivers/xen/xen-pciback/xenbus.c:	err = xenbus_map_ring_valloc(pdev->xdev, gnt_ref, &vaddr);
drivers/xen/xen-pciback/xenbus.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:	pdev->sh_info = vaddr;
drivers/xen/xen-pciback/xenbus.c:		pdev->xdev->otherend_id, remote_evtchn, xen_pcibk_handle_event,
drivers/xen/xen-pciback/xenbus.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:	pdev->evtchn_irq = err;
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&pdev->xdev->dev, "Attached!\n");
drivers/xen/xen-pciback/xenbus.c:	mutex_lock(&pdev->dev_lock);
drivers/xen/xen-pciback/xenbus.c:	if (xenbus_read_driver_state(pdev->xdev->nodename) !=
drivers/xen/xen-pciback/xenbus.c:	if (xenbus_read_driver_state(pdev->xdev->otherend) !=
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&pdev->xdev->dev, "Reading frontend config\n");
drivers/xen/xen-pciback/xenbus.c:	err = xenbus_gather(XBT_NIL, pdev->xdev->otherend,
drivers/xen/xen-pciback/xenbus.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:		xenbus_dev_fatal(pdev->xdev, -EFAULT,
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&pdev->xdev->dev, "Connecting...\n");
drivers/xen/xen-pciback/xenbus.c:	err = xenbus_switch_state(pdev->xdev, XenbusStateConnected);
drivers/xen/xen-pciback/xenbus.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&pdev->xdev->dev, "Connected? %d\n", err);
drivers/xen/xen-pciback/xenbus.c:	mutex_unlock(&pdev->dev_lock);
drivers/xen/xen-pciback/xenbus.c:	err = xenbus_printf(XBT_NIL, pdev->xdev->nodename, str,
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&pdev->xdev->dev, "exporting dom %x bus %x slot %x func %x\n",
drivers/xen/xen-pciback/xenbus.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&dev->dev, "registering for %d\n", pdev->xdev->otherend_id);
drivers/xen/xen-pciback/xenbus.c:					     pdev->xdev->otherend_id) != 0) {
drivers/xen/xen-pciback/xenbus.c:		xen_register_device_domain_owner(dev, pdev->xdev->otherend_id);
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&pdev->xdev->dev, "removing dom %x bus %x slot %x func %x\n",
drivers/xen/xen-pciback/xenbus.c:		dev_dbg(&pdev->xdev->dev, "Couldn't locate PCI device "
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&dev->dev, "unregistering for %d\n", pdev->xdev->otherend_id);
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&pdev->xdev->dev, "Publishing pci roots\n");
drivers/xen/xen-pciback/xenbus.c:	err = xenbus_scanf(XBT_NIL, pdev->xdev->nodename,
drivers/xen/xen-pciback/xenbus.c:		err = xenbus_scanf(XBT_NIL, pdev->xdev->nodename,
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&pdev->xdev->dev, "writing root %d at %04x:%02x\n",
drivers/xen/xen-pciback/xenbus.c:	err = xenbus_printf(XBT_NIL, pdev->xdev->nodename, str,
drivers/xen/xen-pciback/xenbus.c:	err = xenbus_printf(XBT_NIL, pdev->xdev->nodename,
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&pdev->xdev->dev, "Reconfiguring device ...\n");
drivers/xen/xen-pciback/xenbus.c:	mutex_lock(&pdev->dev_lock);
drivers/xen/xen-pciback/xenbus.c:	if (xenbus_read_driver_state(pdev->xdev->nodename) !=
drivers/xen/xen-pciback/xenbus.c:	err = xenbus_scanf(XBT_NIL, pdev->xdev->nodename, "num_devs", "%d",
drivers/xen/xen-pciback/xenbus.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:			xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:		err = xenbus_scanf(XBT_NIL, pdev->xdev->nodename, state_str,
drivers/xen/xen-pciback/xenbus.c:			dev_dbg(&pdev->xdev->dev, "Attaching dev-%d ...\n", i);
drivers/xen/xen-pciback/xenbus.c:				xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:			err = xenbus_scanf(XBT_NIL, pdev->xdev->nodename,
drivers/xen/xen-pciback/xenbus.c:				xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:				xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:				xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:			err = xenbus_printf(XBT_NIL, pdev->xdev->nodename,
drivers/xen/xen-pciback/xenbus.c:				xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:			dev_dbg(&pdev->xdev->dev, "Detaching dev-%d ...\n", i);
drivers/xen/xen-pciback/xenbus.c:				xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:			err = xenbus_scanf(XBT_NIL, pdev->xdev->nodename,
drivers/xen/xen-pciback/xenbus.c:				xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:				xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:	err = xenbus_switch_state(pdev->xdev, XenbusStateReconfigured);
drivers/xen/xen-pciback/xenbus.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:	mutex_unlock(&pdev->dev_lock);
drivers/xen/xen-pciback/xenbus.c:	mutex_lock(&pdev->dev_lock);
drivers/xen/xen-pciback/xenbus.c:	if (xenbus_read_driver_state(pdev->xdev->nodename) !=
drivers/xen/xen-pciback/xenbus.c:	dev_dbg(&pdev->xdev->dev, "getting be setup\n");
drivers/xen/xen-pciback/xenbus.c:	err = xenbus_scanf(XBT_NIL, pdev->xdev->nodename, "num_devs", "%d",
drivers/xen/xen-pciback/xenbus.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:			xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:		err = xenbus_scanf(XBT_NIL, pdev->xdev->nodename, dev_str,
drivers/xen/xen-pciback/xenbus.c:			xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:			xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:			xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:		err = xenbus_printf(XBT_NIL, pdev->xdev->nodename, state_str,
drivers/xen/xen-pciback/xenbus.c:			xenbus_dev_fatal(pdev->xdev, err, "Error switching "
drivers/xen/xen-pciback/xenbus.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:	err = xenbus_switch_state(pdev->xdev, XenbusStateInitialised);
drivers/xen/xen-pciback/xenbus.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/xen/xen-pciback/xenbus.c:	mutex_unlock(&pdev->dev_lock);
drivers/xen/xen-pciback/xenbus.c:	switch (xenbus_read_driver_state(pdev->xdev->nodename)) {
drivers/xen/xen-pciback/xenbus.c:	err = xenbus_watch_path(dev, dev->nodename, &pdev->be_watch,
drivers/xen/xen-pciback/xenbus.c:	pdev->be_watching = 1;
drivers/xen/xen-pciback/xenbus.c:	xen_pcibk_be_watch(&pdev->be_watch, NULL, 0);
drivers/xen/platform-pci.c:	irq = pdev->irq;
drivers/xen/platform-pci.c:	pin = pdev->pin;
drivers/xen/platform-pci.c:		((uint64_t)pci_domain_nr(pdev->bus) << 32) |
drivers/xen/platform-pci.c:		((uint64_t)pdev->bus->number << 16) |
drivers/xen/platform-pci.c:		((uint64_t)(pdev->devfn & 0xff) << 8) |
drivers/xen/platform-pci.c:	return request_irq(pdev->irq, do_hvm_evtchn_intr,
drivers/xen/platform-pci.c:		dev_err(&pdev->dev, "platform_pci_resume failure!\n");
drivers/xen/platform-pci.c:		dev_err(&pdev->dev, "no resources found\n");
drivers/xen/platform-pci.c:			dev_warn(&pdev->dev, "request_irq failed err=%d\n", ret);
drivers/xen/platform-pci.c:			dev_warn(&pdev->dev, "Unable to set the evtchn callback "
drivers/macintosh/macio_asic.c:	dev->ofdev.dev.archdata = chip->lbus.pdev->dev.archdata;
drivers/macintosh/macio_asic.c:		parent = &chip->lbus.pdev->dev;
drivers/macintosh/macio_asic.c:		root_res = &chip->lbus.pdev->resource[0];
drivers/macintosh/therm_adt746x.c:	dev = &th->pdev->dev;
drivers/macintosh/therm_adt746x.c:	dev = &th->pdev->dev;
drivers/hwmon/mc13783-adc.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
drivers/hwmon/mc13783-adc.c:	priv->mc13xxx = dev_get_drvdata(pdev->dev.parent);
drivers/hwmon/mc13783-adc.c:	ret = sysfs_create_group(&pdev->dev.kobj, &mc13783_group_base);
drivers/hwmon/mc13783-adc.c:		ret = sysfs_create_group(&pdev->dev.kobj,
drivers/hwmon/mc13783-adc.c:		ret = sysfs_create_group(&pdev->dev.kobj, &mc13783_group_ts);
drivers/hwmon/mc13783-adc.c:	priv->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/mc13783-adc.c:		dev_err(&pdev->dev,
drivers/hwmon/mc13783-adc.c:		sysfs_remove_group(&pdev->dev.kobj, &mc13783_group_ts);
drivers/hwmon/mc13783-adc.c:		sysfs_remove_group(&pdev->dev.kobj, &mc13783_group_16chans);
drivers/hwmon/mc13783-adc.c:	sysfs_remove_group(&pdev->dev.kobj, &mc13783_group_base);
drivers/hwmon/mc13783-adc.c:		sysfs_remove_group(&pdev->dev.kobj, &mc13783_group_ts);
drivers/hwmon/mc13783-adc.c:		sysfs_remove_group(&pdev->dev.kobj, &mc13783_group_16chans);
drivers/hwmon/mc13783-adc.c:	sysfs_remove_group(&pdev->dev.kobj, &mc13783_group_base);
drivers/hwmon/sis5595.c:	if (!devm_request_region(&pdev->dev, res->start, SIS5595_EXTENT,
drivers/hwmon/sis5595.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct sis5595_data),
drivers/hwmon/sis5595.c:	err = sysfs_create_group(&pdev->dev.kobj, &sis5595_group);
drivers/hwmon/sis5595.c:		err = sysfs_create_group(&pdev->dev.kobj, &sis5595_group_in4);
drivers/hwmon/sis5595.c:		err = sysfs_create_group(&pdev->dev.kobj, &sis5595_group_temp1);
drivers/hwmon/sis5595.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/sis5595.c:	sysfs_remove_group(&pdev->dev.kobj, &sis5595_group);
drivers/hwmon/sis5595.c:	sysfs_remove_group(&pdev->dev.kobj, &sis5595_group_in4);
drivers/hwmon/sis5595.c:	sysfs_remove_group(&pdev->dev.kobj, &sis5595_group_temp1);
drivers/hwmon/sis5595.c:	sysfs_remove_group(&pdev->dev.kobj, &sis5595_group);
drivers/hwmon/sis5595.c:	sysfs_remove_group(&pdev->dev.kobj, &sis5595_group_in4);
drivers/hwmon/sis5595.c:	sysfs_remove_group(&pdev->dev.kobj, &sis5595_group_temp1);
drivers/hwmon/k10temp.c:	pci_bus_read_config_dword(pdev->bus,
drivers/hwmon/k10temp.c:				  PCI_DEVFN(PCI_SLOT(pdev->devfn), 2),
drivers/hwmon/k10temp.c:		dev_err(&pdev->dev,
drivers/hwmon/k10temp.c:	err = device_create_file(&pdev->dev, &dev_attr_temp1_input);
drivers/hwmon/k10temp.c:	err = device_create_file(&pdev->dev, &dev_attr_temp1_max);
drivers/hwmon/k10temp.c:		err = device_create_file(&pdev->dev,
drivers/hwmon/k10temp.c:		err = device_create_file(&pdev->dev,
drivers/hwmon/k10temp.c:	err = device_create_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/k10temp.c:	hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/k10temp.c:		dev_warn(&pdev->dev,
drivers/hwmon/k10temp.c:	device_remove_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/k10temp.c:	device_remove_file(&pdev->dev, &dev_attr_temp1_input);
drivers/hwmon/k10temp.c:	device_remove_file(&pdev->dev, &dev_attr_temp1_max);
drivers/hwmon/k10temp.c:	device_remove_file(&pdev->dev,
drivers/hwmon/k10temp.c:	device_remove_file(&pdev->dev,
drivers/hwmon/k10temp.c:	device_remove_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/k10temp.c:	device_remove_file(&pdev->dev, &dev_attr_temp1_input);
drivers/hwmon/k10temp.c:	device_remove_file(&pdev->dev, &dev_attr_temp1_max);
drivers/hwmon/k10temp.c:	device_remove_file(&pdev->dev,
drivers/hwmon/k10temp.c:	device_remove_file(&pdev->dev,
drivers/hwmon/it87.c:	struct device *dev = &pdev->dev;
drivers/hwmon/it87.c:	if (!devm_request_region(&pdev->dev, res->start, IT87_EC_EXTENT,
drivers/hwmon/it87.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct it87_data), GFP_KERNEL);
drivers/hwmon/it87.c:	it87_remove_files(&pdev->dev);
drivers/hwmon/it87.c:	struct it87_sio_data *sio_data = pdev->dev.platform_data;
drivers/hwmon/it87.c:			dev_dbg(&pdev->dev,
drivers/hwmon/dme1737.c:	struct device *dev = &pdev->dev;
drivers/hwmon/dme1737.c:	dme1737_remove_files(&pdev->dev);
drivers/hwmon/i5k_amb.c:			res = device_create_file(&pdev->dev,
drivers/hwmon/i5k_amb.c:			res = device_create_file(&pdev->dev,
drivers/hwmon/i5k_amb.c:			res = device_create_file(&pdev->dev,
drivers/hwmon/i5k_amb.c:			res = device_create_file(&pdev->dev,
drivers/hwmon/i5k_amb.c:			res = device_create_file(&pdev->dev,
drivers/hwmon/i5k_amb.c:			res = device_create_file(&pdev->dev,
drivers/hwmon/i5k_amb.c:	res = device_create_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/i5k_amb.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/i5k_amb.c:	device_remove_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/i5k_amb.c:		device_remove_file(&pdev->dev, &data->attrs[i].s_attr.dev_attr);
drivers/hwmon/i5k_amb.c:	device_remove_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/i5k_amb.c:		device_remove_file(&pdev->dev, &data->attrs[i].s_attr.dev_attr);
drivers/hwmon/pc87360.c:		sysfs_remove_group(&pdev->dev.kobj, &pc8736x_fan_attr_group[i]);
drivers/hwmon/pc87360.c:	struct device *dev = &pdev->dev;
drivers/hwmon/pc87360.c:	pc87360_remove_files(&pdev->dev);
drivers/hwmon/pc87360.c:		dev_info(&pdev->dev,
drivers/hwmon/pc87360.c:		dev_dbg(&pdev->dev, "bios in%d status:0x%02x\n", i, reg);
drivers/hwmon/pc87360.c:				dev_dbg(&pdev->dev, "Forcibly enabling in%d\n",
drivers/hwmon/pc87360.c:	dev_dbg(&pdev->dev, "bios thermistors:%d\n", use_thermistors);
drivers/hwmon/pc87360.c:		dev_dbg(&pdev->dev, "bios temp%d_status:0x%02x\n", i-7, reg);
drivers/hwmon/pc87360.c:	dev_dbg(&pdev->dev, "using thermistors:%d\n", use_thermistors);
drivers/hwmon/pc87360.c:		dev_dbg(&pdev->dev, "bios temp%d_status:0x%02x\n", i + 1, reg);
drivers/hwmon/pc87360.c:				dev_dbg(&pdev->dev,
drivers/hwmon/pc87360.c:					dev_dbg(&pdev->dev,
drivers/hwmon/pc87360.c:					dev_dbg(&pdev->dev,
drivers/hwmon/pc87360.c:		dev_dbg(&pdev->dev, "bios vin-cfg:0x%02x\n", reg);
drivers/hwmon/pc87360.c:			dev_dbg(&pdev->dev,
drivers/hwmon/pc87360.c:		dev_dbg(&pdev->dev, "bios temp-cfg:0x%02x\n", reg);
drivers/hwmon/pc87360.c:			dev_dbg(&pdev->dev,
drivers/hwmon/w83627ehf.c:	struct device *dev = &pdev->dev;
drivers/hwmon/w83627ehf.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct w83627ehf_data),
drivers/hwmon/w83627ehf.c:	w83627ehf_device_remove_files(&pdev->dev);
drivers/hwmon/sch5627.c:	sysfs_remove_group(&pdev->dev.kobj, &sch5627_group);
drivers/hwmon/sch5627.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct sch5627_data),
drivers/hwmon/sch5627.c:	err = sysfs_create_group(&pdev->dev.kobj, &sch5627_group);
drivers/hwmon/sch5627.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/sch5627.c:	data->watchdog = sch56xx_watchdog_register(&pdev->dev, data->addr,
drivers/hwmon/applesmc.c:			sysfs_remove_file(&pdev->dev.kobj,
drivers/hwmon/applesmc.c:			ret = sysfs_create_file(&pdev->dev.kobj, attr);
drivers/hwmon/applesmc.c:	idev->dev.parent = &pdev->dev;
drivers/hwmon/applesmc.c:	return led_classdev_register(&pdev->dev, &applesmc_backlight);
drivers/hwmon/applesmc.c:	hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/twl4030-madc-hwmon.c:	ret = sysfs_create_group(&pdev->dev.kobj, &twl4030_madc_group);
drivers/hwmon/twl4030-madc-hwmon.c:	hwmon = hwmon_device_register(&pdev->dev);
drivers/hwmon/twl4030-madc-hwmon.c:		dev_err(&pdev->dev, "hwmon_device_register failed.\n");
drivers/hwmon/twl4030-madc-hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &twl4030_madc_group);
drivers/hwmon/twl4030-madc-hwmon.c:	hwmon_device_unregister(&pdev->dev);
drivers/hwmon/twl4030-madc-hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &twl4030_madc_group);
drivers/hwmon/ibmaem.c:	data->pdev->dev.driver = &aem_driver.driver;
drivers/hwmon/ibmaem.c:	data->hwmon_dev = hwmon_device_register(&data->pdev->dev);
drivers/hwmon/ibmaem.c:		dev_err(&data->pdev->dev,
drivers/hwmon/ibmaem.c:	data->pdev->dev.driver = &aem_driver.driver;
drivers/hwmon/ibmaem.c:	data->hwmon_dev = hwmon_device_register(&data->pdev->dev);
drivers/hwmon/ibmaem.c:		dev_err(&data->pdev->dev,
drivers/hwmon/ibmaem.c:	struct device *dev = &data->pdev->dev;
drivers/hwmon/ibmaem.c:		device_remove_file(&data->pdev->dev,
drivers/hwmon/ibmaem.c:	device_remove_file(&data->pdev->dev,
drivers/hwmon/ibmaem.c:	device_remove_file(&data->pdev->dev,
drivers/hwmon/sch5636.c:		device_remove_file(&pdev->dev, &sch5636_attr[i].dev_attr);
drivers/hwmon/sch5636.c:		device_remove_file(&pdev->dev,
drivers/hwmon/sch5636.c:		device_remove_file(&pdev->dev,
drivers/hwmon/sch5636.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct sch5636_data),
drivers/hwmon/sch5636.c:		err = device_create_file(&pdev->dev,
drivers/hwmon/sch5636.c:		err = device_create_file(&pdev->dev,
drivers/hwmon/sch5636.c:		err = device_create_file(&pdev->dev,
drivers/hwmon/sch5636.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/sch5636.c:	data->watchdog = sch56xx_watchdog_register(&pdev->dev, data->addr,
drivers/hwmon/vt8231.c:	if (!devm_request_region(&pdev->dev, res->start, VT8231_EXTENT,
drivers/hwmon/vt8231.c:		dev_err(&pdev->dev, "Region 0x%lx-0x%lx already in use!\n",
drivers/hwmon/vt8231.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct vt8231_data), GFP_KERNEL);
drivers/hwmon/vt8231.c:	err = sysfs_create_group(&pdev->dev.kobj, &vt8231_group);
drivers/hwmon/vt8231.c:			err = sysfs_create_group(&pdev->dev.kobj,
drivers/hwmon/vt8231.c:			err = sysfs_create_group(&pdev->dev.kobj,
drivers/hwmon/vt8231.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/vt8231.c:		sysfs_remove_group(&pdev->dev.kobj, &vt8231_group_volts[i]);
drivers/hwmon/vt8231.c:		sysfs_remove_group(&pdev->dev.kobj, &vt8231_group_temps[i]);
drivers/hwmon/vt8231.c:	sysfs_remove_group(&pdev->dev.kobj, &vt8231_group);
drivers/hwmon/vt8231.c:		sysfs_remove_group(&pdev->dev.kobj, &vt8231_group_volts[i]);
drivers/hwmon/vt8231.c:		sysfs_remove_group(&pdev->dev.kobj, &vt8231_group_temps[i]);
drivers/hwmon/vt8231.c:	sysfs_remove_group(&pdev->dev.kobj, &vt8231_group);
drivers/hwmon/coretemp.c:	tdata->tjmax = get_tjmax(c, cpu, &pdev->dev);
drivers/hwmon/coretemp.c:	err = create_core_attrs(tdata, &pdev->dev, attr_no);
drivers/hwmon/coretemp.c:		dev_err(&pdev->dev, "Adding Core %u failed\n", cpu);
drivers/hwmon/coretemp.c:	err = create_name_attr(pdata, &pdev->dev);
drivers/hwmon/coretemp.c:	pdata->phys_proc_id = pdev->id;
drivers/hwmon/coretemp.c:	pdata->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/coretemp.c:		dev_err(&pdev->dev, "Class registration failed (%d)\n", err);
drivers/hwmon/coretemp.c:	device_remove_file(&pdev->dev, &pdata->name_attr);
drivers/hwmon/coretemp.c:			coretemp_remove_core(pdata, &pdev->dev, i);
drivers/hwmon/coretemp.c:	device_remove_file(&pdev->dev, &pdata->name_attr);
drivers/hwmon/coretemp.c:	pdev_entry->phys_proc_id = pdev->id;
drivers/hwmon/coretemp.c:		coretemp_remove_core(pdata, &pdev->dev, indx);
drivers/hwmon/w83781d.c:	if (!devm_request_region(&pdev->dev,
drivers/hwmon/w83781d.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct w83781d_data),
drivers/hwmon/w83781d.c:	w83781d_init_device(&pdev->dev);
drivers/hwmon/w83781d.c:	err = w83781d_create_files(&pdev->dev, data->type, 1);
drivers/hwmon/w83781d.c:	err = device_create_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/w83781d.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/w83781d.c:	w83781d_remove_files(&pdev->dev);
drivers/hwmon/w83781d.c:	device_remove_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/w83781d.c:	w83781d_remove_files(&pdev->dev);
drivers/hwmon/w83781d.c:	device_remove_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/wm8350-hwmon.c:	ret = sysfs_create_group(&pdev->dev.kobj, &wm8350_attr_group);
drivers/hwmon/wm8350-hwmon.c:	wm8350->hwmon.classdev = hwmon_device_register(&pdev->dev);
drivers/hwmon/wm8350-hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &wm8350_attr_group);
drivers/hwmon/wm8350-hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &wm8350_attr_group);
drivers/hwmon/lm78.c:	if (!devm_request_region(&pdev->dev, res->start + LM78_ADDR_REG_OFFSET,
drivers/hwmon/lm78.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct lm78_data), GFP_KERNEL);
drivers/hwmon/lm78.c:	err = sysfs_create_group(&pdev->dev.kobj, &lm78_group);
drivers/hwmon/lm78.c:	err = device_create_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/lm78.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/lm78.c:	sysfs_remove_group(&pdev->dev.kobj, &lm78_group);
drivers/hwmon/lm78.c:	device_remove_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/lm78.c:	sysfs_remove_group(&pdev->dev.kobj, &lm78_group);
drivers/hwmon/lm78.c:	device_remove_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/via-cputemp.c:	struct cpuinfo_x86 *c = &cpu_data(pdev->id);
drivers/hwmon/via-cputemp.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct via_cputemp_data),
drivers/hwmon/via-cputemp.c:	data->id = pdev->id;
drivers/hwmon/via-cputemp.c:		dev_err(&pdev->dev,
drivers/hwmon/via-cputemp.c:	err = sysfs_create_group(&pdev->dev.kobj, &via_cputemp_group);
drivers/hwmon/via-cputemp.c:		err = device_create_file(&pdev->dev, &dev_attr_cpu0_vid);
drivers/hwmon/via-cputemp.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/via-cputemp.c:		dev_err(&pdev->dev, "Class registration failed (%d)\n",
drivers/hwmon/via-cputemp.c:		device_remove_file(&pdev->dev, &dev_attr_cpu0_vid);
drivers/hwmon/via-cputemp.c:	sysfs_remove_group(&pdev->dev.kobj, &via_cputemp_group);
drivers/hwmon/via-cputemp.c:		device_remove_file(&pdev->dev, &dev_attr_cpu0_vid);
drivers/hwmon/via-cputemp.c:	sysfs_remove_group(&pdev->dev.kobj, &via_cputemp_group);
drivers/hwmon/ntc_thermistor.c:	struct device_node *np = pdev->dev.of_node;
drivers/hwmon/ntc_thermistor.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/hwmon/ntc_thermistor.c:	chan = iio_channel_get(&pdev->dev, NULL);
drivers/hwmon/ntc_thermistor.c:			of_match_device(of_match_ptr(ntc_match), &pdev->dev);
drivers/hwmon/ntc_thermistor.c:		pdata = pdev->dev.platform_data;
drivers/hwmon/ntc_thermistor.c:		dev_err(&pdev->dev, "No platform init data supplied.\n");
drivers/hwmon/ntc_thermistor.c:		dev_err(&pdev->dev,
drivers/hwmon/ntc_thermistor.c:		dev_warn(&pdev->dev,
drivers/hwmon/ntc_thermistor.c:		dev_err(&pdev->dev,
drivers/hwmon/ntc_thermistor.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct ntc_data), GFP_KERNEL);
drivers/hwmon/ntc_thermistor.c:	data->dev = &pdev->dev;
drivers/hwmon/ntc_thermistor.c:		dev_err(&pdev->dev, "Unknown device type: %lu(%s)\n",
drivers/hwmon/ntc_thermistor.c:	dev_info(&pdev->dev, "Thermistor type: %s successfully probed.\n",
drivers/hwmon/ntc_thermistor.c:								pdev->name);
drivers/hwmon/sht15.c:	return sprintf(buf, "%s\n", pdev->name);
drivers/hwmon/sht15.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/hwmon/sht15.c:	data->dev = &pdev->dev;
drivers/hwmon/sht15.c:	if (pdev->dev.platform_data == NULL) {
drivers/hwmon/sht15.c:		dev_err(&pdev->dev, "no platform data supplied\n");
drivers/hwmon/sht15.c:	data->pdata = pdev->dev.platform_data;
drivers/hwmon/sht15.c:			dev_err(&pdev->dev,
drivers/hwmon/sht15.c:			dev_err(&pdev->dev,
drivers/hwmon/sht15.c:	ret = devm_gpio_request_one(&pdev->dev, data->pdata->gpio_sck,
drivers/hwmon/sht15.c:		dev_err(&pdev->dev, "clock line GPIO request failed\n");
drivers/hwmon/sht15.c:	ret = devm_gpio_request(&pdev->dev, data->pdata->gpio_data,
drivers/hwmon/sht15.c:		dev_err(&pdev->dev, "data line GPIO request failed\n");
drivers/hwmon/sht15.c:	ret = devm_request_irq(&pdev->dev, gpio_to_irq(data->pdata->gpio_data),
drivers/hwmon/sht15.c:		dev_err(&pdev->dev, "failed to get irq for data line\n");
drivers/hwmon/sht15.c:	ret = sysfs_create_group(&pdev->dev.kobj, &sht15_attr_group);
drivers/hwmon/sht15.c:		dev_err(&pdev->dev, "sysfs create failed\n");
drivers/hwmon/sht15.c:	sysfs_remove_group(&pdev->dev.kobj, &sht15_attr_group);
drivers/hwmon/sht15.c:	sysfs_remove_group(&pdev->dev.kobj, &sht15_attr_group);
drivers/hwmon/abx500.c:	dev_dbg(&data->pdev->dev, "No active thresholds.\n");
drivers/hwmon/abx500.c:			dev_err(&data->pdev->dev, "GPADC read failed\n");
drivers/hwmon/abx500.c:			sysfs_notify(&data->pdev->dev.kobj, NULL, alarm_node);
drivers/hwmon/abx500.c:			sysfs_notify(&data->pdev->dev.kobj, NULL, alarm_node);
drivers/hwmon/abx500.c:		dev_err(&pdev->dev, "Get irq by name failed\n");
drivers/hwmon/abx500.c:	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
drivers/hwmon/abx500.c:		dev_err(&pdev->dev, "Request threaded irq failed (%d)\n", ret);
drivers/hwmon/abx500.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/hwmon/abx500.c:	err = sysfs_create_group(&pdev->dev.kobj, &abx500_temp_group);
drivers/hwmon/abx500.c:		dev_err(&pdev->dev, "Create sysfs group failed (%d)\n", err);
drivers/hwmon/abx500.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/abx500.c:		dev_err(&pdev->dev, "Class registration failed (%d)\n", err);
drivers/hwmon/abx500.c:	sysfs_remove_group(&pdev->dev.kobj, &abx500_temp_group);
drivers/hwmon/abx500.c:	sysfs_remove_group(&pdev->dev.kobj, &abx500_temp_group);
drivers/hwmon/smsc47b397.c:	sysfs_remove_group(&pdev->dev.kobj, &smsc47b397_group);
drivers/hwmon/smsc47b397.c:	struct device *dev = &pdev->dev;
drivers/hwmon/ab8500.c:	dev_warn(&abx500_data->pdev->dev, "Power off due to critical temp\n");
drivers/hwmon/ab8500.c:	dev_warn(&data->pdev->dev, "Power off in %d s\n",
drivers/hwmon/ab8500.c:	ab8500_data = devm_kzalloc(&data->pdev->dev, sizeof(*ab8500_data),
drivers/hwmon/vexpress.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/hwmon/vexpress.c:	match = of_match_device(vexpress_hwmon_of_match, &pdev->dev);
drivers/hwmon/vexpress.c:	data->func = vexpress_config_func_get_by_dev(&pdev->dev);
drivers/hwmon/vexpress.c:	err = sysfs_create_group(&pdev->dev.kobj, match->data);
drivers/hwmon/vexpress.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/vexpress.c:	sysfs_remove_group(&pdev->dev.kobj, match->data);
drivers/hwmon/vexpress.c:	match = of_match_device(vexpress_hwmon_of_match, &pdev->dev);
drivers/hwmon/vexpress.c:	sysfs_remove_group(&pdev->dev.kobj, match->data);
drivers/hwmon/abituguru.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct abituguru_data),
drivers/hwmon/abituguru.c:		res = device_create_file(&pdev->dev,
drivers/hwmon/abituguru.c:		res = device_create_file(&pdev->dev,
drivers/hwmon/abituguru.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/abituguru.c:		device_remove_file(&pdev->dev, &data->sysfs_attr[i].dev_attr);
drivers/hwmon/abituguru.c:		device_remove_file(&pdev->dev,
drivers/hwmon/abituguru.c:		device_remove_file(&pdev->dev, &data->sysfs_attr[i].dev_attr);
drivers/hwmon/abituguru.c:		device_remove_file(&pdev->dev,
drivers/hwmon/gpio-fan.c:	sysfs_notify(&fan_data->pdev->dev.kobj, NULL, "fan1_alarm");
drivers/hwmon/gpio-fan.c:	kobject_uevent(&fan_data->pdev->dev.kobj, KOBJ_CHANGE);
drivers/hwmon/gpio-fan.c:	err = devm_gpio_request(&pdev->dev, alarm->gpio, "GPIO fan alarm");
drivers/hwmon/gpio-fan.c:	err = devm_request_irq(&pdev->dev, alarm_irq, fan_alarm_irq_handler,
drivers/hwmon/gpio-fan.c:	dev_warn(&fan_data->pdev->dev,
drivers/hwmon/gpio-fan.c:		err = devm_gpio_request(&pdev->dev, ctrl[i],
drivers/hwmon/gpio-fan.c:	struct gpio_fan_platform_data *pdata = pdev->dev.platform_data;
drivers/hwmon/gpio-fan.c:		pdata = devm_kzalloc(&pdev->dev,
drivers/hwmon/gpio-fan.c:		err = gpio_fan_get_of_pdata(&pdev->dev, pdata);
drivers/hwmon/gpio-fan.c:	fan_data = devm_kzalloc(&pdev->dev, sizeof(struct gpio_fan_data),
drivers/hwmon/gpio-fan.c:	err = sysfs_create_group(&pdev->dev.kobj, &gpio_fan_group);
drivers/hwmon/gpio-fan.c:	fan_data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/gpio-fan.c:	dev_info(&pdev->dev, "GPIO fan initialized\n");
drivers/hwmon/gpio-fan.c:	sysfs_remove_group(&pdev->dev.kobj, &gpio_fan_group);
drivers/hwmon/gpio-fan.c:	sysfs_remove_group(&pdev->dev.kobj, &gpio_fan_group);
drivers/hwmon/pc87427.c:			dev_err(&pdev->dev, "Missing resource #%d\n", i);
drivers/hwmon/pc87427.c:		if (!devm_request_region(&pdev->dev, res->start,
drivers/hwmon/pc87427.c:			dev_err(&pdev->dev,
drivers/hwmon/pc87427.c:	struct pc87427_sio_data *sio_data = pdev->dev.platform_data;
drivers/hwmon/pc87427.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct pc87427_data),
drivers/hwmon/pc87427.c:	pc87427_init_device(&pdev->dev);
drivers/hwmon/pc87427.c:	err = device_create_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/pc87427.c:		err = sysfs_create_group(&pdev->dev.kobj,
drivers/hwmon/pc87427.c:		err = sysfs_create_group(&pdev->dev.kobj,
drivers/hwmon/pc87427.c:		err = sysfs_create_group(&pdev->dev.kobj,
drivers/hwmon/pc87427.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/pc87427.c:		dev_err(&pdev->dev, "Class registration failed (%d)\n", err);
drivers/hwmon/pc87427.c:	pc87427_remove_files(&pdev->dev);
drivers/hwmon/pc87427.c:	pc87427_remove_files(&pdev->dev);
drivers/hwmon/da9055-hwmon.c:	hwmon = devm_kzalloc(&pdev->dev, sizeof(struct da9055_hwmon),
drivers/hwmon/da9055-hwmon.c:	hwmon->da9055 = dev_get_drvdata(pdev->dev.parent);
drivers/hwmon/da9055-hwmon.c:	ret = devm_request_threaded_irq(&pdev->dev, hwmon_irq,
drivers/hwmon/da9055-hwmon.c:	ret = sysfs_create_group(&pdev->dev.kobj, &da9055_attr_group);
drivers/hwmon/da9055-hwmon.c:	hwmon->class_device = hwmon_device_register(&pdev->dev);
drivers/hwmon/da9055-hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &da9055_attr_group);
drivers/hwmon/da9055-hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &da9055_attr_group);
drivers/hwmon/sch56xx-common.c:	res.name = sch56xx_pdev->name;
drivers/hwmon/w83627hf.c:	struct device *dev = &pdev->dev;
drivers/hwmon/w83627hf.c:	sysfs_remove_group(&pdev->dev.kobj, &w83627hf_group);
drivers/hwmon/w83627hf.c:	sysfs_remove_group(&pdev->dev.kobj, &w83627hf_group_opt);
drivers/hwmon/w83627hf.c:	struct w83627hf_sio_data *sio_data = pdev->dev.platform_data;
drivers/hwmon/w83627hf.c:		dev_dbg(&pdev->dev, "GPIO5 disabled, no VID function\n");
drivers/hwmon/w83627hf.c:		dev_dbg(&pdev->dev, "GPIO5 not configured for VID "
drivers/hwmon/w83627hf.c:	dev_info(&pdev->dev, "Reading VID from GPIO5\n");
drivers/hwmon/w83627hf.c:	struct w83627hf_sio_data *sio_data = pdev->dev.platform_data;
drivers/hwmon/w83627hf.c:		dev_dbg(&pdev->dev, "VID disabled, no VID function\n");
drivers/hwmon/w83627hf.c:		dev_dbg(&pdev->dev, "VID configured as output, "
drivers/hwmon/w83627hf.c:			dev_warn(&pdev->dev, "Enabling temp2, readings "
drivers/hwmon/w83627hf.c:				dev_warn(&pdev->dev, "Enabling temp3, "
drivers/hwmon/abituguru3.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct abituguru3_data),
drivers/hwmon/abituguru3.c:	if (!abituguru3_update_device(&pdev->dev))
drivers/hwmon/abituguru3.c:		if (device_create_file(&pdev->dev,
drivers/hwmon/abituguru3.c:		if (device_create_file(&pdev->dev,
drivers/hwmon/abituguru3.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/abituguru3.c:		device_remove_file(&pdev->dev, &data->sysfs_attr[i].dev_attr);
drivers/hwmon/abituguru3.c:		device_remove_file(&pdev->dev,
drivers/hwmon/abituguru3.c:		device_remove_file(&pdev->dev, &data->sysfs_attr[i].dev_attr);
drivers/hwmon/abituguru3.c:		device_remove_file(&pdev->dev,
drivers/hwmon/via686a.c:	if (!devm_request_region(&pdev->dev, res->start, VIA686A_EXTENT,
drivers/hwmon/via686a.c:		dev_err(&pdev->dev, "Region 0x%lx-0x%lx already in use!\n",
drivers/hwmon/via686a.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct via686a_data),
drivers/hwmon/via686a.c:	err = sysfs_create_group(&pdev->dev.kobj, &via686a_group);
drivers/hwmon/via686a.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/via686a.c:	sysfs_remove_group(&pdev->dev.kobj, &via686a_group);
drivers/hwmon/via686a.c:	sysfs_remove_group(&pdev->dev.kobj, &via686a_group);
drivers/hwmon/f71882fg.c:		err = device_create_file(&pdev->dev, &attr[i].dev_attr);
drivers/hwmon/f71882fg.c:		device_remove_file(&pdev->dev, &attr[i].dev_attr);
drivers/hwmon/f71882fg.c:		dev_err(&pdev->dev,
drivers/hwmon/f71882fg.c:	dev_info(&pdev->dev, "Fan: %d is in %s mode\n", idx + 1,
drivers/hwmon/f71882fg.c:			dev_warn(&pdev->dev,
drivers/hwmon/f71882fg.c:	struct f71882fg_sio_data *sio_data = pdev->dev.platform_data;
drivers/hwmon/f71882fg.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct f71882fg_data),
drivers/hwmon/f71882fg.c:		dev_warn(&pdev->dev, "Hardware monitor is powered down\n");
drivers/hwmon/f71882fg.c:		dev_warn(&pdev->dev, "Hardware monitoring not activated\n");
drivers/hwmon/f71882fg.c:	err = device_create_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/f71882fg.c:				err = device_create_file(&pdev->dev,
drivers/hwmon/f71882fg.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/f71882fg.c:	device_remove_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/f71882fg.c:				device_remove_file(&pdev->dev,
drivers/hwmon/f71882fg.c:	res.name = f71882fg_pdev->name;
drivers/hwmon/da9052-hwmon.c:	hwmon = devm_kzalloc(&pdev->dev, sizeof(struct da9052_hwmon),
drivers/hwmon/da9052-hwmon.c:	hwmon->da9052 = dev_get_drvdata(pdev->dev.parent);
drivers/hwmon/da9052-hwmon.c:	ret = sysfs_create_group(&pdev->dev.kobj, &da9052_attr_group);
drivers/hwmon/da9052-hwmon.c:	hwmon->class_device = hwmon_device_register(&pdev->dev);
drivers/hwmon/da9052-hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &da9052_attr_group);
drivers/hwmon/da9052-hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &da9052_attr_group);
drivers/hwmon/max197.c:	return sprintf(buf, "%s\n", pdev->name);
drivers/hwmon/max197.c:	struct max197_platform_data *pdata = pdev->dev.platform_data;
drivers/hwmon/max197.c:		dev_err(&pdev->dev, "no platform data supplied\n");
drivers/hwmon/max197.c:		dev_err(&pdev->dev, "no convert function supplied\n");
drivers/hwmon/max197.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct max197_data), GFP_KERNEL);
drivers/hwmon/max197.c:		dev_err(&pdev->dev, "devm_kzalloc failed\n");
drivers/hwmon/max197.c:	ret = sysfs_create_group(&pdev->dev.kobj, &max197_sysfs_group);
drivers/hwmon/max197.c:		dev_err(&pdev->dev, "sysfs create group failed\n");
drivers/hwmon/max197.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/max197.c:		dev_err(&pdev->dev, "hwmon device register failed\n");
drivers/hwmon/max197.c:	sysfs_remove_group(&pdev->dev.kobj, &max197_sysfs_group);
drivers/hwmon/max197.c:	sysfs_remove_group(&pdev->dev.kobj, &max197_sysfs_group);
drivers/hwmon/wm831x-hwmon.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/hwmon/wm831x-hwmon.c:	hwmon = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_hwmon),
drivers/hwmon/wm831x-hwmon.c:	ret = sysfs_create_group(&pdev->dev.kobj, &wm831x_attr_group);
drivers/hwmon/wm831x-hwmon.c:	hwmon->classdev = hwmon_device_register(&pdev->dev);
drivers/hwmon/wm831x-hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &wm831x_attr_group);
drivers/hwmon/wm831x-hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &wm831x_attr_group);
drivers/hwmon/k8temp.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct k8temp_data), GFP_KERNEL);
drivers/hwmon/k8temp.c:		dev_warn(&pdev->dev,
drivers/hwmon/k8temp.c:		dev_err(&pdev->dev, "Configuration bit(s) stuck at 1!\n");
drivers/hwmon/k8temp.c:	err = device_create_file(&pdev->dev,
drivers/hwmon/k8temp.c:		err = device_create_file(&pdev->dev,
drivers/hwmon/k8temp.c:		err = device_create_file(&pdev->dev,
drivers/hwmon/k8temp.c:			err = device_create_file(&pdev->dev,
drivers/hwmon/k8temp.c:	err = device_create_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/k8temp.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/k8temp.c:	device_remove_file(&pdev->dev,
drivers/hwmon/k8temp.c:	device_remove_file(&pdev->dev,
drivers/hwmon/k8temp.c:	device_remove_file(&pdev->dev,
drivers/hwmon/k8temp.c:	device_remove_file(&pdev->dev,
drivers/hwmon/k8temp.c:	device_remove_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/k8temp.c:	device_remove_file(&pdev->dev,
drivers/hwmon/k8temp.c:	device_remove_file(&pdev->dev,
drivers/hwmon/k8temp.c:	device_remove_file(&pdev->dev,
drivers/hwmon/k8temp.c:	device_remove_file(&pdev->dev,
drivers/hwmon/k8temp.c:	device_remove_file(&pdev->dev, &dev_attr_name);
drivers/hwmon/f71805f.c:	struct f71805f_sio_data *sio_data = pdev->dev.platform_data;
drivers/hwmon/f71805f.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct f71805f_data),
drivers/hwmon/f71805f.c:	if (!devm_request_region(&pdev->dev, res->start + ADDR_REG_OFFSET, 2,
drivers/hwmon/f71805f.c:		dev_err(&pdev->dev, "Failed to request region 0x%lx-0x%lx\n",
drivers/hwmon/f71805f.c:	err = sysfs_create_group(&pdev->dev.kobj, &f71805f_group);
drivers/hwmon/f71805f.c:		err = sysfs_create_group(&pdev->dev.kobj,
drivers/hwmon/f71805f.c:		err = sysfs_create_group(&pdev->dev.kobj,
drivers/hwmon/f71805f.c:		err = sysfs_create_group(&pdev->dev.kobj,
drivers/hwmon/f71805f.c:		err = sysfs_create_group(&pdev->dev.kobj,
drivers/hwmon/f71805f.c:			err = sysfs_create_file(&pdev->dev.kobj,
drivers/hwmon/f71805f.c:			err = sysfs_chmod_file(&pdev->dev.kobj,
drivers/hwmon/f71805f.c:				dev_err(&pdev->dev, "chmod +w pwm%d failed\n",
drivers/hwmon/f71805f.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/hwmon/f71805f.c:		dev_err(&pdev->dev, "Class registration failed (%d)\n", err);
drivers/hwmon/f71805f.c:	sysfs_remove_group(&pdev->dev.kobj, &f71805f_group);
drivers/hwmon/f71805f.c:		sysfs_remove_group(&pdev->dev.kobj, &f71805f_group_optin[i]);
drivers/hwmon/f71805f.c:	sysfs_remove_group(&pdev->dev.kobj, &f71805f_group_pwm_freq);
drivers/hwmon/f71805f.c:	sysfs_remove_group(&pdev->dev.kobj, &f71805f_group);
drivers/hwmon/f71805f.c:		sysfs_remove_group(&pdev->dev.kobj, &f71805f_group_optin[i]);
drivers/hwmon/f71805f.c:	sysfs_remove_group(&pdev->dev.kobj, &f71805f_group_pwm_freq);
drivers/hwmon/f71805f.c:	res.name = pdev->name;
drivers/hwmon/jz4740-hwmon.c:	hwmon = devm_kzalloc(&pdev->dev, sizeof(*hwmon), GFP_KERNEL);
drivers/hwmon/jz4740-hwmon.c:		dev_err(&pdev->dev, "Failed to get platform irq: %d\n",
drivers/hwmon/jz4740-hwmon.c:		dev_err(&pdev->dev, "Failed to get platform mmio resource\n");
drivers/hwmon/jz4740-hwmon.c:	hwmon->mem = devm_request_mem_region(&pdev->dev, hwmon->mem->start,
drivers/hwmon/jz4740-hwmon.c:			resource_size(hwmon->mem), pdev->name);
drivers/hwmon/jz4740-hwmon.c:		dev_err(&pdev->dev, "Failed to request mmio memory region\n");
drivers/hwmon/jz4740-hwmon.c:	hwmon->base = devm_ioremap_nocache(&pdev->dev, hwmon->mem->start,
drivers/hwmon/jz4740-hwmon.c:		dev_err(&pdev->dev, "Failed to ioremap mmio memory\n");
drivers/hwmon/jz4740-hwmon.c:	ret = devm_request_irq(&pdev->dev, hwmon->irq, jz4740_hwmon_irq, 0,
drivers/hwmon/jz4740-hwmon.c:			       pdev->name, hwmon);
drivers/hwmon/jz4740-hwmon.c:		dev_err(&pdev->dev, "Failed to request irq: %d\n", ret);
drivers/hwmon/jz4740-hwmon.c:	ret = sysfs_create_group(&pdev->dev.kobj, &jz4740_hwmon_attr_group);
drivers/hwmon/jz4740-hwmon.c:		dev_err(&pdev->dev, "Failed to create sysfs group: %d\n", ret);
drivers/hwmon/jz4740-hwmon.c:	hwmon->hwmon = hwmon_device_register(&pdev->dev);
drivers/hwmon/jz4740-hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &jz4740_hwmon_attr_group);
drivers/hwmon/jz4740-hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &jz4740_hwmon_attr_group);
drivers/hwmon/smsc47m1.c:	struct device *dev = &pdev->dev;
drivers/hwmon/smsc47m1.c:	smsc47m1_remove_files(&pdev->dev);
drivers/hwmon/smsc47m1.c:	smsc47m1_restore(pdev->dev.platform_data);
drivers/hwmon/nct6775.c:	struct device *dev = &pdev->dev;
drivers/hwmon/nct6775.c:	if (!devm_request_region(&pdev->dev, res->start, IOREGION_LENGTH,
drivers/hwmon/nct6775.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct nct6775_data),
drivers/hwmon/nct6775.c:		dev_info(&pdev->dev, "Enabled fan debounce for chip %s\n",
drivers/hwmon/nct6775.c:	nct6775_device_remove_files(&pdev->dev);
drivers/hwmon/vt1211.c:	struct device *dev = &pdev->dev;
drivers/hwmon/vt1211.c:	struct device *dev = &pdev->dev;
drivers/hwmon/vt1211.c:	res.name = pdev->name;
drivers/hwmon/iio_hwmon.c:	struct device *dev = &pdev->dev;
drivers/hwmon/iio_hwmon.c:	sysfs_remove_group(&pdev->dev.kobj, &st->attr_group);
drivers/hwmon/fam15h_power.c:	pci_bus_read_config_dword(pdev->bus,
drivers/hwmon/fam15h_power.c:		PCI_DEVFN(PCI_SLOT(pdev->devfn), 5),
drivers/hwmon/fam15h_power.c:	pci_bus_write_config_dword(pdev->bus,
drivers/hwmon/fam15h_power.c:		PCI_DEVFN(PCI_SLOT(pdev->devfn), 5),
drivers/hwmon/fam15h_power.c:	struct device *dev = &pdev->dev;
drivers/hwmon/fam15h_power.c:	dev = &pdev->dev;
drivers/rpmsg/virtio_rpmsg_bus.c:	return sprintf(buf, format_string, rpdev->path);		\
drivers/rpmsg/virtio_rpmsg_bus.c:	return sprintf(buf, RPMSG_DEVICE_MODALIAS_FMT "\n", rpdev->id.name);
drivers/rpmsg/virtio_rpmsg_bus.c:	return strncmp(id->name, rpdev->id.name, RPMSG_NAME_SIZE) == 0;
drivers/rpmsg/virtio_rpmsg_bus.c:					rpdev->id.name);
drivers/rpmsg/virtio_rpmsg_bus.c:	struct device *dev = rpdev ? &rpdev->dev : &vrp->vdev->dev;
drivers/rpmsg/virtio_rpmsg_bus.c:	return __rpmsg_create_ept(rpdev->vrp, rpdev, cb, priv, addr);
drivers/rpmsg/virtio_rpmsg_bus.c:	__rpmsg_destroy_ept(ept->rpdev->vrp, ept);
drivers/rpmsg/virtio_rpmsg_bus.c:	struct rpmsg_driver *rpdrv = to_rpmsg_driver(rpdev->dev.driver);
drivers/rpmsg/virtio_rpmsg_bus.c:	struct virtproc_info *vrp = rpdev->vrp;
drivers/rpmsg/virtio_rpmsg_bus.c:	ept = rpmsg_create_ept(rpdev, rpdrv->callback, NULL, rpdev->src);
drivers/rpmsg/virtio_rpmsg_bus.c:	rpdev->ept = ept;
drivers/rpmsg/virtio_rpmsg_bus.c:	rpdev->src = ept->addr;
drivers/rpmsg/virtio_rpmsg_bus.c:	if (rpdev->announce &&
drivers/rpmsg/virtio_rpmsg_bus.c:		strncpy(nsm.name, rpdev->id.name, RPMSG_NAME_SIZE);
drivers/rpmsg/virtio_rpmsg_bus.c:		nsm.addr = rpdev->src;
drivers/rpmsg/virtio_rpmsg_bus.c:	struct rpmsg_driver *rpdrv = to_rpmsg_driver(rpdev->dev.driver);
drivers/rpmsg/virtio_rpmsg_bus.c:	struct virtproc_info *vrp = rpdev->vrp;
drivers/rpmsg/virtio_rpmsg_bus.c:	if (rpdev->announce &&
drivers/rpmsg/virtio_rpmsg_bus.c:		strncpy(nsm.name, rpdev->id.name, RPMSG_NAME_SIZE);
drivers/rpmsg/virtio_rpmsg_bus.c:		nsm.addr = rpdev->src;
drivers/rpmsg/virtio_rpmsg_bus.c:	rpmsg_destroy_ept(rpdev->ept);
drivers/rpmsg/virtio_rpmsg_bus.c:	if (chinfo->src != RPMSG_ADDR_ANY && chinfo->src != rpdev->src)
drivers/rpmsg/virtio_rpmsg_bus.c:	if (chinfo->dst != RPMSG_ADDR_ANY && chinfo->dst != rpdev->dst)
drivers/rpmsg/virtio_rpmsg_bus.c:	if (strncmp(chinfo->name, rpdev->id.name, RPMSG_NAME_SIZE))
drivers/rpmsg/virtio_rpmsg_bus.c:	rpdev->vrp = vrp;
drivers/rpmsg/virtio_rpmsg_bus.c:	rpdev->src = chinfo->src;
drivers/rpmsg/virtio_rpmsg_bus.c:	rpdev->dst = chinfo->dst;
drivers/rpmsg/virtio_rpmsg_bus.c:	rpdev->announce = rpdev->src != RPMSG_ADDR_ANY ? true : false;
drivers/rpmsg/virtio_rpmsg_bus.c:	strncpy(rpdev->id.name, chinfo->name, RPMSG_NAME_SIZE);
drivers/rpmsg/virtio_rpmsg_bus.c:	dev_set_name(&rpdev->dev, "rpmsg%d", rpmsg_dev_index++);
drivers/rpmsg/virtio_rpmsg_bus.c:	rpdev->dev.parent = &vrp->vdev->dev;
drivers/rpmsg/virtio_rpmsg_bus.c:	rpdev->dev.bus = &rpmsg_bus;
drivers/rpmsg/virtio_rpmsg_bus.c:	rpdev->dev.release = rpmsg_release_device;
drivers/rpmsg/virtio_rpmsg_bus.c:	ret = device_register(&rpdev->dev);
drivers/rpmsg/virtio_rpmsg_bus.c:		put_device(&rpdev->dev);
drivers/rpmsg/virtio_rpmsg_bus.c:	struct virtproc_info *vrp = rpdev->vrp;
drivers/rpmsg/virtio_rpmsg_bus.c:	struct device *dev = &rpdev->dev;
drivers/infiniband/hw/qib/qib_iba6120.c:	dd->cspec->irq = pdev->irq; /* save IRQ */
drivers/infiniband/hw/qib/qib_init.c:		qib_early_err(&pdev->dev,
drivers/infiniband/hw/qib/qib_init.c:			qib_early_err(&pdev->dev,
drivers/infiniband/hw/qib/qib_init.c:		qib_early_err(&pdev->dev,
drivers/infiniband/hw/qib/qib_init.c:		qib_early_err(&pdev->dev,
drivers/infiniband/hw/qib/qib_iba7220.c:	dd->cspec->irq = pdev->irq;
drivers/infiniband/hw/qib/qib_pcie.c:		qib_early_err(&pdev->dev, "pci enable failed: error %d\n",
drivers/infiniband/hw/qib/qib_pcie.c:		qib_early_err(&pdev->dev,
drivers/infiniband/hw/qib/qib_pcie.c:		qib_early_err(&pdev->dev,
drivers/infiniband/hw/cxgb3/cxio_hal.c:	cq->queue = dma_alloc_coherent(&(rdev_p->rnic_info.pdev->dev), size,
drivers/infiniband/hw/cxgb3/cxio_hal.c:	wq->queue = dma_alloc_coherent(&(rdev_p->rnic_info.pdev->dev),
drivers/infiniband/hw/cxgb3/cxio_hal.c:	dma_free_coherent(&(rdev_p->rnic_info.pdev->dev),
drivers/infiniband/hw/cxgb3/cxio_hal.c:	dma_free_coherent(&(rdev_p->rnic_info.pdev->dev),
drivers/infiniband/hw/cxgb3/cxio_hal.c:					&(rdev_p->rnic_info.pdev->dev),
drivers/infiniband/hw/cxgb3/cxio_hal.c:	dma_free_coherent(&(rdev_p->rnic_info.pdev->dev),
drivers/infiniband/hw/cxgb3/iwch_provider.c:	props->vendor_id = (u32)dev->rdev.rnic_info.pdev->vendor;
drivers/infiniband/hw/cxgb3/iwch_provider.c:	props->vendor_part_id = (u32)dev->rdev.rnic_info.pdev->device;
drivers/infiniband/hw/cxgb3/iwch_provider.c:	return sprintf(buf, "%x.%x\n", iwch_dev->rdev.rnic_info.pdev->vendor,
drivers/infiniband/hw/cxgb3/iwch_provider.c:		       iwch_dev->rdev.rnic_info.pdev->device);
drivers/infiniband/hw/cxgb3/iwch_provider.c:	dev->ibdev.dma_device = &(dev->rdev.rnic_info.pdev->dev);
drivers/infiniband/hw/ocrdma/ocrdma_verbs.c:	attr->vendor_id = dev->nic_info.pdev->vendor;
drivers/infiniband/hw/ocrdma/ocrdma_verbs.c:	attr->vendor_part_id = dev->nic_info.pdev->device;
drivers/infiniband/hw/ocrdma/ocrdma_verbs.c:	ctx->ah_tbl.va = dma_alloc_coherent(&pdev->dev, map_len,
drivers/infiniband/hw/ocrdma/ocrdma_verbs.c:	dma_free_coherent(&pdev->dev, ctx->ah_tbl.len, ctx->ah_tbl.va,
drivers/infiniband/hw/ocrdma/ocrdma_verbs.c:	dma_free_coherent(&pdev->dev, uctx->ah_tbl.len, uctx->ah_tbl.va,
drivers/infiniband/hw/ocrdma/ocrdma_verbs.c:			dma_free_coherent(&pdev->dev, mr->pbl_size,
drivers/infiniband/hw/ocrdma/ocrdma_verbs.c:		va = dma_alloc_coherent(&pdev->dev, dma_len, &pa, GFP_KERNEL);
drivers/infiniband/hw/ocrdma/ocrdma_main.c:	dev->ibdev.dma_device = &dev->nic_info.pdev->dev;
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	dma_free_coherent(&dev->nic_info.pdev->dev, q->size, q->va, q->dma);
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	q->va = dma_alloc_coherent(&dev->nic_info.pdev->dev, q->size,
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:		irq = dev->nic_info.pdev->irq;
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	dev->av_tbl.pbl.va = dma_alloc_coherent(&pdev->dev, PAGE_SIZE,
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	dev->av_tbl.va = dma_alloc_coherent(&pdev->dev, dev->av_tbl.size,
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	dma_free_coherent(&pdev->dev, dev->av_tbl.size, dev->av_tbl.va,
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	dma_free_coherent(&pdev->dev, PAGE_SIZE, dev->av_tbl.pbl.va,
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	dma_free_coherent(&pdev->dev, dev->av_tbl.size, dev->av_tbl.va,
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	dma_free_coherent(&pdev->dev, PAGE_SIZE, dev->av_tbl.pbl.va,
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	cq->va = dma_alloc_coherent(&pdev->dev, cq->len, &cq->pa, GFP_KERNEL);
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	dma_free_coherent(&pdev->dev, cq->len, cq->va, cq->pa);
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	dma_free_coherent(&dev->nic_info.pdev->dev, cq->len, cq->va, cq->pa);
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	qp->sq.va = dma_alloc_coherent(&pdev->dev, len, &pa, GFP_KERNEL);
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	qp->rq.va = dma_alloc_coherent(&pdev->dev, len, &pa, GFP_KERNEL);
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	qp->ird_q_va = dma_alloc_coherent(&pdev->dev, ird_q_len,
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:		dma_free_coherent(&pdev->dev, qp->rq.len, qp->rq.va, qp->rq.pa);
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	dma_free_coherent(&pdev->dev, qp->sq.len, qp->sq.va, qp->sq.pa);
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:		dma_free_coherent(&pdev->dev, qp->sq.len, qp->sq.va, qp->sq.pa);
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:		dma_free_coherent(&pdev->dev, qp->rq.len, qp->rq.va, qp->rq.pa);
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	srq->rq.va = dma_alloc_coherent(&pdev->dev, len, &pa, GFP_KERNEL);
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:	dma_free_coherent(&pdev->dev, srq->rq.len, srq->rq.va, pa);
drivers/infiniband/hw/ocrdma/ocrdma_hw.c:		dma_free_coherent(&pdev->dev, srq->rq.len,
drivers/infiniband/hw/cxgb4/cm.c:	flowc->mnemval[0].val = cpu_to_be32(PCI_FUNC(ep->com.dev->rdev.lldi.pdev->devfn) << 8);
drivers/infiniband/hw/cxgb4/cm.c:		ep->mtu = pdev->mtu;
drivers/infiniband/hw/cxgb4/cm.c:		ep->mtu = pdev->mtu;
drivers/infiniband/hw/cxgb4/qp.c:	dma_free_coherent(&(rdev->lldi.pdev->dev), sq->memsize, sq->queue,
drivers/infiniband/hw/cxgb4/qp.c:	sq->queue = dma_alloc_coherent(&(rdev->lldi.pdev->dev), sq->memsize,
drivers/infiniband/hw/cxgb4/qp.c:	dma_free_coherent(&(rdev->lldi.pdev->dev),
drivers/infiniband/hw/cxgb4/qp.c:	wq->rq.queue = dma_alloc_coherent(&(rdev->lldi.pdev->dev),
drivers/infiniband/hw/cxgb4/qp.c:	dma_free_coherent(&(rdev->lldi.pdev->dev),
drivers/infiniband/hw/cxgb4/mem.c:	daddr = dma_map_single(&rdev->lldi.pdev->dev, data, len, DMA_TO_DEVICE);
drivers/infiniband/hw/cxgb4/mem.c:	if (dma_mapping_error(&rdev->lldi.pdev->dev, daddr))
drivers/infiniband/hw/cxgb4/mem.c:	dma_unmap_single(&rdev->lldi.pdev->dev, save, len, DMA_TO_DEVICE);
drivers/infiniband/hw/cxgb4/mem.c:	c4pl->ibpl.page_list = dma_alloc_coherent(&dev->rdev.lldi.pdev->dev,
drivers/infiniband/hw/cxgb4/mem.c:	dma_free_coherent(&c4pl->dev->rdev.lldi.pdev->dev,
drivers/infiniband/hw/cxgb4/cq.c:	dma_free_coherent(&(rdev->lldi.pdev->dev),
drivers/infiniband/hw/cxgb4/cq.c:	cq->queue = dma_alloc_coherent(&rdev->lldi.pdev->dev, cq->memsize,
drivers/infiniband/hw/cxgb4/cq.c:	dma_free_coherent(&rdev->lldi.pdev->dev, cq->memsize, cq->queue,
drivers/infiniband/hw/cxgb4/provider.c:	props->vendor_id = (u32)dev->rdev.lldi.pdev->vendor;
drivers/infiniband/hw/cxgb4/provider.c:	props->vendor_part_id = (u32)dev->rdev.lldi.pdev->device;
drivers/infiniband/hw/cxgb4/provider.c:	return sprintf(buf, "%x.%x\n", c4iw_dev->rdev.lldi.pdev->vendor,
drivers/infiniband/hw/cxgb4/provider.c:		       c4iw_dev->rdev.lldi.pdev->device);
drivers/infiniband/hw/cxgb4/provider.c:	dev->ibdev.dma_device = &(dev->rdev.lldi.pdev->dev);
drivers/infiniband/hw/ipath/ipath_iba6110.c:			dev_info(&pdev->dev, "Couldn't read linkerror%d "
drivers/infiniband/hw/ipath/ipath_iba6110.c:				dev_info(&pdev->dev, "Couldn't reread "
drivers/infiniband/hw/ipath/ipath_iba6110.c:				dev_info(&pdev->dev, "HT linkerror%d bits "
drivers/infiniband/hw/ipath/ipath_iba6110.c:			dev_info(&pdev->dev, "Couldn't read config "
drivers/infiniband/hw/ipath/ipath_driver.c:		   "driver_data %lx\n", addr, len, pdev->irq, ent->vendor,
drivers/infiniband/hw/ipath/ipath_driver.c:			dev_info(&pdev->dev, "BAR is 0 (probable RESET), "
drivers/infiniband/hw/ipath/ipath_driver.c:		dev_info(&pdev->dev, "pci_request_regions unit %u fails: "
drivers/infiniband/hw/ipath/ipath_driver.c:			dev_info(&pdev->dev,
drivers/infiniband/hw/ipath/ipath_driver.c:				dev_info(&pdev->dev,
drivers/infiniband/hw/ipath/ipath_driver.c:			dev_info(&pdev->dev,
drivers/infiniband/hw/ipath/ipath_driver.c:		if (!pdev->resource[j].start)
drivers/infiniband/hw/ipath/ipath_driver.c:			   j, &pdev->resource[j],
drivers/infiniband/hw/ipath/ipath_driver.c:	dd->ipath_pcirev = pdev->revision;
drivers/infiniband/hw/ipath/ipath_driver.c:	ipath_device_create_group(&pdev->dev, dd);
drivers/infiniband/hw/ipath/ipath_driver.c:	ipath_device_remove_group(&pdev->dev, dd);
drivers/infiniband/hw/mlx4/mr.c:	mfrpl->mapped_page_list = dma_alloc_coherent(&dev->dev->pdev->dev,
drivers/infiniband/hw/mlx4/mr.c:	dma_free_coherent(&dev->dev->pdev->dev, size, mfrpl->mapped_page_list,
drivers/infiniband/hw/mlx4/main.c:	props->vendor_part_id	   = dev->dev->pdev->device;
drivers/infiniband/hw/mlx4/main.c:	return sprintf(buf, "MT%d\n", dev->dev->pdev->device);
drivers/infiniband/hw/mlx4/main.c:				i, j, dev->pdev->bus->name);
drivers/infiniband/hw/mlx4/main.c:		dev_err(&dev->pdev->dev, "RoCE is not supported over SRIOV as yet\n");
drivers/infiniband/hw/mlx4/main.c:		dev_err(&dev->pdev->dev, "Device struct alloc failed\n");
drivers/infiniband/hw/mlx4/main.c:	ibdev->ib_dev.dma_device	= &dev->pdev->dev;
drivers/infiniband/hw/mthca/mthca_memfree.c:		dma_free_coherent(&dev->pdev->dev, chunk->mem[i].length,
drivers/infiniband/hw/mthca/mthca_memfree.c:			ret = mthca_alloc_icm_coherent(&dev->pdev->dev,
drivers/infiniband/hw/mthca/mthca_memfree.c:	page->db_rec = dma_alloc_coherent(&dev->pdev->dev, MTHCA_ICM_PAGE_SIZE,
drivers/infiniband/hw/mthca/mthca_memfree.c:		dma_free_coherent(&dev->pdev->dev, MTHCA_ICM_PAGE_SIZE,
drivers/infiniband/hw/mthca/mthca_memfree.c:		dma_free_coherent(&dev->pdev->dev, MTHCA_ICM_PAGE_SIZE,
drivers/infiniband/hw/mthca/mthca_memfree.c:		dma_free_coherent(&dev->pdev->dev, MTHCA_ICM_PAGE_SIZE,
drivers/infiniband/hw/mthca/mthca_cq.c:		synchronize_irq(dev->pdev->irq);
drivers/infiniband/hw/mthca/mthca_main.c:				  dev->pdev->irq);
drivers/infiniband/hw/mthca/mthca_main.c:		dev_err(&pdev->dev, "Cannot enable PCI device, "
drivers/infiniband/hw/mthca/mthca_main.c:		dev_err(&pdev->dev, "Missing DCS, aborting.\n");
drivers/infiniband/hw/mthca/mthca_main.c:		dev_err(&pdev->dev, "Missing UAR, aborting.\n");
drivers/infiniband/hw/mthca/mthca_main.c:		dev_err(&pdev->dev, "Cannot obtain PCI resources, "
drivers/infiniband/hw/mthca/mthca_main.c:		dev_warn(&pdev->dev, "Warning: couldn't set 64-bit PCI DMA mask.\n");
drivers/infiniband/hw/mthca/mthca_main.c:			dev_err(&pdev->dev, "Can't set PCI DMA mask, aborting.\n");
drivers/infiniband/hw/mthca/mthca_main.c:		dev_warn(&pdev->dev, "Warning: couldn't set 64-bit "
drivers/infiniband/hw/mthca/mthca_main.c:			dev_err(&pdev->dev, "Can't set consistent PCI DMA mask, "
drivers/infiniband/hw/mthca/mthca_main.c:	dma_set_max_seg_size(&pdev->dev, 1024 * 1024 * 1024);
drivers/infiniband/hw/mthca/mthca_main.c:		dev_err(&pdev->dev, "Device struct alloc failed, "
drivers/infiniband/hw/mthca/mthca_mr.c:	dma_sync_single_for_cpu(&dev->pdev->dev, dma_handle,
drivers/infiniband/hw/mthca/mthca_mr.c:	dma_sync_single_for_device(&dev->pdev->dev, dma_handle,
drivers/infiniband/hw/mthca/mthca_mr.c:	dma_sync_single_for_cpu(&dev->pdev->dev, fmr->mem.arbel.dma_handle,
drivers/infiniband/hw/mthca/mthca_mr.c:	dma_sync_single_for_device(&dev->pdev->dev, fmr->mem.arbel.dma_handle,
drivers/infiniband/hw/mthca/mthca_reset.c:		while ((bridge = pci_get_device(mdev->pdev->vendor,
drivers/infiniband/hw/mthca/mthca_reset.c:						mdev->pdev->device + 2,
drivers/infiniband/hw/mthca/mthca_reset.c:			    bridge->subordinate == mdev->pdev->bus) {
drivers/infiniband/hw/mthca/mthca_provider.c:	switch (dev->pdev->device) {
drivers/infiniband/hw/mthca/mthca_provider.c:	dev->ib_dev.dma_device           = &dev->pdev->dev;
drivers/infiniband/hw/mthca/mthca_allocator.c:		buf->direct.buf = dma_alloc_coherent(&dev->pdev->dev,
drivers/infiniband/hw/mthca/mthca_allocator.c:				dma_alloc_coherent(&dev->pdev->dev, PAGE_SIZE,
drivers/infiniband/hw/mthca/mthca_allocator.c:		dma_free_coherent(&dev->pdev->dev, size, buf->direct.buf,
drivers/infiniband/hw/mthca/mthca_allocator.c:			dma_free_coherent(&dev->pdev->dev, PAGE_SIZE,
drivers/infiniband/hw/mthca/mthca_dev.h:			dev_printk(KERN_DEBUG, &mdev->pdev->dev, format, ## arg); \
drivers/infiniband/hw/mthca/mthca_dev.h:	dev_err(&mdev->pdev->dev, format, ## arg)
drivers/infiniband/hw/mthca/mthca_dev.h:	dev_info(&mdev->pdev->dev, format, ## arg)
drivers/infiniband/hw/mthca/mthca_dev.h:	dev_warn(&mdev->pdev->dev, format, ## arg)
drivers/infiniband/hw/mthca/mthca_qp.c:	sqp->header_buf = dma_alloc_coherent(&dev->pdev->dev, sqp->header_buf_size,
drivers/infiniband/hw/mthca/mthca_qp.c:	dma_free_coherent(&dev->pdev->dev, sqp->header_buf_size,
drivers/infiniband/hw/mthca/mthca_qp.c:		dma_free_coherent(&dev->pdev->dev,
drivers/infiniband/hw/mthca/mthca_eq.c:		eq->page_list[i].buf = dma_alloc_coherent(&dev->pdev->dev,
drivers/infiniband/hw/mthca/mthca_eq.c:			dma_free_coherent(&dev->pdev->dev, PAGE_SIZE,
drivers/infiniband/hw/mthca/mthca_eq.c:		free_irq(dev->pdev->irq, dev);
drivers/infiniband/hw/mthca/mthca_eq.c:		err = request_irq(dev->pdev->irq,
drivers/of/device.c:	device_initialize(&pdev->dev);
drivers/of/of_pci_irq.c:		ppdev = pdev->bus->self;
drivers/of/of_pci_irq.c:			ppnode = pci_bus_to_OF_node(pdev->bus);
drivers/of/of_pci_irq.c:	laddr[0] = cpu_to_be32((pdev->bus->number << 16) | (pdev->devfn << 8));
drivers/atm/iphase.c:		pdev->bus->number, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));)
drivers/atm/iphase.c:	dev = atm_dev_register(DEV_LABEL, &pdev->dev, &ops, -1, NULL);
drivers/pinctrl/pinctrl-exynos5440.c:	struct device *dev = &pdev->dev;
drivers/pinctrl/pinctrl-exynos5440.c:	struct device *dev = &pdev->dev;
drivers/pinctrl/pinctrl-exynos5440.c:	struct device *dev = &pdev->dev;
drivers/pinctrl/pinctrl-exynos5440.c:	pindesc = devm_kzalloc(&pdev->dev, sizeof(*pindesc) *
drivers/pinctrl/pinctrl-exynos5440.c:		dev_err(&pdev->dev, "mem alloc for pin descriptors failed\n");
drivers/pinctrl/pinctrl-exynos5440.c:	pin_names = devm_kzalloc(&pdev->dev, sizeof(char) * PIN_NAME_LENGTH *
drivers/pinctrl/pinctrl-exynos5440.c:		dev_err(&pdev->dev, "mem alloc for pin names failed\n");
drivers/pinctrl/pinctrl-exynos5440.c:	pctl_dev = pinctrl_register(ctrldesc, &pdev->dev, priv);
drivers/pinctrl/pinctrl-exynos5440.c:		dev_err(&pdev->dev, "could not register pinctrl driver\n");
drivers/pinctrl/pinctrl-exynos5440.c:	gc = devm_kzalloc(&pdev->dev, sizeof(*gc), GFP_KERNEL);
drivers/pinctrl/pinctrl-exynos5440.c:		dev_err(&pdev->dev, "mem alloc for gpio_chip failed\n");
drivers/pinctrl/pinctrl-exynos5440.c:	gc->dev = &pdev->dev;
drivers/pinctrl/pinctrl-exynos5440.c:		dev_err(&pdev->dev, "failed to register gpio_chip %s, error "
drivers/pinctrl/pinctrl-exynos5440.c:		dev_err(&pdev->dev, "gpio chip remove failed\n");
drivers/pinctrl/pinctrl-exynos5440.c:	struct device *dev = &pdev->dev;
drivers/pinctrl/pinctrl-exynos5440.c:	struct device *dev = &pdev->dev;
drivers/pinctrl/pinctrl-exynos5440.c:	priv->reg_base = devm_ioremap_resource(&pdev->dev, res);
drivers/pinctrl/pinctrl-falcon.c:			dev_err(&pdev->dev, "failed to find pad pdev\n");
drivers/pinctrl/pinctrl-falcon.c:		falcon_info.clk[*bank] = clk_get(&ppdev->dev, NULL);
drivers/pinctrl/pinctrl-falcon.c:			dev_err(&ppdev->dev, "failed to get clock\n");
drivers/pinctrl/pinctrl-falcon.c:		falcon_info.membase[*bank] = devm_ioremap_resource(&pdev->dev,
drivers/pinctrl/pinctrl-falcon.c:		dev_dbg(&pdev->dev, "found %s with %d pads\n",
drivers/pinctrl/pinctrl-falcon.c:	dev_dbg(&pdev->dev, "found a total of %d pads\n", pad_count);
drivers/pinctrl/pinctrl-falcon.c:	falcon_pctrl_desc.name	= dev_name(&pdev->dev);
drivers/pinctrl/pinctrl-falcon.c:		dev_info(&pdev->dev, "Init done\n");
drivers/pinctrl/pinctrl-xway.c:	xway_info.membase[0] = devm_ioremap_resource(&pdev->dev, res);
drivers/pinctrl/pinctrl-xway.c:	match = of_match_device(xway_match, &pdev->dev);
drivers/pinctrl/pinctrl-xway.c:	xway_info.pads = devm_kzalloc(&pdev->dev,
drivers/pinctrl/pinctrl-xway.c:		dev_err(&pdev->dev, "Failed to allocate pads\n");
drivers/pinctrl/pinctrl-xway.c:		char *name = devm_kzalloc(&pdev->dev, 5, GFP_KERNEL);
drivers/pinctrl/pinctrl-xway.c:			dev_err(&pdev->dev, "Failed to allocate pad name\n");
drivers/pinctrl/pinctrl-xway.c:	xway_chip.dev = &pdev->dev;
drivers/pinctrl/pinctrl-xway.c:		dev_err(&pdev->dev, "Failed to register gpio chip\n");
drivers/pinctrl/pinctrl-xway.c:	xway_pctrl_desc.name	= dev_name(&pdev->dev);
drivers/pinctrl/pinctrl-xway.c:		dev_err(&pdev->dev, "Failed to register pinctrl driver\n");
drivers/pinctrl/pinctrl-xway.c:	dev_info(&pdev->dev, "Init done\n");
drivers/pinctrl/pinctrl-coh901.c:	struct u300_gpio_platform *plat = dev_get_platdata(&pdev->dev);
drivers/pinctrl/pinctrl-coh901.c:	gpio = devm_kzalloc(&pdev->dev, sizeof(struct u300_gpio), GFP_KERNEL);
drivers/pinctrl/pinctrl-coh901.c:	gpio->chip.dev = &pdev->dev;
drivers/pinctrl/pinctrl-coh901.c:	gpio->dev = &pdev->dev;
drivers/pinctrl/pinctrl-coh901.c:	gpio->base = devm_ioremap_resource(&pdev->dev, memres);
drivers/pinctrl/pinctrl-coh901.c:		port->domain = irq_domain_add_linear(pdev->dev.of_node,
drivers/pinctrl/pinctrl-coh901.c:		dev_err(&pdev->dev, "failed to remove gpio chip\n");
drivers/pinctrl/pinctrl-coh901.c:	dev_err(&pdev->dev, "module ERROR:%d\n", err);
drivers/pinctrl/pinctrl-tegra.c:	pmx = devm_kzalloc(&pdev->dev, sizeof(*pmx), GFP_KERNEL);
drivers/pinctrl/pinctrl-tegra.c:		dev_err(&pdev->dev, "Can't alloc tegra_pmx\n");
drivers/pinctrl/pinctrl-tegra.c:	pmx->dev = &pdev->dev;
drivers/pinctrl/pinctrl-tegra.c:	tegra_pinctrl_desc.name = dev_name(&pdev->dev);
drivers/pinctrl/pinctrl-tegra.c:	pmx->regs = devm_kzalloc(&pdev->dev, pmx->nbanks * sizeof(*pmx->regs),
drivers/pinctrl/pinctrl-tegra.c:		dev_err(&pdev->dev, "Can't alloc regs pointer\n");
drivers/pinctrl/pinctrl-tegra.c:			dev_err(&pdev->dev, "Missing MEM resource\n");
drivers/pinctrl/pinctrl-tegra.c:		if (!devm_request_mem_region(&pdev->dev, res->start,
drivers/pinctrl/pinctrl-tegra.c:					    dev_name(&pdev->dev))) {
drivers/pinctrl/pinctrl-tegra.c:			dev_err(&pdev->dev,
drivers/pinctrl/pinctrl-tegra.c:		pmx->regs[i] = devm_ioremap(&pdev->dev, res->start,
drivers/pinctrl/pinctrl-tegra.c:			dev_err(&pdev->dev, "Couldn't ioremap regs %d\n", i);
drivers/pinctrl/pinctrl-tegra.c:	pmx->pctl = pinctrl_register(&tegra_pinctrl_desc, &pdev->dev, pmx);
drivers/pinctrl/pinctrl-tegra.c:		dev_err(&pdev->dev, "Couldn't register pinctrl driver\n");
drivers/pinctrl/pinctrl-tegra.c:	dev_dbg(&pdev->dev, "Probed Tegra pinctrl driver\n");
drivers/pinctrl/pinctrl-u300.c:	upmx = devm_kzalloc(&pdev->dev, sizeof(*upmx), GFP_KERNEL);
drivers/pinctrl/pinctrl-u300.c:	upmx->dev = &pdev->dev;
drivers/pinctrl/pinctrl-u300.c:	upmx->virtbase = devm_ioremap_resource(&pdev->dev, res);
drivers/pinctrl/pinctrl-u300.c:	upmx->pctl = pinctrl_register(&u300_pmx_desc, &pdev->dev, upmx);
drivers/pinctrl/pinctrl-u300.c:		dev_err(&pdev->dev, "could not register U300 pinmux driver\n");
drivers/pinctrl/pinctrl-u300.c:	dev_info(&pdev->dev, "initialized U300 pin control driver\n");
drivers/pinctrl/pinctrl-bcm2835.c:	struct device *dev = &pdev->dev;
drivers/pinctrl/pinctrl-at91.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/pinctrl-at91.c:	info->dev = &pdev->dev;
drivers/pinctrl/pinctrl-at91.c:		of_match_device(at91_pinctrl_of_match, &pdev->dev)->data;
drivers/pinctrl/pinctrl-at91.c:		dev_err(&pdev->dev, "you need to specify atleast one gpio-controller\n");
drivers/pinctrl/pinctrl-at91.c:	dev_dbg(&pdev->dev, "nmux = %d\n", info->nmux);
drivers/pinctrl/pinctrl-at91.c:	dev_dbg(&pdev->dev, "mux-mask\n");
drivers/pinctrl/pinctrl-at91.c:			dev_dbg(&pdev->dev, "%d:%d\t0x%x\n", i, j, tmp[0]);
drivers/pinctrl/pinctrl-at91.c:	dev_dbg(&pdev->dev, "nfunctions = %d\n", info->nfunctions);
drivers/pinctrl/pinctrl-at91.c:	dev_dbg(&pdev->dev, "ngroups = %d\n", info->ngroups);
drivers/pinctrl/pinctrl-at91.c:	info->functions = devm_kzalloc(&pdev->dev, info->nfunctions * sizeof(struct at91_pmx_func),
drivers/pinctrl/pinctrl-at91.c:	info->groups = devm_kzalloc(&pdev->dev, info->ngroups * sizeof(struct at91_pin_group),
drivers/pinctrl/pinctrl-at91.c:	dev_dbg(&pdev->dev, "nbanks = %d\n", info->nbanks);
drivers/pinctrl/pinctrl-at91.c:	dev_dbg(&pdev->dev, "nfunctions = %d\n", info->nfunctions);
drivers/pinctrl/pinctrl-at91.c:	dev_dbg(&pdev->dev, "ngroups = %d\n", info->ngroups);
drivers/pinctrl/pinctrl-at91.c:			dev_err(&pdev->dev, "failed to parse function\n");
drivers/pinctrl/pinctrl-at91.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
drivers/pinctrl/pinctrl-at91.c:			dev_warn(&pdev->dev, "GPIO chip %d not registered yet\n", i);
drivers/pinctrl/pinctrl-at91.c:			devm_kfree(&pdev->dev, info);
drivers/pinctrl/pinctrl-at91.c:	at91_pinctrl_desc.name = dev_name(&pdev->dev);
drivers/pinctrl/pinctrl-at91.c:		devm_kzalloc(&pdev->dev, sizeof(*pdesc) * at91_pinctrl_desc.npins, GFP_KERNEL);
drivers/pinctrl/pinctrl-at91.c:	info->pctl = pinctrl_register(&at91_pinctrl_desc, &pdev->dev, info);
drivers/pinctrl/pinctrl-at91.c:		dev_err(&pdev->dev, "could not register AT91 pinctrl driver\n");
drivers/pinctrl/pinctrl-at91.c:	dev_info(&pdev->dev, "initialized AT91 pinctrl driver\n");
drivers/pinctrl/pinctrl-at91.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/pinctrl-at91.c:	at91_chip = devm_kzalloc(&pdev->dev, sizeof(*at91_chip), GFP_KERNEL);
drivers/pinctrl/pinctrl-at91.c:	at91_chip->regbase = devm_ioremap_resource(&pdev->dev, res);
drivers/pinctrl/pinctrl-at91.c:		of_match_device(at91_gpio_of_match, &pdev->dev)->data;
drivers/pinctrl/pinctrl-at91.c:	at91_chip->clock = clk_get(&pdev->dev, NULL);
drivers/pinctrl/pinctrl-at91.c:		dev_err(&pdev->dev, "failed to get clock, ignoring.\n");
drivers/pinctrl/pinctrl-at91.c:		dev_err(&pdev->dev, "failed to enable clock, ignoring.\n");
drivers/pinctrl/pinctrl-at91.c:	chip->label = dev_name(&pdev->dev);
drivers/pinctrl/pinctrl-at91.c:	chip->dev = &pdev->dev;
drivers/pinctrl/pinctrl-at91.c:	names = devm_kzalloc(&pdev->dev, sizeof(char *) * chip->ngpio,
drivers/pinctrl/pinctrl-at91.c:	dev_info(&pdev->dev, "at address %p\n", at91_chip->regbase);
drivers/pinctrl/pinctrl-at91.c:	dev_err(&pdev->dev, "Failure %i for GPIO %i\n", ret, alias_idx);
drivers/pinctrl/pinctrl-sirf.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/pinctrl-sirf.c:	spmx = devm_kzalloc(&pdev->dev, sizeof(*spmx), GFP_KERNEL);
drivers/pinctrl/pinctrl-sirf.c:	spmx->dev = &pdev->dev;
drivers/pinctrl/pinctrl-sirf.c:		dev_err(&pdev->dev, "can't map gpio registers\n");
drivers/pinctrl/pinctrl-sirf.c:		dev_err(&pdev->dev, "can't map rsc registers\n");
drivers/pinctrl/pinctrl-sirf.c:	spmx->pmx = pinctrl_register(&sirfsoc_pinmux_desc, &pdev->dev, spmx);
drivers/pinctrl/pinctrl-sirf.c:		dev_err(&pdev->dev, "could not register SIRFSOC pinmux driver\n");
drivers/pinctrl/pinctrl-sirf.c:	dev_info(&pdev->dev, "initialized SIRFSOC pinmux driver\n");
drivers/pinctrl/sh-pfc/core.c:	if (pdev->num_resources == 0)
drivers/pinctrl/sh-pfc/core.c:	pfc->window = devm_kzalloc(pfc->dev, pdev->num_resources *
drivers/pinctrl/sh-pfc/core.c:	pfc->num_windows = pdev->num_resources;
drivers/pinctrl/sh-pfc/core.c:	for (k = 0, res = pdev->resource; k < pdev->num_resources; k++, res++) {
drivers/pinctrl/sh-pfc/core.c:	info = pdev->id_entry->driver_data
drivers/pinctrl/sh-pfc/core.c:	      ? (void *)pdev->id_entry->driver_data : pdev->dev.platform_data;
drivers/pinctrl/sh-pfc/core.c:	pfc = devm_kzalloc(&pdev->dev, sizeof(*pfc), GFP_KERNEL);
drivers/pinctrl/sh-pfc/core.c:	pfc->dev = &pdev->dev;
drivers/pinctrl/pinctrl-samsung.c:	struct device *dev = &pdev->dev;
drivers/pinctrl/pinctrl-samsung.c:	struct device *dev = &pdev->dev;
drivers/pinctrl/pinctrl-samsung.c:	pindesc = devm_kzalloc(&pdev->dev, sizeof(*pindesc) *
drivers/pinctrl/pinctrl-samsung.c:		dev_err(&pdev->dev, "mem alloc for pin descriptors failed\n");
drivers/pinctrl/pinctrl-samsung.c:	pin_names = devm_kzalloc(&pdev->dev, sizeof(char) * PIN_NAME_LENGTH *
drivers/pinctrl/pinctrl-samsung.c:		dev_err(&pdev->dev, "mem alloc for pin names failed\n");
drivers/pinctrl/pinctrl-samsung.c:	drvdata->pctl_dev = pinctrl_register(ctrldesc, &pdev->dev, drvdata);
drivers/pinctrl/pinctrl-samsung.c:		dev_err(&pdev->dev, "could not register pinctrl driver\n");
drivers/pinctrl/pinctrl-samsung.c:		gc->dev = &pdev->dev;
drivers/pinctrl/pinctrl-samsung.c:			dev_err(&pdev->dev, "failed to register gpio_chip %s, error code: %d\n",
drivers/pinctrl/pinctrl-samsung.c:			dev_err(&pdev->dev, "gpio chip %s remove failed\n",
drivers/pinctrl/pinctrl-samsung.c:		dev_err(&pdev->dev, "gpio chip remove failed\n");
drivers/pinctrl/pinctrl-samsung.c:	struct device_node *node = pdev->dev.of_node;
drivers/pinctrl/pinctrl-samsung.c:		dev_err(&pdev->dev, "failed to get alias id\n");
drivers/pinctrl/pinctrl-samsung.c:	struct device *dev = &pdev->dev;
drivers/pinctrl/pinctrl-samsung.c:		dev_err(&pdev->dev, "driver data not available\n");
drivers/pinctrl/pinctrl-samsung.c:	drvdata->virt_base = devm_ioremap_resource(&pdev->dev, res);
drivers/pinctrl/pinctrl-abx500.c:				dev_get_platdata(pdev->dev.parent);
drivers/pinctrl/pinctrl-abx500.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/pinctrl-abx500.c:		dev_err(&pdev->dev, "gpio dt and platform data missing\n");
drivers/pinctrl/pinctrl-abx500.c:	pct = devm_kzalloc(&pdev->dev, sizeof(struct abx500_pinctrl),
drivers/pinctrl/pinctrl-abx500.c:		dev_err(&pdev->dev,
drivers/pinctrl/pinctrl-abx500.c:	pct->dev = &pdev->dev;
drivers/pinctrl/pinctrl-abx500.c:	pct->parent = dev_get_drvdata(pdev->dev.parent);
drivers/pinctrl/pinctrl-abx500.c:	pct->chip.dev = &pdev->dev;
drivers/pinctrl/pinctrl-abx500.c:		match = of_match_device(abx500_gpio_match, &pdev->dev);
drivers/pinctrl/pinctrl-abx500.c:		dev_err(&pdev->dev, "Unsupported pinctrl sub driver (%d)\n", id);
drivers/pinctrl/pinctrl-abx500.c:		dev_err(&pdev->dev, "Invalid SOC data\n");
drivers/pinctrl/pinctrl-abx500.c:		dev_err(&pdev->dev, "unable to add gpiochip: %d\n", ret);
drivers/pinctrl/pinctrl-abx500.c:	dev_info(&pdev->dev, "added gpiochip\n");
drivers/pinctrl/pinctrl-abx500.c:	pct->pctldev = pinctrl_register(&abx500_pinctrl_desc, &pdev->dev, pct);
drivers/pinctrl/pinctrl-abx500.c:		dev_err(&pdev->dev,
drivers/pinctrl/pinctrl-abx500.c:	dev_info(&pdev->dev, "registered pin controller\n");
drivers/pinctrl/pinctrl-abx500.c:					dev_name(&pdev->dev),
drivers/pinctrl/pinctrl-abx500.c:	dev_info(&pdev->dev, "initialized abx500 pinctrl driver\n");
drivers/pinctrl/pinctrl-abx500.c:		dev_info(&pdev->dev, "failed to remove gpiochip\n");
drivers/pinctrl/pinctrl-mxs.c:	group = devm_kzalloc(&pdev->dev, length, GFP_KERNEL);
drivers/pinctrl/pinctrl-mxs.c:	g->pins = devm_kzalloc(&pdev->dev, g->npins * sizeof(*g->pins),
drivers/pinctrl/pinctrl-mxs.c:	g->muxsel = devm_kzalloc(&pdev->dev, g->npins * sizeof(*g->muxsel),
drivers/pinctrl/pinctrl-mxs.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/pinctrl-mxs.c:		dev_err(&pdev->dev, "no group is defined\n");
drivers/pinctrl/pinctrl-mxs.c:	soc->functions = devm_kzalloc(&pdev->dev, soc->nfunctions *
drivers/pinctrl/pinctrl-mxs.c:	soc->groups = devm_kzalloc(&pdev->dev, soc->ngroups *
drivers/pinctrl/pinctrl-mxs.c:			f->groups = devm_kzalloc(&pdev->dev, f->ngroups *
drivers/pinctrl/pinctrl-mxs.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/pinctrl-mxs.c:	d = devm_kzalloc(&pdev->dev, sizeof(*d), GFP_KERNEL);
drivers/pinctrl/pinctrl-mxs.c:	d->dev = &pdev->dev;
drivers/pinctrl/pinctrl-mxs.c:	mxs_pinctrl_desc.name = dev_name(&pdev->dev);
drivers/pinctrl/pinctrl-mxs.c:		dev_err(&pdev->dev, "dt probe failed: %d\n", ret);
drivers/pinctrl/pinctrl-mxs.c:	d->pctl = pinctrl_register(&mxs_pinctrl_desc, &pdev->dev, d);
drivers/pinctrl/pinctrl-mxs.c:		dev_err(&pdev->dev, "Couldn't register MXS pinctrl driver\n");
drivers/pinctrl/pinctrl-sunxi.c:	pctl->groups = devm_kzalloc(&pdev->dev,
drivers/pinctrl/pinctrl-sunxi.c:	pctl->functions = devm_kzalloc(&pdev->dev,
drivers/pinctrl/pinctrl-sunxi.c:					devm_kzalloc(&pdev->dev,
drivers/pinctrl/pinctrl-sunxi.c:	struct device_node *node = pdev->dev.of_node;
drivers/pinctrl/pinctrl-sunxi.c:	pctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);
drivers/pinctrl/pinctrl-sunxi.c:	device = of_match_device(sunxi_pinctrl_match, &pdev->dev);
drivers/pinctrl/pinctrl-sunxi.c:		dev_err(&pdev->dev, "dt probe failed: %d\n", ret);
drivers/pinctrl/pinctrl-sunxi.c:	pins = devm_kzalloc(&pdev->dev,
drivers/pinctrl/pinctrl-sunxi.c:	sunxi_pctrl_desc.name = dev_name(&pdev->dev);
drivers/pinctrl/pinctrl-sunxi.c:	pctl->dev = &pdev->dev;
drivers/pinctrl/pinctrl-sunxi.c:					  &pdev->dev, pctl);
drivers/pinctrl/pinctrl-sunxi.c:		dev_err(&pdev->dev, "couldn't register pinctrl driver\n");
drivers/pinctrl/pinctrl-sunxi.c:	pctl->chip = devm_kzalloc(&pdev->dev, sizeof(*pctl->chip), GFP_KERNEL);
drivers/pinctrl/pinctrl-sunxi.c:	pctl->chip->label = dev_name(&pdev->dev);
drivers/pinctrl/pinctrl-sunxi.c:	pctl->chip->dev = &pdev->dev;
drivers/pinctrl/pinctrl-sunxi.c:		ret = gpiochip_add_pin_range(pctl->chip, dev_name(&pdev->dev),
drivers/pinctrl/pinctrl-sunxi.c:	clk = devm_clk_get(&pdev->dev, NULL);
drivers/pinctrl/pinctrl-sunxi.c:	dev_info(&pdev->dev, "initialized sunXi PIO driver\n");
drivers/pinctrl/pinctrl-sunxi.c:		dev_err(&pdev->dev, "failed to remove gpio chip\n");
drivers/pinctrl/pinctrl-lantiq.c:	info->dev = &pdev->dev;
drivers/pinctrl/pinctrl-lantiq.c:	info->pctrl = pinctrl_register(desc, &pdev->dev, info);
drivers/pinctrl/pinctrl-lantiq.c:		dev_err(&pdev->dev, "failed to register LTQ pinmux driver\n");
drivers/pinctrl/spear/pinctrl-spear.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/spear/pinctrl-spear.c:	pmx = devm_kzalloc(&pdev->dev, sizeof(*pmx), GFP_KERNEL);
drivers/pinctrl/spear/pinctrl-spear.c:		dev_err(&pdev->dev, "Can't alloc spear_pmx\n");
drivers/pinctrl/spear/pinctrl-spear.c:	pmx->vbase = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/pinctrl/spear/pinctrl-spear.c:		dev_err(&pdev->dev, "Couldn't ioremap at index 0\n");
drivers/pinctrl/spear/pinctrl-spear.c:	pmx->dev = &pdev->dev;
drivers/pinctrl/spear/pinctrl-spear.c:			dev_err(&pdev->dev, "OF: pinmux mode not passed\n");
drivers/pinctrl/spear/pinctrl-spear.c:			dev_err(&pdev->dev, "OF: Couldn't configure mode: %x\n",
drivers/pinctrl/spear/pinctrl-spear.c:	pmx->pctl = pinctrl_register(&spear_pinctrl_desc, &pdev->dev, pmx);
drivers/pinctrl/spear/pinctrl-spear.c:		dev_err(&pdev->dev, "Couldn't register pinctrl driver\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "DT: Invalid ngpio field\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "DT: Invalid wdata reg\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "DT: Invalid dir reg\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "DT: Invalid ie reg\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "DT: Invalid rdata reg\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "DT: Invalid mis reg\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "invalid IORESOURCE_MEM\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:	plgpio = devm_kzalloc(&pdev->dev, sizeof(*plgpio), GFP_KERNEL);
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "memory allocation fail\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:	plgpio->base = devm_ioremap_resource(&pdev->dev, res);
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "DT probe failed\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:	plgpio->clk = devm_clk_get(&pdev->dev, NULL);
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_warn(&pdev->dev, "clk_get() failed, work without it\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:	plgpio->csave_regs = devm_kzalloc(&pdev->dev,
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "csave registers memory allocation fail\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:	plgpio->chip.label = dev_name(&pdev->dev);
drivers/pinctrl/spear/pinctrl-plgpio.c:	plgpio->chip.dev = &pdev->dev;
drivers/pinctrl/spear/pinctrl-plgpio.c:			dev_err(&pdev->dev, "clk prepare failed\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "unable to add gpio chip\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_info(&pdev->dev, "irqs not supported\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_warn(&pdev->dev, "couldn't allocate irq base\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "irq domain init failed\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:	dev_info(&pdev->dev, "PLGPIO registered with IRQs\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:	dev_info(&pdev->dev, "Remove gpiochip\n");
drivers/pinctrl/spear/pinctrl-plgpio.c:		dev_err(&pdev->dev, "unable to remove gpiochip\n");
drivers/pinctrl/mvebu/pinctrl-mvebu.c:	funcs = devm_kzalloc(&pdev->dev, funcsize *
drivers/pinctrl/mvebu/pinctrl-mvebu.c:				dev_err(&pdev->dev,
drivers/pinctrl/mvebu/pinctrl-mvebu.c:				f->groups = devm_kzalloc(&pdev->dev,
drivers/pinctrl/mvebu/pinctrl-mvebu.c:	struct mvebu_pinctrl_soc_info *soc = dev_get_platdata(&pdev->dev);
drivers/pinctrl/mvebu/pinctrl-mvebu.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/mvebu/pinctrl-mvebu.c:		dev_err(&pdev->dev, "wrong pinctrl soc info\n");
drivers/pinctrl/mvebu/pinctrl-mvebu.c:		dev_err(&pdev->dev, "unable to get base address\n");
drivers/pinctrl/mvebu/pinctrl-mvebu.c:	pctl = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_pinctrl),
drivers/pinctrl/mvebu/pinctrl-mvebu.c:		dev_err(&pdev->dev, "unable to alloc driver\n");
drivers/pinctrl/mvebu/pinctrl-mvebu.c:	pctl->desc.name = dev_name(&pdev->dev);
drivers/pinctrl/mvebu/pinctrl-mvebu.c:	pctl->dev = &pdev->dev;
drivers/pinctrl/mvebu/pinctrl-mvebu.c:				dev_err(&pdev->dev, "wrong soc control info\n");
drivers/pinctrl/mvebu/pinctrl-mvebu.c:		names = devm_kzalloc(&pdev->dev, ctrl->npins * 8, GFP_KERNEL);
drivers/pinctrl/mvebu/pinctrl-mvebu.c:			dev_err(&pdev->dev, "failed to alloc mpp names\n");
drivers/pinctrl/mvebu/pinctrl-mvebu.c:	pdesc = devm_kzalloc(&pdev->dev, pctl->desc.npins *
drivers/pinctrl/mvebu/pinctrl-mvebu.c:		dev_err(&pdev->dev, "failed to alloc pinctrl pins\n");
drivers/pinctrl/mvebu/pinctrl-mvebu.c:	pctl->groups = devm_kzalloc(&pdev->dev, pctl->num_groups *
drivers/pinctrl/mvebu/pinctrl-mvebu.c:		dev_err(&pdev->dev, "failed to alloc pinctrl groups\n");
drivers/pinctrl/mvebu/pinctrl-mvebu.c:			dev_warn(&pdev->dev, "unknown pinctrl group %d\n",
drivers/pinctrl/mvebu/pinctrl-mvebu.c:		dev_err(&pdev->dev, "unable to build functions\n");
drivers/pinctrl/mvebu/pinctrl-mvebu.c:	pctl->pctldev = pinctrl_register(&pctl->desc, &pdev->dev, pctl);
drivers/pinctrl/mvebu/pinctrl-mvebu.c:		dev_err(&pdev->dev, "unable to register pinctrl driver\n");
drivers/pinctrl/mvebu/pinctrl-mvebu.c:	dev_info(&pdev->dev, "registered pinctrl driver\n");
drivers/pinctrl/mvebu/pinctrl-armada-xp.c:		of_match_device(armada_xp_pinctrl_of_match, &pdev->dev);
drivers/pinctrl/mvebu/pinctrl-armada-xp.c:	pdev->dev.platform_data = soc;
drivers/pinctrl/mvebu/pinctrl-dove.c:		of_match_device(dove_pinctrl_of_match, &pdev->dev);
drivers/pinctrl/mvebu/pinctrl-dove.c:	pdev->dev.platform_data = (void *)match->data;
drivers/pinctrl/mvebu/pinctrl-dove.c:	clk = devm_clk_get(&pdev->dev, NULL);
drivers/pinctrl/mvebu/pinctrl-dove.c:		dev_err(&pdev->dev, "Unable to get pdma clock");
drivers/pinctrl/mvebu/pinctrl-kirkwood.c:		of_match_device(kirkwood_pinctrl_of_match, &pdev->dev);
drivers/pinctrl/mvebu/pinctrl-kirkwood.c:	pdev->dev.platform_data = (void *)match->data;
drivers/pinctrl/mvebu/pinctrl-armada-370.c:	pdev->dev.platform_data = soc;
drivers/pinctrl/pinctrl-single.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/pinctrl-single.c:	match = of_match_device(pcs_of_match, &pdev->dev);
drivers/pinctrl/pinctrl-single.c:	pcs = devm_kzalloc(&pdev->dev, sizeof(*pcs), GFP_KERNEL);
drivers/pinctrl/pinctrl-single.c:		dev_err(&pdev->dev, "could not allocate\n");
drivers/pinctrl/pinctrl-single.c:	pcs->dev = &pdev->dev;
drivers/pinctrl/pinctrl-nomadik.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/pinctrl-nomadik.c:	npct = devm_kzalloc(&pdev->dev, sizeof(*npct), GFP_KERNEL);
drivers/pinctrl/pinctrl-nomadik.c:		match = of_match_device(nmk_pinctrl_match, &pdev->dev);
drivers/pinctrl/pinctrl-nomadik.c:		npct->prcm_base = devm_ioremap(&pdev->dev, res->start,
drivers/pinctrl/pinctrl-nomadik.c:			dev_info(&pdev->dev,
drivers/pinctrl/pinctrl-nomadik.c:			dev_err(&pdev->dev, "missing PRCM base address\n");
drivers/pinctrl/pinctrl-nomadik.c:			dev_warn(&pdev->dev, "GPIO chip %d not registered yet\n", i);
drivers/pinctrl/pinctrl-nomadik.c:	npct->dev = &pdev->dev;
drivers/pinctrl/pinctrl-nomadik.c:	npct->pctl = pinctrl_register(&nmk_pinctrl_desc, &pdev->dev, npct);
drivers/pinctrl/pinctrl-nomadik.c:		dev_err(&pdev->dev, "could not register Nomadik pinctrl driver\n");
drivers/pinctrl/pinctrl-nomadik.c:	dev_info(&pdev->dev, "initialized Nomadik pin control driver\n");
drivers/pinctrl/vt8500/pinctrl-wm8650.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/pinctrl/vt8500/pinctrl-wm8650.c:		dev_err(&pdev->dev, "failed to allocate data\n");
drivers/pinctrl/vt8500/pinctrl-wm8750.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/pinctrl/vt8500/pinctrl-wm8750.c:		dev_err(&pdev->dev, "failed to allocate data\n");
drivers/pinctrl/vt8500/pinctrl-wm8850.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/pinctrl/vt8500/pinctrl-wm8850.c:		dev_err(&pdev->dev, "failed to allocate data\n");
drivers/pinctrl/vt8500/pinctrl-wmt.c:	data->base = devm_request_and_ioremap(&pdev->dev, res);
drivers/pinctrl/vt8500/pinctrl-wmt.c:		dev_err(&pdev->dev, "failed to map memory resource\n");
drivers/pinctrl/vt8500/pinctrl-wmt.c:	data->gpio_chip.dev = &pdev->dev;
drivers/pinctrl/vt8500/pinctrl-wmt.c:	data->gpio_chip.of_node = pdev->dev.of_node;
drivers/pinctrl/vt8500/pinctrl-wmt.c:	data->dev = &pdev->dev;
drivers/pinctrl/vt8500/pinctrl-wmt.c:	data->pctl_dev = pinctrl_register(&wmt_desc, &pdev->dev, data);
drivers/pinctrl/vt8500/pinctrl-wmt.c:		dev_err(&pdev->dev, "Failed to register pinctrl\n");
drivers/pinctrl/vt8500/pinctrl-wmt.c:		dev_err(&pdev->dev, "could not add GPIO chip\n");
drivers/pinctrl/vt8500/pinctrl-wmt.c:	dev_info(&pdev->dev, "Pin controller initialized\n");
drivers/pinctrl/vt8500/pinctrl-wmt.c:		dev_err(&pdev->dev, "failed to remove gpio chip\n");
drivers/pinctrl/vt8500/pinctrl-wmt.c:		dev_err(&pdev->dev, "failed to remove gpio chip\n");
drivers/pinctrl/vt8500/pinctrl-wm8505.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/pinctrl/vt8500/pinctrl-wm8505.c:		dev_err(&pdev->dev, "failed to allocate data\n");
drivers/pinctrl/vt8500/pinctrl-vt8500.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/pinctrl/vt8500/pinctrl-vt8500.c:		dev_err(&pdev->dev, "failed to allocate data\n");
drivers/pinctrl/pinctrl-imx.c:	struct device_node *np = pdev->dev.of_node;
drivers/pinctrl/pinctrl-imx.c:		dev_err(&pdev->dev, "no functions defined\n");
drivers/pinctrl/pinctrl-imx.c:	info->functions = devm_kzalloc(&pdev->dev, nfuncs * sizeof(struct imx_pmx_func),
drivers/pinctrl/pinctrl-imx.c:	info->groups = devm_kzalloc(&pdev->dev, info->ngroups * sizeof(struct imx_pin_group),
drivers/pinctrl/pinctrl-imx.c:			dev_err(&pdev->dev, "failed to parse function\n");
drivers/pinctrl/pinctrl-imx.c:		dev_err(&pdev->dev, "wrong pinctrl info\n");
drivers/pinctrl/pinctrl-imx.c:	info->dev = &pdev->dev;
drivers/pinctrl/pinctrl-imx.c:	ipctl = devm_kzalloc(&pdev->dev, sizeof(*ipctl), GFP_KERNEL);
drivers/pinctrl/pinctrl-imx.c:	info->pin_regs = devm_kzalloc(&pdev->dev, sizeof(*info->pin_regs) *
drivers/pinctrl/pinctrl-imx.c:	ipctl->base = devm_ioremap_resource(&pdev->dev, res);
drivers/pinctrl/pinctrl-imx.c:	imx_pinctrl_desc.name = dev_name(&pdev->dev);
drivers/pinctrl/pinctrl-imx.c:		dev_err(&pdev->dev, "fail to probe dt properties\n");
drivers/pinctrl/pinctrl-imx.c:	ipctl->pctl = pinctrl_register(&imx_pinctrl_desc, &pdev->dev, ipctl);
drivers/pinctrl/pinctrl-imx.c:		dev_err(&pdev->dev, "could not register IMX pinctrl driver\n");
drivers/pinctrl/pinctrl-imx.c:	dev_info(&pdev->dev, "initialized IMX pinctrl driver\n");
drivers/md/raid5.c:	    (s.p_failed || ((test_bit(R5_Insync, &pdev->flags)
drivers/md/raid5.c:			     && !test_bit(R5_LOCKED, &pdev->flags)
drivers/md/raid5.c:			     && (test_bit(R5_UPTODATE, &pdev->flags) ||
drivers/md/raid5.c:				 test_bit(R5_Discard, &pdev->flags))))) &&
drivers/media/parport/c-qcam.c:	    && !strcmp(qcam->pdev->port->probe_info[0].model,
drivers/media/parport/bw-qcam.c:		if (qcam && qcam->pdev->port == port) {
drivers/media/radio/radio-maxiradio.c:		dev_err(&pdev->dev, "not enough memory\n");
drivers/media/radio/radio-maxiradio.c:	retval = v4l2_device_register(&pdev->dev, v4l2_dev);
drivers/media/radio/radio-maxiradio.c:		dev_err(&pdev->dev, "can't reserve I/O ports\n");
drivers/media/radio/radio-maxiradio.c:	struct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);
drivers/media/radio/radio-isa.c:	struct radio_isa_driver *drv = pdev->platform_data;
drivers/media/radio/radio-isa.c:	struct radio_isa_driver *drv = pdev->platform_data;
drivers/media/radio/radio-wl1273.c:	dev_info(&pdev->dev, "%s.\n", __func__);
drivers/media/radio/radio-wl1273.c:	struct wl1273_core **core = pdev->dev.platform_data;
drivers/media/radio/radio-wl1273.c:		dev_err(&pdev->dev, "No platform data.\n");
drivers/media/radio/radio-wl1273.c:	radio = devm_kzalloc(&pdev->dev, sizeof(*radio), GFP_KERNEL);
drivers/media/radio/radio-wl1273.c:	radio->buffer = devm_kzalloc(&pdev->dev, radio->buf_size, GFP_KERNEL);
drivers/media/radio/radio-wl1273.c:	radio->write_buf = devm_kzalloc(&pdev->dev, 256, GFP_KERNEL);
drivers/media/radio/radio-wl1273.c:	radio->dev = &pdev->dev;
drivers/media/radio/radio-wl1273.c:	r = v4l2_device_register(&pdev->dev, &radio->v4l2dev);
drivers/media/radio/radio-wl1273.c:		dev_err(&pdev->dev, "Cannot register v4l2_device.\n");
drivers/media/radio/radio-wl1273.c:		dev_err(&pdev->dev, "Ctrl handler error: %d\n", r);
drivers/media/radio/radio-wl1273.c:		dev_err(&pdev->dev, WL1273_FM_DRIVER_NAME
drivers/media/radio/radio-timb.c:	struct timb_radio_platform_data *pdata = pdev->dev.platform_data;
drivers/media/radio/radio-timb.c:		dev_err(&pdev->dev, "Platform data missing\n");
drivers/media/radio/radio-timb.c:	tr = devm_kzalloc(&pdev->dev, sizeof(*tr), GFP_KERNEL);
drivers/media/radio/radio-timb.c:		dev_err(&pdev->dev, "Error reg video\n");
drivers/media/radio/radio-timb.c:	dev_err(&pdev->dev, "Failed to register: %d\n", err);
drivers/media/radio/radio-si4713.c:	struct radio_si4713_platform_data *pdata = pdev->dev.platform_data;
drivers/media/radio/radio-si4713.c:		dev_err(&pdev->dev, "Cannot proceed without platform data.\n");
drivers/media/radio/radio-si4713.c:	rsdev = devm_kzalloc(&pdev->dev, sizeof(*rsdev), GFP_KERNEL);
drivers/media/radio/radio-si4713.c:		dev_err(&pdev->dev, "Failed to alloc video device.\n");
drivers/media/radio/radio-si4713.c:	rval = v4l2_device_register(&pdev->dev, &rsdev->v4l2_dev);
drivers/media/radio/radio-si4713.c:		dev_err(&pdev->dev, "Failed to register v4l2 device.\n");
drivers/media/radio/radio-si4713.c:		dev_err(&pdev->dev, "Cannot get i2c adapter %d\n",
drivers/media/radio/radio-si4713.c:		dev_err(&pdev->dev, "Cannot get v4l2 subdevice\n");
drivers/media/radio/radio-si4713.c:		dev_err(&pdev->dev, "Could not register video device.\n");
drivers/media/radio/radio-si4713.c:	dev_info(&pdev->dev, "New device successfully probed\n");
drivers/media/radio/radio-si476x.c:	radio = devm_kzalloc(&pdev->dev, sizeof(*radio), GFP_KERNEL);
drivers/media/radio/radio-si476x.c:	radio->core = i2c_mfd_cell_to_core(&pdev->dev);
drivers/media/radio/radio-si476x.c:	rval = v4l2_device_register(&pdev->dev, &radio->v4l2dev);
drivers/media/radio/radio-si476x.c:		dev_err(&pdev->dev, "Cannot register v4l2_device.\n");
drivers/media/radio/radio-si476x.c:			dev_err(&pdev->dev, "Could not initialize V4L2_CID_POWER_LINE_FREQUENCY control %d\n",
drivers/media/radio/radio-si476x.c:		dev_err(&pdev->dev, "Could not initialize V4L2_CID_TUNE_DEEMPHASIS control %d\n",
drivers/media/radio/radio-si476x.c:		dev_err(&pdev->dev, "Could not initialize V4L2_CID_RDS_RECEPTION control %d\n",
drivers/media/radio/radio-si476x.c:		dev_err(&pdev->dev, "Could not register video device\n");
drivers/media/radio/radio-si476x.c:		dev_err(&pdev->dev, "Could not creat debugfs interface\n");
drivers/media/radio/radio-sf16fmr2.c:	ret = fmr2_probe(fmr2, &pdev->dev, pnp_port_start(pdev, 0));
drivers/media/pci/ddbridge/ddbridge-core.c:		adap->dev.parent = &dev->pdev->dev;
drivers/media/pci/ddbridge/ddbridge-core.c:				   &input->port->dev->pdev->dev,
drivers/media/pci/ddbridge/ddbridge-core.c:				   &port->dev->pdev->dev,
drivers/media/pci/ddbridge/ddbridge-core.c:	free_irq(dev->pdev->irq, dev);
drivers/media/pci/ddbridge/ddbridge-core.c:	stat = request_irq(dev->pdev->irq, irq_handler,
drivers/media/pci/ddbridge/ddbridge-core.c:	free_irq(dev->pdev->irq, dev);
drivers/media/pci/b2c2/flexcop-pci.c:	info("card revision %x", fc_pci->pdev->revision);
drivers/media/pci/b2c2/flexcop-pci.c:	if ((ret = request_irq(fc_pci->pdev->irq, flexcop_pci_isr,
drivers/media/pci/b2c2/flexcop-pci.c:		free_irq(fc_pci->pdev->irq, fc_pci);
drivers/media/pci/b2c2/flexcop-pci.c:	fc->dev = &pdev->dev;
drivers/media/pci/pluto2/pluto2.c:			dev_printk(KERN_DEBUG, &pluto->pdev->dev, "resetting TS because of invalid packet counter\n");
drivers/media/pci/pluto2/pluto2.c:			dev_err(&pluto->pdev->dev, "card has hung or been ejected.\n");
drivers/media/pci/pluto2/pluto2.c:			dev_err(&pluto->pdev->dev, "overflow irq (%d)\n",
drivers/media/pci/pluto2/pluto2.c:	return request_firmware(fw, name, &pluto->pdev->dev);
drivers/media/pci/pluto2/pluto2.c:		dev_err(&pluto->pdev->dev, "could not attach frontend\n");
drivers/media/pci/pluto2/pluto2.c:	dev_info(&pluto->pdev->dev, "board revision %d.%d\n",
drivers/media/pci/pluto2/pluto2.c:	dev_info(&pluto->pdev->dev, "MAC %pM\n", mac);
drivers/media/pci/pluto2/pluto2.c:	dev_info(&pdev->dev, "S/N ");
drivers/media/pci/pluto2/pluto2.c:	ret = request_irq(pdev->irq, pluto_irq, IRQF_SHARED, DRIVER_NAME, pluto);
drivers/media/pci/pluto2/pluto2.c:	pluto->i2c_adap.dev.parent = &pdev->dev;
drivers/media/pci/pluto2/pluto2.c:				   THIS_MODULE, &pdev->dev, adapter_nr);
drivers/media/pci/pluto2/pluto2.c:	free_irq(pdev->irq, pluto);
drivers/media/pci/pluto2/pluto2.c:	free_irq(pdev->irq, pluto);
drivers/media/pci/dm1105/dm1105.c:	if (dm1105->pdev->subsystem_vendor) {
drivers/media/pci/dm1105/dm1105.c:		dev->input_id.vendor = dm1105->pdev->subsystem_vendor;
drivers/media/pci/dm1105/dm1105.c:		dev->input_id.product = dm1105->pdev->subsystem_device;
drivers/media/pci/dm1105/dm1105.c:		dev->input_id.vendor = dm1105->pdev->vendor;
drivers/media/pci/dm1105/dm1105.c:		dev->input_id.product = dm1105->pdev->device;
drivers/media/pci/dm1105/dm1105.c:	dev->dev.parent = &dm1105->pdev->dev;
drivers/media/pci/dm1105/dm1105.c:		dev_err(&dev->pdev->dev, "could not attach frontend\n");
drivers/media/pci/dm1105/dm1105.c:	dev_info(&dev->pdev->dev, "MAC %pM\n", mac);
drivers/media/pci/dm1105/dm1105.c:		if (pdev->subsystem_vendor ==
drivers/media/pci/dm1105/dm1105.c:				pdev->subsystem_device ==
drivers/media/pci/dm1105/dm1105.c:	dev->i2c_adap.dev.parent = &pdev->dev;
drivers/media/pci/dm1105/dm1105.c:	dev->i2c_bb_adap.dev.parent = &pdev->dev;
drivers/media/pci/dm1105/dm1105.c:					THIS_MODULE, &pdev->dev, adapter_nr);
drivers/media/pci/dm1105/dm1105.c:	ret = request_irq(pdev->irq, dm1105_irq, IRQF_SHARED,
drivers/media/pci/dm1105/dm1105.c:	synchronize_irq(pdev->irq);
drivers/media/pci/dm1105/dm1105.c:	free_irq(pdev->irq, dev);
drivers/media/pci/pt1/pt1.c:	dev_printk(level, &(pt1)->pdev->dev, format, ##arg)
drivers/media/pci/pt1/pt1.c:	phase = pt1->pdev->device == 0x211a ? 128 : 166;
drivers/media/pci/pt1/pt1.c:	dma_free_coherent(&pt1->pdev->dev, PT1_PAGE_SIZE, page, addr);
drivers/media/pci/pt1/pt1.c:	page = dma_alloc_coherent(&pt1->pdev->dev, PT1_PAGE_SIZE, &addr,
drivers/media/pci/pt1/pt1.c:				   &pt1->pdev->dev, adapter_nr);
drivers/media/pci/pt1/pt1.c:	configs = pt1->pdev->device == 0x211a ? pt1_configs : pt2_configs;
drivers/media/pci/pt1/pt1.c:	i2c_adap->dev.parent = &pdev->dev;
drivers/media/pci/mantis/mantis_core.c:		mantis->pdev->bus->number, PCI_SLOT(mantis->pdev->devfn), PCI_FUNC(mantis->pdev->devfn));
drivers/media/pci/mantis/mantis_core.c:		mantis->pdev->irq, mantis->latency,
drivers/media/pci/mantis/mantis_pci.c:		mantis->pdev->bus->number,
drivers/media/pci/mantis/mantis_pci.c:		PCI_SLOT(mantis->pdev->devfn),
drivers/media/pci/mantis/mantis_pci.c:		PCI_FUNC(mantis->pdev->devfn));
drivers/media/pci/mantis/mantis_pci.c:	mantis->revision = pdev->revision;
drivers/media/pci/mantis/mantis_pci.c:		mantis->pdev->subsystem_vendor,
drivers/media/pci/mantis/mantis_pci.c:		mantis->pdev->subsystem_device);
drivers/media/pci/mantis/mantis_pci.c:		mantis->pdev->irq,
drivers/media/pci/mantis/mantis_pci.c:	err = request_irq(pdev->irq,
drivers/media/pci/mantis/mantis_pci.c:	free_irq(pdev->irq, mantis);
drivers/media/pci/mantis/mantis_i2c.c:	i2c_adapter->dev.parent	= &pdev->dev;
drivers/media/pci/mantis/mantis_dvb.c:				      &mantis->pdev->dev,
drivers/media/pci/mantis/mantis_input.c:	dev->dev.parent         = &mantis->pdev->dev;
drivers/media/pci/zoran/zoran_card.c:	struct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);
drivers/media/pci/zoran/zoran_card.c:	if (v4l2_device_register(&pdev->dev, &zr->v4l2_dev))
drivers/media/pci/sta2x11/sta2x11_vip.c:	err = dma_set_coherent_mask(&vip->pdev->dev, DMA_BIT_MASK(29));
drivers/media/pci/sta2x11/sta2x11_vip.c:	vip->alloc_ctx = vb2_dma_contig_init_ctx(&vip->pdev->dev);
drivers/media/pci/sta2x11/sta2x11_vip.c:	if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(26))) {
drivers/media/pci/sta2x11/sta2x11_vip.c:		dev_err(&pdev->dev, "26-bit DMA addressing not available\n");
drivers/media/pci/sta2x11/sta2x11_vip.c:	config = dev_get_platdata(&pdev->dev);
drivers/media/pci/sta2x11/sta2x11_vip.c:		dev_info(&pdev->dev, "VIP slot disabled\n");
drivers/media/pci/sta2x11/sta2x11_vip.c:	ret = vip_gpio_reserve(&pdev->dev, config->pwr_pin, 0,
drivers/media/pci/sta2x11/sta2x11_vip.c:		ret = vip_gpio_reserve(&pdev->dev, config->reset_pin, 0,
drivers/media/pci/sta2x11/sta2x11_vip.c:			vip_gpio_release(&pdev->dev, config->pwr_pin,
drivers/media/pci/sta2x11/sta2x11_vip.c:	if (v4l2_device_register(&pdev->dev, &vip->v4l2_dev))
drivers/media/pci/sta2x11/sta2x11_vip.c:	dev_dbg(&pdev->dev, "BAR #0 at 0x%lx 0x%lx irq %d\n",
drivers/media/pci/sta2x11/sta2x11_vip.c:		(unsigned long)pci_resource_len(pdev, 0), pdev->irq);
drivers/media/pci/sta2x11/sta2x11_vip.c:	ret = request_irq(pdev->irq,
drivers/media/pci/sta2x11/sta2x11_vip.c:		dev_err(&pdev->dev, "request_irq failed\n");
drivers/media/pci/sta2x11/sta2x11_vip.c:		dev_err(&pdev->dev, "no I2C adapter found\n");
drivers/media/pci/sta2x11/sta2x11_vip.c:		dev_err(&pdev->dev, "no decoder found\n");
drivers/media/pci/sta2x11/sta2x11_vip.c:	dev_info(&pdev->dev, "STA2X11 Video Input Port (VIP) loaded\n");
drivers/media/pci/sta2x11/sta2x11_vip.c:	free_irq(pdev->irq, vip);
drivers/media/pci/sta2x11/sta2x11_vip.c:	vip_gpio_release(&pdev->dev, config->reset_pin, config->reset_name);
drivers/media/pci/sta2x11/sta2x11_vip.c:	vip_gpio_release(&pdev->dev, config->pwr_pin, config->pwr_name);
drivers/media/pci/sta2x11/sta2x11_vip.c:	free_irq(pdev->irq, vip);
drivers/media/pci/sta2x11/sta2x11_vip.c:	vip_gpio_release(&pdev->dev, vip->config->pwr_pin,
drivers/media/pci/sta2x11/sta2x11_vip.c:	vip_gpio_release(&pdev->dev, vip->config->reset_pin,
drivers/media/pci/ivtv/ivtv-i2c.c:	itv->i2c_adap.dev.parent = &itv->pdev->dev;
drivers/media/pci/ivtv/ivtv-driver.c:	int pci_slot = PCI_SLOT(itv->pdev->devfn);
drivers/media/pci/ivtv/ivtv-driver.c:	itv->has_cx23415 = (itv->pdev->device == PCI_DEVICE_ID_IVTV15);
drivers/media/pci/ivtv/ivtv-driver.c:		if (itv->pdev->subsystem_vendor == IVTV_PCI_ID_HAUPPAUGE ||
drivers/media/pci/ivtv/ivtv-driver.c:		    itv->pdev->subsystem_vendor == IVTV_PCI_ID_HAUPPAUGE_ALT1 ||
drivers/media/pci/ivtv/ivtv-driver.c:		    itv->pdev->subsystem_vendor == IVTV_PCI_ID_HAUPPAUGE_ALT2) {
drivers/media/pci/ivtv/ivtv-driver.c:				if (itv->pdev->device !=
drivers/media/pci/ivtv/ivtv-driver.c:				if (itv->pdev->subsystem_vendor !=
drivers/media/pci/ivtv/ivtv-driver.c:				if (itv->pdev->subsystem_device !=
drivers/media/pci/ivtv/ivtv-driver.c:		     itv->pdev->vendor, itv->pdev->device);
drivers/media/pci/ivtv/ivtv-driver.c:		     itv->pdev->subsystem_vendor, itv->pdev->subsystem_device);
drivers/media/pci/ivtv/ivtv-driver.c:		   pdev->device, pdev->revision, pdev->bus->number,
drivers/media/pci/ivtv/ivtv-driver.c:		   PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
drivers/media/pci/ivtv/ivtv-driver.c:		   pdev->irq, pci_latency, (u64)itv->base_addr);
drivers/media/pci/ivtv/ivtv-driver.c:	retval = v4l2_device_register(&pdev->dev, &itv->v4l2_dev);
drivers/media/pci/ivtv/ivtv-driver.c:	retval = request_irq(itv->pdev->irq, ivtv_irq_handler,
drivers/media/pci/ivtv/ivtv-driver.c:	free_irq(itv->pdev->irq, (void *)itv);
drivers/media/pci/ivtv/ivtv-driver.c:	struct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);
drivers/media/pci/ivtv/ivtv-driver.c:	free_irq(itv->pdev->irq, (void *)itv);
drivers/media/pci/ivtv/ivtv-firmware.c:	if (retries && request_firmware(&fw, fn, &itv->pdev->dev) == 0) {
drivers/media/rc/nuvoton-cir.c:		dev_err(&pdev->dev, "IR PNP Port not valid!\n");
drivers/media/rc/nuvoton-cir.c:		dev_err(&pdev->dev, "PNP IRQ not valid!\n");
drivers/media/rc/nuvoton-cir.c:		dev_err(&pdev->dev, "Wake PNP Port not valid!\n");
drivers/media/rc/nuvoton-cir.c:	rdev->dev.parent = &pdev->dev;
drivers/media/rc/nuvoton-cir.c:	device_init_wakeup(&pdev->dev, true);
drivers/media/rc/gpio-ir-recv.c:					pdev->dev.platform_data;
drivers/media/rc/gpio-ir-recv.c:	if (pdev->dev.of_node) {
drivers/media/rc/gpio-ir-recv.c:			devm_kzalloc(&pdev->dev, sizeof(*dtpdata), GFP_KERNEL);
drivers/media/rc/gpio-ir-recv.c:		rc = gpio_ir_recv_get_devtree_pdata(&pdev->dev, dtpdata);
drivers/media/rc/gpio-ir-recv.c:	rcdev->dev.parent = &pdev->dev;
drivers/media/rc/gpio-ir-recv.c:		dev_err(&pdev->dev, "failed to register rc device\n");
drivers/media/rc/fintek-cir.c:		dev_err(&pdev->dev, "IR PNP Port not valid!\n");
drivers/media/rc/fintek-cir.c:		dev_err(&pdev->dev, "IR PNP IRQ not valid!\n");
drivers/media/rc/fintek-cir.c:	rdev->dev.parent = &pdev->dev;
drivers/media/rc/fintek-cir.c:	device_init_wakeup(&pdev->dev, true);
drivers/media/rc/ite-cir.c:		dev_err(&pdev->dev, "IR PNP Port not valid!\n");
drivers/media/rc/ite-cir.c:		dev_err(&pdev->dev, "PNP IRQ not valid!\n");
drivers/media/platform/s5p-jpeg/jpeg-core.c:	jpeg = devm_kzalloc(&pdev->dev, sizeof(struct s5p_jpeg), GFP_KERNEL);
drivers/media/platform/s5p-jpeg/jpeg-core.c:	jpeg->dev = &pdev->dev;
drivers/media/platform/s5p-jpeg/jpeg-core.c:	jpeg->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/media/platform/s5p-jpeg/jpeg-core.c:		dev_err(&pdev->dev, "cannot find IRQ\n");
drivers/media/platform/s5p-jpeg/jpeg-core.c:	ret = devm_request_irq(&pdev->dev, jpeg->irq, s5p_jpeg_irq, 0,
drivers/media/platform/s5p-jpeg/jpeg-core.c:			dev_name(&pdev->dev), jpeg);
drivers/media/platform/s5p-jpeg/jpeg-core.c:		dev_err(&pdev->dev, "cannot claim IRQ %d\n", jpeg->irq);
drivers/media/platform/s5p-jpeg/jpeg-core.c:	jpeg->clk = clk_get(&pdev->dev, "jpeg");
drivers/media/platform/s5p-jpeg/jpeg-core.c:		dev_err(&pdev->dev, "cannot get clock\n");
drivers/media/platform/s5p-jpeg/jpeg-core.c:	dev_dbg(&pdev->dev, "clock source %p\n", jpeg->clk);
drivers/media/platform/s5p-jpeg/jpeg-core.c:	ret = v4l2_device_register(&pdev->dev, &jpeg->v4l2_dev);
drivers/media/platform/s5p-jpeg/jpeg-core.c:		dev_err(&pdev->dev, "Failed to register v4l2 device\n");
drivers/media/platform/s5p-jpeg/jpeg-core.c:	jpeg->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);
drivers/media/platform/s5p-jpeg/jpeg-core.c:	pm_runtime_enable(&pdev->dev);
drivers/media/platform/s5p-g2d/g2d.c:	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
drivers/media/platform/s5p-g2d/g2d.c:	dev->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/media/platform/s5p-g2d/g2d.c:	dev->clk = clk_get(&pdev->dev, "sclk_fimg2d");
drivers/media/platform/s5p-g2d/g2d.c:		dev_err(&pdev->dev, "failed to get g2d clock\n");
drivers/media/platform/s5p-g2d/g2d.c:		dev_err(&pdev->dev, "failed to prepare g2d clock\n");
drivers/media/platform/s5p-g2d/g2d.c:	dev->gate = clk_get(&pdev->dev, "fimg2d");
drivers/media/platform/s5p-g2d/g2d.c:		dev_err(&pdev->dev, "failed to get g2d clock gate\n");
drivers/media/platform/s5p-g2d/g2d.c:		dev_err(&pdev->dev, "failed to prepare g2d clock gate\n");
drivers/media/platform/s5p-g2d/g2d.c:		dev_err(&pdev->dev, "failed to find IRQ\n");
drivers/media/platform/s5p-g2d/g2d.c:	ret = devm_request_irq(&pdev->dev, dev->irq, g2d_isr,
drivers/media/platform/s5p-g2d/g2d.c:						0, pdev->name, dev);
drivers/media/platform/s5p-g2d/g2d.c:		dev_err(&pdev->dev, "failed to install IRQ\n");
drivers/media/platform/s5p-g2d/g2d.c:	dev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);
drivers/media/platform/s5p-g2d/g2d.c:	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
drivers/media/platform/s5p-g2d/g2d.c:	if (!pdev->dev.of_node) {
drivers/media/platform/s5p-g2d/g2d.c:		of_id = of_match_node(exynos_g2d_match, pdev->dev.of_node);
drivers/media/platform/via-camera.c:	struct viafb_dev *viadev = pdev->dev.platform_data;
drivers/media/platform/via-camera.c:	ret = v4l2_device_register(&pdev->dev, &cam->v4l2_dev);
drivers/media/platform/via-camera.c:		dev_err(&pdev->dev, "Unable to register v4l2 device\n");
drivers/media/platform/via-camera.c:	pdev->dev.dma_mask = &viadev->pdev->dma_mask;
drivers/media/platform/via-camera.c:	dma_set_mask(&pdev->dev, 0xffffffff);
drivers/media/platform/via-camera.c:		dev_err(&pdev->dev, "Unable to find the sensor!\n");
drivers/media/platform/via-camera.c:	ret = request_threaded_irq(viadev->pdev->irq, viacam_quick_irq,
drivers/media/platform/via-camera.c:	free_irq(viadev->pdev->irq, cam);
drivers/media/platform/via-camera.c:	struct viafb_dev *viadev = pdev->dev.platform_data;
drivers/media/platform/via-camera.c:	free_irq(viadev->pdev->irq, cam);
drivers/media/platform/s3c-camif/camif-core.c:			dev_err(&pdev->dev, "failed to get IRQ %d\n", i);
drivers/media/platform/s3c-camif/camif-core.c:		ret = devm_request_irq(&pdev->dev, irq, s3c_camif_irq_handler,
drivers/media/platform/s3c-camif/camif-core.c:				       0, dev_name(&pdev->dev), vp);
drivers/media/platform/s3c-camif/camif-core.c:			dev_err(&pdev->dev, "failed to install IRQ: %d\n", ret);
drivers/media/platform/s3c-camif/camif-core.c:	struct device *dev = &pdev->dev;
drivers/media/platform/s3c-camif/camif-core.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/mem2mem_testdev.c:	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
drivers/media/platform/mem2mem_testdev.c:	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
drivers/media/platform/marvell-ccic/mmp-driver.c:	pdata = cam->pdev->dev.platform_data;
drivers/media/platform/marvell-ccic/mmp-driver.c:	pdata = cam->pdev->dev.platform_data;
drivers/media/platform/marvell-ccic/mmp-driver.c:	mcam->dev = &pdev->dev;
drivers/media/platform/marvell-ccic/mmp-driver.c:		dev_err(&pdev->dev, "no iomem resource!\n");
drivers/media/platform/marvell-ccic/mmp-driver.c:		dev_err(&pdev->dev, "MMIO ioremap fail\n");
drivers/media/platform/marvell-ccic/mmp-driver.c:		dev_err(&pdev->dev, "no power resource!\n");
drivers/media/platform/marvell-ccic/mmp-driver.c:		dev_err(&pdev->dev, "power MMIO ioremap fail\n");
drivers/media/platform/marvell-ccic/mmp-driver.c:	pdata = pdev->dev.platform_data;
drivers/media/platform/marvell-ccic/mmp-driver.c:		dev_err(&pdev->dev, "No i2c adapter\n");
drivers/media/platform/marvell-ccic/mmp-driver.c:		dev_err(&pdev->dev, "Can't get sensor power gpio %d",
drivers/media/platform/marvell-ccic/mmp-driver.c:		dev_err(&pdev->dev, "Can't get sensor reset gpio %d",
drivers/media/platform/marvell-ccic/mmp-driver.c:	pdata = cam->pdev->dev.platform_data;
drivers/media/platform/marvell-ccic/cafe-driver.c:	dev_err(&(cam)->pdev->dev, fmt, ##arg);
drivers/media/platform/marvell-ccic/cafe-driver.c:	dev_warn(&(cam)->pdev->dev, fmt, ##arg);
drivers/media/platform/marvell-ccic/cafe-driver.c:	adap->dev.parent = &cam->pdev->dev;
drivers/media/platform/marvell-ccic/cafe-driver.c:	mcam->dev = &pdev->dev;
drivers/media/platform/marvell-ccic/cafe-driver.c:	ret = request_irq(pdev->irq, cafe_irq, IRQF_SHARED, "cafe-ccic", cam);
drivers/media/platform/marvell-ccic/cafe-driver.c:	free_irq(pdev->irq, cam);
drivers/media/platform/marvell-ccic/cafe-driver.c:	free_irq(cam->pdev->irq, cam);
drivers/media/platform/marvell-ccic/cafe-driver.c:	struct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);
drivers/media/platform/marvell-ccic/cafe-driver.c:	struct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);
drivers/media/platform/marvell-ccic/cafe-driver.c:	struct v4l2_device *v4l2_dev = dev_get_drvdata(&pdev->dev);
drivers/media/platform/sh_vou.c:	struct sh_vou_pdata *vou_pdata = pdev->dev.platform_data;
drivers/media/platform/sh_vou.c:		dev_err(&pdev->dev, "Insufficient VOU platform information.\n");
drivers/media/platform/sh_vou.c:				    pdev->name);
drivers/media/platform/sh_vou.c:		dev_err(&pdev->dev, "VOU region already claimed\n");
drivers/media/platform/sh_vou.c:	ret = v4l2_device_register(&pdev->dev, &vou_dev->v4l2_dev);
drivers/media/platform/sh_vou.c:		dev_err(&pdev->dev, "Error registering v4l2 device\n");
drivers/media/platform/sh_vou.c:	pm_runtime_enable(&pdev->dev);
drivers/media/platform/sh_vou.c:	pm_runtime_resume(&pdev->dev);
drivers/media/platform/sh_vou.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/sh_vou.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/exynos4-is/fimc-isp.c:		ret = pm_runtime_get_sync(&is->pdev->dev);
drivers/media/platform/exynos4-is/fimc-isp.c:			pm_runtime_put(&is->pdev->dev);
drivers/media/platform/exynos4-is/fimc-isp.c:		pm_runtime_put_sync(&is->pdev->dev);
drivers/media/platform/exynos4-is/fimc-is-i2c.c:	struct device_node *node = pdev->dev.of_node;
drivers/media/platform/exynos4-is/fimc-is-i2c.c:	isp_i2c = devm_kzalloc(&pdev->dev, sizeof(*isp_i2c), GFP_KERNEL);
drivers/media/platform/exynos4-is/fimc-is-i2c.c:	isp_i2c->clock = devm_clk_get(&pdev->dev, "i2c_isp");
drivers/media/platform/exynos4-is/fimc-is-i2c.c:		dev_err(&pdev->dev, "failed to get the clock\n");
drivers/media/platform/exynos4-is/fimc-is-i2c.c:	i2c_adap->dev.parent = &pdev->dev;
drivers/media/platform/exynos4-is/fimc-is-i2c.c:		dev_err(&pdev->dev, "failed to add I2C bus %s\n",
drivers/media/platform/exynos4-is/fimc-is-i2c.c:	pm_runtime_enable(&pdev->dev);
drivers/media/platform/exynos4-is/fimc-is-i2c.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/exynos4-is/fimc-m2m.c:	ret = pm_runtime_get_sync(&ctx->fimc_dev->pdev->dev);
drivers/media/platform/exynos4-is/fimc-m2m.c:	pm_runtime_put(&ctx->fimc_dev->pdev->dev);
drivers/media/platform/exynos4-is/fimc-m2m.c:	__fimc_vidioc_querycap(&fimc->pdev->dev, cap, caps);
drivers/media/platform/exynos4-is/fimc-is-regs.c:			dev_warn(&is->pdev->dev, "%s timeout\n",
drivers/media/platform/exynos4-is/fimc-is-regs.c:			dev_warn(&is->pdev->dev, "%s timeout\n",
drivers/media/platform/exynos4-is/fimc-is-regs.c:		dev_err(&is->pdev->dev, "%s() timeout\n", __func__);
drivers/media/platform/exynos4-is/fimc-is-regs.c:		dev_err(&is->pdev->dev, "%s(): mode change (%d) timeout\n",
drivers/media/platform/exynos4-is/mipi-csis.c:	struct device *dev = &state->pdev->dev;
drivers/media/platform/exynos4-is/mipi-csis.c:	struct device *dev = &state->pdev->dev;
drivers/media/platform/exynos4-is/mipi-csis.c:		ret = pm_runtime_get_sync(&state->pdev->dev);
drivers/media/platform/exynos4-is/mipi-csis.c:		pm_runtime_put(&state->pdev->dev);
drivers/media/platform/exynos4-is/mipi-csis.c:	struct s5p_platform_mipi_csis *pdata = pdev->dev.platform_data;
drivers/media/platform/exynos4-is/mipi-csis.c:		dev_err(&pdev->dev, "Platform data not specified\n");
drivers/media/platform/exynos4-is/mipi-csis.c:	state->index = max(0, pdev->id);
drivers/media/platform/exynos4-is/mipi-csis.c:	struct device_node *node = pdev->dev.of_node;
drivers/media/platform/exynos4-is/mipi-csis.c:		dev_err(&pdev->dev, "No port node at %s\n",
drivers/media/platform/exynos4-is/mipi-csis.c:				pdev->dev.of_node->full_name);
drivers/media/platform/exynos4-is/mipi-csis.c:	struct device *dev = &pdev->dev;
drivers/media/platform/exynos4-is/mipi-csis.c:	dev_info(&pdev->dev, "lanes: %d, hs_settle: %d, wclk: %d, freq: %u\n",
drivers/media/platform/exynos4-is/mipi-csis.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/exynos4-is/mipi-csis.c:	s5pcsis_pm_suspend(&pdev->dev, false);
drivers/media/platform/exynos4-is/mipi-csis.c:	pm_runtime_set_suspended(&pdev->dev);
drivers/media/platform/exynos4-is/fimc-is.c:		is->clocks[i] = clk_get(&is->pdev->dev, fimc_is_clocks[i]);
drivers/media/platform/exynos4-is/fimc-is.c:	dev_err(&is->pdev->dev, "failed to get clock: %s\n",
drivers/media/platform/exynos4-is/fimc-is.c:			dev_err(&is->pdev->dev, "clock %s enable failed\n",
drivers/media/platform/exynos4-is/fimc-is.c:				dev_warn(&is->pdev->dev, "DT parse error: %s\n",
drivers/media/platform/exynos4-is/fimc-is.c:	ret = request_firmware(&fw, file_name, &is->pdev->dev);
drivers/media/platform/exynos4-is/fimc-is.c:		dev_err(&is->pdev->dev, "firmware request failed (%d)\n", ret);
drivers/media/platform/exynos4-is/fimc-is.c:		dev_WARN(&is->pdev->dev, "%s() timed out\n", __func__);
drivers/media/platform/exynos4-is/fimc-is.c:	struct device *dev = &is->pdev->dev;
drivers/media/platform/exynos4-is/fimc-is.c:	struct device *dev = &is->pdev->dev;
drivers/media/platform/exynos4-is/fimc-is.c:	struct device *dev = &is->pdev->dev;
drivers/media/platform/exynos4-is/fimc-is.c:	struct device *dev = &is->pdev->dev;
drivers/media/platform/exynos4-is/fimc-is.c:				FW_ACTION_HOTPLUG, fw_name, &is->pdev->dev,
drivers/media/platform/exynos4-is/fimc-is.c:	struct device *dev = &is->pdev->dev;
drivers/media/platform/exynos4-is/fimc-is.c:		dev_err(&is->pdev->dev, "firmware memory is not initialized\n");
drivers/media/platform/exynos4-is/fimc-is.c:	struct device *dev = &pdev->dev;
drivers/media/platform/exynos4-is/fimc-is.c:	is = devm_kzalloc(&pdev->dev, sizeof(*is), GFP_KERNEL);
drivers/media/platform/exynos4-is/fimc-is.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/exynos4-is/fimc-is.c:	pm_runtime_set_suspended(&pdev->dev);
drivers/media/platform/exynos4-is/fimc-lite.c:	ret = pm_runtime_get_sync(&fimc->pdev->dev);
drivers/media/platform/exynos4-is/fimc-lite.c:	pm_runtime_put_sync(&fimc->pdev->dev);
drivers/media/platform/exynos4-is/fimc-lite.c:	pm_runtime_put(&fimc->pdev->dev);
drivers/media/platform/exynos4-is/fimc-lite.c:	fimc->clock = clk_get(&fimc->pdev->dev, FLITE_CLK_NAME);
drivers/media/platform/exynos4-is/fimc-lite.c:	struct device *dev = &pdev->dev;
drivers/media/platform/exynos4-is/fimc-lite.c:		fimc->index = pdev->id;
drivers/media/platform/exynos4-is/fimc-lite.c:	struct device *dev = &pdev->dev;
drivers/media/platform/exynos4-is/fimc-core.c:	struct device *dev = &ctx->fimc_dev->pdev->dev;
drivers/media/platform/exynos4-is/fimc-core.c:		fimc->clock[i] = clk_get(&fimc->pdev->dev, fimc_clocks[i]);
drivers/media/platform/exynos4-is/fimc-core.c:	dev_err(&fimc->pdev->dev, "failed to get clock: %s\n",
drivers/media/platform/exynos4-is/fimc-core.c:	struct device *dev = &fimc->pdev->dev;
drivers/media/platform/exynos4-is/fimc-core.c:	struct device *dev = &pdev->dev;
drivers/media/platform/exynos4-is/fimc-core.c:		fimc->id = pdev->id;
drivers/media/platform/exynos4-is/fimc-core.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/exynos4-is/fimc-core.c:	pm_runtime_set_suspended(&pdev->dev);
drivers/media/platform/exynos4-is/fimc-core.c:	dev_info(&pdev->dev, "driver unloaded\n");
drivers/media/platform/exynos4-is/fimc-capture.c:	ret = pm_runtime_get_sync(&fimc->pdev->dev);
drivers/media/platform/exynos4-is/fimc-capture.c:		pm_runtime_put(&fimc->pdev->dev);
drivers/media/platform/exynos4-is/fimc-capture.c:			pm_runtime_put_sync(&fimc->pdev->dev);
drivers/media/platform/exynos4-is/fimc-capture.c:	pm_runtime_put(&fimc->pdev->dev);
drivers/media/platform/exynos4-is/fimc-capture.c:	__fimc_vidioc_querycap(&fimc->pdev->dev, cap, V4L2_CAP_STREAMING |
drivers/media/platform/exynos4-is/media-dev.c:	struct device_node *parent = fmd->pdev->dev.of_node;
drivers/media/platform/exynos4-is/media-dev.c:	struct s5p_platform_fimc *pdata = fmd->pdev->dev.platform_data;
drivers/media/platform/exynos4-is/media-dev.c:	struct device_node *of_node = fmd->pdev->dev.of_node;
drivers/media/platform/exynos4-is/media-dev.c:			fmd->pmf = &fimc->pdev->dev;
drivers/media/platform/exynos4-is/media-dev.c:	struct device_node *node = pdev->dev.of_node;
drivers/media/platform/exynos4-is/media-dev.c:	id = node ? __of_get_csis_id(node) : max(0, pdev->id);
drivers/media/platform/exynos4-is/media-dev.c:	struct device *dev = &pdev->dev;
drivers/media/platform/exynos4-is/media-dev.c:		dev_info(&fmd->pdev->dev, "deferring %s device registration\n",
drivers/media/platform/exynos4-is/media-dev.c:		dev_err(&fmd->pdev->dev, "%s device registration failed (%d)\n",
drivers/media/platform/exynos4-is/media-dev.c:	if (!strcmp(pdev->name, CSIS_DRIVER_NAME)) {
drivers/media/platform/exynos4-is/media-dev.c:	} else if (!strcmp(pdev->name, FIMC_LITE_DRV_NAME)) {
drivers/media/platform/exynos4-is/media-dev.c:		p = strstr(pdev->name, "fimc");
drivers/media/platform/exynos4-is/media-dev.c:		put_device(&pdev->dev);
drivers/media/platform/exynos4-is/media-dev.c:	if (fmd->pdev->dev.of_node)
drivers/media/platform/exynos4-is/media-dev.c:		dev = &fmd->pdev->dev;
drivers/media/platform/exynos4-is/media-dev.c:			dev_err(&fmd->pdev->dev, "Failed to get clock: %s\n",
drivers/media/platform/exynos4-is/media-dev.c:	struct device *dev = &fmd->pdev->dev;
drivers/media/platform/exynos4-is/media-dev.c:	struct device *dev = &pdev->dev;
drivers/media/platform/exynos4-is/media-dev.c:	ret = device_create_file(&pdev->dev, &dev_attr_subdev_conf_mode);
drivers/media/platform/exynos4-is/media-dev.c:	device_remove_file(&pdev->dev, &dev_attr_subdev_conf_mode);
drivers/media/platform/coda.c:	dev->codebuf.vaddr = dma_alloc_coherent(&pdev->dev, fw->size,
drivers/media/platform/coda.c:		dev_err(&pdev->dev, "failed to allocate code buffer\n");
drivers/media/platform/coda.c:	dev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);
drivers/media/platform/coda.c:			of_match_device(of_match_ptr(coda_dt_ids), &pdev->dev);
drivers/media/platform/coda.c:	struct coda_platform_data *pdata = pdev->dev.platform_data;
drivers/media/platform/coda.c:	struct device_node *np = pdev->dev.of_node;
drivers/media/platform/coda.c:	dev = devm_kzalloc(&pdev->dev, sizeof *dev, GFP_KERNEL);
drivers/media/platform/coda.c:		dev_err(&pdev->dev, "Not enough memory for %s\n",
drivers/media/platform/coda.c:	dev->clk_per = devm_clk_get(&pdev->dev, "per");
drivers/media/platform/coda.c:		dev_err(&pdev->dev, "Could not get per clock\n");
drivers/media/platform/coda.c:	dev->clk_ahb = devm_clk_get(&pdev->dev, "ahb");
drivers/media/platform/coda.c:		dev_err(&pdev->dev, "Could not get ahb clock\n");
drivers/media/platform/coda.c:		dev_err(&pdev->dev, "failed to get memory region resource\n");
drivers/media/platform/coda.c:	if (devm_request_mem_region(&pdev->dev, res->start,
drivers/media/platform/coda.c:		dev_err(&pdev->dev, "failed to request memory region\n");
drivers/media/platform/coda.c:	dev->regs_base = devm_ioremap(&pdev->dev, res->start,
drivers/media/platform/coda.c:		dev_err(&pdev->dev, "failed to ioremap address region\n");
drivers/media/platform/coda.c:		dev_err(&pdev->dev, "failed to get irq resource\n");
drivers/media/platform/coda.c:	if (devm_request_irq(&pdev->dev, irq, coda_irq_handler,
drivers/media/platform/coda.c:		dev_err(&pdev->dev, "failed to request irq\n");
drivers/media/platform/coda.c:		dev_err(&pdev->dev, "iram pool not available\n");
drivers/media/platform/coda.c:	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
drivers/media/platform/coda.c:	dev->workbuf.vaddr = dma_alloc_coherent(&pdev->dev, dev->workbuf.size,
drivers/media/platform/coda.c:		dev_err(&pdev->dev, "failed to allocate work buffer\n");
drivers/media/platform/coda.c:		dev_err(&pdev->dev, "unable to alloc iram\n");
drivers/media/platform/coda.c:		dma_free_coherent(&pdev->dev, dev->codebuf.size,
drivers/media/platform/coda.c:		dma_free_coherent(&pdev->dev, dev->workbuf.size, &dev->workbuf.vaddr,
drivers/media/platform/soc_camera/atmel-isi.c:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
drivers/media/platform/soc_camera/atmel-isi.c:	dma_free_coherent(&pdev->dev,
drivers/media/platform/soc_camera/atmel-isi.c:	struct device *dev = &pdev->dev;
drivers/media/platform/soc_camera/atmel-isi.c:		dev_err(&pdev->dev,
drivers/media/platform/soc_camera/atmel-isi.c:	pclk = clk_get(&pdev->dev, "isi_clk");
drivers/media/platform/soc_camera/atmel-isi.c:		dev_err(&pdev->dev, "Can't allocate interface!\n");
drivers/media/platform/soc_camera/atmel-isi.c:	isi->p_fb_descriptors = dma_alloc_coherent(&pdev->dev,
drivers/media/platform/soc_camera/atmel-isi.c:		dev_err(&pdev->dev, "Can't allocate descriptors!\n");
drivers/media/platform/soc_camera/atmel-isi.c:	isi->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);
drivers/media/platform/soc_camera/atmel-isi.c:		dev_err(&pdev->dev, "Unable to request irq %d\n", irq);
drivers/media/platform/soc_camera/atmel-isi.c:	soc_host->v4l2_dev.dev	= &pdev->dev;
drivers/media/platform/soc_camera/atmel-isi.c:	soc_host->nr		= pdev->id;
drivers/media/platform/soc_camera/atmel-isi.c:		dev_err(&pdev->dev, "Unable to register soc camera host\n");
drivers/media/platform/soc_camera/atmel-isi.c:	dma_free_coherent(&pdev->dev,
drivers/media/platform/soc_camera/soc_camera_platform.c:	struct soc_camera_platform_info *p = pdev->dev.platform_data;
drivers/media/platform/soc_camera/soc_camera_platform.c:		dev_err(&pdev->dev,
drivers/media/platform/soc_camera/soc_camera_platform.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
drivers/media/platform/soc_camera/soc_camera_platform.c:	icd->control = &pdev->dev;
drivers/media/platform/soc_camera/soc_camera_platform.c:	strncpy(priv->subdev.name, dev_name(&pdev->dev), V4L2_SUBDEV_NAME_SIZE);
drivers/media/platform/soc_camera/soc_camera.c:	struct soc_camera_desc *sdesc = pdev->dev.platform_data;
drivers/media/platform/soc_camera/soc_camera.c:	icd = devm_kzalloc(&pdev->dev, sizeof(*icd), GFP_KERNEL);
drivers/media/platform/soc_camera/soc_camera.c:	ret = devm_regulator_bulk_get(&pdev->dev, ssdd->num_regulators,
drivers/media/platform/soc_camera/soc_camera.c:	icd->pdev = &pdev->dev;
drivers/media/platform/soc_camera/pxa_camera.c:	struct device *dev = &pdev->dev;
drivers/media/platform/soc_camera/pxa_camera.c:	pcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);
drivers/media/platform/soc_camera/pxa_camera.c:		dev_err(&pdev->dev, "Could not allocate pcdev\n");
drivers/media/platform/soc_camera/pxa_camera.c:	pcdev->clk = devm_clk_get(&pdev->dev, NULL);
drivers/media/platform/soc_camera/pxa_camera.c:	pcdev->pdata = pdev->dev.platform_data;
drivers/media/platform/soc_camera/pxa_camera.c:		dev_warn(&pdev->dev, "WARNING! Platform hasn't set available "
drivers/media/platform/soc_camera/pxa_camera.c:		dev_warn(&pdev->dev,
drivers/media/platform/soc_camera/pxa_camera.c:	base = devm_ioremap_resource(&pdev->dev, res);
drivers/media/platform/soc_camera/pxa_camera.c:		dev_err(&pdev->dev, "Can't request DMA for Y\n");
drivers/media/platform/soc_camera/pxa_camera.c:	dev_dbg(&pdev->dev, "got DMA channel %d\n", pcdev->dma_chans[0]);
drivers/media/platform/soc_camera/pxa_camera.c:		dev_err(&pdev->dev, "Can't request DMA for U\n");
drivers/media/platform/soc_camera/pxa_camera.c:	dev_dbg(&pdev->dev, "got DMA channel (U) %d\n", pcdev->dma_chans[1]);
drivers/media/platform/soc_camera/pxa_camera.c:		dev_err(&pdev->dev, "Can't request DMA for V\n");
drivers/media/platform/soc_camera/pxa_camera.c:	dev_dbg(&pdev->dev, "got DMA channel (V) %d\n", pcdev->dma_chans[2]);
drivers/media/platform/soc_camera/pxa_camera.c:	err = devm_request_irq(&pdev->dev, pcdev->irq, pxa_camera_irq, 0,
drivers/media/platform/soc_camera/pxa_camera.c:		dev_err(&pdev->dev, "Camera interrupt register failed\n");
drivers/media/platform/soc_camera/pxa_camera.c:	pcdev->soc_host.v4l2_dev.dev	= &pdev->dev;
drivers/media/platform/soc_camera/pxa_camera.c:	pcdev->soc_host.nr		= pdev->id;
drivers/media/platform/soc_camera/pxa_camera.c:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
drivers/media/platform/soc_camera/pxa_camera.c:	dev_info(&pdev->dev, "PXA Camera driver unloaded\n");
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		if (&pcdev->csi2_pdev->dev == v4l2_get_subdevdata(sd))
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		dev_err(&pdev->dev, "Not enough CEU platform resources.\n");
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	pcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		dev_err(&pdev->dev, "Could not allocate pcdev\n");
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	pcdev->pdata = pdev->dev.platform_data;
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		dev_err(&pdev->dev, "CEU platform data not set.\n");
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	base = devm_ioremap_resource(&pdev->dev, res);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		err = dma_declare_coherent_memory(&pdev->dev, res->start,
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:			dev_err(&pdev->dev, "Unable to declare CEU memory.\n");
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	err = devm_request_irq(&pdev->dev, pcdev->irq, sh_mobile_ceu_irq,
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:			       IRQF_DISABLED, dev_name(&pdev->dev), pcdev);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		dev_err(&pdev->dev, "Unable to register CEU interrupt.\n");
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	pm_suspend_ignore_children(&pdev->dev, true);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	pm_runtime_enable(&pdev->dev);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	pm_runtime_resume(&pdev->dev);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	pcdev->ici.v4l2_dev.dev = &pdev->dev;
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	pcdev->ici.nr = pdev->id;
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	pcdev->ici.drv_name = dev_name(&pdev->dev);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	pcdev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		csi2_pdata			= csi2_pdev->dev.platform_data;
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		csi2_pdev->resource		= csi2->resource;
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		csi2_pdev->num_resources	= csi2->num_resources;
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		wait.dev = &csi2_pdev->dev;
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		if (!csi2_pdev->dev.driver) {
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		err = try_module_get(csi2_pdev->dev.driver->owner);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	pcdev->csi2_pdev->resource = NULL;
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		dma_release_declared_memory(&pdev->dev);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		dma_release_declared_memory(&pdev->dev);
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:	if (csi2_pdev && csi2_pdev->dev.driver) {
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		struct module *csi2_drv = csi2_pdev->dev.driver->owner;
drivers/media/platform/soc_camera/sh_mobile_ceu_camera.c:		csi2_pdev->resource = NULL;
drivers/media/platform/soc_camera/omap1_camera.c:	clk = clk_get(&pdev->dev, "armper_ck");
drivers/media/platform/soc_camera/omap1_camera.c:		dev_err(&pdev->dev, "Could not allocate pcdev\n");
drivers/media/platform/soc_camera/omap1_camera.c:	pcdev->pdata = pdev->dev.platform_data;
drivers/media/platform/soc_camera/omap1_camera.c:		dev_warn(&pdev->dev,
drivers/media/platform/soc_camera/omap1_camera.c:		dev_info(&pdev->dev, "Not providing sensor clock\n");
drivers/media/platform/soc_camera/omap1_camera.c:		dev_err(&pdev->dev, "Can't request DMA for OMAP1 Camera\n");
drivers/media/platform/soc_camera/omap1_camera.c:	dev_dbg(&pdev->dev, "got DMA channel %d\n", pcdev->dma_ch);
drivers/media/platform/soc_camera/omap1_camera.c:		dev_err(&pdev->dev, "Camera interrupt register failed\n");
drivers/media/platform/soc_camera/omap1_camera.c:	pcdev->soc_host.v4l2_dev.dev	= &pdev->dev;
drivers/media/platform/soc_camera/omap1_camera.c:	pcdev->soc_host.nr		= pdev->id;
drivers/media/platform/soc_camera/omap1_camera.c:	dev_info(&pdev->dev, "OMAP1 Camera Interface driver loaded\n");
drivers/media/platform/soc_camera/omap1_camera.c:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
drivers/media/platform/soc_camera/omap1_camera.c:	dev_info(&pdev->dev, "OMAP1 Camera Interface driver unloaded\n");
drivers/media/platform/soc_camera/mx3_camera.c:		dev_err(&pdev->dev, "Could not allocate mx3 camera object\n");
drivers/media/platform/soc_camera/mx3_camera.c:	mx3_cam->clk = clk_get(&pdev->dev, NULL);
drivers/media/platform/soc_camera/mx3_camera.c:	mx3_cam->pdata = pdev->dev.platform_data;
drivers/media/platform/soc_camera/mx3_camera.c:		dev_warn(&pdev->dev, "WARNING! Platform hasn't set available "
drivers/media/platform/soc_camera/mx3_camera.c:		dev_warn(&pdev->dev,
drivers/media/platform/soc_camera/mx3_camera.c:	soc_host->v4l2_dev.dev	= &pdev->dev;
drivers/media/platform/soc_camera/mx3_camera.c:	soc_host->nr		= pdev->id;
drivers/media/platform/soc_camera/mx3_camera.c:	mx3_cam->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);
drivers/media/platform/soc_camera/mx3_camera.c:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
drivers/media/platform/soc_camera/mx1_camera.c:	clk = clk_get(&pdev->dev, "csi_clk");
drivers/media/platform/soc_camera/mx1_camera.c:		dev_err(&pdev->dev, "Could not allocate pcdev\n");
drivers/media/platform/soc_camera/mx1_camera.c:	pcdev->pdata = pdev->dev.platform_data;
drivers/media/platform/soc_camera/mx1_camera.c:		dev_warn(&pdev->dev,
drivers/media/platform/soc_camera/mx1_camera.c:		dev_err(&pdev->dev, "Can't request DMA for MX1 CSI\n");
drivers/media/platform/soc_camera/mx1_camera.c:	dev_dbg(&pdev->dev, "got DMA channel %d\n", pcdev->dma_chan);
drivers/media/platform/soc_camera/mx1_camera.c:		dev_err(&pdev->dev, "Camera interrupt register failed\n");
drivers/media/platform/soc_camera/mx1_camera.c:	pcdev->soc_host.v4l2_dev.dev	= &pdev->dev;
drivers/media/platform/soc_camera/mx1_camera.c:	pcdev->soc_host.nr		= pdev->id;
drivers/media/platform/soc_camera/mx1_camera.c:	dev_info(&pdev->dev, "MX1 Camera driver loaded\n");
drivers/media/platform/soc_camera/mx1_camera.c:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
drivers/media/platform/soc_camera/mx1_camera.c:	dev_info(&pdev->dev, "MX1 Camera driver unloaded\n");
drivers/media/platform/soc_camera/sh_mobile_csi2.c:	struct sh_csi2_pdata *pdata = priv->pdev->dev.platform_data;
drivers/media/platform/soc_camera/sh_mobile_csi2.c:	struct sh_csi2_pdata *pdata = priv->pdev->dev.platform_data;
drivers/media/platform/soc_camera/sh_mobile_csi2.c:	struct sh_csi2_pdata *pdata = priv->pdev->dev.platform_data;
drivers/media/platform/soc_camera/sh_mobile_csi2.c:		if (&pdata->clients[i].pdev->dev == icd->pdev)
drivers/media/platform/soc_camera/sh_mobile_csi2.c:	struct sh_csi2_pdata *pdata = pdev->dev.platform_data;
drivers/media/platform/soc_camera/sh_mobile_csi2.c:		dev_err(&pdev->dev, "Not enough CSI2 platform resources.\n");
drivers/media/platform/soc_camera/sh_mobile_csi2.c:		dev_err(&pdev->dev, "Only CSI2C supported ATM.\n");
drivers/media/platform/soc_camera/sh_mobile_csi2.c:	priv = devm_kzalloc(&pdev->dev, sizeof(struct sh_csi2), GFP_KERNEL);
drivers/media/platform/soc_camera/sh_mobile_csi2.c:	priv->base = devm_ioremap_resource(&pdev->dev, res);
drivers/media/platform/soc_camera/sh_mobile_csi2.c:	v4l2_set_subdevdata(&priv->subdev, &pdev->dev);
drivers/media/platform/soc_camera/sh_mobile_csi2.c:	dev_dbg(&pdev->dev, "%s(%p): ret(register_subdev) = %d\n", __func__, priv, ret);
drivers/media/platform/soc_camera/sh_mobile_csi2.c:	pm_runtime_enable(&pdev->dev);
drivers/media/platform/soc_camera/sh_mobile_csi2.c:	dev_dbg(&pdev->dev, "CSI2 probed.\n");
drivers/media/platform/soc_camera/sh_mobile_csi2.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/soc_camera/mx2_camera.c:	dev_dbg(&pdev->dev, "initialising\n");
drivers/media/platform/soc_camera/mx2_camera.c:		dev_err(&pdev->dev, "Missing platform resources data\n");
drivers/media/platform/soc_camera/mx2_camera.c:	pcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);
drivers/media/platform/soc_camera/mx2_camera.c:		dev_err(&pdev->dev, "Could not allocate pcdev\n");
drivers/media/platform/soc_camera/mx2_camera.c:	pcdev->clk_csi_ahb = devm_clk_get(&pdev->dev, "ahb");
drivers/media/platform/soc_camera/mx2_camera.c:		dev_err(&pdev->dev, "Could not get csi ahb clock\n");
drivers/media/platform/soc_camera/mx2_camera.c:	pcdev->clk_csi_per = devm_clk_get(&pdev->dev, "per");
drivers/media/platform/soc_camera/mx2_camera.c:		dev_err(&pdev->dev, "Could not get csi per clock\n");
drivers/media/platform/soc_camera/mx2_camera.c:	pcdev->pdata = pdev->dev.platform_data;
drivers/media/platform/soc_camera/mx2_camera.c:	pcdev->base_csi = devm_ioremap_resource(&pdev->dev, res_csi);
drivers/media/platform/soc_camera/mx2_camera.c:	pcdev->dev = &pdev->dev;
drivers/media/platform/soc_camera/mx2_camera.c:	pcdev->soc_host.v4l2_dev.dev	= &pdev->dev;
drivers/media/platform/soc_camera/mx2_camera.c:	pcdev->soc_host.nr		= pdev->id;
drivers/media/platform/soc_camera/mx2_camera.c:	pcdev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);
drivers/media/platform/soc_camera/mx2_camera.c:	dev_info(&pdev->dev, "MX2 Camera (CSI) driver probed, clock frequency: %ld\n",
drivers/media/platform/soc_camera/mx2_camera.c:	struct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);
drivers/media/platform/soc_camera/mx2_camera.c:	dev_info(&pdev->dev, "MX2 Camera driver unloaded\n");
drivers/media/platform/m2m-deinterlace.c:	ret = v4l2_device_register(&pdev->dev, &pcdev->v4l2_dev);
drivers/media/platform/m2m-deinterlace.c:	pcdev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);
drivers/media/platform/omap/omap_vout.c:	dev_info(&pdev->dev, "Buffer Size = %d\n", vout->buffer_size);
drivers/media/platform/omap/omap_vout.c:	for (k = 0; k < pdev->num_resources; k++) {
drivers/media/platform/omap/omap_vout.c:			dev_err(&pdev->dev, ": could not allocate memory\n");
drivers/media/platform/omap/omap_vout.c:		if (pdev->num_resources == 1)
drivers/media/platform/omap/omap_vout.c:			dev_err(&pdev->dev, ": Could not register "
drivers/media/platform/omap/omap_vout.c:		dev_info(&pdev->dev, ": registered and initialized"
drivers/media/platform/omap/omap_vout.c:		if (k == (pdev->num_resources - 1))
drivers/media/platform/omap/omap_vout.c:	for (k = 0; k < pdev->num_resources; k++)
drivers/media/platform/omap/omap_vout.c:		dev_err(&pdev->dev, "failed to init dss\n");
drivers/media/platform/omap/omap_vout.c:	if (pdev->num_resources == 0) {
drivers/media/platform/omap/omap_vout.c:		dev_err(&pdev->dev, "probed for an unknown device\n");
drivers/media/platform/omap/omap_vout.c:			dev_warn(&pdev->dev, "no driver for display: %s\n",
drivers/media/platform/omap/omap_vout.c:		dev_err(&pdev->dev, "no displays\n");
drivers/media/platform/omap/omap_vout.c:			dev_warn(&pdev->dev, "cannot find display\n");
drivers/media/platform/omap/omap_vout.c:				dev_warn(&pdev->dev,
drivers/media/platform/omap/omap_vout.c:	if (v4l2_device_register(&pdev->dev, &vid_dev->v4l2_dev) < 0) {
drivers/media/platform/omap/omap_vout.c:		dev_err(&pdev->dev, "v4l2_device_register failed\n");
drivers/media/platform/omap/omap_vout_vrfb.c:			dev_info(&pdev->dev, ": VRFB allocation failed\n");
drivers/media/platform/omap/omap_vout_vrfb.c:		dev_info(&pdev->dev, ": failed to allocate DMA Channel for"
drivers/media/platform/s5p-mfc/s5p_mfc.c:	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
drivers/media/platform/s5p-mfc/s5p_mfc.c:		dev_err(&pdev->dev, "Not enough memory for MFC device\n");
drivers/media/platform/s5p-mfc/s5p_mfc.c:		dev_err(&pdev->dev, "No platform data specified\n");
drivers/media/platform/s5p-mfc/s5p_mfc.c:		dev_err(&pdev->dev, "failed to get mfc clock source\n");
drivers/media/platform/s5p-mfc/s5p_mfc.c:	dev->regs_base = devm_ioremap_resource(&pdev->dev, res);
drivers/media/platform/s5p-mfc/s5p_mfc.c:		dev_err(&pdev->dev, "failed to get irq resource\n");
drivers/media/platform/s5p-mfc/s5p_mfc.c:	ret = devm_request_irq(&pdev->dev, dev->irq, s5p_mfc_irq,
drivers/media/platform/s5p-mfc/s5p_mfc.c:					IRQF_DISABLED, pdev->name, dev);
drivers/media/platform/s5p-mfc/s5p_mfc.c:		dev_err(&pdev->dev, "Failed to install irq (%d)\n", ret);
drivers/media/platform/s5p-mfc/s5p_mfc.c:	if (pdev->dev.of_node) {
drivers/media/platform/s5p-mfc/s5p_mfc.c:	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
drivers/media/platform/s5p-mfc/s5p_mfc.c:	v4l2_info(&dev->v4l2_dev, "Removing %s\n", pdev->name);
drivers/media/platform/s5p-mfc/s5p_mfc.c:	if (pdev->dev.of_node) {
drivers/media/platform/s5p-mfc/s5p_mfc.c:	if (pdev->dev.of_node) {
drivers/media/platform/s5p-mfc/s5p_mfc.c:				pdev->dev.of_node);
drivers/media/platform/s5p-tv/hdmi_drv.c:	struct device *dev = &pdev->dev;
drivers/media/platform/s5p-tv/hdmi_drv.c:	hdmi_dev = devm_kzalloc(&pdev->dev, sizeof(*hdmi_dev), GFP_KERNEL);
drivers/media/platform/s5p-tv/hdmi_drv.c:	hdmi_dev->regs = devm_ioremap(&pdev->dev, res->start,
drivers/media/platform/s5p-tv/hdmi_drv.c:	ret = devm_request_irq(&pdev->dev, res->start, hdmi_irq_handler, 0,
drivers/media/platform/s5p-tv/hdmi_drv.c:	struct device *dev = &pdev->dev;
drivers/media/platform/s5p-tv/sdo_drv.c:	struct device *dev = &pdev->dev;
drivers/media/platform/s5p-tv/sdo_drv.c:	sdev = devm_kzalloc(&pdev->dev, sizeof(*sdev), GFP_KERNEL);
drivers/media/platform/s5p-tv/sdo_drv.c:	sdev->regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/media/platform/s5p-tv/sdo_drv.c:	ret = devm_request_irq(&pdev->dev, res->start, sdo_irq_handler, 0,
drivers/media/platform/s5p-tv/sdo_drv.c:	struct v4l2_subdev *sd = dev_get_drvdata(&pdev->dev);
drivers/media/platform/s5p-tv/sdo_drv.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/s5p-tv/sdo_drv.c:	dev_info(&pdev->dev, "remove successful\n");
drivers/media/platform/s5p-tv/mixer_drv.c:	struct device *dev = &pdev->dev;
drivers/media/platform/s5p-tv/mixer_drv.c:	struct device *dev = &pdev->dev;
drivers/media/platform/blackfin/bfin_capture.c:	config = pdev->dev.platform_data;
drivers/media/platform/blackfin/bfin_capture.c:		v4l2_err(pdev->dev.driver, "Unable to get board config\n");
drivers/media/platform/blackfin/bfin_capture.c:		v4l2_err(pdev->dev.driver, "Unable to alloc bcap_dev\n");
drivers/media/platform/blackfin/bfin_capture.c:		v4l2_err(pdev->dev.driver, "Unable to create ppi\n");
drivers/media/platform/blackfin/bfin_capture.c:	bcap_dev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);
drivers/media/platform/blackfin/bfin_capture.c:		v4l2_err(pdev->dev.driver, "Unable to alloc video device\n");
drivers/media/platform/blackfin/bfin_capture.c:	ret = v4l2_device_register(&pdev->dev, &bcap_dev->v4l2_dev);
drivers/media/platform/blackfin/bfin_capture.c:		v4l2_err(pdev->dev.driver,
drivers/media/platform/exynos-gsc/gsc-m2m.c:	ret = pm_runtime_get_sync(&ctx->gsc_dev->pdev->dev);
drivers/media/platform/exynos-gsc/gsc-m2m.c:	pm_runtime_put(&ctx->gsc_dev->pdev->dev);
drivers/media/platform/exynos-gsc/gsc-m2m.c:	strlcpy(cap->driver, gsc->pdev->name, sizeof(cap->driver));
drivers/media/platform/exynos-gsc/gsc-m2m.c:	strlcpy(cap->card, gsc->pdev->name, sizeof(cap->card));
drivers/media/platform/exynos-gsc/gsc-m2m.c:		dev_err(&pdev->dev, "failed to initialize v4l2-m2m device\n");
drivers/media/platform/exynos-gsc/gsc-m2m.c:		dev_err(&pdev->dev,
drivers/media/platform/exynos-gsc/gsc-core.c:	struct device *dev = &ctx->gsc_dev->pdev->dev;
drivers/media/platform/exynos-gsc/gsc-core.c:	if (pdev->dev.of_node) {
drivers/media/platform/exynos-gsc/gsc-core.c:					pdev->dev.of_node);
drivers/media/platform/exynos-gsc/gsc-core.c:	dev_dbg(&gsc->pdev->dev, "gsc_clk_get Called\n");
drivers/media/platform/exynos-gsc/gsc-core.c:	gsc->clock = devm_clk_get(&gsc->pdev->dev, GSC_CLOCK_GATE_NAME);
drivers/media/platform/exynos-gsc/gsc-core.c:		dev_err(&gsc->pdev->dev, "failed to get clock~~~: %s\n",
drivers/media/platform/exynos-gsc/gsc-core.c:		dev_err(&gsc->pdev->dev, "clock prepare failed for clock: %s\n",
drivers/media/platform/exynos-gsc/gsc-core.c:	struct device *dev = &pdev->dev;
drivers/media/platform/exynos-gsc/gsc-core.c:		gsc->id = of_alias_get_id(pdev->dev.of_node, "gsc");
drivers/media/platform/exynos-gsc/gsc-core.c:		gsc->id = pdev->id;
drivers/media/platform/exynos-gsc/gsc-core.c:				0, pdev->name, gsc);
drivers/media/platform/exynos-gsc/gsc-core.c:	ret = pm_runtime_get_sync(&pdev->dev);
drivers/media/platform/exynos-gsc/gsc-core.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/exynos-gsc/gsc-core.c:	dev_dbg(&pdev->dev, "%s driver unloaded\n", pdev->name);
drivers/media/platform/timblogiw.c:	struct timb_video_platform_data *pdata = pdev->dev.platform_data;
drivers/media/platform/timblogiw.c:		dev_err(&pdev->dev, "No platform data\n");
drivers/media/platform/timblogiw.c:		dev_info(&pdev->dev, "Running without decoder\n");
drivers/media/platform/timblogiw.c:	if (pdev->dev.parent)
drivers/media/platform/timblogiw.c:		lw->dev = pdev->dev.parent;
drivers/media/platform/timblogiw.c:		lw->dev = &pdev->dev;
drivers/media/platform/timblogiw.c:		dev_err(&pdev->dev, "Error reg video: %d\n", err);
drivers/media/platform/timblogiw.c:	dev_err(&pdev->dev, "Failed to register: %d\n", err);
drivers/media/platform/omap24xxcam.c:		dev_err(&pdev->dev, "could not allocate memory\n");
drivers/media/platform/omap24xxcam.c:	cam->dev = &pdev->dev;
drivers/media/platform/omap24xxcam.c:	if (!request_mem_region(mem->start, resource_size(mem), pdev->name)) {
drivers/media/platform/sh_veu.c:		dev_err(&pdev->dev, "Insufficient VEU platform information.\n");
drivers/media/platform/sh_veu.c:	veu = devm_kzalloc(&pdev->dev, sizeof(*veu), GFP_KERNEL);
drivers/media/platform/sh_veu.c:	veu->base = devm_ioremap_resource(&pdev->dev, reg_res);
drivers/media/platform/sh_veu.c:	ret = devm_request_threaded_irq(&pdev->dev, irq, sh_veu_isr, sh_veu_bh,
drivers/media/platform/sh_veu.c:	ret = v4l2_device_register(&pdev->dev, &veu->v4l2_dev);
drivers/media/platform/sh_veu.c:		dev_err(&pdev->dev, "Error registering v4l2 device\n");
drivers/media/platform/sh_veu.c:	veu->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);
drivers/media/platform/sh_veu.c:	veu->dev	= &pdev->dev;
drivers/media/platform/sh_veu.c:	pm_runtime_enable(&pdev->dev);
drivers/media/platform/sh_veu.c:	pm_runtime_resume(&pdev->dev);
drivers/media/platform/sh_veu.c:	pm_runtime_suspend(&pdev->dev);
drivers/media/platform/sh_veu.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/sh_veu.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/mx2_emmaprp.c:	pcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);
drivers/media/platform/mx2_emmaprp.c:	pcdev->clk_emma_ipg = devm_clk_get(&pdev->dev, "ipg");
drivers/media/platform/mx2_emmaprp.c:	pcdev->clk_emma_ahb = devm_clk_get(&pdev->dev, "ahb");
drivers/media/platform/mx2_emmaprp.c:		dev_err(&pdev->dev, "Missing platform resources data\n");
drivers/media/platform/mx2_emmaprp.c:	ret = v4l2_device_register(&pdev->dev, &pcdev->v4l2_dev);
drivers/media/platform/mx2_emmaprp.c:	pcdev->base_emma = devm_ioremap_resource(&pdev->dev, res_emma);
drivers/media/platform/mx2_emmaprp.c:	if (devm_request_irq(&pdev->dev, pcdev->irq_emma, emmaprp_irq,
drivers/media/platform/mx2_emmaprp.c:	pcdev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);
drivers/media/platform/davinci/vpss.c:	if (!pdev->dev.platform_data) {
drivers/media/platform/davinci/vpss.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/media/platform/davinci/vpss.c:	platform_name = pdev->dev.platform_data;
drivers/media/platform/davinci/vpss.c:		dev_err(&pdev->dev, "vpss driver not supported on"
drivers/media/platform/davinci/vpss.c:	dev_info(&pdev->dev, "%s vpss probed\n", platform_name);
drivers/media/platform/davinci/vpss.c:	pm_runtime_enable(&pdev->dev);
drivers/media/platform/davinci/vpss.c:	pm_runtime_get(&pdev->dev);
drivers/media/platform/davinci/vpss.c:	dev_info(&pdev->dev, "%s vpss probe success\n", platform_name);
drivers/media/platform/davinci/vpss.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/davinci/dm644x_ccdc.c:	ccdc_cfg.dev = &pdev->dev;
drivers/media/platform/davinci/vpfe_capture.c:		v4l2_err(pdev->dev.driver,
drivers/media/platform/davinci/vpfe_capture.c:	vpfe_dev->pdev = &pdev->dev;
drivers/media/platform/davinci/vpfe_capture.c:	if (NULL == pdev->dev.platform_data) {
drivers/media/platform/davinci/vpfe_capture.c:		v4l2_err(pdev->dev.driver, "Unable to get vpfe config\n");
drivers/media/platform/davinci/vpfe_capture.c:	vpfe_cfg = pdev->dev.platform_data;
drivers/media/platform/davinci/vpfe_capture.c:		v4l2_err(pdev->dev.driver, "null ptr in vpfe_cfg\n");
drivers/media/platform/davinci/vpfe_capture.c:		v4l2_err(pdev->dev.driver,
drivers/media/platform/davinci/vpfe_capture.c:		v4l2_err(pdev->dev.driver,
drivers/media/platform/davinci/vpfe_capture.c:		v4l2_err(pdev->dev.driver,
drivers/media/platform/davinci/vpfe_capture.c:		v4l2_err(pdev->dev.driver, "Unable to request interrupt\n");
drivers/media/platform/davinci/vpfe_capture.c:		v4l2_err(pdev->dev.driver, "Unable to alloc video device\n");
drivers/media/platform/davinci/vpfe_capture.c:	ret = v4l2_device_register(&pdev->dev, &vpfe_dev->v4l2_dev);
drivers/media/platform/davinci/vpfe_capture.c:		v4l2_err(pdev->dev.driver,
drivers/media/platform/davinci/vpfe_capture.c:		v4l2_err(pdev->dev.driver,
drivers/media/platform/davinci/vpfe_capture.c:	v4l2_info(pdev->dev.driver, "vpfe_remove\n");
drivers/media/platform/davinci/vpif.c:	pm_runtime_enable(&pdev->dev);
drivers/media/platform/davinci/vpif.c:	pm_runtime_get(&pdev->dev);
drivers/media/platform/davinci/vpif.c:	dev_info(&pdev->dev, "vpif probe success\n");
drivers/media/platform/davinci/vpif.c:	pm_runtime_disable(&pdev->dev);
drivers/media/platform/davinci/vpif_capture.c:	vpif_dev = &pdev->dev;
drivers/media/platform/davinci/vpif_capture.c:	config = pdev->dev.platform_data;
drivers/media/platform/davinci/vpif_display.c:	vpif_dev = &pdev->dev;
drivers/media/platform/davinci/vpif_display.c:	config = pdev->dev.platform_data;
drivers/media/platform/davinci/vpbe_venc.c:	if (strstr(pdev->name, "vpbe-venc") != NULL)
drivers/media/platform/davinci/vpbe_venc.c:	venc->pdev = &pdev->dev;
drivers/media/platform/davinci/vpbe_venc.c:	venc->pdata = pdev->dev.platform_data;
drivers/media/platform/davinci/isif.c:	if (!pdev->dev.platform_data)
drivers/media/platform/davinci/isif.c:	setup_pinmux = pdev->dev.platform_data;
drivers/media/platform/davinci/isif.c:	isif_cfg.dev = &pdev->dev;
drivers/media/platform/davinci/dm355_ccdc.c:	if (NULL == pdev->dev.platform_data) {
drivers/media/platform/davinci/dm355_ccdc.c:	setup_pinmux = pdev->dev.platform_data;
drivers/media/platform/davinci/dm355_ccdc.c:	ccdc_cfg.dev = &pdev->dev;
drivers/media/platform/davinci/vpbe_display.c:	if (strcmp("vpbe_controller", pdev->name) == 0)
drivers/media/platform/davinci/vpbe_display.c:	if (strstr(pdev->name, "vpbe-osd") != NULL)
drivers/media/platform/davinci/vpbe_display.c:		err = disp_dev->vpbe_dev->ops.initialize(&pdev->dev,
drivers/media/platform/davinci/vpbe_display.c:		vpbe_dev->ops.deinitialize(&pdev->dev, vpbe_dev);
drivers/media/platform/davinci/vpbe.c:	if (strstr(pdev->name, "vpbe-osd") != NULL)
drivers/media/platform/davinci/vpbe.c:	if (strstr(pdev->name, "vpbe-venc") != NULL)
drivers/media/platform/davinci/vpbe.c:		vpbe_dev->venc_device = dev_get_platdata(&pdev->dev);
drivers/media/platform/davinci/vpbe.c:	if (pdev->dev.platform_data == NULL) {
drivers/media/platform/davinci/vpbe.c:		v4l2_err(pdev->dev.driver, "No platform data\n");
drivers/media/platform/davinci/vpbe.c:	cfg = pdev->dev.platform_data;
drivers/media/platform/davinci/vpbe.c:		v4l2_err(pdev->dev.driver, "vpbe display module names not"
drivers/media/platform/davinci/vpbe.c:		v4l2_err(pdev->dev.driver, "Unable to allocate memory"
drivers/media/platform/davinci/vpbe.c:	vpbe_dev->pdev = &pdev->dev;
drivers/media/platform/davinci/vpbe_osd.c:	osd->dev = &pdev->dev;
drivers/media/platform/omap3isp/isp.c:	iommu_detach_device(isp->domain, &pdev->dev);
drivers/media/platform/omap3isp/isp.c:				     pdev->name)) {
drivers/media/platform/omap3isp/isp.c:	struct isp_platform_data *pdata = pdev->dev.platform_data;
drivers/media/platform/omap3isp/isp.c:	isp = devm_kzalloc(&pdev->dev, sizeof(*isp), GFP_KERNEL);
drivers/media/platform/omap3isp/isp.c:		dev_err(&pdev->dev, "could not allocate memory\n");
drivers/media/platform/omap3isp/isp.c:	isp->dev = &pdev->dev;
drivers/media/platform/omap3isp/isp.c:	isp->isp_csiphy1.vdd = devm_regulator_get(&pdev->dev, "VDD_CSIPHY1");
drivers/media/platform/omap3isp/isp.c:	isp->isp_csiphy2.vdd = devm_regulator_get(&pdev->dev, "VDD_CSIPHY2");
drivers/media/platform/omap3isp/isp.c:	isp->domain = iommu_domain_alloc(pdev->dev.bus);
drivers/media/platform/omap3isp/isp.c:	ret = iommu_attach_device(isp->domain, &pdev->dev);
drivers/media/platform/omap3isp/isp.c:		dev_err(&pdev->dev, "can't attach iommu device: %d\n", ret);
drivers/media/platform/omap3isp/isp.c:	iommu_detach_device(isp->domain, &pdev->dev);
drivers/media/common/saa7146/saa7146_core.c:	free_irq(pdev->irq, dev);
drivers/media/usb/pwc/pwc-dec23.c:	struct pwc_dec23_private *pdec = &pdev->dec23;
drivers/media/usb/pwc/pwc-dec23.c:	if (DEVICE_USE_CODEC3(pdev->type)) {
drivers/media/usb/pwc/pwc-dec23.c:	struct pwc_dec23_private *pdec = &pdev->dec23;
drivers/media/usb/pwc/pwc-dec23.c:	bandlines_left = pdev->height / 4;
drivers/media/usb/pwc/pwc-dec23.c:	bytes_per_block = pdev->width * 4;
drivers/media/usb/pwc/pwc-dec23.c:	plane_size = pdev->height * pdev->width;
drivers/media/usb/pwc/pwc-dec23.c:				 pdev->width, pdev->width);
drivers/media/usb/pwc/pwc-dec23.c:		src += pdev->vbandlength;
drivers/media/usb/pwc/pwc-dec23.c:		pout_planar_u += pdev->width;
drivers/media/usb/pwc/pwc-dec23.c:		pout_planar_v += pdev->width;
drivers/media/usb/pwc/pwc-v4l.c:	hdl = &pdev->ctrl_handler;
drivers/media/usb/pwc/pwc-v4l.c:	pdev->brightness = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	pdev->contrast = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->type >= 675) {
drivers/media/usb/pwc/pwc-v4l.c:		if (pdev->type < 730)
drivers/media/usb/pwc/pwc-v4l.c:			pdev->saturation_fmt = SATURATION_MODE_FORMATTER2;
drivers/media/usb/pwc/pwc-v4l.c:			pdev->saturation_fmt = SATURATION_MODE_FORMATTER1;
drivers/media/usb/pwc/pwc-v4l.c:		r = pwc_get_s8_ctrl(pdev, GET_CHROM_CTL, pdev->saturation_fmt,
drivers/media/usb/pwc/pwc-v4l.c:		pdev->saturation = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	pdev->gamma = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	pdev->auto_white_balance = v4l2_ctrl_new_custom(hdl, &cfg, NULL);
drivers/media/usb/pwc/pwc-v4l.c:	if (!pdev->auto_white_balance)
drivers/media/usb/pwc/pwc-v4l.c:	pdev->red_balance = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	pdev->blue_balance = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	v4l2_ctrl_auto_cluster(3, &pdev->auto_white_balance, awb_manual, true);
drivers/media/usb/pwc/pwc-v4l.c:	pdev->autogain = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	if (!pdev->autogain)
drivers/media/usb/pwc/pwc-v4l.c:	pdev->gain = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	if (DEVICE_USE_CODEC2(pdev->type)) {
drivers/media/usb/pwc/pwc-v4l.c:		pdev->exposure_auto = v4l2_ctrl_new_std_menu(hdl,
drivers/media/usb/pwc/pwc-v4l.c:		if (!pdev->exposure_auto)
drivers/media/usb/pwc/pwc-v4l.c:		pdev->exposure = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:		v4l2_ctrl_auto_cluster(2, &pdev->autogain, 0, true);
drivers/media/usb/pwc/pwc-v4l.c:		v4l2_ctrl_auto_cluster(2, &pdev->exposure_auto,
drivers/media/usb/pwc/pwc-v4l.c:	} else if (DEVICE_USE_CODEC3(pdev->type)) {
drivers/media/usb/pwc/pwc-v4l.c:		pdev->exposure = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:		pdev->autogain_expo_cluster[0] = pdev->autogain;
drivers/media/usb/pwc/pwc-v4l.c:		pdev->autogain_expo_cluster[1] = pdev->gain;
drivers/media/usb/pwc/pwc-v4l.c:		pdev->autogain_expo_cluster[2] = pdev->exposure;
drivers/media/usb/pwc/pwc-v4l.c:		v4l2_ctrl_auto_cluster(3, pdev->autogain_expo_cluster,
drivers/media/usb/pwc/pwc-v4l.c:	pdev->colorfx = v4l2_ctrl_new_std_menu(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	pdev->autocontour = v4l2_ctrl_new_custom(hdl, &cfg, NULL);
drivers/media/usb/pwc/pwc-v4l.c:	if (!pdev->autocontour)
drivers/media/usb/pwc/pwc-v4l.c:	pdev->contour = v4l2_ctrl_new_custom(hdl, &cfg, NULL);
drivers/media/usb/pwc/pwc-v4l.c:	v4l2_ctrl_auto_cluster(2, &pdev->autocontour, 0, false);
drivers/media/usb/pwc/pwc-v4l.c:	pdev->backlight = v4l2_ctrl_new_custom(hdl, &cfg, NULL);
drivers/media/usb/pwc/pwc-v4l.c:	pdev->flicker = v4l2_ctrl_new_custom(hdl, &cfg, NULL);
drivers/media/usb/pwc/pwc-v4l.c:	pdev->noise_reduction = v4l2_ctrl_new_custom(hdl, &cfg, NULL);
drivers/media/usb/pwc/pwc-v4l.c:	pdev->save_user = v4l2_ctrl_new_custom(hdl, &pwc_save_user_cfg, NULL);
drivers/media/usb/pwc/pwc-v4l.c:	pdev->restore_user = v4l2_ctrl_new_custom(hdl, &pwc_restore_user_cfg,
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->restore_user)
drivers/media/usb/pwc/pwc-v4l.c:		pdev->restore_user->flags |= V4L2_CTRL_FLAG_UPDATE;
drivers/media/usb/pwc/pwc-v4l.c:	pdev->restore_factory = v4l2_ctrl_new_custom(hdl,
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->restore_factory)
drivers/media/usb/pwc/pwc-v4l.c:		pdev->restore_factory->flags |= V4L2_CTRL_FLAG_UPDATE;
drivers/media/usb/pwc/pwc-v4l.c:	pdev->awb_speed = v4l2_ctrl_new_custom(hdl, &cfg, NULL);
drivers/media/usb/pwc/pwc-v4l.c:	pdev->awb_delay = v4l2_ctrl_new_custom(hdl, &cfg, NULL);
drivers/media/usb/pwc/pwc-v4l.c:	if (!(pdev->features & FEATURE_MOTOR_PANTILT))
drivers/media/usb/pwc/pwc-v4l.c:	pdev->motor_pan = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	if (!pdev->motor_pan)
drivers/media/usb/pwc/pwc-v4l.c:	pdev->motor_tilt = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	pdev->motor_pan_reset = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	pdev->motor_tilt_reset = v4l2_ctrl_new_std(hdl, &pwc_ctrl_ops,
drivers/media/usb/pwc/pwc-v4l.c:	v4l2_ctrl_cluster(4, &pdev->motor_pan);
drivers/media/usb/pwc/pwc-v4l.c:			if (DEVICE_USE_CODEC23(pdev->type)) {
drivers/media/usb/pwc/pwc-v4l.c:			if (DEVICE_USE_CODEC1(pdev->type)) {
drivers/media/usb/pwc/pwc-v4l.c:	if (vb2_is_busy(&pdev->vb_queue))
drivers/media/usb/pwc/pwc-v4l.c:			f->fmt.pix.width, f->fmt.pix.height, pdev->vframes,
drivers/media/usb/pwc/pwc-v4l.c:	pwc_vidioc_fill_fmt(f, pdev->width, pdev->height, pdev->pixfmt);
drivers/media/usb/pwc/pwc-v4l.c:	strlcpy(cap->card, pdev->vdev.name, sizeof(cap->card));
drivers/media/usb/pwc/pwc-v4l.c:	usb_make_path(pdev->udev, cap->bus_info, sizeof(cap->bus_info));
drivers/media/usb/pwc/pwc-v4l.c:		if (pdev->color_bal_valid &&
drivers/media/usb/pwc/pwc-v4l.c:			(pdev->auto_white_balance->val != awb_auto ||
drivers/media/usb/pwc/pwc-v4l.c:				pdev->last_color_bal_update + HZ / 4))) {
drivers/media/usb/pwc/pwc-v4l.c:			pdev->red_balance->val  = pdev->last_red_balance;
drivers/media/usb/pwc/pwc-v4l.c:			pdev->blue_balance->val = pdev->last_blue_balance;
drivers/media/usb/pwc/pwc-v4l.c:				      &pdev->red_balance->val);
drivers/media/usb/pwc/pwc-v4l.c:				      &pdev->blue_balance->val);
drivers/media/usb/pwc/pwc-v4l.c:		pdev->last_red_balance  = pdev->red_balance->val;
drivers/media/usb/pwc/pwc-v4l.c:		pdev->last_blue_balance = pdev->blue_balance->val;
drivers/media/usb/pwc/pwc-v4l.c:		pdev->last_color_bal_update = jiffies;
drivers/media/usb/pwc/pwc-v4l.c:		pdev->color_bal_valid = true;
drivers/media/usb/pwc/pwc-v4l.c:		if (pdev->gain_valid && time_before(jiffies,
drivers/media/usb/pwc/pwc-v4l.c:				pdev->last_gain_update + HZ / 4)) {
drivers/media/usb/pwc/pwc-v4l.c:			pdev->gain->val = pdev->last_gain;
drivers/media/usb/pwc/pwc-v4l.c:				      READ_AGC_FORMATTER, &pdev->gain->val);
drivers/media/usb/pwc/pwc-v4l.c:		pdev->last_gain = pdev->gain->val;
drivers/media/usb/pwc/pwc-v4l.c:		pdev->last_gain_update = jiffies;
drivers/media/usb/pwc/pwc-v4l.c:		pdev->gain_valid = true;
drivers/media/usb/pwc/pwc-v4l.c:		if (!DEVICE_USE_CODEC3(pdev->type))
drivers/media/usb/pwc/pwc-v4l.c:		if (pdev->exposure_valid && time_before(jiffies,
drivers/media/usb/pwc/pwc-v4l.c:				pdev->last_exposure_update + HZ / 4)) {
drivers/media/usb/pwc/pwc-v4l.c:			pdev->exposure->val = pdev->last_exposure;
drivers/media/usb/pwc/pwc-v4l.c:				       &pdev->exposure->val);
drivers/media/usb/pwc/pwc-v4l.c:		pdev->last_exposure = pdev->exposure->val;
drivers/media/usb/pwc/pwc-v4l.c:		pdev->last_exposure_update = jiffies;
drivers/media/usb/pwc/pwc-v4l.c:		pdev->exposure_valid = true;
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->auto_white_balance->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:				      pdev->auto_white_balance->val);
drivers/media/usb/pwc/pwc-v4l.c:		if (pdev->auto_white_balance->val != awb_manual)
drivers/media/usb/pwc/pwc-v4l.c:			pdev->color_bal_valid = false; /* Force cache update */
drivers/media/usb/pwc/pwc-v4l.c:		if (pdev->auto_white_balance->val == awb_indoor ||
drivers/media/usb/pwc/pwc-v4l.c:		    pdev->auto_white_balance->val == awb_outdoor ||
drivers/media/usb/pwc/pwc-v4l.c:		    pdev->auto_white_balance->val == awb_fl)
drivers/media/usb/pwc/pwc-v4l.c:			pwc_g_volatile_ctrl(pdev->auto_white_balance);
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->auto_white_balance->val != awb_manual)
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->red_balance->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:				      pdev->red_balance->val);
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->blue_balance->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:				      pdev->blue_balance->val);
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->autogain->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:				      pdev->autogain->val ? 0 : 0xff);
drivers/media/usb/pwc/pwc-v4l.c:		if (pdev->autogain->val)
drivers/media/usb/pwc/pwc-v4l.c:			pdev->gain_valid = false; /* Force cache update */
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->autogain->val)
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->gain->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:				      pdev->gain->val);
drivers/media/usb/pwc/pwc-v4l.c:	int is_auto = pdev->exposure_auto->val == V4L2_EXPOSURE_AUTO;
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->exposure_auto->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:			pdev->exposure_valid = false; /* Force cache update */
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->exposure->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:				       pdev->exposure->val);
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->autogain->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:				      pdev->autogain->val ? 0 : 0xff);
drivers/media/usb/pwc/pwc-v4l.c:		if (pdev->autogain->val) {
drivers/media/usb/pwc/pwc-v4l.c:			pdev->gain_valid     = false; /* Force cache update */
drivers/media/usb/pwc/pwc-v4l.c:			pdev->exposure_valid = false; /* Force cache update */
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->autogain->val)
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->gain->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:				      pdev->gain->val);
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->exposure->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:				       pdev->exposure->val);
drivers/media/usb/pwc/pwc-v4l.c:	pdev->ctrl_buf[0] = 0;
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->motor_pan_reset->is_new)
drivers/media/usb/pwc/pwc-v4l.c:		pdev->ctrl_buf[0] |= 0x01;
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->motor_tilt_reset->is_new)
drivers/media/usb/pwc/pwc-v4l.c:		pdev->ctrl_buf[0] |= 0x02;
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->motor_pan_reset->is_new || pdev->motor_tilt_reset->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:				       pdev->ctrl_buf, 1);
drivers/media/usb/pwc/pwc-v4l.c:	memset(pdev->ctrl_buf, 0, 4);
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->motor_pan->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:		pdev->ctrl_buf[0] = pdev->motor_pan->val & 0xFF;
drivers/media/usb/pwc/pwc-v4l.c:		pdev->ctrl_buf[1] = (pdev->motor_pan->val >> 8);
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->motor_tilt->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:		pdev->ctrl_buf[2] = pdev->motor_tilt->val & 0xFF;
drivers/media/usb/pwc/pwc-v4l.c:		pdev->ctrl_buf[3] = (pdev->motor_tilt->val >> 8);
drivers/media/usb/pwc/pwc-v4l.c:	if (pdev->motor_pan->is_new || pdev->motor_tilt->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:				       pdev->ctrl_buf, 4);
drivers/media/usb/pwc/pwc-v4l.c:				      pdev->saturation_fmt, ctrl->val);
drivers/media/usb/pwc/pwc-v4l.c:		if (DEVICE_USE_CODEC2(pdev->type))
drivers/media/usb/pwc/pwc-v4l.c:		else if (DEVICE_USE_CODEC3(pdev->type))
drivers/media/usb/pwc/pwc-v4l.c:		if (DEVICE_USE_CODEC2(pdev->type))
drivers/media/usb/pwc/pwc-v4l.c:		if (pdev->autocontour->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:					pdev->autocontour->val ? 0 : 0xff);
drivers/media/usb/pwc/pwc-v4l.c:		if (ret == 0 && pdev->contour->is_new) {
drivers/media/usb/pwc/pwc-v4l.c:					      pdev->contour->val);
drivers/media/usb/pwc/pwc-v4l.c:		f->pixelformat = pdev->type <= 646 ? V4L2_PIX_FMT_PWC1 : V4L2_PIX_FMT_PWC2;
drivers/media/usb/pwc/pwc-v4l.c:			pdev->width, pdev->height);
drivers/media/usb/pwc/pwc-v4l.c:	pwc_vidioc_fill_fmt(f, pdev->width, pdev->height, pdev->pixfmt);
drivers/media/usb/pwc/pwc-v4l.c:			DEVICE_USE_CODEC1(pdev->type)) ||
drivers/media/usb/pwc/pwc-v4l.c:			DEVICE_USE_CODEC23(pdev->type))) {
drivers/media/usb/pwc/pwc-v4l.c:			if (!(pdev->image_mask & (1UL << i)))
drivers/media/usb/pwc/pwc-v4l.c:	parm->parm.capture.timeperframe.denominator = pdev->vframes;
drivers/media/usb/pwc/pwc-v4l.c:	if (vb2_is_busy(&pdev->vb_queue))
drivers/media/usb/pwc/pwc-v4l.c:	ret = pwc_set_video_mode(pdev, pdev->width, pdev->height, pdev->pixfmt,
drivers/media/usb/pwc/pwc-dec1.c:	struct pwc_dec1_private *pdec = &pdev->dec1;
drivers/media/usb/pwc/pwc-dec1.c:	pdec->version = pdev->release;
drivers/media/usb/pwc/pwc-if.c:	spin_lock_irqsave(&pdev->queued_bufs_lock, flags);
drivers/media/usb/pwc/pwc-if.c:	if (list_empty(&pdev->queued_bufs))
drivers/media/usb/pwc/pwc-if.c:	buf = list_entry(pdev->queued_bufs.next, struct pwc_frame_buf, list);
drivers/media/usb/pwc/pwc-if.c:	spin_unlock_irqrestore(&pdev->queued_bufs_lock, flags);
drivers/media/usb/pwc/pwc-if.c:	if (pdev->button_dev) {
drivers/media/usb/pwc/pwc-if.c:		input_report_key(pdev->button_dev, KEY_CAMERA, down);
drivers/media/usb/pwc/pwc-if.c:		input_sync(pdev->button_dev);
drivers/media/usb/pwc/pwc-if.c:	struct pwc_frame_buf *fbuf = pdev->fill_buf;
drivers/media/usb/pwc/pwc-if.c:	if (pdev->type == 730) {
drivers/media/usb/pwc/pwc-if.c:			pdev->drop_frames += 2;
drivers/media/usb/pwc/pwc-if.c:		if ((ptr[0] ^ pdev->vmirror) & 0x01) {
drivers/media/usb/pwc/pwc-if.c:		if ((ptr[0] ^ pdev->vmirror) & 0x02) {
drivers/media/usb/pwc/pwc-if.c:		pdev->vmirror = ptr[0] & 0x03;
drivers/media/usb/pwc/pwc-if.c:			pdev->drop_frames++;
drivers/media/usb/pwc/pwc-if.c:	} else if (pdev->type == 740 || pdev->type == 720) {
drivers/media/usb/pwc/pwc-if.c:		if ((ptr[0] ^ pdev->vmirror) & 0x01) {
drivers/media/usb/pwc/pwc-if.c:		pdev->vmirror = ptr[0] & 0x03;
drivers/media/usb/pwc/pwc-if.c:	if (pdev->drop_frames > 0) {
drivers/media/usb/pwc/pwc-if.c:		pdev->drop_frames--;
drivers/media/usb/pwc/pwc-if.c:		if (fbuf->filled < pdev->frame_total_size) {
drivers/media/usb/pwc/pwc-if.c:			fbuf->vb.v4l2_buf.sequence = pdev->vframe_count;
drivers/media/usb/pwc/pwc-if.c:			pdev->fill_buf = NULL;
drivers/media/usb/pwc/pwc-if.c:			pdev->vsync = 0;
drivers/media/usb/pwc/pwc-if.c:	pdev->vframe_count++;
drivers/media/usb/pwc/pwc-if.c:	if (pdev->fill_buf == NULL)
drivers/media/usb/pwc/pwc-if.c:		pdev->fill_buf = pwc_get_next_fill_buf(pdev);
drivers/media/usb/pwc/pwc-if.c:		if (++pdev->visoc_errors > MAX_ISOC_ERRORS)
drivers/media/usb/pwc/pwc-if.c:			if (pdev->fill_buf) {
drivers/media/usb/pwc/pwc-if.c:				vb2_buffer_done(&pdev->fill_buf->vb,
drivers/media/usb/pwc/pwc-if.c:				pdev->fill_buf = NULL;
drivers/media/usb/pwc/pwc-if.c:		pdev->vsync = 0; /* Drop the current frame */
drivers/media/usb/pwc/pwc-if.c:	pdev->visoc_errors = 0;
drivers/media/usb/pwc/pwc-if.c:		if (flen > 0 && pdev->vsync) {
drivers/media/usb/pwc/pwc-if.c:			struct pwc_frame_buf *fbuf = pdev->fill_buf;
drivers/media/usb/pwc/pwc-if.c:			if (pdev->vsync == 1) {
drivers/media/usb/pwc/pwc-if.c:				pdev->vsync = 2;
drivers/media/usb/pwc/pwc-if.c:			if (flen + fbuf->filled > pdev->frame_total_size) {
drivers/media/usb/pwc/pwc-if.c:					  pdev->frame_total_size);
drivers/media/usb/pwc/pwc-if.c:				pdev->vsync = 0; /* Let's wait for an EOF */
drivers/media/usb/pwc/pwc-if.c:		if (flen < pdev->vlast_packet_size) {
drivers/media/usb/pwc/pwc-if.c:			if (pdev->vsync == 2)
drivers/media/usb/pwc/pwc-if.c:			if (pdev->fill_buf == NULL)
drivers/media/usb/pwc/pwc-if.c:				pdev->fill_buf = pwc_get_next_fill_buf(pdev);
drivers/media/usb/pwc/pwc-if.c:			if (pdev->fill_buf) {
drivers/media/usb/pwc/pwc-if.c:				pdev->fill_buf->filled = 0;
drivers/media/usb/pwc/pwc-if.c:				pdev->vsync = 1;
drivers/media/usb/pwc/pwc-if.c:		pdev->vlast_packet_size = flen;
drivers/media/usb/pwc/pwc-if.c:	pdev->vsync = 0;
drivers/media/usb/pwc/pwc-if.c:	pdev->vlast_packet_size = 0;
drivers/media/usb/pwc/pwc-if.c:	pdev->fill_buf = NULL;
drivers/media/usb/pwc/pwc-if.c:	pdev->vframe_count = 0;
drivers/media/usb/pwc/pwc-if.c:	pdev->visoc_errors = 0;
drivers/media/usb/pwc/pwc-if.c:	udev = pdev->udev;
drivers/media/usb/pwc/pwc-if.c:	ret = pwc_set_video_mode(pdev, pdev->width, pdev->height, pdev->pixfmt,
drivers/media/usb/pwc/pwc-if.c:				 pdev->vframes, &compression, 1);
drivers/media/usb/pwc/pwc-if.c:		idesc = usb_altnum_to_altsetting(intf, pdev->valternate);
drivers/media/usb/pwc/pwc-if.c:	pdev->vmax_packet_size = -1;
drivers/media/usb/pwc/pwc-if.c:		if ((idesc->endpoint[i].desc.bEndpointAddress & 0xF) == pdev->vendpoint) {
drivers/media/usb/pwc/pwc-if.c:			pdev->vmax_packet_size = le16_to_cpu(idesc->endpoint[i].desc.wMaxPacketSize);
drivers/media/usb/pwc/pwc-if.c:	if (pdev->vmax_packet_size < 0 || pdev->vmax_packet_size > ISO_MAX_FRAME_SIZE) {
drivers/media/usb/pwc/pwc-if.c:	PWC_DEBUG_OPEN("Setting alternate interface %d\n", pdev->valternate);
drivers/media/usb/pwc/pwc-if.c:	ret = usb_set_interface(pdev->udev, 0, pdev->valternate);
drivers/media/usb/pwc/pwc-if.c:		pdev->urbs[i] = urb;
drivers/media/usb/pwc/pwc-if.c:		urb->pipe = usb_rcvisocpipe(udev, pdev->vendpoint);
drivers/media/usb/pwc/pwc-if.c:			urb->iso_frame_desc[j].length = pdev->vmax_packet_size;
drivers/media/usb/pwc/pwc-if.c:		ret = usb_submit_urb(pdev->urbs[i], GFP_KERNEL);
drivers/media/usb/pwc/pwc-if.c:		PWC_DEBUG_MEMORY("URB 0x%p submitted.\n", pdev->urbs[i]);
drivers/media/usb/pwc/pwc-if.c:		if (pdev->urbs[i]) {
drivers/media/usb/pwc/pwc-if.c:			PWC_DEBUG_MEMORY("Unlinking URB %p\n", pdev->urbs[i]);
drivers/media/usb/pwc/pwc-if.c:			usb_kill_urb(pdev->urbs[i]);
drivers/media/usb/pwc/pwc-if.c:		if (pdev->urbs[i]) {
drivers/media/usb/pwc/pwc-if.c:			if (pdev->urbs[i]->transfer_buffer) {
drivers/media/usb/pwc/pwc-if.c:				usb_free_coherent(pdev->udev,
drivers/media/usb/pwc/pwc-if.c:					pdev->urbs[i]->transfer_buffer_length,
drivers/media/usb/pwc/pwc-if.c:					pdev->urbs[i]->transfer_buffer,
drivers/media/usb/pwc/pwc-if.c:					pdev->urbs[i]->transfer_dma);
drivers/media/usb/pwc/pwc-if.c:			usb_free_urb(pdev->urbs[i]);
drivers/media/usb/pwc/pwc-if.c:			pdev->urbs[i] = NULL;
drivers/media/usb/pwc/pwc-if.c:	usb_set_interface(pdev->udev, 0, 0);
drivers/media/usb/pwc/pwc-if.c:	spin_lock_irqsave(&pdev->queued_bufs_lock, flags);
drivers/media/usb/pwc/pwc-if.c:	while (!list_empty(&pdev->queued_bufs)) {
drivers/media/usb/pwc/pwc-if.c:		buf = list_entry(pdev->queued_bufs.next, struct pwc_frame_buf,
drivers/media/usb/pwc/pwc-if.c:	spin_unlock_irqrestore(&pdev->queued_bufs_lock, flags);
drivers/media/usb/pwc/pwc-if.c:	v4l2_ctrl_handler_free(&pdev->ctrl_handler);
drivers/media/usb/pwc/pwc-if.c:	v4l2_device_unregister(&pdev->v4l2_dev);
drivers/media/usb/pwc/pwc-if.c:	kfree(pdev->ctrl_buf);
drivers/media/usb/pwc/pwc-if.c:	if (!pdev->udev)
drivers/media/usb/pwc/pwc-if.c:	if (!pdev->udev) {
drivers/media/usb/pwc/pwc-if.c:	spin_lock_irqsave(&pdev->queued_bufs_lock, flags);
drivers/media/usb/pwc/pwc-if.c:	list_add_tail(&buf->list, &pdev->queued_bufs);
drivers/media/usb/pwc/pwc-if.c:	spin_unlock_irqrestore(&pdev->queued_bufs_lock, flags);
drivers/media/usb/pwc/pwc-if.c:	if (!pdev->udev)
drivers/media/usb/pwc/pwc-if.c:	if (mutex_lock_interruptible(&pdev->v4l2_lock))
drivers/media/usb/pwc/pwc-if.c:	mutex_unlock(&pdev->v4l2_lock);
drivers/media/usb/pwc/pwc-if.c:	if (mutex_lock_interruptible(&pdev->v4l2_lock))
drivers/media/usb/pwc/pwc-if.c:	if (pdev->udev) {
drivers/media/usb/pwc/pwc-if.c:	mutex_unlock(&pdev->v4l2_lock);
drivers/media/usb/pwc/pwc-if.c:	pdev->type = type_id;
drivers/media/usb/pwc/pwc-if.c:	pdev->features = features;
drivers/media/usb/pwc/pwc-if.c:	mutex_init(&pdev->v4l2_lock);
drivers/media/usb/pwc/pwc-if.c:	mutex_init(&pdev->vb_queue_lock);
drivers/media/usb/pwc/pwc-if.c:	spin_lock_init(&pdev->queued_bufs_lock);
drivers/media/usb/pwc/pwc-if.c:	INIT_LIST_HEAD(&pdev->queued_bufs);
drivers/media/usb/pwc/pwc-if.c:	pdev->udev = udev;
drivers/media/usb/pwc/pwc-if.c:	pdev->power_save = my_power_save;
drivers/media/usb/pwc/pwc-if.c:	pdev->vb_queue.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
drivers/media/usb/pwc/pwc-if.c:	pdev->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;
drivers/media/usb/pwc/pwc-if.c:	pdev->vb_queue.drv_priv = pdev;
drivers/media/usb/pwc/pwc-if.c:	pdev->vb_queue.buf_struct_size = sizeof(struct pwc_frame_buf);
drivers/media/usb/pwc/pwc-if.c:	pdev->vb_queue.ops = &pwc_vb_queue_ops;
drivers/media/usb/pwc/pwc-if.c:	pdev->vb_queue.mem_ops = &vb2_vmalloc_memops;
drivers/media/usb/pwc/pwc-if.c:	pdev->vb_queue.timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
drivers/media/usb/pwc/pwc-if.c:	rc = vb2_queue_init(&pdev->vb_queue);
drivers/media/usb/pwc/pwc-if.c:	pdev->vdev = pwc_template;
drivers/media/usb/pwc/pwc-if.c:	strcpy(pdev->vdev.name, name);
drivers/media/usb/pwc/pwc-if.c:	pdev->vdev.queue = &pdev->vb_queue;
drivers/media/usb/pwc/pwc-if.c:	pdev->vdev.queue->lock = &pdev->vb_queue_lock;
drivers/media/usb/pwc/pwc-if.c:	set_bit(V4L2_FL_USE_FH_PRIO, &pdev->vdev.flags);
drivers/media/usb/pwc/pwc-if.c:	video_set_drvdata(&pdev->vdev, pdev);
drivers/media/usb/pwc/pwc-if.c:	pdev->release = le16_to_cpu(udev->descriptor.bcdDevice);
drivers/media/usb/pwc/pwc-if.c:	PWC_DEBUG_PROBE("Release: %04x\n", pdev->release);
drivers/media/usb/pwc/pwc-if.c:	pdev->ctrl_buf = kmalloc(sizeof(pdev->cmd_buf), GFP_KERNEL);
drivers/media/usb/pwc/pwc-if.c:	if (!pdev->ctrl_buf) {
drivers/media/usb/pwc/pwc-if.c:				pdev->vdev.name,
drivers/media/usb/pwc/pwc-if.c:	pdev->v4l2_dev.release = pwc_video_release;
drivers/media/usb/pwc/pwc-if.c:	rc = v4l2_device_register(&intf->dev, &pdev->v4l2_dev);
drivers/media/usb/pwc/pwc-if.c:	pdev->v4l2_dev.ctrl_handler = &pdev->ctrl_handler;
drivers/media/usb/pwc/pwc-if.c:	pdev->vdev.v4l2_dev = &pdev->v4l2_dev;
drivers/media/usb/pwc/pwc-if.c:	pdev->vdev.lock = &pdev->v4l2_lock;
drivers/media/usb/pwc/pwc-if.c:	rc = video_register_device(&pdev->vdev, VFL_TYPE_GRABBER, -1);
drivers/media/usb/pwc/pwc-if.c:	PWC_INFO("Registered as %s.\n", video_device_node_name(&pdev->vdev));
drivers/media/usb/pwc/pwc-if.c:	pdev->button_dev = input_allocate_device();
drivers/media/usb/pwc/pwc-if.c:	if (!pdev->button_dev) {
drivers/media/usb/pwc/pwc-if.c:	usb_make_path(udev, pdev->button_phys, sizeof(pdev->button_phys));
drivers/media/usb/pwc/pwc-if.c:	strlcat(pdev->button_phys, "/input0", sizeof(pdev->button_phys));
drivers/media/usb/pwc/pwc-if.c:	pdev->button_dev->name = "PWC snapshot button";
drivers/media/usb/pwc/pwc-if.c:	pdev->button_dev->phys = pdev->button_phys;
drivers/media/usb/pwc/pwc-if.c:	usb_to_input_id(pdev->udev, &pdev->button_dev->id);
drivers/media/usb/pwc/pwc-if.c:	pdev->button_dev->dev.parent = &pdev->udev->dev;
drivers/media/usb/pwc/pwc-if.c:	pdev->button_dev->evbit[0] = BIT_MASK(EV_KEY);
drivers/media/usb/pwc/pwc-if.c:	pdev->button_dev->keybit[BIT_WORD(KEY_CAMERA)] = BIT_MASK(KEY_CAMERA);
drivers/media/usb/pwc/pwc-if.c:	rc = input_register_device(pdev->button_dev);
drivers/media/usb/pwc/pwc-if.c:		input_free_device(pdev->button_dev);
drivers/media/usb/pwc/pwc-if.c:		pdev->button_dev = NULL;
drivers/media/usb/pwc/pwc-if.c:	video_unregister_device(&pdev->vdev);
drivers/media/usb/pwc/pwc-if.c:	v4l2_device_unregister(&pdev->v4l2_dev);
drivers/media/usb/pwc/pwc-if.c:	v4l2_ctrl_handler_free(&pdev->ctrl_handler);
drivers/media/usb/pwc/pwc-if.c:	kfree(pdev->ctrl_buf);
drivers/media/usb/pwc/pwc-if.c:	mutex_lock(&pdev->vb_queue_lock);
drivers/media/usb/pwc/pwc-if.c:	mutex_lock(&pdev->v4l2_lock);
drivers/media/usb/pwc/pwc-if.c:	if (pdev->vb_queue.streaming)
drivers/media/usb/pwc/pwc-if.c:	pdev->udev = NULL;
drivers/media/usb/pwc/pwc-if.c:	v4l2_device_disconnect(&pdev->v4l2_dev);
drivers/media/usb/pwc/pwc-if.c:	video_unregister_device(&pdev->vdev);
drivers/media/usb/pwc/pwc-if.c:	mutex_unlock(&pdev->v4l2_lock);
drivers/media/usb/pwc/pwc-if.c:	mutex_unlock(&pdev->vb_queue_lock);
drivers/media/usb/pwc/pwc-if.c:	if (pdev->button_dev)
drivers/media/usb/pwc/pwc-if.c:		input_unregister_device(pdev->button_dev);
drivers/media/usb/pwc/pwc-if.c:	v4l2_device_put(&pdev->v4l2_dev);
drivers/media/usb/pwc/pwc-uncompress.c:	yuv = fbuf->data + pdev->frame_header_size;  /* Skip header */
drivers/media/usb/pwc/pwc-uncompress.c:	if (pdev->pixfmt != V4L2_PIX_FMT_YUV420)
drivers/media/usb/pwc/pwc-uncompress.c:		raw_frame->type = cpu_to_le16(pdev->type);
drivers/media/usb/pwc/pwc-uncompress.c:		raw_frame->vbandlength = cpu_to_le16(pdev->vbandlength);
drivers/media/usb/pwc/pwc-uncompress.c:		memcpy(raw_frame->cmd, pdev->cmd_buf, 4);
drivers/media/usb/pwc/pwc-uncompress.c:		memcpy(raw_frame+1, yuv, pdev->frame_size);
drivers/media/usb/pwc/pwc-uncompress.c:			pdev->frame_size + sizeof(struct pwc_raw_frame));
drivers/media/usb/pwc/pwc-uncompress.c:			      pdev->width * pdev->height * 3 / 2);
drivers/media/usb/pwc/pwc-uncompress.c:	if (pdev->vbandlength == 0) {
drivers/media/usb/pwc/pwc-uncompress.c:		n = pdev->width * pdev->height;
drivers/media/usb/pwc/pwc-uncompress.c:		for (line = 0; line < pdev->height; line++) {
drivers/media/usb/pwc/pwc-uncompress.c:			for (col = 0; col < pdev->width; col += 4) {
drivers/media/usb/pwc/pwc-uncompress.c:	if (DEVICE_USE_CODEC1(pdev->type)) {
drivers/media/usb/pwc/pwc-misc.c:		if (!(pdev->image_mask & (1 << i)))
drivers/media/usb/pwc/pwc-misc.c:		if (pdev->image_mask & (1 << i))
drivers/media/usb/pwc/pwc-misc.c:	if (DEVICE_USE_CODEC1(pdev->type)) {
drivers/media/usb/pwc/pwc-misc.c:		pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QCIF | 1 << PSZ_CIF;
drivers/media/usb/pwc/pwc-misc.c:		pdev->vcinterface = 2;
drivers/media/usb/pwc/pwc-misc.c:		pdev->vendpoint = 4;
drivers/media/usb/pwc/pwc-misc.c:		pdev->frame_header_size = 0;
drivers/media/usb/pwc/pwc-misc.c:		pdev->frame_trailer_size = 0;
drivers/media/usb/pwc/pwc-misc.c:	} else if (DEVICE_USE_CODEC3(pdev->type)) {
drivers/media/usb/pwc/pwc-misc.c:		pdev->image_mask = 1 << PSZ_QSIF | 1 << PSZ_SIF | 1 << PSZ_VGA;
drivers/media/usb/pwc/pwc-misc.c:		pdev->vcinterface = 3;
drivers/media/usb/pwc/pwc-misc.c:		pdev->vendpoint = 5;
drivers/media/usb/pwc/pwc-misc.c:		pdev->frame_header_size = TOUCAM_HEADER_SIZE;
drivers/media/usb/pwc/pwc-misc.c:		pdev->frame_trailer_size = TOUCAM_TRAILER_SIZE;
drivers/media/usb/pwc/pwc-misc.c:	} else /* if (DEVICE_USE_CODEC2(pdev->type)) */ {
drivers/media/usb/pwc/pwc-misc.c:		pdev->image_mask = 1 << PSZ_SQCIF | 1 << PSZ_QSIF | 1 << PSZ_QCIF | 1 << PSZ_SIF | 1 << PSZ_CIF | 1 << PSZ_VGA;
drivers/media/usb/pwc/pwc-misc.c:		pdev->vcinterface = 3;
drivers/media/usb/pwc/pwc-misc.c:		pdev->vendpoint = 4;
drivers/media/usb/pwc/pwc-misc.c:		pdev->frame_header_size = 0;
drivers/media/usb/pwc/pwc-misc.c:		pdev->frame_trailer_size = 0;
drivers/media/usb/pwc/pwc-ctrl.c:	rc = usb_control_msg(pdev->udev, usb_rcvctrlpipe(pdev->udev, 0),
drivers/media/usb/pwc/pwc-ctrl.c:		value, pdev->vcinterface,
drivers/media/usb/pwc/pwc-ctrl.c:		pdev->ctrl_buf, recv_count, USB_CTRL_GET_TIMEOUT);
drivers/media/usb/pwc/pwc-ctrl.c:	memcpy(pdev->ctrl_buf, buf, buflen);
drivers/media/usb/pwc/pwc-ctrl.c:	rc = usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
drivers/media/usb/pwc/pwc-ctrl.c:			pdev->ctrl_buf, buflen, USB_CTRL_SET_TIMEOUT);
drivers/media/usb/pwc/pwc-ctrl.c:		memcpy(pdev->cmd_buf, buf, buflen);
drivers/media/usb/pwc/pwc-ctrl.c:	return usb_control_msg(pdev->udev, usb_sndctrlpipe(pdev->udev, 0),
drivers/media/usb/pwc/pwc-ctrl.c:			value, pdev->vcinterface,
drivers/media/usb/pwc/pwc-ctrl.c:		ret = send_video_command(pdev, pdev->vendpoint,
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->pixfmt = pixfmt;
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->vframes = frames;
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->valternate = pEntry->alternate;
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->width  = pwc_image_sizes[size][0];
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->height = pwc_image_sizes[size][1];
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->frame_size = (pdev->width * pdev->height * 3) / 2;
drivers/media/usb/pwc/pwc-ctrl.c:		if (pdev->release < 5) { /* 4 fold compression */
drivers/media/usb/pwc/pwc-ctrl.c:			pdev->vbandlength = 528;
drivers/media/usb/pwc/pwc-ctrl.c:			pdev->frame_size /= 4;
drivers/media/usb/pwc/pwc-ctrl.c:			pdev->vbandlength = 704;
drivers/media/usb/pwc/pwc-ctrl.c:			pdev->frame_size /= 3;
drivers/media/usb/pwc/pwc-ctrl.c:		pdev->vbandlength = 0;
drivers/media/usb/pwc/pwc-ctrl.c:		ret = send_video_command(pdev, pdev->vendpoint,
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->pixfmt = pixfmt;
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->vframes = (fps + 1) * 5;
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->valternate = pChoose->alternate;
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->width  = pwc_image_sizes[size][0];
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->height = pwc_image_sizes[size][1];
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->vbandlength = pChoose->bandlength;
drivers/media/usb/pwc/pwc-ctrl.c:		pdev->frame_size = (pChoose->bandlength * pdev->height) / 4;
drivers/media/usb/pwc/pwc-ctrl.c:		pdev->frame_size = (pdev->width * pdev->height * 12) / 8;
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->pixfmt = pixfmt;
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->vframes = (fps + 1) * 5;
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->valternate = pChoose->alternate;
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->width  = pwc_image_sizes[size][0];
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->height = pwc_image_sizes[size][1];
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->vbandlength = pChoose->bandlength;
drivers/media/usb/pwc/pwc-ctrl.c:	if (pdev->vbandlength > 0)
drivers/media/usb/pwc/pwc-ctrl.c:		pdev->frame_size = (pdev->vbandlength * pdev->height) / 4;
drivers/media/usb/pwc/pwc-ctrl.c:		pdev->frame_size = (pdev->width * pdev->height * 12) / 8;
drivers/media/usb/pwc/pwc-ctrl.c:	    pdev->frame_size, pdev->vframes, size, pdev->vbandlength);
drivers/media/usb/pwc/pwc-ctrl.c:	if (DEVICE_USE_CODEC1(pdev->type)) {
drivers/media/usb/pwc/pwc-ctrl.c:	} else if (DEVICE_USE_CODEC3(pdev->type)) {
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->frame_total_size = pdev->frame_size + pdev->frame_header_size + pdev->frame_trailer_size;
drivers/media/usb/pwc/pwc-ctrl.c:	PWC_DEBUG_SIZE("Set resolution to %dx%d\n", pdev->width, pdev->height);
drivers/media/usb/pwc/pwc-ctrl.c:	if (DEVICE_USE_CODEC1(pdev->type)) {
drivers/media/usb/pwc/pwc-ctrl.c:	} else if (DEVICE_USE_CODEC3(pdev->type)) {
drivers/media/usb/pwc/pwc-ctrl.c:	*data = pdev->ctrl_buf[0];
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->ctrl_buf[0] = data;
drivers/media/usb/pwc/pwc-ctrl.c:	ret = send_control_msg(pdev, request, value, pdev->ctrl_buf, 1);
drivers/media/usb/pwc/pwc-ctrl.c:	*data = ((s8 *)pdev->ctrl_buf)[0];
drivers/media/usb/pwc/pwc-ctrl.c:	*data = (pdev->ctrl_buf[1] << 8) | pdev->ctrl_buf[0];
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->ctrl_buf[0] = data & 0xff;
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->ctrl_buf[1] = data >> 8;
drivers/media/usb/pwc/pwc-ctrl.c:	ret = send_control_msg(pdev, request, value, pdev->ctrl_buf, 2);
drivers/media/usb/pwc/pwc-ctrl.c:	if (!pdev->power_save)
drivers/media/usb/pwc/pwc-ctrl.c:	if (pdev->type < 675 || (pdev->type < 730 && pdev->release < 6))
drivers/media/usb/pwc/pwc-ctrl.c:		pdev->ctrl_buf[0] = 0x00; /* active */
drivers/media/usb/pwc/pwc-ctrl.c:		pdev->ctrl_buf[0] = 0xFF; /* power save */
drivers/media/usb/pwc/pwc-ctrl.c:		SET_POWER_SAVE_MODE_FORMATTER, pdev->ctrl_buf, 1);
drivers/media/usb/pwc/pwc-ctrl.c:	if (pdev->type < 730)
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->ctrl_buf[0] = on_value;
drivers/media/usb/pwc/pwc-ctrl.c:	pdev->ctrl_buf[1] = off_value;
drivers/media/usb/pwc/pwc-ctrl.c:		SET_STATUS_CTL, LED_FORMATTER, pdev->ctrl_buf, 2);
drivers/media/usb/pwc/pwc-ctrl.c:	if (pdev->type < 675)
drivers/media/usb/pwc/pwc-ctrl.c:	else if (pdev->type < 730)
drivers/media/usb/pwc/pwc-ctrl.c:	if (pdev->type < 675)
drivers/media/usb/pwc/pwc-ctrl.c:		*sensor = pdev->ctrl_buf[0] | 0x100;
drivers/media/usb/pwc/pwc-ctrl.c:		*sensor = pdev->ctrl_buf[0];
drivers/i2c/busses/i2c-highlander.c:		dev_err(&pdev->dev, "no mem resource\n");
drivers/i2c/busses/i2c-highlander.c:	dev->dev = &pdev->dev;
drivers/i2c/busses/i2c-highlander.c:				  pdev->name, dev);
drivers/i2c/busses/i2c-highlander.c:		dev_notice(&pdev->dev, "no IRQ, using polling mode\n");
drivers/i2c/busses/i2c-highlander.c:	adap->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-highlander.c:	adap->nr = pdev->id;
drivers/i2c/busses/i2c-highlander.c:		dev_err(&pdev->dev, "controller didn't come up\n");
drivers/i2c/busses/i2c-highlander.c:		dev_err(&pdev->dev, "failure adding adapter\n");
drivers/i2c/busses/i2c-viapro.c:			dev_err(&pdev->dev, "Cannot configure "
drivers/i2c/busses/i2c-viapro.c:		dev_err(&pdev->dev, "SMBus base address "
drivers/i2c/busses/i2c-viapro.c:		dev_err(&pdev->dev, "SMBus region 0x%x already in use!\n",
drivers/i2c/busses/i2c-viapro.c:		dev_warn(&pdev->dev, "WARNING: SMBus interface set to new "
drivers/i2c/busses/i2c-viapro.c:			dev_info(&pdev->dev, "Enabling SMBus device\n");
drivers/i2c/busses/i2c-viapro.c:			dev_err(&pdev->dev, "SMBUS: Error: Host SMBus "
drivers/i2c/busses/i2c-viapro.c:	dev_dbg(&pdev->dev, "VT596_smba = 0x%X\n", vt596_smba);
drivers/i2c/busses/i2c-viapro.c:	switch (pdev->device) {
drivers/i2c/busses/i2c-viapro.c:		if (pdev->revision >= 0x40)
drivers/i2c/busses/i2c-viapro.c:	vt596_adapter.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-puv3.c:		dev_err(&pdev->dev, "can't allocate interface!\n");
drivers/i2c/busses/i2c-puv3.c:	adapter->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-puv3.c:	adapter->nr = pdev->id;
drivers/i2c/busses/i2c-puv3.c:		dev_err(&pdev->dev, "Adapter '%s' registration failed\n",
drivers/i2c/busses/i2c-puv3.c:	dev_info(&pdev->dev, "PKUnity v3 i2c bus adapter.\n");
drivers/i2c/busses/i2c-puv3.c:	put_device(&pdev->dev);
drivers/i2c/busses/i2c-octeon.c:	i2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);
drivers/i2c/busses/i2c-octeon.c:		dev_err(&pdev->dev, "kzalloc failed\n");
drivers/i2c/busses/i2c-octeon.c:	i2c->dev = &pdev->dev;
drivers/i2c/busses/i2c-octeon.c:	if (of_property_read_u32(pdev->dev.of_node,
drivers/i2c/busses/i2c-octeon.c:	    of_property_read_u32(pdev->dev.of_node,
drivers/i2c/busses/i2c-octeon.c:	if (!devm_request_mem_region(&pdev->dev, i2c->twsi_phys, i2c->regsize,
drivers/i2c/busses/i2c-octeon.c:	i2c->twsi_base = devm_ioremap(&pdev->dev, i2c->twsi_phys, i2c->regsize);
drivers/i2c/busses/i2c-octeon.c:	result = devm_request_irq(&pdev->dev, i2c->irq,
drivers/i2c/busses/i2c-octeon.c:	i2c->adap.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-octeon.c:	i2c->adap.dev.of_node = pdev->dev.of_node;
drivers/i2c/busses/i2c-bcm2835.c:	i2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);
drivers/i2c/busses/i2c-bcm2835.c:		dev_err(&pdev->dev, "Cannot allocate i2c_dev\n");
drivers/i2c/busses/i2c-bcm2835.c:	i2c_dev->dev = &pdev->dev;
drivers/i2c/busses/i2c-bcm2835.c:		dev_err(&pdev->dev, "No mem resource\n");
drivers/i2c/busses/i2c-bcm2835.c:	requested = devm_request_mem_region(&pdev->dev, mem->start,
drivers/i2c/busses/i2c-bcm2835.c:					    dev_name(&pdev->dev));
drivers/i2c/busses/i2c-bcm2835.c:		dev_err(&pdev->dev, "Could not claim register region\n");
drivers/i2c/busses/i2c-bcm2835.c:	i2c_dev->regs = devm_ioremap(&pdev->dev, mem->start,
drivers/i2c/busses/i2c-bcm2835.c:		dev_err(&pdev->dev, "Could not map registers\n");
drivers/i2c/busses/i2c-bcm2835.c:	i2c_dev->clk = devm_clk_get(&pdev->dev, NULL);
drivers/i2c/busses/i2c-bcm2835.c:		dev_err(&pdev->dev, "Could not get clock\n");
drivers/i2c/busses/i2c-bcm2835.c:	ret = of_property_read_u32(pdev->dev.of_node, "clock-frequency",
drivers/i2c/busses/i2c-bcm2835.c:		dev_warn(&pdev->dev,
drivers/i2c/busses/i2c-bcm2835.c:		dev_err(&pdev->dev, "No IRQ resource\n");
drivers/i2c/busses/i2c-bcm2835.c:			  dev_name(&pdev->dev), i2c_dev);
drivers/i2c/busses/i2c-bcm2835.c:		dev_err(&pdev->dev, "Could not request IRQ\n");
drivers/i2c/busses/i2c-bcm2835.c:	adap->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-s3c2410.c:	if (pdev->dev.of_node) {
drivers/i2c/busses/i2c-s3c2410.c:		match = of_match_node(s3c24xx_i2c_match, pdev->dev.of_node);
drivers/i2c/busses/i2c-s3c2410.c:	if (!pdev->dev.of_node) {
drivers/i2c/busses/i2c-s3c2410.c:		pdata = pdev->dev.platform_data;
drivers/i2c/busses/i2c-s3c2410.c:			dev_err(&pdev->dev, "no platform data\n");
drivers/i2c/busses/i2c-s3c2410.c:	i2c = devm_kzalloc(&pdev->dev, sizeof(struct s3c24xx_i2c), GFP_KERNEL);
drivers/i2c/busses/i2c-s3c2410.c:		dev_err(&pdev->dev, "no memory for state\n");
drivers/i2c/busses/i2c-s3c2410.c:	i2c->pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/i2c/busses/i2c-s3c2410.c:		dev_err(&pdev->dev, "no memory for platform data\n");
drivers/i2c/busses/i2c-s3c2410.c:		s3c24xx_i2c_parse_dt(pdev->dev.of_node, i2c);
drivers/i2c/busses/i2c-s3c2410.c:	i2c->dev = &pdev->dev;
drivers/i2c/busses/i2c-s3c2410.c:	i2c->clk = devm_clk_get(&pdev->dev, "i2c");
drivers/i2c/busses/i2c-s3c2410.c:		dev_err(&pdev->dev, "cannot get clock\n");
drivers/i2c/busses/i2c-s3c2410.c:	dev_dbg(&pdev->dev, "clock source %p\n", i2c->clk);
drivers/i2c/busses/i2c-s3c2410.c:	i2c->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/i2c/busses/i2c-s3c2410.c:	dev_dbg(&pdev->dev, "registers %p (%p)\n",
drivers/i2c/busses/i2c-s3c2410.c:	i2c->adap.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-s3c2410.c:		dev_err(&pdev->dev, "I2C controller init failed\n");
drivers/i2c/busses/i2c-s3c2410.c:		dev_err(&pdev->dev, "cannot find IRQ\n");
drivers/i2c/busses/i2c-s3c2410.c:	ret = devm_request_irq(&pdev->dev, i2c->irq, s3c24xx_i2c_irq, 0,
drivers/i2c/busses/i2c-s3c2410.c:			       dev_name(&pdev->dev), i2c);
drivers/i2c/busses/i2c-s3c2410.c:		dev_err(&pdev->dev, "cannot claim IRQ %d\n", i2c->irq);
drivers/i2c/busses/i2c-s3c2410.c:		dev_err(&pdev->dev, "failed to register cpufreq notifier\n");
drivers/i2c/busses/i2c-s3c2410.c:	i2c->adap.dev.of_node = pdev->dev.of_node;
drivers/i2c/busses/i2c-s3c2410.c:		dev_err(&pdev->dev, "failed to add bus to i2c core\n");
drivers/i2c/busses/i2c-s3c2410.c:	pm_runtime_enable(&pdev->dev);
drivers/i2c/busses/i2c-s3c2410.c:	dev_info(&pdev->dev, "%s: S3C I2C adapter\n", dev_name(&i2c->adap.dev));
drivers/i2c/busses/i2c-s3c2410.c:	pm_runtime_disable(&pdev->dev);
drivers/i2c/busses/i2c-s3c2410.c:	if (pdev->dev.of_node && IS_ERR(i2c->pctrl))
drivers/i2c/busses/i2c-pxa.c:	struct device_node *np = pdev->dev.of_node;
drivers/i2c/busses/i2c-pxa.c:			of_match_device(i2c_pxa_dt_ids, &pdev->dev);
drivers/i2c/busses/i2c-pxa.c:	struct i2c_pxa_platform_data *plat = pdev->dev.platform_data;
drivers/i2c/busses/i2c-xlr.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
drivers/i2c/busses/i2c-xlr.c:	priv->iobase = devm_ioremap_resource(&pdev->dev, res);
drivers/i2c/busses/i2c-xlr.c:	priv->adap.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-xlr.c:	priv->adap.nr		= pdev->id;
drivers/i2c/busses/i2c-au1550.c:					  pdev->name);
drivers/i2c/busses/i2c-au1550.c:	priv->adap.nr = pdev->id;
drivers/i2c/busses/i2c-au1550.c:	priv->adap.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-sirf.c:	clk = clk_get(&pdev->dev, NULL);
drivers/i2c/busses/i2c-sirf.c:		dev_err(&pdev->dev, "Clock get failed\n");
drivers/i2c/busses/i2c-sirf.c:		dev_err(&pdev->dev, "Clock prepare failed\n");
drivers/i2c/busses/i2c-sirf.c:		dev_err(&pdev->dev, "Clock enable failed\n");
drivers/i2c/busses/i2c-sirf.c:	siic = devm_kzalloc(&pdev->dev, sizeof(*siic), GFP_KERNEL);
drivers/i2c/busses/i2c-sirf.c:		dev_err(&pdev->dev, "Can't allocate driver data\n");
drivers/i2c/busses/i2c-sirf.c:	siic->base = devm_ioremap_resource(&pdev->dev, mem_res);
drivers/i2c/busses/i2c-sirf.c:	err = devm_request_irq(&pdev->dev, irq, i2c_sirfsoc_irq, 0,
drivers/i2c/busses/i2c-sirf.c:		dev_name(&pdev->dev), siic);
drivers/i2c/busses/i2c-sirf.c:	adap->dev.of_node = pdev->dev.of_node;
drivers/i2c/busses/i2c-sirf.c:	adap->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-sirf.c:	adap->nr = pdev->id;
drivers/i2c/busses/i2c-sirf.c:	err = of_property_read_u32(pdev->dev.of_node,
drivers/i2c/busses/i2c-sirf.c:		dev_err(&pdev->dev, "Can't add new i2c adapter\n");
drivers/i2c/busses/i2c-sirf.c:	dev_info(&pdev->dev, " I2C adapter ready to operate\n");
drivers/i2c/busses/i2c-ocores.c:	struct device_node *np = pdev->dev.of_node;
drivers/i2c/busses/i2c-ocores.c:				dev_err(&pdev->dev, "invalid regstep %d\n",
drivers/i2c/busses/i2c-ocores.c:			dev_warn(&pdev->dev,
drivers/i2c/busses/i2c-ocores.c:		dev_err(&pdev->dev,
drivers/i2c/busses/i2c-ocores.c:	of_property_read_u32(pdev->dev.of_node, "reg-io-width",
drivers/i2c/busses/i2c-ocores.c:	match = of_match_node(ocores_i2c_match, pdev->dev.of_node);
drivers/i2c/busses/i2c-ocores.c:		dev_dbg(&pdev->dev, "GRLIB variant of i2c-ocores\n");
drivers/i2c/busses/i2c-ocores.c:	i2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);
drivers/i2c/busses/i2c-ocores.c:	i2c->base = devm_ioremap_resource(&pdev->dev, res);
drivers/i2c/busses/i2c-ocores.c:	pdata = pdev->dev.platform_data;
drivers/i2c/busses/i2c-ocores.c:			dev_err(&pdev->dev, "Unsupported I/O width (%d)\n",
drivers/i2c/busses/i2c-ocores.c:	ret = devm_request_irq(&pdev->dev, irq, ocores_isr, 0,
drivers/i2c/busses/i2c-ocores.c:			       pdev->name, i2c);
drivers/i2c/busses/i2c-ocores.c:		dev_err(&pdev->dev, "Cannot claim IRQ\n");
drivers/i2c/busses/i2c-ocores.c:	i2c->adap.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-ocores.c:	i2c->adap.dev.of_node = pdev->dev.of_node;
drivers/i2c/busses/i2c-ocores.c:		dev_err(&pdev->dev, "Failed to add adapter\n");
drivers/i2c/busses/i2c-gpio.c:	if (pdev->dev.of_node) {
drivers/i2c/busses/i2c-gpio.c:		ret = of_i2c_gpio_get_pins(pdev->dev.of_node,
drivers/i2c/busses/i2c-gpio.c:		if (!pdev->dev.platform_data)
drivers/i2c/busses/i2c-gpio.c:		pdata = pdev->dev.platform_data;
drivers/i2c/busses/i2c-gpio.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
drivers/i2c/busses/i2c-gpio.c:	if (pdev->dev.of_node) {
drivers/i2c/busses/i2c-gpio.c:		of_i2c_gpio_get_props(pdev->dev.of_node, pdata);
drivers/i2c/busses/i2c-gpio.c:		memcpy(pdata, pdev->dev.platform_data, sizeof(*pdata));
drivers/i2c/busses/i2c-gpio.c:	if (pdev->dev.of_node)
drivers/i2c/busses/i2c-gpio.c:		strlcpy(adap->name, dev_name(&pdev->dev), sizeof(adap->name));
drivers/i2c/busses/i2c-gpio.c:		snprintf(adap->name, sizeof(adap->name), "i2c-gpio%d", pdev->id);
drivers/i2c/busses/i2c-gpio.c:	adap->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-gpio.c:	adap->dev.of_node = pdev->dev.of_node;
drivers/i2c/busses/i2c-gpio.c:	adap->nr = pdev->id;
drivers/i2c/busses/i2c-gpio.c:	dev_info(&pdev->dev, "using pins %u (SDA) and %u (SCL%s)\n",
drivers/i2c/busses/i2c-tegra.c:	base = devm_ioremap_resource(&pdev->dev, res);
drivers/i2c/busses/i2c-tegra.c:		dev_err(&pdev->dev, "no irq resource\n");
drivers/i2c/busses/i2c-tegra.c:	div_clk = devm_clk_get(&pdev->dev, "div-clk");
drivers/i2c/busses/i2c-tegra.c:		dev_err(&pdev->dev, "missing controller clock");
drivers/i2c/busses/i2c-tegra.c:	i2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);
drivers/i2c/busses/i2c-tegra.c:		dev_err(&pdev->dev, "Could not allocate struct tegra_i2c_dev");
drivers/i2c/busses/i2c-tegra.c:	i2c_dev->cont_id = pdev->id;
drivers/i2c/busses/i2c-tegra.c:	i2c_dev->dev = &pdev->dev;
drivers/i2c/busses/i2c-tegra.c:	if (pdev->dev.of_node) {
drivers/i2c/busses/i2c-tegra.c:		match = of_match_device(tegra_i2c_of_match, &pdev->dev);
drivers/i2c/busses/i2c-tegra.c:		i2c_dev->is_dvc = of_device_is_compatible(pdev->dev.of_node,
drivers/i2c/busses/i2c-tegra.c:	} else if (pdev->id == 3) {
drivers/i2c/busses/i2c-tegra.c:		fast_clk = devm_clk_get(&pdev->dev, "fast-clk");
drivers/i2c/busses/i2c-tegra.c:			dev_err(&pdev->dev, "missing fast clock");
drivers/i2c/busses/i2c-tegra.c:		dev_err(&pdev->dev, "Failed to initialize i2c controller");
drivers/i2c/busses/i2c-tegra.c:	ret = devm_request_irq(&pdev->dev, i2c_dev->irq,
drivers/i2c/busses/i2c-tegra.c:			tegra_i2c_isr, 0, dev_name(&pdev->dev), i2c_dev);
drivers/i2c/busses/i2c-tegra.c:		dev_err(&pdev->dev, "Failed to request irq %i\n", i2c_dev->irq);
drivers/i2c/busses/i2c-tegra.c:	i2c_dev->adapter.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-tegra.c:	i2c_dev->adapter.nr = pdev->id;
drivers/i2c/busses/i2c-tegra.c:	i2c_dev->adapter.dev.of_node = pdev->dev.of_node;
drivers/i2c/busses/i2c-tegra.c:		dev_err(&pdev->dev, "Failed to add I2C adapter\n");
drivers/i2c/busses/i2c-designware-platdrv.c:	if (!ACPI_HANDLE(&pdev->dev))
drivers/i2c/busses/i2c-designware-platdrv.c:		dev_err(&pdev->dev, "no mem resource?\n");
drivers/i2c/busses/i2c-designware-platdrv.c:		dev_err(&pdev->dev, "no irq resource?\n");
drivers/i2c/busses/i2c-designware-platdrv.c:	dev = devm_kzalloc(&pdev->dev, sizeof(struct dw_i2c_dev), GFP_KERNEL);
drivers/i2c/busses/i2c-designware-platdrv.c:	dev->base = devm_ioremap_resource(&pdev->dev, mem);
drivers/i2c/busses/i2c-designware-platdrv.c:	dev->dev = &pdev->dev;
drivers/i2c/busses/i2c-designware-platdrv.c:	dev->clk = devm_clk_get(&pdev->dev, NULL);
drivers/i2c/busses/i2c-designware-platdrv.c:		dev->adapter.nr = pdev->id;
drivers/i2c/busses/i2c-designware-platdrv.c:	r = devm_request_irq(&pdev->dev, dev->irq, i2c_dw_isr, IRQF_SHARED,
drivers/i2c/busses/i2c-designware-platdrv.c:			pdev->name, dev);
drivers/i2c/busses/i2c-designware-platdrv.c:		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
drivers/i2c/busses/i2c-designware-platdrv.c:	adap->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-designware-platdrv.c:	adap->dev.of_node = pdev->dev.of_node;
drivers/i2c/busses/i2c-designware-platdrv.c:		dev_err(&pdev->dev, "failure adding adapter\n");
drivers/i2c/busses/i2c-designware-platdrv.c:	pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
drivers/i2c/busses/i2c-designware-platdrv.c:	pm_runtime_use_autosuspend(&pdev->dev);
drivers/i2c/busses/i2c-designware-platdrv.c:	pm_runtime_set_active(&pdev->dev);
drivers/i2c/busses/i2c-designware-platdrv.c:	pm_runtime_enable(&pdev->dev);
drivers/i2c/busses/i2c-designware-platdrv.c:	pm_runtime_get_sync(&pdev->dev);
drivers/i2c/busses/i2c-designware-platdrv.c:	pm_runtime_put(&pdev->dev);
drivers/i2c/busses/i2c-designware-platdrv.c:	pm_runtime_disable(&pdev->dev);
drivers/i2c/busses/i2c-davinci.c:		dev_err(&pdev->dev, "no mem resource?\n");
drivers/i2c/busses/i2c-davinci.c:		dev_err(&pdev->dev, "no irq resource?\n");
drivers/i2c/busses/i2c-davinci.c:	dev = devm_kzalloc(&pdev->dev, sizeof(struct davinci_i2c_dev),
drivers/i2c/busses/i2c-davinci.c:		dev_err(&pdev->dev, "Memory allocation failed\n");
drivers/i2c/busses/i2c-davinci.c:	dev->dev = &pdev->dev;
drivers/i2c/busses/i2c-davinci.c:	if (!dev->pdata && pdev->dev.of_node) {
drivers/i2c/busses/i2c-davinci.c:		dev->pdata = devm_kzalloc(&pdev->dev,
drivers/i2c/busses/i2c-davinci.c:		if (!of_property_read_u32(pdev->dev.of_node, "clock-frequency",
drivers/i2c/busses/i2c-davinci.c:	dev->clk = devm_clk_get(&pdev->dev, NULL);
drivers/i2c/busses/i2c-davinci.c:	dev->base = devm_ioremap_resource(&pdev->dev, mem);
drivers/i2c/busses/i2c-davinci.c:	r = devm_request_irq(&pdev->dev, dev->irq, i2c_davinci_isr, 0,
drivers/i2c/busses/i2c-davinci.c:			pdev->name, dev);
drivers/i2c/busses/i2c-davinci.c:		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
drivers/i2c/busses/i2c-davinci.c:		dev_err(&pdev->dev, "failed to register cpufreq\n");
drivers/i2c/busses/i2c-davinci.c:	adap->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-davinci.c:	adap->dev.of_node = pdev->dev.of_node;
drivers/i2c/busses/i2c-davinci.c:	adap->nr = pdev->id;
drivers/i2c/busses/i2c-davinci.c:		dev_err(&pdev->dev, "failure adding adapter\n");
drivers/i2c/busses/i2c-at91.c:	if (pdev->dev.of_node) {
drivers/i2c/busses/i2c-at91.c:		match = of_match_node(atmel_twi_dt_ids, pdev->dev.of_node);
drivers/i2c/busses/i2c-at91.c:	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
drivers/i2c/busses/i2c-at91.c:	dev->dev = &pdev->dev;
drivers/i2c/busses/i2c-at91.c:	dev->base = devm_ioremap_resource(&pdev->dev, mem);
drivers/i2c/busses/i2c-at91.c:	rc = devm_request_irq(&pdev->dev, dev->irq, atmel_twi_interrupt, 0,
drivers/i2c/busses/i2c-at91.c:	dev->adapter.nr = pdev->id;
drivers/i2c/busses/i2c-at91.c:	dev->adapter.dev.of_node = pdev->dev.of_node;
drivers/i2c/busses/i2c-pca-platform.c:				pdev->dev.platform_data;
drivers/i2c/busses/i2c-pca-platform.c:	i2c->adap.nr = pdev->id;
drivers/i2c/busses/i2c-pca-platform.c:	i2c->adap.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-pca-platform.c:			IRQF_TRIGGER_FALLING, pdev->name, i2c);
drivers/i2c/busses/i2c-parport-light.c:	parport_adapter.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-parport-light.c:		dev_err(&pdev->dev, "Unable to register with I2C\n");
drivers/i2c/busses/i2c-parport-light.c:			dev_warn(&pdev->dev, "Failed to register ARA client\n");
drivers/i2c/busses/i2c-stu300.c:	dev_err(&dev->pdev->dev,
drivers/i2c/busses/i2c-stu300.c:		dev_err(&dev->pdev->dev,
drivers/i2c/busses/i2c-stu300.c:		dev_err(&dev->pdev->dev, "controller timed out "
drivers/i2c/busses/i2c-stu300.c:		dev_err(&dev->pdev->dev, "controller (start) "
drivers/i2c/busses/i2c-stu300.c:		dev_err(&dev->pdev->dev, "irqs are disabled on this "
drivers/i2c/busses/i2c-stu300.c:		dev_err(&dev->pdev->dev,
drivers/i2c/busses/i2c-stu300.c:			dev_err(&dev->pdev->dev, "controller "
drivers/i2c/busses/i2c-stu300.c:			dev_err(&dev->pdev->dev, "controller "
drivers/i2c/busses/i2c-stu300.c:		dev_err(&dev->pdev->dev, "transaction timed out "
drivers/i2c/busses/i2c-stu300.c:		dev_err(&dev->pdev->dev, "base address = "
drivers/i2c/busses/i2c-stu300.c:	dev_err(&dev->pdev->dev, "giving up after %d attempts "
drivers/i2c/busses/i2c-stu300.c:		dev_err(&dev->pdev->dev, "too %s clock rate requested "
drivers/i2c/busses/i2c-stu300.c:	dev_dbg(&dev->pdev->dev, "Clock rate %lu Hz, I2C bus speed %d Hz "
drivers/i2c/busses/i2c-stu300.c:		dev_err(&dev->pdev->dev, "too low clock rate (%lu Hz).\n",
drivers/i2c/busses/i2c-stu300.c:		dev_err(&dev->pdev->dev, "too high clock rate (%lu Hz).\n",
drivers/i2c/busses/i2c-stu300.c:		dev_dbg(&dev->pdev->dev, "set clock divider to 0x%08x, "
drivers/i2c/busses/i2c-stu300.c:		dev_dbg(&dev->pdev->dev, "set clock divider to "
drivers/i2c/busses/i2c-stu300.c:			dev_dbg(&dev->pdev->dev, "read resend\n");
drivers/i2c/busses/i2c-stu300.c:		dev_dbg(&dev->pdev->dev, "write resend\n");
drivers/i2c/busses/i2c-stu300.c:		dev_dbg(&dev->pdev->dev, "await event 6\n");
drivers/i2c/busses/i2c-stu300.c:		dev_dbg(&dev->pdev->dev, "I2C message to: 0x%04x, len: %d, "
drivers/i2c/busses/i2c-stu300.c:			dev_dbg(&dev->pdev->dev, "wait while busy\n");
drivers/i2c/busses/i2c-stu300.c:			dev_dbg(&dev->pdev->dev, "re-int hw\n");
drivers/i2c/busses/i2c-stu300.c:				dev_dbg(&dev->pdev->dev, "send start event\n");
drivers/i2c/busses/i2c-stu300.c:			dev_dbg(&dev->pdev->dev, "send address\n");
drivers/i2c/busses/i2c-stu300.c:			dev_dbg(&dev->pdev->dev, "failed sending address, "
drivers/i2c/busses/i2c-stu300.c:		dev_dbg(&dev->pdev->dev, "managed to get address "
drivers/i2c/busses/i2c-stu300.c:		dev_dbg(&dev->pdev->dev, "I give up, tried %d times "
drivers/i2c/busses/i2c-stu300.c:				dev_err(&dev->pdev->dev, "error awaiting "
drivers/i2c/busses/i2c-stu300.c:				dev_err(&dev->pdev->dev, "I2C payload "
drivers/i2c/busses/i2c-stu300.c:		dev_err(&dev->pdev->dev, "timout waiting for transfer "
drivers/i2c/busses/i2c-stu300.c:	dev = devm_kzalloc(&pdev->dev, sizeof(struct stu300_dev), GFP_KERNEL);
drivers/i2c/busses/i2c-stu300.c:		dev_err(&pdev->dev, "could not allocate device struct\n");
drivers/i2c/busses/i2c-stu300.c:	bus_nr = pdev->id;
drivers/i2c/busses/i2c-stu300.c:	dev->clk = devm_clk_get(&pdev->dev, clk_name);
drivers/i2c/busses/i2c-stu300.c:		dev_err(&pdev->dev, "could not retrieve i2c bus clock\n");
drivers/i2c/busses/i2c-stu300.c:	dev->virtbase = devm_ioremap_resource(&pdev->dev, res);
drivers/i2c/busses/i2c-stu300.c:	dev_dbg(&pdev->dev, "initialize bus device I2C%d on virtual "
drivers/i2c/busses/i2c-stu300.c:	ret = devm_request_irq(&pdev->dev, dev->irq, stu300_irh, 0, NAME, dev);
drivers/i2c/busses/i2c-stu300.c:		dev_err(&dev->pdev->dev, "error initializing hardware.\n");
drivers/i2c/busses/i2c-stu300.c:	adap->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-stu300.c:		dev_err(&pdev->dev, "failure adding ST Micro DDC "
drivers/i2c/busses/i2c-pnx.c:	alg_data->adapter.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-pnx.c:	alg_data->adapter.nr = pdev->id;
drivers/i2c/busses/i2c-pnx.c:	alg_data->adapter.dev.of_node = of_node_get(pdev->dev.of_node);
drivers/i2c/busses/i2c-pnx.c:	if (pdev->dev.of_node) {
drivers/i2c/busses/i2c-pnx.c:		of_property_read_u32(pdev->dev.of_node, "clock-frequency",
drivers/i2c/busses/i2c-pnx.c:		 * of_property_read_u32(pdev->dev.of_node, "timeout",
drivers/i2c/busses/i2c-pnx.c:	alg_data->clk = clk_get(&pdev->dev, NULL);
drivers/i2c/busses/i2c-pnx.c:		 "%s", pdev->name);
drivers/i2c/busses/i2c-pnx.c:		dev_err(&pdev->dev, "Unable to get mem resource.\n");
drivers/i2c/busses/i2c-pnx.c:				pdev->name)) {
drivers/i2c/busses/i2c-pnx.c:		dev_err(&pdev->dev,
drivers/i2c/busses/i2c-pnx.c:		dev_err(&pdev->dev, "Couldn't ioremap I2C I/O region\n");
drivers/i2c/busses/i2c-pnx.c:		dev_err(&pdev->dev, "Failed to get IRQ from platform resource\n");
drivers/i2c/busses/i2c-pnx.c:			0, pdev->name, alg_data);
drivers/i2c/busses/i2c-pnx.c:		dev_err(&pdev->dev, "I2C: Failed to add bus\n");
drivers/i2c/busses/i2c-pnx.c:	dev_dbg(&pdev->dev, "%s: Master at %#8x, irq %d.\n",
drivers/i2c/busses/i2c-pxa-pci.c:	pdev->dev.parent = &dev->dev;
drivers/i2c/busses/i2c-pxa-pci.c:	pdev->dev.of_node = child;
drivers/i2c/busses/i2c-iop3xx.c:	if (!request_mem_region(res->start, IOP3XX_I2C_IO_SIZE, pdev->name)) {
drivers/i2c/busses/i2c-iop3xx.c:				pdev->name, adapter_data);
drivers/i2c/busses/i2c-iop3xx.c:	memcpy(new_adapter->name, pdev->name, strlen(pdev->name));
drivers/i2c/busses/i2c-iop3xx.c:	new_adapter->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-iop3xx.c:	new_adapter->nr = pdev->id;
drivers/i2c/busses/i2c-cbus-gpio.c:	adapter = devm_kzalloc(&pdev->dev, sizeof(struct i2c_adapter),
drivers/i2c/busses/i2c-cbus-gpio.c:	chost = devm_kzalloc(&pdev->dev, sizeof(*chost), GFP_KERNEL);
drivers/i2c/busses/i2c-cbus-gpio.c:	if (pdev->dev.of_node) {
drivers/i2c/busses/i2c-cbus-gpio.c:		struct device_node *dnode = pdev->dev.of_node;
drivers/i2c/busses/i2c-cbus-gpio.c:	} else if (pdev->dev.platform_data) {
drivers/i2c/busses/i2c-cbus-gpio.c:		struct i2c_cbus_platform_data *pdata = pdev->dev.platform_data;
drivers/i2c/busses/i2c-cbus-gpio.c:	adapter->dev.parent	= &pdev->dev;
drivers/i2c/busses/i2c-cbus-gpio.c:	adapter->nr		= pdev->id;
drivers/i2c/busses/i2c-cbus-gpio.c:	chost->dev = &pdev->dev;
drivers/i2c/busses/i2c-cbus-gpio.c:	ret = devm_gpio_request_one(&pdev->dev, chost->clk_gpio,
drivers/i2c/busses/i2c-cbus-gpio.c:	ret = devm_gpio_request_one(&pdev->dev, chost->dat_gpio, GPIOF_IN,
drivers/i2c/busses/i2c-cbus-gpio.c:	ret = devm_gpio_request_one(&pdev->dev, chost->sel_gpio,
drivers/i2c/busses/i2c-amd756.c:		dev_err(&pdev->dev, "Only one device supported "
drivers/i2c/busses/i2c-amd756.c:		if (PCI_FUNC(pdev->devfn) != 1)
drivers/i2c/busses/i2c-amd756.c:		if (PCI_FUNC(pdev->devfn) != 3)
drivers/i2c/busses/i2c-amd756.c:			dev_err(&pdev->dev,
drivers/i2c/busses/i2c-amd756.c:		dev_err(&pdev->dev, "SMB region 0x%x already in use!\n",
drivers/i2c/busses/i2c-amd756.c:	dev_dbg(&pdev->dev, "SMBREV = 0x%X\n", temp);
drivers/i2c/busses/i2c-amd756.c:	dev_dbg(&pdev->dev, "AMD756_smba = 0x%X\n", amd756_ioport);
drivers/i2c/busses/i2c-amd756.c:	amd756_smbus.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-amd756.c:		dev_err(&pdev->dev,
drivers/i2c/busses/i2c-xiic.c:	pdata = (struct xiic_i2c_platform_data *) pdev->dev.platform_data;
drivers/i2c/busses/i2c-xiic.c:	if (!request_mem_region(res->start, resource_size(res), pdev->name)) {
drivers/i2c/busses/i2c-xiic.c:		dev_err(&pdev->dev, "Memory region busy\n");
drivers/i2c/busses/i2c-xiic.c:		dev_err(&pdev->dev, "Unable to map registers\n");
drivers/i2c/busses/i2c-xiic.c:	i2c->adap.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-xiic.c:	i2c->adap.dev.of_node = pdev->dev.of_node;
drivers/i2c/busses/i2c-xiic.c:	ret = request_irq(irq, xiic_isr, 0, pdev->name, i2c);
drivers/i2c/busses/i2c-xiic.c:		dev_err(&pdev->dev, "Cannot claim IRQ\n");
drivers/i2c/busses/i2c-xiic.c:		dev_err(&pdev->dev, "Failed to add adapter\n");
drivers/i2c/busses/i2c-xiic.c:	dev_err(&pdev->dev, "IRQ or Memory resource is missing\n");
drivers/i2c/busses/i2c-mxs.c:	struct device *dev = &pdev->dev;
drivers/i2c/busses/i2c-mxs.c:	adap->nr = pdev->id;
drivers/i2c/busses/i2c-mxs.c:	adap->dev.of_node = pdev->dev.of_node;
drivers/i2c/busses/i2c-ismt.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
drivers/i2c/busses/i2c-ismt.c:	priv->adapter.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-ismt.c:		dev_err(&pdev->dev, "Failed to enable SMBus PCI device (%d)\n",
drivers/i2c/busses/i2c-ismt.c:		dev_err(&pdev->dev,
drivers/i2c/busses/i2c-ismt.c:	err = acpi_check_resource_conflict(&pdev->resource[SMBBAR]);
drivers/i2c/busses/i2c-ismt.c:		dev_err(&pdev->dev, "ACPI resource conflict!\n");
drivers/i2c/busses/i2c-ismt.c:		dev_err(&pdev->dev,
drivers/i2c/busses/i2c-ismt.c:		dev_err(&pdev->dev, "Unable to ioremap SMBus BAR\n");
drivers/i2c/busses/i2c-ismt.c:			dev_err(&pdev->dev, "pci_set_dma_mask fail %p\n",
drivers/i2c/busses/i2c-ismt.c:		dev_err(&pdev->dev, "Failed to add SMBus iSMT adapter\n");
drivers/i2c/busses/i2c-nuc900.c:	pdata = pdev->dev.platform_data;
drivers/i2c/busses/i2c-nuc900.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/i2c/busses/i2c-nuc900.c:		dev_err(&pdev->dev, "no memory for state\n");
drivers/i2c/busses/i2c-nuc900.c:	i2c->dev = &pdev->dev;
drivers/i2c/busses/i2c-nuc900.c:	i2c->clk = clk_get(&pdev->dev, NULL);
drivers/i2c/busses/i2c-nuc900.c:		dev_err(&pdev->dev, "cannot get clock\n");
drivers/i2c/busses/i2c-nuc900.c:	dev_dbg(&pdev->dev, "clock source %p\n", i2c->clk);
drivers/i2c/busses/i2c-nuc900.c:		dev_err(&pdev->dev, "cannot find IO resource\n");
drivers/i2c/busses/i2c-nuc900.c:					 pdev->name);
drivers/i2c/busses/i2c-nuc900.c:		dev_err(&pdev->dev, "cannot request IO\n");
drivers/i2c/busses/i2c-nuc900.c:		dev_err(&pdev->dev, "cannot map IO\n");
drivers/i2c/busses/i2c-nuc900.c:	dev_dbg(&pdev->dev, "registers %p (%p, %p)\n",
drivers/i2c/busses/i2c-nuc900.c:	i2c->adap.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-nuc900.c:	mfp_set_groupg(&pdev->dev, NULL);
drivers/i2c/busses/i2c-nuc900.c:		dev_err(&pdev->dev, "cannot find IRQ\n");
drivers/i2c/busses/i2c-nuc900.c:			  dev_name(&pdev->dev), i2c);
drivers/i2c/busses/i2c-nuc900.c:		dev_err(&pdev->dev, "cannot claim IRQ %d\n", i2c->irq);
drivers/i2c/busses/i2c-nuc900.c:		dev_err(&pdev->dev, "failed to add bus to i2c core\n");
drivers/i2c/busses/i2c-nuc900.c:	dev_info(&pdev->dev, "%s: NUC900 I2C adapter\n",
drivers/i2c/busses/i2c-bfin-twi.c:		dev_err(&pdev->dev, "Cannot allocate memory\n");
drivers/i2c/busses/i2c-bfin-twi.c:		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
drivers/i2c/busses/i2c-bfin-twi.c:		dev_err(&pdev->dev, "Cannot map IO\n");
drivers/i2c/busses/i2c-bfin-twi.c:		dev_err(&pdev->dev, "No IRQ specified\n");
drivers/i2c/busses/i2c-bfin-twi.c:	p_adap->nr = pdev->id;
drivers/i2c/busses/i2c-bfin-twi.c:	strlcpy(p_adap->name, pdev->name, sizeof(p_adap->name));
drivers/i2c/busses/i2c-bfin-twi.c:	p_adap->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-bfin-twi.c:	rc = peripheral_request_list((unsigned short *)pdev->dev.platform_data,
drivers/i2c/busses/i2c-bfin-twi.c:		dev_err(&pdev->dev, "Can't setup pin mux!\n");
drivers/i2c/busses/i2c-bfin-twi.c:		0, pdev->name, iface);
drivers/i2c/busses/i2c-bfin-twi.c:		dev_err(&pdev->dev, "Can't get IRQ %d !\n", iface->irq);
drivers/i2c/busses/i2c-bfin-twi.c:		dev_err(&pdev->dev, "Can't add i2c adapter!\n");
drivers/i2c/busses/i2c-bfin-twi.c:	dev_info(&pdev->dev, "Blackfin BF5xx on-chip I2C TWI Contoller, "
drivers/i2c/busses/i2c-bfin-twi.c:	peripheral_free_list((unsigned short *)pdev->dev.platform_data);
drivers/i2c/busses/i2c-bfin-twi.c:	peripheral_free_list((unsigned short *)pdev->dev.platform_data);
drivers/i2c/busses/i2c-designware-pcidrv.c:		dev_err(&pdev->dev, "pci_save_state failed\n");
drivers/i2c/busses/i2c-designware-pcidrv.c:		dev_err(&pdev->dev, "pci_set_power_state failed\n");
drivers/i2c/busses/i2c-designware-pcidrv.c:		dev_err(&pdev->dev, "pci_set_power_state() failed\n");
drivers/i2c/busses/i2c-designware-pcidrv.c:		dev_err(&pdev->dev, "%s: invalid driver data %ld\n", __func__,
drivers/i2c/busses/i2c-designware-pcidrv.c:		dev_err(&pdev->dev, "Failed to enable I2C PCI device (%d)\n",
drivers/i2c/busses/i2c-designware-pcidrv.c:		dev_err(&pdev->dev, "I/O memory remapping failed\n");
drivers/i2c/busses/i2c-designware-pcidrv.c:	dev = devm_kzalloc(&pdev->dev, sizeof(struct dw_i2c_dev), GFP_KERNEL);
drivers/i2c/busses/i2c-designware-pcidrv.c:	dev->dev = &pdev->dev;
drivers/i2c/busses/i2c-designware-pcidrv.c:	adap->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-designware-pcidrv.c:	r = devm_request_irq(&pdev->dev, pdev->irq, i2c_dw_isr, IRQF_SHARED,
drivers/i2c/busses/i2c-designware-pcidrv.c:		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
drivers/i2c/busses/i2c-designware-pcidrv.c:		dev_err(&pdev->dev, "failure adding adapter\n");
drivers/i2c/busses/i2c-designware-pcidrv.c:	pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
drivers/i2c/busses/i2c-designware-pcidrv.c:	pm_runtime_use_autosuspend(&pdev->dev);
drivers/i2c/busses/i2c-designware-pcidrv.c:	pm_runtime_allow(&pdev->dev);
drivers/i2c/busses/i2c-designware-pcidrv.c:	pm_runtime_forbid(&pdev->dev);
drivers/i2c/busses/i2c-designware-pcidrv.c:	pm_runtime_get_noresume(&pdev->dev);
drivers/i2c/busses/i2c-viperboard.c:	struct vprbrd *vb = dev_get_drvdata(pdev->dev.parent);
drivers/i2c/busses/i2c-viperboard.c:		dev_err(&pdev->dev,
drivers/i2c/busses/i2c-viperboard.c:		dev_err(&pdev->dev,
drivers/i2c/busses/i2c-viperboard.c:	vb_i2c->i2c.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-rcar.c:	struct i2c_rcar_platform_data *pdata = pdev->dev.platform_data;
drivers/i2c/busses/i2c-rcar.c:	struct device *dev = &pdev->dev;
drivers/i2c/busses/i2c-rcar.c:	adap->nr		= pdev->id;
drivers/i2c/busses/i2c-rcar.c:	strlcpy(adap->name, pdev->name, sizeof(adap->name));
drivers/i2c/busses/i2c-rcar.c:	struct device *dev = &pdev->dev;
drivers/i2c/busses/i2c-sh7760.c:	pd = pdev->dev.platform_data;
drivers/i2c/busses/i2c-sh7760.c:		dev_err(&pdev->dev, "no platform_data!\n");
drivers/i2c/busses/i2c-sh7760.c:		dev_err(&pdev->dev, "no mem for private data\n");
drivers/i2c/busses/i2c-sh7760.c:		dev_err(&pdev->dev, "no mmio resources\n");
drivers/i2c/busses/i2c-sh7760.c:	id->ioarea = request_mem_region(res->start, REGSIZE, pdev->name);
drivers/i2c/busses/i2c-sh7760.c:		dev_err(&pdev->dev, "mmio already reserved\n");
drivers/i2c/busses/i2c-sh7760.c:		dev_err(&pdev->dev, "cannot ioremap\n");
drivers/i2c/busses/i2c-sh7760.c:	id->adap.nr = pdev->id;
drivers/i2c/busses/i2c-sh7760.c:	id->adap.dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-sh7760.c:		dev_err(&pdev->dev, "invalid SCL clock: %dkHz\n",
drivers/i2c/busses/i2c-sh7760.c:		dev_err(&pdev->dev, "cannot get irq %d\n", id->irq);
drivers/i2c/busses/i2c-sh7760.c:		dev_err(&pdev->dev, "reg adap failed: %d\n", ret);
drivers/i2c/busses/i2c-sh7760.c:	dev_info(&pdev->dev, "%d kHz mmio %08x irq %d\n",
drivers/i2c/busses/i2c-imx.c:							   &pdev->dev);
drivers/i2c/busses/i2c-imx.c:	struct imxi2c_platform_data *pdata = pdev->dev.platform_data;
drivers/i2c/busses/i2c-imx.c:	dev_dbg(&pdev->dev, "<%s>\n", __func__);
drivers/i2c/busses/i2c-imx.c:		dev_err(&pdev->dev, "can't get device resources\n");
drivers/i2c/busses/i2c-imx.c:		dev_err(&pdev->dev, "can't get irq number\n");
drivers/i2c/busses/i2c-imx.c:	base = devm_ioremap_resource(&pdev->dev, res);
drivers/i2c/busses/i2c-imx.c:	i2c_imx = devm_kzalloc(&pdev->dev, sizeof(struct imx_i2c_struct),
drivers/i2c/busses/i2c-imx.c:		dev_err(&pdev->dev, "can't allocate interface\n");
drivers/i2c/busses/i2c-imx.c:		pdev->id_entry = of_id->data;
drivers/i2c/busses/i2c-imx.c:	i2c_imx->devtype = pdev->id_entry->driver_data;
drivers/i2c/busses/i2c-imx.c:	strlcpy(i2c_imx->adapter.name, pdev->name, sizeof(i2c_imx->adapter.name));
drivers/i2c/busses/i2c-imx.c:	i2c_imx->adapter.dev.parent	= &pdev->dev;
drivers/i2c/busses/i2c-imx.c:	i2c_imx->adapter.nr 		= pdev->id;
drivers/i2c/busses/i2c-imx.c:	i2c_imx->adapter.dev.of_node	= pdev->dev.of_node;
drivers/i2c/busses/i2c-imx.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/i2c/busses/i2c-imx.c:		dev_err(&pdev->dev, "can't get/select pinctrl\n");
drivers/i2c/busses/i2c-imx.c:	i2c_imx->clk = devm_clk_get(&pdev->dev, NULL);
drivers/i2c/busses/i2c-imx.c:		dev_err(&pdev->dev, "can't get I2C clock\n");
drivers/i2c/busses/i2c-imx.c:	ret = devm_request_irq(&pdev->dev, irq, i2c_imx_isr, 0,
drivers/i2c/busses/i2c-imx.c:				pdev->name, i2c_imx);
drivers/i2c/busses/i2c-imx.c:		dev_err(&pdev->dev, "can't claim irq %d\n", irq);
drivers/i2c/busses/i2c-imx.c:	ret = of_property_read_u32(pdev->dev.of_node,
drivers/i2c/busses/i2c-imx.c:		dev_err(&pdev->dev, "registration failed\n");
drivers/i2c/busses/i2c-eg20t.c:	dev_err(&pdev->dev, "%s :" fmt, __func__, ##arg)
drivers/i2c/busses/i2c-eg20t.c:	dev_dbg(&pdev->dev, "%s :" fmt, __func__, ##arg)
drivers/i2c/busses/i2c-eg20t.c:	ret = request_irq(pdev->irq, pch_i2c_handler, IRQF_SHARED,
drivers/i2c/busses/i2c-eg20t.c:		pch_adap->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-eg20t.c:	free_irq(pdev->irq, adap_info);
drivers/i2c/busses/i2c-eg20t.c:	free_irq(pdev->irq, adap_info);
drivers/i2c/busses/scx200_acb.c:		dev_err(&pdev->dev, "can't fetch device resource info\n");
drivers/i2c/busses/scx200_acb.c:	iface = scx200_create_dev("CS5535", res->start, 0, &pdev->dev);
drivers/i2c/busses/scx200_acb.c:	dev_info(&pdev->dev, "SCx200 device '%s' registered\n",
drivers/i2c/busses/i2c-parport.c:		if (adapter->pdev->port == port) {
drivers/i2c/busses/i2c-omap.c:		pdev->dev.platform_data;
drivers/i2c/busses/i2c-omap.c:	struct device_node	*node = pdev->dev.of_node;
drivers/i2c/busses/i2c-omap.c:		dev_err(&pdev->dev, "no mem resource?\n");
drivers/i2c/busses/i2c-omap.c:		dev_err(&pdev->dev, "no irq resource?\n");
drivers/i2c/busses/i2c-omap.c:	dev = devm_kzalloc(&pdev->dev, sizeof(struct omap_i2c_dev), GFP_KERNEL);
drivers/i2c/busses/i2c-omap.c:		dev_err(&pdev->dev, "Menory allocation failed\n");
drivers/i2c/busses/i2c-omap.c:	dev->base = devm_ioremap_resource(&pdev->dev, mem);
drivers/i2c/busses/i2c-omap.c:	match = of_match_device(of_match_ptr(omap_i2c_of_match), &pdev->dev);
drivers/i2c/busses/i2c-omap.c:	dev->pins = devm_pinctrl_get_select_default(&pdev->dev);
drivers/i2c/busses/i2c-omap.c:		dev_warn(&pdev->dev, "did not get pins for i2c error: %li\n",
drivers/i2c/busses/i2c-omap.c:	dev->dev = &pdev->dev;
drivers/i2c/busses/i2c-omap.c:		r = devm_request_irq(&pdev->dev, dev->irq, omap_i2c_omap1_isr,
drivers/i2c/busses/i2c-omap.c:				IRQF_NO_SUSPEND, pdev->name, dev);
drivers/i2c/busses/i2c-omap.c:		r = devm_request_threaded_irq(&pdev->dev, dev->irq,
drivers/i2c/busses/i2c-omap.c:				pdev->name, dev);
drivers/i2c/busses/i2c-omap.c:	adap->dev.parent = &pdev->dev;
drivers/i2c/busses/i2c-omap.c:	adap->dev.of_node = pdev->dev.of_node;
drivers/i2c/busses/i2c-omap.c:	adap->nr = pdev->id;
drivers/i2c/busses/i2c-omap.c:	pm_runtime_disable(&pdev->dev);
drivers/i2c/busses/i2c-omap.c:	ret = pm_runtime_get_sync(&pdev->dev);
drivers/i2c/busses/i2c-omap.c:	pm_runtime_put(&pdev->dev);
drivers/i2c/busses/i2c-omap.c:	pm_runtime_disable(&pdev->dev);
drivers/i2c/muxes/i2c-mux-pinctrl.c:	struct device_node *np = pdev->dev.of_node;
drivers/i2c/muxes/i2c-mux-pinctrl.c:	mux->pdata = devm_kzalloc(&pdev->dev, sizeof(*mux->pdata), GFP_KERNEL);
drivers/i2c/muxes/i2c-mux-pinctrl.c:	mux->pdata->pinctrl_states = devm_kzalloc(&pdev->dev,
drivers/i2c/muxes/i2c-mux-pinctrl.c:	mux = devm_kzalloc(&pdev->dev, sizeof(*mux), GFP_KERNEL);
drivers/i2c/muxes/i2c-mux-pinctrl.c:		dev_err(&pdev->dev, "Cannot allocate i2c_mux_pinctrl\n");
drivers/i2c/muxes/i2c-mux-pinctrl.c:	mux->dev = &pdev->dev;
drivers/i2c/muxes/i2c-mux-pinctrl.c:	mux->pdata = pdev->dev.platform_data;
drivers/i2c/muxes/i2c-mux-pinctrl.c:		dev_err(&pdev->dev, "Missing platform data\n");
drivers/i2c/muxes/i2c-mux-pinctrl.c:	mux->states = devm_kzalloc(&pdev->dev,
drivers/i2c/muxes/i2c-mux-pinctrl.c:		dev_err(&pdev->dev, "Cannot allocate states\n");
drivers/i2c/muxes/i2c-mux-pinctrl.c:	mux->busses = devm_kzalloc(&pdev->dev,
drivers/i2c/muxes/i2c-mux-pinctrl.c:		dev_err(&pdev->dev, "Cannot allocate busses\n");
drivers/i2c/muxes/i2c-mux-pinctrl.c:	mux->pinctrl = devm_pinctrl_get(&pdev->dev);
drivers/i2c/muxes/i2c-mux-pinctrl.c:		dev_err(&pdev->dev, "Cannot get pinctrl: %d\n", ret);
drivers/i2c/muxes/i2c-mux-pinctrl.c:				dev_err(&pdev->dev,
drivers/i2c/muxes/i2c-mux-pinctrl.c:			dev_err(&pdev->dev,
drivers/i2c/muxes/i2c-mux-pinctrl.c:		dev_err(&pdev->dev, "Parent adapter (%d) not found\n",
drivers/i2c/muxes/i2c-mux-pinctrl.c:		mux->busses[i] = i2c_add_mux_adapter(mux->parent, &pdev->dev,
drivers/i2c/muxes/i2c-mux-pinctrl.c:			dev_err(&pdev->dev, "Failed to add adapter %d\n", i);
drivers/i2c/muxes/i2c-mux-gpio.c:	struct device_node *np = pdev->dev.of_node;
drivers/i2c/muxes/i2c-mux-gpio.c:		dev_err(&pdev->dev, "Cannot parse i2c-parent\n");
drivers/i2c/muxes/i2c-mux-gpio.c:		dev_err(&pdev->dev, "Cannot find parent bus\n");
drivers/i2c/muxes/i2c-mux-gpio.c:	values = devm_kzalloc(&pdev->dev,
drivers/i2c/muxes/i2c-mux-gpio.c:		dev_err(&pdev->dev, "Cannot allocate values array");
drivers/i2c/muxes/i2c-mux-gpio.c:		dev_err(&pdev->dev, "Missing mux-gpios property in the DT.\n");
drivers/i2c/muxes/i2c-mux-gpio.c:	gpios = devm_kzalloc(&pdev->dev,
drivers/i2c/muxes/i2c-mux-gpio.c:		dev_err(&pdev->dev, "Cannot allocate gpios array");
drivers/i2c/muxes/i2c-mux-gpio.c:	mux = devm_kzalloc(&pdev->dev, sizeof(*mux), GFP_KERNEL);
drivers/i2c/muxes/i2c-mux-gpio.c:		dev_err(&pdev->dev, "Cannot allocate gpiomux structure");
drivers/i2c/muxes/i2c-mux-gpio.c:	if (!pdev->dev.platform_data) {
drivers/i2c/muxes/i2c-mux-gpio.c:		memcpy(&mux->data, pdev->dev.platform_data, sizeof(mux->data));
drivers/i2c/muxes/i2c-mux-gpio.c:		dev_err(&pdev->dev, "Parent adapter (%d) not found\n",
drivers/i2c/muxes/i2c-mux-gpio.c:	mux->adap = devm_kzalloc(&pdev->dev,
drivers/i2c/muxes/i2c-mux-gpio.c:		dev_err(&pdev->dev, "Cannot allocate i2c_adapter structure");
drivers/i2c/muxes/i2c-mux-gpio.c:			dev_err(&pdev->dev, "Failed to request GPIO %d\n",
drivers/i2c/muxes/i2c-mux-gpio.c:			dev_err(&pdev->dev,
drivers/i2c/muxes/i2c-mux-gpio.c:		mux->adap[i] = i2c_add_mux_adapter(parent, &pdev->dev, mux, nr,
drivers/i2c/muxes/i2c-mux-gpio.c:			dev_err(&pdev->dev, "Failed to add adapter %d\n", i);
drivers/i2c/muxes/i2c-mux-gpio.c:	dev_info(&pdev->dev, "%d port mux on %s adapter\n",
drivers/i2c/muxes/i2c-arb-gpio-challenge.c:	struct device *dev = &pdev->dev;
drivers/leds/leds-fsg.c:	latch_address = (unsigned short *) devm_ioremap(&pdev->dev,
drivers/leds/leds-fsg.c:	ret = led_classdev_register(&pdev->dev, &fsg_wlan_led);
drivers/leds/leds-fsg.c:	ret = led_classdev_register(&pdev->dev, &fsg_wan_led);
drivers/leds/leds-fsg.c:	ret = led_classdev_register(&pdev->dev, &fsg_sata_led);
drivers/leds/leds-fsg.c:	ret = led_classdev_register(&pdev->dev, &fsg_usb_led);
drivers/leds/leds-fsg.c:	ret = led_classdev_register(&pdev->dev, &fsg_sync_led);
drivers/leds/leds-fsg.c:	ret = led_classdev_register(&pdev->dev, &fsg_ring_led);
drivers/leds/leds-pwm.c:	struct device_node *node = pdev->dev.of_node;
drivers/leds/leds-pwm.c:	priv = devm_kzalloc(&pdev->dev, sizeof_pwm_leds_priv(count),
drivers/leds/leds-pwm.c:		led_dat->pwm = devm_of_pwm_get(&pdev->dev, child, NULL);
drivers/leds/leds-pwm.c:			dev_err(&pdev->dev, "unable to request PWM for %s\n",
drivers/leds/leds-pwm.c:		ret = led_classdev_register(&pdev->dev, &led_dat->cdev);
drivers/leds/leds-pwm.c:			dev_err(&pdev->dev, "failed to register for %s\n",
drivers/leds/leds-pwm.c:	struct led_pwm_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-pwm.c:		priv = devm_kzalloc(&pdev->dev,
drivers/leds/leds-pwm.c:			led_dat->pwm = devm_pwm_get(&pdev->dev, cur_led->name);
drivers/leds/leds-pwm.c:				dev_err(&pdev->dev,
drivers/leds/leds-pwm.c:			ret = led_classdev_register(&pdev->dev, &led_dat->cdev);
drivers/leds/leds-atmel-pwm.c:	pdata = pdev->dev.platform_data;
drivers/leds/leds-atmel-pwm.c:	leds = devm_kzalloc(&pdev->dev, pdata->num_leds * sizeof(*leds),
drivers/leds/leds-atmel-pwm.c:		status = led_classdev_register(&pdev->dev, &led->cdev);
drivers/leds/leds-atmel-pwm.c:	pdata = pdev->dev.platform_data;
drivers/leds/leds-gpio.c:	struct device_node *np = pdev->dev.of_node, *child;
drivers/leds/leds-gpio.c:	priv = devm_kzalloc(&pdev->dev, sizeof_gpio_leds_priv(count),
drivers/leds/leds-gpio.c:				      &pdev->dev, NULL);
drivers/leds/leds-gpio.c:	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-gpio.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/leds/leds-gpio.c:		dev_warn(&pdev->dev,
drivers/leds/leds-gpio.c:		priv = devm_kzalloc(&pdev->dev,
drivers/leds/leds-gpio.c:					      &pdev->dev, pdata->gpio_blink_set);
drivers/leds/leds-mc13783.c:	struct mc13xxx_leds_platform_data *pdata = dev_get_platdata(&pdev->dev);
drivers/leds/leds-mc13783.c:	struct mc13xxx *dev = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-mc13783.c:	struct mc13xxx_leds_platform_data *pdata = dev_get_platdata(&pdev->dev);
drivers/leds/leds-mc13783.c:		dev_err(&pdev->dev, "missing platform data\n");
drivers/leds/leds-mc13783.c:		dev_err(&pdev->dev, "Invalid led count %d\n", pdata->num_leds);
drivers/leds/leds-mc13783.c:	led = devm_kzalloc(&pdev->dev, pdata->num_leds * sizeof(*led),
drivers/leds/leds-mc13783.c:		dev_err(&pdev->dev, "failed to alloc memory\n");
drivers/leds/leds-mc13783.c:		dev_err(&pdev->dev, "unable to init led driver\n");
drivers/leds/leds-mc13783.c:			dev_err(&pdev->dev, "invalid id %d\n", led_cur->id);
drivers/leds/leds-mc13783.c:			dev_err(&pdev->dev, "led %d already initialized\n",
drivers/leds/leds-mc13783.c:		led_dat->master = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-mc13783.c:		ret = led_classdev_register(pdev->dev.parent, &led_dat->cdev);
drivers/leds/leds-mc13783.c:			dev_err(&pdev->dev, "failed to register led %d\n",
drivers/leds/leds-mc13783.c:			dev_err(&pdev->dev, "unable to init led %d\n",
drivers/leds/leds-mc13783.c:	struct mc13xxx_leds_platform_data *pdata = dev_get_platdata(&pdev->dev);
drivers/leds/leds-mc13783.c:	struct mc13xxx *dev = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-lp8788.c:	struct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-lp8788.c:	struct device *dev = &pdev->dev;
drivers/leds/leds-regulator.c:	struct led_regulator_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-regulator.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/leds/leds-regulator.c:	vcc = regulator_get_exclusive(&pdev->dev, "vled");
drivers/leds/leds-regulator.c:		dev_err(&pdev->dev, "Cannot get vcc for %s\n", pdata->name);
drivers/leds/leds-regulator.c:	led = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);
drivers/leds/leds-regulator.c:		dev_err(&pdev->dev, "Invalid default brightness %d\n",
drivers/leds/leds-regulator.c:	ret = led_classdev_register(&pdev->dev, &led->cdev);
drivers/leds/leds-max8997.c:	struct max8997_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-max8997.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/leds/leds-max8997.c:	led = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);
drivers/leds/leds-max8997.c:	led->id = pdev->id;
drivers/leds/leds-max8997.c:	snprintf(name, sizeof(name), "max8997-led%d", pdev->id);
drivers/leds/leds-max8997.c:	ret = led_classdev_register(&pdev->dev, &led->cdev);
drivers/leds/leds-max8997.c:		dev_err(&pdev->dev,
drivers/leds/leds-ns2.c:	ret = devm_gpio_request_one(&pdev->dev, template->cmd,
drivers/leds/leds-ns2.c:		dev_err(&pdev->dev, "%s: failed to setup command GPIO\n",
drivers/leds/leds-ns2.c:	ret = devm_gpio_request_one(&pdev->dev, template->slow,
drivers/leds/leds-ns2.c:		dev_err(&pdev->dev, "%s: failed to setup slow GPIO\n",
drivers/leds/leds-ns2.c:	ret = led_classdev_register(&pdev->dev, &led_dat->cdev);
drivers/leds/leds-ns2.c:	struct ns2_led_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-ns2.c:		pdata = devm_kzalloc(&pdev->dev,
drivers/leds/leds-ns2.c:		ret = ns2_leds_get_of_pdata(&pdev->dev, pdata);
drivers/leds/leds-ns2.c:	priv = devm_kzalloc(&pdev->dev,
drivers/leds/leds-hp6xx.c:	ret = led_classdev_register(&pdev->dev, &hp6xx_red_led);
drivers/leds/leds-hp6xx.c:	ret = led_classdev_register(&pdev->dev, &hp6xx_green_led);
drivers/leds/leds-rb532.c:	return led_classdev_register(&pdev->dev, &rb532_uled);
drivers/leds/leds-cobalt-qube.c:	led_port = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/leds/leds-cobalt-qube.c:	retval = led_classdev_register(&pdev->dev, &qube_front_led);
drivers/leds/leds-sunfire.c:	if (pdev->num_resources != 1) {
drivers/leds/leds-sunfire.c:		dev_err(&pdev->dev, "Wrong number of resources %d, should be 1\n",
drivers/leds/leds-sunfire.c:		       pdev->num_resources);
drivers/leds/leds-sunfire.c:	p = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);
drivers/leds/leds-sunfire.c:		dev_err(&pdev->dev, "Could not allocate struct sunfire_drvdata\n");
drivers/leds/leds-sunfire.c:		p->leds[i].reg = (void __iomem *) pdev->resource[0].start;
drivers/leds/leds-sunfire.c:		err = led_classdev_register(&pdev->dev, lp);
drivers/leds/leds-sunfire.c:			dev_err(&pdev->dev, "Could not register %s LED\n",
drivers/leds/leds-sunfire.c:	dev_set_drvdata(&pdev->dev, p);
drivers/leds/leds-sunfire.c:	struct sunfire_drvdata *p = dev_get_drvdata(&pdev->dev);
drivers/leds/leds-asic3.c:	struct asic3 *asic = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-asic3.c:	struct asic3 *asic = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-asic3.c:	struct asic3_led *led = pdev->dev.platform_data;
drivers/leds/leds-asic3.c:	led->cdev = devm_kzalloc(&pdev->dev, sizeof(struct led_classdev),
drivers/leds/leds-asic3.c:	ret = led_classdev_register(&pdev->dev, led->cdev);
drivers/leds/leds-asic3.c:	struct asic3_led *led = pdev->dev.platform_data;
drivers/leds/leds-wm831x-status.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-wm831x-status.c:	int id = pdev->id % ARRAY_SIZE(chip_pdata->status);
drivers/leds/leds-wm831x-status.c:		dev_err(&pdev->dev, "No register resource\n");
drivers/leds/leds-wm831x-status.c:	drvdata = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_status),
drivers/leds/leds-wm831x-status.c:	dev_set_drvdata(&pdev->dev, drvdata);
drivers/leds/leds-wm831x-status.c:		pdata.name = dev_name(&pdev->dev);
drivers/leds/leds-wm831x-status.c:		dev_err(&pdev->dev, "Failed to register LED: %d\n", ret);
drivers/leds/leds-wm831x-status.c:		dev_err(&pdev->dev,
drivers/leds/leds-renesas-tpu.c:	struct led_renesas_tpu_config *cfg = p->pdev->dev.platform_data;
drivers/leds/leds-renesas-tpu.c:	struct led_renesas_tpu_config *cfg = p->pdev->dev.platform_data;
drivers/leds/leds-renesas-tpu.c:	struct led_renesas_tpu_config *cfg = p->pdev->dev.platform_data;
drivers/leds/leds-renesas-tpu.c:	struct led_renesas_tpu_config *cfg = p->pdev->dev.platform_data;
drivers/leds/leds-renesas-tpu.c:	pm_runtime_get_sync(&p->pdev->dev);
drivers/leds/leds-renesas-tpu.c:		dev_err(&p->pdev->dev, "cannot enable clock\n");
drivers/leds/leds-renesas-tpu.c:		dev_err(&p->pdev->dev, "clock rate mismatch\n");
drivers/leds/leds-renesas-tpu.c:	dev_dbg(&p->pdev->dev, "rate = %lu, prescaler %u\n",
drivers/leds/leds-renesas-tpu.c:	dev_dbg(&p->pdev->dev, "TRGB = 0x%04lx\n", rate);
drivers/leds/leds-renesas-tpu.c:	dev_dbg(&p->pdev->dev, "TRGA = 0x%04lx\n", tmp / cfg->max_brightness);
drivers/leds/leds-renesas-tpu.c:	pm_runtime_put_sync(&p->pdev->dev);
drivers/leds/leds-renesas-tpu.c:	pm_runtime_put_sync(&p->pdev->dev);
drivers/leds/leds-renesas-tpu.c:	struct led_renesas_tpu_config *cfg = p->pdev->dev.platform_data;
drivers/leds/leds-renesas-tpu.c:	struct led_renesas_tpu_config *cfg = pdev->dev.platform_data;
drivers/leds/leds-renesas-tpu.c:		dev_err(&pdev->dev, "missing platform data\n");
drivers/leds/leds-renesas-tpu.c:	p = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);
drivers/leds/leds-renesas-tpu.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/leds/leds-renesas-tpu.c:		dev_err(&pdev->dev, "failed to get I/O memory\n");
drivers/leds/leds-renesas-tpu.c:	p->mapbase = devm_ioremap_nocache(&pdev->dev, res->start,
drivers/leds/leds-renesas-tpu.c:		dev_err(&pdev->dev, "failed to remap I/O memory\n");
drivers/leds/leds-renesas-tpu.c:	p->clk = devm_clk_get(&pdev->dev, NULL);
drivers/leds/leds-renesas-tpu.c:		dev_err(&pdev->dev, "cannot get clock\n");
drivers/leds/leds-renesas-tpu.c:	ret = led_classdev_register(&pdev->dev, &p->ldev);
drivers/leds/leds-renesas-tpu.c:	pm_runtime_enable(&pdev->dev);
drivers/leds/leds-renesas-tpu.c:	pm_runtime_disable(&pdev->dev);
drivers/leds/leds-clevo-mail.c:	return led_classdev_register(&pdev->dev, &clevo_mail_led);
drivers/leds/leds-adp5520.c:	struct adp5520_leds_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-adp5520.c:	struct device *dev = pdev->dev.parent;
drivers/leds/leds-adp5520.c:	struct adp5520_leds_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-adp5520.c:		dev_err(&pdev->dev, "missing platform data\n");
drivers/leds/leds-adp5520.c:		dev_err(&pdev->dev, "can't handle more than %d LEDS\n",
drivers/leds/leds-adp5520.c:	led = devm_kzalloc(&pdev->dev, sizeof(*led) * pdata->num_leds,
drivers/leds/leds-adp5520.c:		dev_err(&pdev->dev, "failed to alloc memory\n");
drivers/leds/leds-adp5520.c:		dev_err(&pdev->dev, "failed to write\n");
drivers/leds/leds-adp5520.c:		led_dat->master = pdev->dev.parent;
drivers/leds/leds-adp5520.c:			dev_err(&pdev->dev, "failed to register LED %d\n",
drivers/leds/leds-adp5520.c:			dev_err(&pdev->dev, "failed to write\n");
drivers/leds/leds-adp5520.c:	struct adp5520_leds_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-cobalt-raq.c:	led_port = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/leds/leds-cobalt-raq.c:	retval = led_classdev_register(&pdev->dev, &raq_power_off_led);
drivers/leds/leds-cobalt-raq.c:	retval = led_classdev_register(&pdev->dev, &raq_web_led);
drivers/leds/leds-netxbig.c:	struct netxbig_led_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-netxbig.c:	ret = led_classdev_register(&pdev->dev, &led_dat->cdev);
drivers/leds/leds-netxbig.c:	struct netxbig_led_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-netxbig.c:	leds_data = devm_kzalloc(&pdev->dev,
drivers/leds/leds-netxbig.c:	struct netxbig_led_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-wm8350.c:	struct wm8350_led_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-wm8350.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/leds/leds-wm8350.c:		dev_err(&pdev->dev, "Invalid maximum current %duA\n",
drivers/leds/leds-wm8350.c:	isink = devm_regulator_get(&pdev->dev, "led_isink");
drivers/leds/leds-wm8350.c:		dev_err(&pdev->dev, "%s: can't get ISINK\n", __func__);
drivers/leds/leds-wm8350.c:	dcdc = devm_regulator_get(&pdev->dev, "led_vcc");
drivers/leds/leds-wm8350.c:		dev_err(&pdev->dev, "%s: can't get DCDC\n", __func__);
drivers/leds/leds-wm8350.c:	led = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);
drivers/leds/leds-wm8350.c:		dev_warn(&pdev->dev,
drivers/leds/leds-wm8350.c:	return led_classdev_register(&pdev->dev, &led->cdev);
drivers/leds/leds-lt3593.c:	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-lt3593.c:	leds_data = devm_kzalloc(&pdev->dev,
drivers/leds/leds-lt3593.c:				      &pdev->dev);
drivers/leds/leds-lt3593.c:	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
drivers/leds/leds-ot200.c:		ret = led_classdev_register(&pdev->dev, &leds[i].cdev);
drivers/leds/leds-88pm860x.c:	nproot = of_node_get(pdev->dev.parent->of_node);
drivers/leds/leds-88pm860x.c:		dev_err(&pdev->dev, "failed to find leds node\n");
drivers/leds/leds-88pm860x.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-88pm860x.c:	struct pm860x_led_pdata *pdata = pdev->dev.platform_data;
drivers/leds/leds-88pm860x.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct pm860x_led), GFP_KERNEL);
drivers/leds/leds-88pm860x.c:		dev_err(&pdev->dev, "No REG resource for control\n");
drivers/leds/leds-88pm860x.c:		dev_err(&pdev->dev, "No REG resource for blink\n");
drivers/leds/leds-88pm860x.c:	switch (pdev->id) {
drivers/leds/leds-88pm860x.c:	dev_set_drvdata(&pdev->dev, data);
drivers/leds/leds-88pm860x.c:	data->port = pdev->id;
drivers/leds/leds-88pm860x.c:		dev_err(&pdev->dev, "Failed to register LED: %d\n", ret);
drivers/leds/leds-da903x.c:	struct led_info *pdata = pdev->dev.platform_data;
drivers/leds/leds-da903x.c:	id = pdev->id;
drivers/leds/leds-da903x.c:		dev_err(&pdev->dev, "invalid LED ID (%d) specified\n", id);
drivers/leds/leds-da903x.c:	led = devm_kzalloc(&pdev->dev, sizeof(struct da903x_led), GFP_KERNEL);
drivers/leds/leds-da903x.c:		dev_err(&pdev->dev, "failed to alloc memory for LED%d\n", id);
drivers/leds/leds-da903x.c:	led->master = pdev->dev.parent;
drivers/leds/leds-da903x.c:		dev_err(&pdev->dev, "failed to register LED %d\n", id);
drivers/leds/leds-da9052.c:	da9052 = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-da9052.c:		dev_err(&pdev->dev, "No platform data\n");
drivers/leds/leds-da9052.c:		dev_err(&pdev->dev, "No platform data for LED\n");
drivers/leds/leds-da9052.c:	led = devm_kzalloc(&pdev->dev,
drivers/leds/leds-da9052.c:		dev_err(&pdev->dev, "Failed to alloc memory\n");
drivers/leds/leds-da9052.c:		led[i].da9052 = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-da9052.c:		error = led_classdev_register(pdev->dev.parent, &led[i].cdev);
drivers/leds/leds-da9052.c:			dev_err(&pdev->dev, "Failed to register led %d\n",
drivers/leds/leds-da9052.c:			dev_err(&pdev->dev, "Unable to init led %d\n",
drivers/leds/leds-da9052.c:		dev_err(&pdev->dev, "Failed to configure GPIO LED%d\n", error);
drivers/leds/leds-da9052.c:	da9052 = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-net48xx.c:	return led_classdev_register(&pdev->dev, &net48xx_error_led);
drivers/leds/leds-lm3533.c:	dev_dbg(&pdev->dev, "%s\n", __func__);
drivers/leds/leds-lm3533.c:	lm3533 = dev_get_drvdata(pdev->dev.parent);
drivers/leds/leds-lm3533.c:	pdata = pdev->dev.platform_data;
drivers/leds/leds-lm3533.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/leds/leds-lm3533.c:	if (pdev->id < 0 || pdev->id >= LM3533_LVCTRLBANK_COUNT) {
drivers/leds/leds-lm3533.c:		dev_err(&pdev->dev, "illegal LED id %d\n", pdev->id);
drivers/leds/leds-lm3533.c:	led = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);
drivers/leds/leds-lm3533.c:	led->id = pdev->id;
drivers/leds/leds-lm3533.c:	ret = led_classdev_register(pdev->dev.parent, &led->cdev);
drivers/leds/leds-lm3533.c:		dev_err(&pdev->dev, "failed to register LED %d\n", pdev->id);
drivers/leds/leds-lm3533.c:		dev_err(&pdev->dev, "failed to create sysfs attributes\n");
drivers/leds/leds-lm3533.c:	dev_dbg(&pdev->dev, "%s\n", __func__);
drivers/leds/leds-lm3533.c:	dev_dbg(&pdev->dev, "%s\n", __func__);
drivers/leds/leds-wrap.c:	ret = led_classdev_register(&pdev->dev, &wrap_power_led);
drivers/leds/leds-wrap.c:	ret = led_classdev_register(&pdev->dev, &wrap_error_led);
drivers/leds/leds-wrap.c:	ret = led_classdev_register(&pdev->dev, &wrap_extra_led);
drivers/watchdog/ie6xx_wdt.c:	if (!request_region(res->start, resource_size(res), pdev->name)) {
drivers/watchdog/ie6xx_wdt.c:		dev_err(&pdev->dev, "Watchdog region 0x%llx already in use!\n",
drivers/watchdog/ie6xx_wdt.c:	dev_dbg(&pdev->dev, "WDT = 0x%X\n", ie6xx_wdt_data.sch_wdtba);
drivers/watchdog/ie6xx_wdt.c:		dev_warn(&pdev->dev,
drivers/watchdog/ie6xx_wdt.c:		dev_err(&pdev->dev,
drivers/watchdog/twl4030_wdt.c:	wdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);
drivers/watchdog/omap_wdt.c:	struct omap_wd_timer_platform_data *pdata = pdev->dev.platform_data;
drivers/watchdog/omap_wdt.c:	omap_wdt = devm_kzalloc(&pdev->dev, sizeof(*omap_wdt), GFP_KERNEL);
drivers/watchdog/omap_wdt.c:	mem = devm_request_mem_region(&pdev->dev, res->start,
drivers/watchdog/omap_wdt.c:				      resource_size(res), pdev->name);
drivers/watchdog/omap_wdt.c:	wdev = devm_kzalloc(&pdev->dev, sizeof(*wdev), GFP_KERNEL);
drivers/watchdog/omap_wdt.c:	wdev->dev		= &pdev->dev;
drivers/watchdog/omap_wdt.c:	wdev->base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/watchdog/da9052_wdt.c:	struct da9052 *da9052 = dev_get_drvdata(pdev->dev.parent);
drivers/watchdog/da9052_wdt.c:	driver_data = devm_kzalloc(&pdev->dev, sizeof(*driver_data),
drivers/watchdog/da9052_wdt.c:		dev_err(&pdev->dev, "Failed to disable watchdog bits, %d\n",
drivers/watchdog/da9052_wdt.c:	dev_set_drvdata(&pdev->dev, driver_data);
drivers/watchdog/da9052_wdt.c:	struct da9052_wdt_data *driver_data = dev_get_drvdata(&pdev->dev);
drivers/watchdog/bcm63xx_wdt.c:		dev_err(&pdev->dev, "failed to get resources\n");
drivers/watchdog/bcm63xx_wdt.c:		dev_err(&pdev->dev, "failed to remap I/O resources\n");
drivers/watchdog/bcm63xx_wdt.c:		dev_err(&pdev->dev, "failed to register wdt timer isr\n");
drivers/watchdog/bcm63xx_wdt.c:		dev_info(&pdev->dev,
drivers/watchdog/bcm63xx_wdt.c:		dev_err(&pdev->dev, "failed to register watchdog device\n");
drivers/watchdog/bcm63xx_wdt.c:	dev_info(&pdev->dev, " started, timer margin: %d sec\n",
drivers/watchdog/ar7_wdt.c:	ar7_wdt = devm_ioremap_resource(&pdev->dev, ar7_regs_wdt);
drivers/watchdog/stmp3xxx_rtc_wdt.c:	watchdog_set_drvdata(&stmp3xxx_wdd, &pdev->dev);
drivers/watchdog/stmp3xxx_rtc_wdt.c:		dev_err(&pdev->dev, "cannot register watchdog device\n");
drivers/watchdog/stmp3xxx_rtc_wdt.c:	dev_info(&pdev->dev, "initialized watchdog with heartbeat %ds\n",
drivers/watchdog/at32ap700x_wdt.c:		dev_dbg(&pdev->dev, "only 1 wdt instance supported.\n");
drivers/watchdog/at32ap700x_wdt.c:		dev_dbg(&pdev->dev, "missing mmio resource\n");
drivers/watchdog/at32ap700x_wdt.c:		dev_dbg(&pdev->dev, "no memory for wdt structure\n");
drivers/watchdog/at32ap700x_wdt.c:		dev_dbg(&pdev->dev, "could not map I/O memory\n");
drivers/watchdog/at32ap700x_wdt.c:		dev_info(&pdev->dev, "CPU must be reset with external "
drivers/watchdog/at32ap700x_wdt.c:	wdt->miscdev.parent	= &pdev->dev;
drivers/watchdog/at32ap700x_wdt.c:		dev_dbg(&pdev->dev,
drivers/watchdog/at32ap700x_wdt.c:		dev_dbg(&pdev->dev, "failed to register wdt miscdev\n");
drivers/watchdog/at32ap700x_wdt.c:	dev_info(&pdev->dev,
drivers/watchdog/bcm47xx_wdt.c:	struct bcm47xx_wdt *wdt = dev_get_platdata(&pdev->dev);
drivers/watchdog/bcm47xx_wdt.c:	dev_info(&pdev->dev, "BCM47xx Watchdog Timer enabled (%d seconds%s%s)\n",
drivers/watchdog/bcm47xx_wdt.c:	struct bcm47xx_wdt *wdt = dev_get_platdata(&pdev->dev);
drivers/watchdog/shwdt.c:	if (pdev->id != -1)
drivers/watchdog/shwdt.c:	wdt = devm_kzalloc(&pdev->dev, sizeof(struct sh_wdt), GFP_KERNEL);
drivers/watchdog/shwdt.c:	wdt->dev = &pdev->dev;
drivers/watchdog/shwdt.c:	wdt->clk = clk_get(&pdev->dev, NULL);
drivers/watchdog/shwdt.c:		dev_warn(&pdev->dev,
drivers/watchdog/shwdt.c:	dev_info(&pdev->dev, "configured with heartbeat=%d sec (nowayout=%d)\n",
drivers/watchdog/shwdt.c:		dev_err(&pdev->dev, "Can't register watchdog (err=%d)\n", rc);
drivers/watchdog/shwdt.c:	dev_info(&pdev->dev, "initialized.\n");
drivers/watchdog/shwdt.c:	pm_runtime_enable(&pdev->dev);
drivers/watchdog/shwdt.c:	pm_runtime_disable(&pdev->dev);
drivers/watchdog/ux500_wdt.c:	struct ux500_wdt_data *pdata = pdev->dev.platform_data;
drivers/watchdog/ux500_wdt.c:	dev_info(&pdev->dev, "initialized\n");
drivers/watchdog/imx2_wdt.c:	imx2_wdt.base = devm_ioremap_resource(&pdev->dev, res);
drivers/watchdog/imx2_wdt.c:	imx2_wdt.clk = clk_get(&pdev->dev, NULL);
drivers/watchdog/imx2_wdt.c:		dev_err(&pdev->dev, "can't get Watchdog clock\n");
drivers/watchdog/imx2_wdt.c:		dev_warn(&pdev->dev, "Initial timeout out of range! "
drivers/watchdog/imx2_wdt.c:	imx2_wdt_miscdev.parent = &pdev->dev;
drivers/watchdog/imx2_wdt.c:	dev_info(&pdev->dev,
drivers/watchdog/at91sam9_wdt.c:		dev_err(&pdev->dev, "failed to map registers, aborting.\n");
drivers/watchdog/at91sam9_wdt.c:	at91_wdt_dev.parent = &pdev->dev;
drivers/watchdog/at91sam9_wdt.c:	watchdog_init_timeout(&at91_wdt_dev, heartbeat, &pdev->dev);
drivers/watchdog/ep93xx_wdt.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
drivers/watchdog/ep93xx_wdt.c:				     resource_size(res), pdev->name))
drivers/watchdog/ep93xx_wdt.c:	mmio_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/watchdog/ep93xx_wdt.c:		dev_warn(&pdev->dev,
drivers/watchdog/ep93xx_wdt.c:	dev_info(&pdev->dev,
drivers/watchdog/ath79_wdt.c:	wdt_base = devm_ioremap_resource(&pdev->dev, res);
drivers/watchdog/ath79_wdt.c:	wdt_clk = devm_clk_get(&pdev->dev, "wdt");
drivers/watchdog/ath79_wdt.c:		dev_info(&pdev->dev,
drivers/watchdog/ath79_wdt.c:		dev_err(&pdev->dev,
drivers/watchdog/davinci_wdt.c:	struct device *dev = &pdev->dev;
drivers/watchdog/max63xx_wdt.c:	table = (struct max63xx_timeout *)pdev->id_entry->driver_data;
drivers/watchdog/max63xx_wdt.c:	dev_info(&pdev->dev, "requesting %ds heartbeat\n", heartbeat);
drivers/watchdog/max63xx_wdt.c:		dev_err(&pdev->dev, "unable to satisfy heartbeat request\n");
drivers/watchdog/max63xx_wdt.c:	dev_info(&pdev->dev, "using %ds heartbeat with %ds initial delay\n",
drivers/watchdog/max63xx_wdt.c:	wdt_base = devm_ioremap_resource(&pdev->dev, wdt_mem);
drivers/watchdog/dw_wdt.c:	dw_wdt.regs = devm_ioremap_resource(&pdev->dev, mem);
drivers/watchdog/dw_wdt.c:	dw_wdt.clk = clk_get(&pdev->dev, NULL);
drivers/watchdog/wm831x_wdt.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/watchdog/wm831x_wdt.c:	driver_data = devm_kzalloc(&pdev->dev, sizeof(*driver_data),
drivers/watchdog/wm831x_wdt.c:	if (pdev->dev.parent->platform_data) {
drivers/watchdog/wm831x_wdt.c:		chip_pdata = pdev->dev.parent->platform_data;
drivers/watchdog/wm831x_wdt.c:	dev_set_drvdata(&pdev->dev, driver_data);
drivers/watchdog/wm831x_wdt.c:	struct wm831x_wdt_drvdata *driver_data = dev_get_drvdata(&pdev->dev);
drivers/watchdog/lantiq_wdt.c:		dev_err(&pdev->dev, "cannot obtain I/O memory region");
drivers/watchdog/lantiq_wdt.c:	ltq_wdt_membase = devm_ioremap_resource(&pdev->dev, res);
drivers/watchdog/lantiq_wdt.c:		dev_err(&pdev->dev, "Failed to get clock\n");
drivers/watchdog/lantiq_wdt.c:	dev_info(&pdev->dev, "Init done\n");
drivers/watchdog/retu_wdt.c:	struct retu_dev *rdev = dev_get_drvdata(pdev->dev.parent);
drivers/watchdog/retu_wdt.c:	retu_wdt = devm_kzalloc(&pdev->dev, sizeof(*retu_wdt), GFP_KERNEL);
drivers/watchdog/retu_wdt.c:	wdev = devm_kzalloc(&pdev->dev, sizeof(*wdev), GFP_KERNEL);
drivers/watchdog/retu_wdt.c:	wdev->dev		= &pdev->dev;
drivers/watchdog/via_wdt.c:		dev_err(&pdev->dev, "cannot enable PCI device\n");
drivers/watchdog/via_wdt.c:		dev_err(&pdev->dev, "MMIO allocation failed\n");
drivers/watchdog/via_wdt.c:		dev_info(&pdev->dev, "VIA Chipset watchdog MMIO: %x\n", mmio);
drivers/watchdog/via_wdt.c:		dev_err(&pdev->dev, "MMIO setting failed. Check BIOS.\n");
drivers/watchdog/via_wdt.c:		dev_err(&pdev->dev, "MMIO region busy\n");
drivers/watchdog/via_wdt.c:		dev_err(&pdev->dev, "cannot remap VIA wdt MMIO registers\n");
drivers/watchdog/mtx-1_wdt.c:	mtx1_wdt_device.gpio = pdev->resource[0].start;
drivers/watchdog/mtx-1_wdt.c:		dev_err(&pdev->dev, "failed to request gpio");
drivers/watchdog/mtx-1_wdt.c:		dev_err(&pdev->dev, "failed to register\n");
drivers/watchdog/mtx-1_wdt.c:	dev_info(&pdev->dev, "MTX-1 Watchdog driver\n");
drivers/watchdog/pnx4008_wdt.c:	watchdog_init_timeout(&pnx4008_wdd, heartbeat, &pdev->dev);
drivers/watchdog/pnx4008_wdt.c:	wdt_base = devm_ioremap_resource(&pdev->dev, r);
drivers/watchdog/pnx4008_wdt.c:	wdt_clk = clk_get(&pdev->dev, NULL);
drivers/watchdog/pnx4008_wdt.c:		dev_err(&pdev->dev, "cannot register watchdog device\n");
drivers/watchdog/pnx4008_wdt.c:	dev_info(&pdev->dev, "PNX4008 Watchdog Timer: heartbeat %d sec\n",
drivers/watchdog/of_xilinx_wdt.c:	pfreq = (u32 *)of_get_property(pdev->dev.of_node,
drivers/watchdog/of_xilinx_wdt.c:	rc = of_address_to_resource(pdev->dev.of_node, 0, &xdev.res);
drivers/watchdog/of_xilinx_wdt.c:	tmptr = (u32 *)of_get_property(pdev->dev.of_node,
drivers/watchdog/of_xilinx_wdt.c:	tmptr = (u32 *)of_get_property(pdev->dev.of_node,
drivers/watchdog/jz4740_wdt.c:	drvdata = devm_kzalloc(&pdev->dev, sizeof(struct jz4740_wdt_drvdata),
drivers/watchdog/jz4740_wdt.c:		dev_err(&pdev->dev, "Unable to alloacate watchdog device\n");
drivers/watchdog/jz4740_wdt.c:	drvdata->base = devm_ioremap_resource(&pdev->dev, res);
drivers/watchdog/jz4740_wdt.c:		dev_err(&pdev->dev, "cannot find RTC clock\n");
drivers/watchdog/rdc321x_wdt.c:	pdata = pdev->dev.platform_data;
drivers/watchdog/rdc321x_wdt.c:		dev_err(&pdev->dev, "no platform data supplied\n");
drivers/watchdog/rdc321x_wdt.c:		dev_err(&pdev->dev, "failed to get wdt-reg resource\n");
drivers/watchdog/rdc321x_wdt.c:		dev_err(&pdev->dev, "misc_register failed\n");
drivers/watchdog/rdc321x_wdt.c:	dev_info(&pdev->dev, "watchdog init success\n");
drivers/watchdog/nuc900_wdt.c:		dev_crit(&nuc900_wdt->pdev->dev,
drivers/watchdog/nuc900_wdt.c:		dev_warn(&nuc900_wdt->pdev->dev, "Will reset the machine !\n");
drivers/watchdog/nuc900_wdt.c:		dev_err(&pdev->dev, "no memory resource specified\n");
drivers/watchdog/nuc900_wdt.c:				resource_size(nuc900_wdt->res), pdev->name)) {
drivers/watchdog/nuc900_wdt.c:		dev_err(&pdev->dev, "failed to get memory region\n");
drivers/watchdog/nuc900_wdt.c:		dev_err(&pdev->dev, "failed to ioremap() region\n");
drivers/watchdog/nuc900_wdt.c:	nuc900_wdt->wdt_clock = clk_get(&pdev->dev, NULL);
drivers/watchdog/nuc900_wdt.c:		dev_err(&pdev->dev, "failed to find watchdog clock source\n");
drivers/watchdog/nuc900_wdt.c:		dev_err(&pdev->dev, "err register miscdev on minor=%d (%d)\n",
drivers/watchdog/sch311x_wdt.c:	struct device *dev = &pdev->dev;
drivers/watchdog/mpcore_wdt.c:	if (pdev->id != -1)
drivers/watchdog/mpcore_wdt.c:	wdt = devm_kzalloc(&pdev->dev, sizeof(struct mpcore_wdt), GFP_KERNEL);
drivers/watchdog/mpcore_wdt.c:	wdt->dev = &pdev->dev;
drivers/watchdog/mpcore_wdt.c:	mpcore_wdt_miscdev.parent = &pdev->dev;
drivers/watchdog/coh901327_wdt.c:	parent = &pdev->dev;
drivers/watchdog/coh901327_wdt.c:	clk = clk_get(&pdev->dev, NULL);
drivers/watchdog/coh901327_wdt.c:		dev_err(&pdev->dev, "could not get clock\n");
drivers/watchdog/coh901327_wdt.c:		dev_err(&pdev->dev, "could not prepare and enable clock\n");
drivers/watchdog/coh901327_wdt.c:		dev_info(&pdev->dev,
drivers/watchdog/coh901327_wdt.c:		dev_info(&pdev->dev,
drivers/watchdog/coh901327_wdt.c:		dev_info(&pdev->dev,
drivers/watchdog/coh901327_wdt.c:		dev_info(&pdev->dev, "currently disabled.\n");
drivers/watchdog/coh901327_wdt.c:		dev_info(&pdev->dev,
drivers/watchdog/coh901327_wdt.c:		dev_err(&pdev->dev,
drivers/watchdog/coh901327_wdt.c:		dev_info(&pdev->dev,
drivers/watchdog/ts72xx_wdt.c:		dev_err(&wdt->pdev->dev,
drivers/watchdog/ts72xx_wdt.c:		dev_warn(&wdt->pdev->dev,
drivers/watchdog/ts72xx_wdt.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/watchdog/ts72xx_wdt.c:		dev_err(&pdev->dev, "failed to get memory resource\n");
drivers/watchdog/ts72xx_wdt.c:	r1 = request_mem_region(r1->start, resource_size(r1), pdev->name);
drivers/watchdog/ts72xx_wdt.c:		dev_err(&pdev->dev, "cannot request memory region\n");
drivers/watchdog/ts72xx_wdt.c:		dev_err(&pdev->dev, "failed to map memory\n");
drivers/watchdog/ts72xx_wdt.c:		dev_err(&pdev->dev, "failed to get memory resource\n");
drivers/watchdog/ts72xx_wdt.c:	r2 = request_mem_region(r2->start, resource_size(r2), pdev->name);
drivers/watchdog/ts72xx_wdt.c:		dev_err(&pdev->dev, "cannot request memory region\n");
drivers/watchdog/ts72xx_wdt.c:		dev_err(&pdev->dev, "failed to map memory\n");
drivers/watchdog/ts72xx_wdt.c:		dev_err(&pdev->dev, "failed to register miscdev\n");
drivers/watchdog/ts72xx_wdt.c:	dev_info(&pdev->dev, "TS-72xx Watchdog driver\n");
drivers/watchdog/ks8695_wdt.c:	ks8695wdt_miscdev.parent = &pdev->dev;
drivers/watchdog/orion_wdt.c:	clk = devm_clk_get(&pdev->dev, NULL);
drivers/watchdog/orion_wdt.c:		dev_err(&pdev->dev, "Orion Watchdog missing clock\n");
drivers/watchdog/orion_wdt.c:	wdt_reg = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/watchdog/orion_wdt.c:	watchdog_init_timeout(&orion_wdt, heartbeat, &pdev->dev);
drivers/watchdog/s3c2410_wdt.c:	dev = &pdev->dev;
drivers/watchdog/s3c2410_wdt.c:	wdt_dev = &pdev->dev;
drivers/watchdog/s3c2410_wdt.c:	watchdog_init_timeout(&s3c2410_wdd, tmr_margin,  &pdev->dev);
drivers/watchdog/s3c2410_wdt.c:				pdev->name, pdev);
drivers/watchdog/da9055_wdt.c:	struct da9055 *da9055 = dev_get_drvdata(pdev->dev.parent);
drivers/watchdog/da9055_wdt.c:	driver_data = devm_kzalloc(&pdev->dev, sizeof(*driver_data),
drivers/watchdog/da9055_wdt.c:		dev_err(&pdev->dev, "Failed to stop watchdog, %d\n", ret);
drivers/watchdog/da9055_wdt.c:	dev_set_drvdata(&pdev->dev, driver_data);
drivers/watchdog/da9055_wdt.c:	struct da9055_wdt_data *driver_data = dev_get_drvdata(&pdev->dev);
drivers/watchdog/at91rm9200_wdt.c:	at91wdt_miscdev.parent = &pdev->dev;
drivers/gpu/drm/r128/r128_cce.c:	rc = request_firmware(&fw, FIRMWARE_NAME, &pdev->dev);
drivers/gpu/drm/drm_edid_load.c:	err = request_firmware(&fw, name, &pdev->dev);
drivers/gpu/drm/tilcdc/tilcdc_panel.c:	struct device_node *node = pdev->dev.of_node;
drivers/gpu/drm/tilcdc/tilcdc_panel.c:		dev_err(&pdev->dev, "device-tree data is missing\n");
drivers/gpu/drm/tilcdc/tilcdc_panel.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/gpu/drm/tilcdc/tilcdc_panel.c:		dev_warn(&pdev->dev, "pins are not configured\n");
drivers/gpu/drm/tilcdc/tilcdc_panel.c:		dev_err(&pdev->dev, "could not get panel timings\n");
drivers/gpu/drm/tilcdc/tilcdc_panel.c:		dev_err(&pdev->dev, "could not get panel info\n");
drivers/gpu/drm/tilcdc/tilcdc_panel.c:		dev_info(&pdev->dev, "found backlight\n");
drivers/gpu/drm/tilcdc/tilcdc_tfp410.c:	struct device_node *node = pdev->dev.of_node;
drivers/gpu/drm/tilcdc/tilcdc_tfp410.c:		dev_err(&pdev->dev, "device-tree data is missing\n");
drivers/gpu/drm/tilcdc/tilcdc_tfp410.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/gpu/drm/tilcdc/tilcdc_tfp410.c:		dev_warn(&pdev->dev, "pins are not configured\n");
drivers/gpu/drm/tilcdc/tilcdc_tfp410.c:		dev_err(&pdev->dev, "could not get i2c bus phandle\n");
drivers/gpu/drm/tilcdc/tilcdc_tfp410.c:		dev_err(&pdev->dev, "could not get i2c bus node\n");
drivers/gpu/drm/tilcdc/tilcdc_tfp410.c:		dev_err(&pdev->dev, "could not get i2c\n");
drivers/gpu/drm/tilcdc/tilcdc_tfp410.c:		dev_warn(&pdev->dev, "No power down GPIO\n");
drivers/gpu/drm/tilcdc/tilcdc_tfp410.c:			dev_err(&pdev->dev, "could not get DVI_PDn gpio\n");
drivers/gpu/drm/tilcdc/tilcdc_drv.c:	struct device_node *node = pdev->dev.of_node;
drivers/gpu/drm/tilcdc/tilcdc_drv.c:	if (!pdev->dev.of_node) {
drivers/gpu/drm/tilcdc/tilcdc_drv.c:		dev_err(&pdev->dev, "device-tree data is missing\n");
drivers/gpu/drm/tilcdc/tilcdc_slave.c:	struct device_node *node = pdev->dev.of_node;
drivers/gpu/drm/tilcdc/tilcdc_slave.c:		dev_err(&pdev->dev, "device-tree data is missing\n");
drivers/gpu/drm/tilcdc/tilcdc_slave.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/gpu/drm/tilcdc/tilcdc_slave.c:		dev_warn(&pdev->dev, "pins are not configured\n");
drivers/gpu/drm/tilcdc/tilcdc_slave.c:		dev_err(&pdev->dev, "could not get i2c bus phandle\n");
drivers/gpu/drm/tilcdc/tilcdc_slave.c:		dev_err(&pdev->dev, "could not get i2c bus node\n");
drivers/gpu/drm/tilcdc/tilcdc_slave.c:		dev_err(&pdev->dev, "could not get i2c\n");
drivers/gpu/drm/cirrus/cirrus_fbdev.c:	struct device *device = &dev->pdev->dev;
drivers/gpu/drm/cirrus/cirrus_drv.c:	primary = pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
drivers/gpu/drm/cirrus/cirrus_main.c:		dev_err(&dev->pdev->dev, "Fatal error during GPU init: %d\n", r);
drivers/gpu/drm/cirrus/cirrus_main.c:		dev_err(&dev->pdev->dev, "fatal err on mm init\n");
drivers/gpu/drm/cirrus/cirrus_main.c:		dev_err(&dev->pdev->dev, "Fatal error during modeset init: %d\n", r);
drivers/gpu/drm/exynos/exynos_drm_gsc.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_drm_gsc.c:	ctx->id = pdev->id;
drivers/gpu/drm/exynos/exynos_drm_gsc.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_drm_fimc.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_drm_fimc.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_drm_hdmi.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_drm_fimd.c:			of_match_device(fimd_driver_dt_match, &pdev->dev);
drivers/gpu/drm/exynos/exynos_drm_fimd.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_drm_fimd.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_drm_ipp.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_drm_rotator.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_drm_rotator.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_drm_vidi.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_mixer.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_mixer.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_mixer.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_mixer.c:	dev_info(&pdev->dev, "remove successful\n");
drivers/gpu/drm/exynos/exynos_mixer.c:	pm_runtime_disable(&pdev->dev);
drivers/gpu/drm/exynos/exynos_drm_drv.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/gpu/drm/exynos/exynos_drm_g2d.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_drm_g2d.c:	pm_runtime_disable(&pdev->dev);
drivers/gpu/drm/exynos/exynos_hdmi.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_hdmi.c:	struct device *dev = &pdev->dev;
drivers/gpu/drm/exynos/exynos_drm_fbdev.c:	fbi = framebuffer_alloc(0, &pdev->dev);
drivers/gpu/drm/ast/ast_main.c:	if (dev->pdev->device == PCI_CHIP_AST1180) {
drivers/gpu/drm/ast/ast_main.c:		if (dev->pdev->revision >= 0x20) {
drivers/gpu/drm/ast/ast_main.c:		} else if (dev->pdev->revision >= 0x10) {
drivers/gpu/drm/ast/ast_post.c:		if (dev->pdev->revision >= 0x20)
drivers/gpu/drm/ast/ast_fb.c:	struct device *device = &dev->pdev->dev;
drivers/gpu/drm/ast/ast_mode.c:	i2c->adapter.dev.parent = &dev->pdev->dev;
drivers/gpu/drm/mga/mga_warp.c:	rc = request_ihex_firmware(&fw, firmware_name, &pdev->dev);
drivers/gpu/drm/mga/mga_drv.c:	if ((pdev->device == 0x0525) && pdev->bus->self
drivers/gpu/drm/mga/mga_drv.c:	    && (pdev->bus->self->vendor == 0x3388)
drivers/gpu/drm/mga/mga_drv.c:	    && (pdev->bus->self->device == 0x0021)) {
drivers/gpu/drm/drm_pci.c:	dmah->vaddr = dma_alloc_coherent(&dev->pdev->dev, size, &dmah->busaddr, GFP_KERNEL | __GFP_COMP);
drivers/gpu/drm/drm_pci.c:		dma_free_coherent(&dev->pdev->dev, dmah->size, dmah->vaddr,
drivers/gpu/drm/drm_pci.c:	return pci_domain_nr(dev->pdev->bus);
drivers/gpu/drm/drm_pci.c:	return dev->pdev->irq;
drivers/gpu/drm/drm_pci.c:		       dev->pdev->bus->number,
drivers/gpu/drm/drm_pci.c:		       PCI_SLOT(dev->pdev->devfn),
drivers/gpu/drm/drm_pci.c:		       PCI_FUNC(dev->pdev->devfn));
drivers/gpu/drm/drm_pci.c:	    (bus != dev->pdev->bus->number) ||
drivers/gpu/drm/drm_pci.c:	    (slot != PCI_SLOT(dev->pdev->devfn)) ||
drivers/gpu/drm/drm_pci.c:	    (func != PCI_FUNC(dev->pdev->devfn))) {
drivers/gpu/drm/drm_pci.c:	    (p->busnum & 0xff) != dev->pdev->bus->number ||
drivers/gpu/drm/drm_pci.c:	    p->devnum != PCI_SLOT(dev->pdev->devfn) || p->funcnum != PCI_FUNC(dev->pdev->devfn))
drivers/gpu/drm/drm_pci.c:	p->irq = dev->pdev->irq;
drivers/gpu/drm/drm_pci.c:	dev->dev = &pdev->dev;
drivers/gpu/drm/drm_pci.c:	dev->pci_device = pdev->device;
drivers/gpu/drm/drm_pci.c:	dev->pci_vendor = pdev->vendor;
drivers/gpu/drm/drm_pci.c:	dev->hose = pdev->sysdata;
drivers/gpu/drm/drm_pci.c:			if ((pdev->class & pid->class_mask) != pid->class)
drivers/gpu/drm/drm_pci.c:	root = dev->pdev->bus->self;
drivers/gpu/drm/vmwgfx/vmwgfx_fb.c:	struct device *device = &vmw_priv->dev->pdev->dev;
drivers/gpu/drm/mgag200/mgag200_fb.c:	struct device *device = &dev->pdev->dev;
drivers/gpu/drm/mgag200/mgag200_i2c.c:	i2c->adapter.dev.parent = &dev->pdev->dev;
drivers/gpu/drm/mgag200/mgag200_drv.c:	primary = pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
drivers/gpu/drm/mgag200/mgag200_main.c:		dev_err(&dev->pdev->dev, "Fatal error during GPU init: %d\n", r);
drivers/gpu/drm/mgag200/mgag200_main.c:		dev_err(&dev->pdev->dev, "Fatal error during modeset init: %d\n", r);
drivers/gpu/drm/shmobile/shmob_drm_drv.c:	sdev->dev = &pdev->dev;
drivers/gpu/drm/shmobile/shmob_drm_drv.c:		dev_err(&pdev->dev, "failed to get memory resource\n");
drivers/gpu/drm/shmobile/shmob_drm_drv.c:		dev_err(&pdev->dev, "failed to remap memory resource\n");
drivers/gpu/drm/shmobile/shmob_drm_drv.c:		dev_err(&pdev->dev, "failed to initialize mode setting\n");
drivers/gpu/drm/shmobile/shmob_drm_drv.c:			dev_err(&pdev->dev, "failed to create plane %u\n", i);
drivers/gpu/drm/shmobile/shmob_drm_drv.c:		dev_err(&pdev->dev, "failed to initialize vblank\n");
drivers/gpu/drm/shmobile/shmob_drm_drv.c:		dev_err(&pdev->dev, "failed to install IRQ handler\n");
drivers/gpu/drm/shmobile/shmob_drm_crtc.c:		pm_runtime_get_sync(&sdev->meram_dev->pdev->dev);
drivers/gpu/drm/shmobile/shmob_drm_crtc.c:		pm_runtime_put_sync(&sdev->meram_dev->pdev->dev);
drivers/gpu/drm/i915/i915_dma.c:		value = dev->pdev->irq ? 1 : 0;
drivers/gpu/drm/i915/i915_dma.c:		pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
drivers/gpu/drm/i915/i915_dma.c:			 dev_priv->dev->pdev->device,
drivers/gpu/drm/i915/i915_dma.c:		dma_set_coherent_mask(&dev->pdev->dev, DMA_BIT_MASK(30));
drivers/gpu/drm/i915/i915_dma.c:		dma_set_coherent_mask(&dev->pdev->dev, DMA_BIT_MASK(32));
drivers/gpu/drm/i915/i915_dma.c:	if (dev->pdev->msi_enabled)
drivers/gpu/drm/i915/i915_dma.c:	if (dev->pdev->msi_enabled)
drivers/gpu/drm/i915/i915_gem.c:	if (IS_GEN6(dev) && dev->pdev->revision < 8) {
drivers/gpu/drm/i915/i915_drv.c:			dev_err(&dev->pdev->dev,
drivers/gpu/drm/i915/i915_drv.c:	if (PCI_FUNC(pdev->devfn))
drivers/gpu/drm/i915/intel_sdvo.c:	sdvo->ddc.dev.parent = &dev->pdev->dev;
drivers/gpu/drm/i915/intel_acpi.c:	dhandle = DEVICE_ACPI_HANDLE(&pdev->dev);
drivers/gpu/drm/i915/i915_gem_gtt.c:	if (!dma_map_sg(&obj->base.dev->pdev->dev,
drivers/gpu/drm/i915/i915_gem_gtt.c:		dma_unmap_sg(&dev->pdev->dev,
drivers/gpu/drm/i915/intel_fb.c:	struct device *device = &dev->pdev->dev;
drivers/gpu/drm/i915/intel_i2c.c:		bus->adapter.dev.parent = &dev->pdev->dev;
drivers/gpu/drm/i915/intel_opregion.c:	handle = DEVICE_ACPI_HANDLE(&dev->pdev->dev);
drivers/gpu/drm/i915/intel_opregion.c:			dev_printk(KERN_ERR, &dev->pdev->dev,
drivers/gpu/drm/i915/intel_opregion.c:			dev_printk(KERN_ERR, &dev->pdev->dev,
drivers/gpu/drm/qxl/qxl_drv.c:	if (pdev->revision < 4) {
drivers/gpu/drm/qxl/qxl_ioctl.c:	if (qdev->pdev->revision < 4)
drivers/gpu/drm/qxl/qxl_fb.c:	struct device *device = &qdev->pdev->dev;
drivers/gpu/drm/qxl/qxl_kms.c:	qdev->dev = &pdev->dev;
drivers/gpu/drm/via/via_dmablit.c:		dma_unmap_single(&pdev->dev, next, sizeof(*desc_ptr), DMA_TO_DEVICE);
drivers/gpu/drm/via/via_dmablit.c:		dma_unmap_page(&pdev->dev, desc_ptr->mem_addr, desc_ptr->size, vsg->direction);
drivers/gpu/drm/via/via_dmablit.c:					dma_map_page(&pdev->dev,
drivers/gpu/drm/via/via_dmablit.c:				next = dma_map_single(&pdev->dev, desc_ptr, sizeof(*desc_ptr),
drivers/gpu/drm/radeon/r420.c:	if ((rdev->pdev->device == 0x5e4c) ||
drivers/gpu/drm/radeon/r420.c:	    (rdev->pdev->device == 0x5e4f))
drivers/gpu/drm/radeon/r100.c:	err = request_firmware(&rdev->me_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/r100.c:	switch (dev->pdev->device) {
drivers/gpu/drm/radeon/r100.c:		if ((dev->pdev->subsystem_vendor == 0x1028 /* DELL */) &&
drivers/gpu/drm/radeon/r100.c:		    ((dev->pdev->subsystem_device == 0x016c) ||
drivers/gpu/drm/radeon/r100.c:		     (dev->pdev->subsystem_device == 0x016d) ||
drivers/gpu/drm/radeon/r100.c:		     (dev->pdev->subsystem_device == 0x016e) ||
drivers/gpu/drm/radeon/r100.c:		     (dev->pdev->subsystem_device == 0x016f) ||
drivers/gpu/drm/radeon/r100.c:		     (dev->pdev->subsystem_device == 0x0170) ||
drivers/gpu/drm/radeon/r100.c:		     (dev->pdev->subsystem_device == 0x017d) ||
drivers/gpu/drm/radeon/r100.c:		     (dev->pdev->subsystem_device == 0x017e) ||
drivers/gpu/drm/radeon/r100.c:		     (dev->pdev->subsystem_device == 0x0183) ||
drivers/gpu/drm/radeon/r100.c:		     (dev->pdev->subsystem_device == 0x018a) ||
drivers/gpu/drm/radeon/r100.c:		     (dev->pdev->subsystem_device == 0x019a)))
drivers/gpu/drm/radeon/r600_cp.c:	err = request_firmware(&dev_priv->pfp_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/r600_cp.c:	err = request_firmware(&dev_priv->me_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/evergreen.c:		if (rdev->pdev->device == 0x9648)
drivers/gpu/drm/radeon/evergreen.c:		else if ((rdev->pdev->device == 0x9647) ||
drivers/gpu/drm/radeon/evergreen.c:			 (rdev->pdev->device == 0x964a))
drivers/gpu/drm/radeon/evergreen.c:	if ((rdev->pdev->bus->max_bus_speed != PCIE_SPEED_5_0GT) &&
drivers/gpu/drm/radeon/evergreen.c:		(rdev->pdev->bus->max_bus_speed != PCIE_SPEED_8_0GT))
drivers/gpu/drm/radeon/radeon_acpi.c:	handle = DEVICE_ACPI_HANDLE(&rdev->pdev->dev);
drivers/gpu/drm/radeon/radeon_acpi.c:	handle = DEVICE_ACPI_HANDLE(&rdev->pdev->dev);
drivers/gpu/drm/radeon/r600_cs.c:	parser.dev = &dev->pdev->dev;
drivers/gpu/drm/radeon/radeon_gem.c:		dev_err(&dev->pdev->dev,
drivers/gpu/drm/radeon/radeon_gem.c:		dev_err(&dev->pdev->dev, "invalid flags 0x%08X vs 0x%08X\n",
drivers/gpu/drm/radeon/radeon_gem.c:		dev_err(&dev->pdev->dev, "only supported snooped mapping for now\n");
drivers/gpu/drm/radeon/radeon_gem.c:		dev_err(&dev->pdev->dev, "unsupported operation %d\n",
drivers/gpu/drm/radeon/radeon_uvd.c:	r = request_firmware(&rdev->uvd_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/radeon_display.c:		dev_err(&dev->pdev->dev, "No GEM object associated to handle 0x%08X, "
drivers/gpu/drm/radeon/si.c:	err = request_firmware(&rdev->pfp_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/si.c:	err = request_firmware(&rdev->me_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/si.c:	err = request_firmware(&rdev->ce_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/si.c:	err = request_firmware(&rdev->rlc_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/si.c:	err = request_firmware(&rdev->mc_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/radeon_kms.c:		dev_err(&dev->pdev->dev, "Fatal error during GPU init\n");
drivers/gpu/drm/radeon/radeon_kms.c:		dev_err(&dev->pdev->dev, "Fatal error during modeset init\n");
drivers/gpu/drm/radeon/radeon_kms.c:		dev_dbg(&dev->pdev->dev,
drivers/gpu/drm/radeon/radeon_fb.c:	struct device *device = &rdev->pdev->dev;
drivers/gpu/drm/radeon/rv770.c:		if (rdev->pdev->device == 0x994e)
drivers/gpu/drm/radeon/rv770.c:	if ((rdev->pdev->bus->max_bus_speed != PCIE_SPEED_5_0GT) &&
drivers/gpu/drm/radeon/rv770.c:		(rdev->pdev->bus->max_bus_speed != PCIE_SPEED_8_0GT))
drivers/gpu/drm/radeon/radeon_clocks.c:	struct device_node *dp = rdev->pdev->dev.of_node;
drivers/gpu/drm/radeon/r300.c:	if ((rdev->family == CHIP_R300 && rdev->pdev->device != 0x4144) ||
drivers/gpu/drm/radeon/r300.c:	    (rdev->family == CHIP_R350 && rdev->pdev->device != 0x4148)) {
drivers/gpu/drm/radeon/radeon_i2c.c:	i2c->adapter.dev.parent = &dev->pdev->dev;
drivers/gpu/drm/radeon/radeon_i2c.c:	i2c->adapter.dev.parent = &dev->pdev->dev;
drivers/gpu/drm/radeon/radeon_drv.c:	primary = pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
drivers/gpu/drm/radeon/radeon_bios.c:		dhandle = DEVICE_ACPI_HANDLE(&pdev->dev);
drivers/gpu/drm/radeon/radeon_bios.c:	if (vhdr->PCIBus != rdev->pdev->bus->number ||
drivers/gpu/drm/radeon/radeon_bios.c:	    vhdr->PCIDevice != PCI_SLOT(rdev->pdev->devfn) ||
drivers/gpu/drm/radeon/radeon_bios.c:	    vhdr->PCIFunction != PCI_FUNC(rdev->pdev->devfn) ||
drivers/gpu/drm/radeon/radeon_bios.c:	    vhdr->VendorID != rdev->pdev->vendor ||
drivers/gpu/drm/radeon/radeon_bios.c:	    vhdr->DeviceID != rdev->pdev->device) {
drivers/gpu/drm/radeon/radeon.h:#define ASIC_IS_RN50(rdev) ((rdev->pdev->device == 0x515e) || \
drivers/gpu/drm/radeon/radeon.h:			    (rdev->pdev->device == 0x5969))
drivers/gpu/drm/radeon/radeon.h:#define ASIC_IS_X2(rdev) ((rdev->ddev->pdev->device == 0x9441) || \
drivers/gpu/drm/radeon/radeon.h:		(rdev->ddev->pdev->device == 0x9443) || \
drivers/gpu/drm/radeon/radeon.h:		(rdev->ddev->pdev->device == 0x944B) || \
drivers/gpu/drm/radeon/radeon.h:		(rdev->ddev->pdev->device == 0x9506) || \
drivers/gpu/drm/radeon/radeon.h:		(rdev->ddev->pdev->device == 0x9509) || \
drivers/gpu/drm/radeon/radeon.h:		(rdev->ddev->pdev->device == 0x950F) || \
drivers/gpu/drm/radeon/radeon.h:		(rdev->ddev->pdev->device == 0x689C) || \
drivers/gpu/drm/radeon/radeon.h:		(rdev->ddev->pdev->device == 0x689D))
drivers/gpu/drm/radeon/radeon_cp.c:		if ((dev->pdev->device == 0x5e4c) ||
drivers/gpu/drm/radeon/radeon_cp.c:		    (dev->pdev->device == 0x5e4f))
drivers/gpu/drm/radeon/radeon_cp.c:		     dev->pdev->device != 0x4144) ||
drivers/gpu/drm/radeon/radeon_cp.c:		     dev->pdev->device != 0x4148)) {
drivers/gpu/drm/radeon/radeon_cp.c:	err = request_firmware(&dev_priv->me_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/ni.c:		if ((rdev->pdev->device == 0x9900) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9901) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9903) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9904) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9905) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9906) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9907) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9908) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9909) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x990A) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x990B) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x990C) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x990D) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x990E) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x990F) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9910) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9913) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9917) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9918)) {
drivers/gpu/drm/radeon/ni.c:	err = request_firmware(&rdev->pfp_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/ni.c:	err = request_firmware(&rdev->me_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/ni.c:	err = request_firmware(&rdev->rlc_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/ni.c:		err = request_firmware(&rdev->mc_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/ni.c:		if ((rdev->pdev->device == 0x9900) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9901) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9905) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9906) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9907) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9908) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9909) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x990B) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x990C) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x990F) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9910) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9917) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x9999) ||
drivers/gpu/drm/radeon/ni.c:		    (rdev->pdev->device == 0x999C)) {
drivers/gpu/drm/radeon/ni.c:		} else if ((rdev->pdev->device == 0x9903) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x9904) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x990A) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x990D) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x990E) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x9913) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x9918) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x999D)) {
drivers/gpu/drm/radeon/ni.c:		} else if ((rdev->pdev->device == 0x9919) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x9990) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x9991) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x9994) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x9995) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x9996) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x999A) ||
drivers/gpu/drm/radeon/ni.c:			   (rdev->pdev->device == 0x99A0)) {
drivers/gpu/drm/radeon/atombios_encoders.c:	if ((rdev->pdev->subsystem_vendor == PCI_VENDOR_ID_APPLE) &&
drivers/gpu/drm/radeon/atombios_encoders.c:	    (rdev->pdev->device == 0x6741))
drivers/gpu/drm/radeon/atombios_encoders.c:	if ((dev->pdev->device == 0x71C5) &&
drivers/gpu/drm/radeon/atombios_encoders.c:	    (dev->pdev->subsystem_vendor == 0x106b) &&
drivers/gpu/drm/radeon/atombios_encoders.c:	    (dev->pdev->subsystem_device == 0x0080)) {
drivers/gpu/drm/radeon/r600.c:	err = request_firmware(&rdev->pfp_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/r600.c:	err = request_firmware(&rdev->me_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/r600.c:	err = request_firmware(&rdev->rlc_fw, fw_name, &pdev->dev);
drivers/gpu/drm/radeon/r600.c:	if ((rdev->pdev->bus->max_bus_speed != PCIE_SPEED_5_0GT) &&
drivers/gpu/drm/radeon/r600.c:		(rdev->pdev->bus->max_bus_speed != PCIE_SPEED_8_0GT))
drivers/gpu/drm/radeon/radeon_atpx_handler.c:	dhandle = DEVICE_ACPI_HANDLE(&pdev->dev);
drivers/gpu/drm/radeon/radeon_atpx_handler.c:	if (radeon_atpx_priv.dhandle == DEVICE_ACPI_HANDLE(&pdev->dev))
drivers/gpu/drm/radeon/radeon_device.c:	    (rdev->pdev->subsystem_vendor == PCI_VENDOR_ID_APPLE) &&
drivers/gpu/drm/radeon/radeon_device.c:		dev_err(&rdev->pdev->dev, "Failed to DMA MAP the dummy page\n");
drivers/gpu/drm/radeon/radeon_device.c:	if (pdev->subsystem_vendor == PCI_VENDOR_ID_APPLE &&
drivers/gpu/drm/radeon/radeon_device.c:	    pdev->subsystem_device == 0x00e2) {
drivers/gpu/drm/radeon/radeon_device.c:		unsigned d3_delay = dev->pdev->d3_delay;
drivers/gpu/drm/radeon/radeon_device.c:			dev->pdev->d3_delay = 20;
drivers/gpu/drm/radeon/radeon_device.c:		dev->pdev->d3_delay = d3_delay;
drivers/gpu/drm/radeon/radeon_device.c:	rdev->dev = &pdev->dev;
drivers/gpu/drm/radeon/radeon_device.c:		radeon_family_name[rdev->family], pdev->vendor, pdev->device,
drivers/gpu/drm/radeon/radeon_device.c:		pdev->subsystem_vendor, pdev->subsystem_device);
drivers/gpu/drm/radeon/radeon_agp.c:		    rdev->pdev->vendor == p->chip_vendor &&
drivers/gpu/drm/radeon/radeon_agp.c:		    rdev->pdev->device == p->chip_device &&
drivers/gpu/drm/radeon/radeon_agp.c:		    rdev->pdev->subsystem_vendor == p->subsys_vendor &&
drivers/gpu/drm/radeon/radeon_agp.c:		    rdev->pdev->subsystem_device == p->subsys_device) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if ((dev->pdev->device == 0x791e) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x1043) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x826d)) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if ((dev->pdev->device == 0x7941) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x1849) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x7941)) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if ((dev->pdev->device == 0x796e) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x1462) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x7302)) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if ((dev->pdev->device == 0x7941) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x147b) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x2412)) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if ((dev->pdev->device == 0x5653) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x1462) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x0291)) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if ((dev->pdev->device == 0x7146) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x17af) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x2058)) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if ((dev->pdev->device == 0x7142) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x1458) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x2134)) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if ((dev->pdev->device == 0x71C5) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x106b) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x0080)) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if ((dev->pdev->device == 0x9598) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x1043) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x01da)) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if ((dev->pdev->device == 0x9598) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x1043) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x01e4)) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if ((dev->pdev->device == 0x95C5) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x1043) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x01e2)) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if (((dev->pdev->device == 0x95c4) || (dev->pdev->device == 0x9591)) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x1025) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x013c)) {
drivers/gpu/drm/radeon/radeon_atombios.c:	if ((dev->pdev->device == 0x9498) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x1682) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x2452) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	if (((dev->pdev->device == 0x9802) || (dev->pdev->device == 0x9806)) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_vendor == 0x1734) &&
drivers/gpu/drm/radeon/radeon_atombios.c:	    (dev->pdev->subsystem_device == 0x11bd)) {
drivers/gpu/drm/radeon/radeon_legacy_encoders.c:			if ((dev->pdev->device == 0x4850) &&
drivers/gpu/drm/radeon/radeon_legacy_encoders.c:			    (dev->pdev->subsystem_vendor == 0x1028) &&
drivers/gpu/drm/radeon/radeon_legacy_encoders.c:			    (dev->pdev->subsystem_device == 0x2001)) /* Dell Inspiron 8600 */
drivers/gpu/drm/radeon/radeon_combios.c:	if (((dev->pdev->device == 0x5159) &&
drivers/gpu/drm/radeon/radeon_combios.c:	    (dev->pdev->subsystem_vendor == 0x174B) &&
drivers/gpu/drm/radeon/radeon_combios.c:	    (dev->pdev->subsystem_device == 0x7c28)) ||
drivers/gpu/drm/radeon/radeon_combios.c:	   ((dev->pdev->device == 0x514D) &&
drivers/gpu/drm/radeon/radeon_combios.c:	    (dev->pdev->subsystem_vendor == 0x174B) &&
drivers/gpu/drm/radeon/radeon_combios.c:	    (dev->pdev->subsystem_device == 0x7149))) {
drivers/gpu/drm/radeon/radeon_combios.c:		} else if ((rdev->pdev->device == 0x4a48) &&
drivers/gpu/drm/radeon/radeon_combios.c:			   (rdev->pdev->subsystem_vendor == 0x1002) &&
drivers/gpu/drm/radeon/radeon_combios.c:			   (rdev->pdev->subsystem_device == 0x4a48)) {
drivers/gpu/drm/radeon/radeon_combios.c:			   (rdev->pdev->device == 0x4150) &&
drivers/gpu/drm/radeon/radeon_combios.c:			   (rdev->pdev->subsystem_vendor == 0x1002) &&
drivers/gpu/drm/radeon/radeon_combios.c:			   (rdev->pdev->subsystem_device == 0x4150)) {
drivers/gpu/drm/radeon/radeon_combios.c:		} else if ((rdev->pdev->device == 0x4c66) &&
drivers/gpu/drm/radeon/radeon_combios.c:			   (rdev->pdev->subsystem_vendor == 0x1002) &&
drivers/gpu/drm/radeon/radeon_combios.c:			   (rdev->pdev->subsystem_device == 0x4c66)) {
drivers/gpu/drm/radeon/radeon_combios.c:	if (dev->pdev->device == 0x515e &&
drivers/gpu/drm/radeon/radeon_combios.c:	    dev->pdev->subsystem_vendor == 0x1014) {
drivers/gpu/drm/radeon/radeon_combios.c:	if (dev->pdev->device == 0x5B60 &&
drivers/gpu/drm/radeon/radeon_combios.c:	    dev->pdev->subsystem_vendor == 0x17af &&
drivers/gpu/drm/radeon/radeon_combios.c:	    dev->pdev->subsystem_device == 0x201e && bios_index == 2) {
drivers/gpu/drm/radeon/radeon_combios.c:	if (dev->pdev->device == 0x5975 &&
drivers/gpu/drm/radeon/radeon_combios.c:	    dev->pdev->subsystem_vendor == 0x1025 &&
drivers/gpu/drm/radeon/radeon_combios.c:	    dev->pdev->subsystem_device == 0x009f)
drivers/gpu/drm/radeon/radeon_combios.c:	if (dev->pdev->device == 0x5974 &&
drivers/gpu/drm/radeon/radeon_combios.c:	    dev->pdev->subsystem_vendor == 0x103c &&
drivers/gpu/drm/radeon/radeon_combios.c:	    dev->pdev->subsystem_device == 0x280a)
drivers/gpu/drm/radeon/radeon_combios.c:	if (dev->pdev->device == 0x5955 &&
drivers/gpu/drm/radeon/radeon_combios.c:	    dev->pdev->subsystem_vendor == 0x1462 &&
drivers/gpu/drm/radeon/radeon_combios.c:	    dev->pdev->subsystem_device == 0x0131)
drivers/gpu/drm/radeon/radeon_combios.c:				if (dev->pdev->device == 0x5159 &&
drivers/gpu/drm/radeon/radeon_combios.c:				    dev->pdev->subsystem_vendor == 0x1014 &&
drivers/gpu/drm/radeon/radeon_combios.c:				    dev->pdev->subsystem_device == 0x029A) {
drivers/gpu/drm/radeon/radeon_combios.c:		if ((dev->pdev->device == 0x4152) &&
drivers/gpu/drm/radeon/radeon_combios.c:		    (dev->pdev->subsystem_vendor == 0x1043) &&
drivers/gpu/drm/radeon/radeon_combios.c:		    (dev->pdev->subsystem_device == 0xc002)) {
drivers/gpu/drm/radeon/radeon_combios.c:	    rdev->pdev->subsystem_vendor == 0x103c &&
drivers/gpu/drm/radeon/radeon_combios.c:	    rdev->pdev->subsystem_device == 0x308b)
drivers/gpu/drm/radeon/radeon_combios.c:	    rdev->pdev->subsystem_vendor == 0x103c &&
drivers/gpu/drm/radeon/radeon_combios.c:	    rdev->pdev->subsystem_device == 0x30a4)
drivers/gpu/drm/radeon/radeon_combios.c:	    rdev->pdev->subsystem_vendor == 0x103c &&
drivers/gpu/drm/radeon/radeon_combios.c:	    rdev->pdev->subsystem_device == 0x30ae)
drivers/gpu/drm/radeon/radeon_irq_kms.c:	if ((rdev->pdev->device == 0x791f) &&
drivers/gpu/drm/radeon/radeon_irq_kms.c:	    (rdev->pdev->subsystem_vendor == 0x103c) &&
drivers/gpu/drm/radeon/radeon_irq_kms.c:	    (rdev->pdev->subsystem_device == 0x30c2))
drivers/gpu/drm/radeon/radeon_irq_kms.c:	if ((rdev->pdev->device == 0x791f) &&
drivers/gpu/drm/radeon/radeon_irq_kms.c:	    (rdev->pdev->subsystem_vendor == 0x1028) &&
drivers/gpu/drm/radeon/radeon_irq_kms.c:	    (rdev->pdev->subsystem_device == 0x01fc))
drivers/gpu/drm/radeon/radeon_irq_kms.c:	if ((rdev->pdev->device == 0x791f) &&
drivers/gpu/drm/radeon/radeon_irq_kms.c:	    (rdev->pdev->subsystem_vendor == 0x1028) &&
drivers/gpu/drm/radeon/radeon_irq_kms.c:	    (rdev->pdev->subsystem_device == 0x01fd))
drivers/gpu/drm/radeon/radeon_irq_kms.c:	if ((rdev->pdev->device == 0x791f) &&
drivers/gpu/drm/radeon/radeon_irq_kms.c:	    (rdev->pdev->subsystem_vendor == 0x107b) &&
drivers/gpu/drm/radeon/radeon_irq_kms.c:	    (rdev->pdev->subsystem_device == 0x0185))
drivers/gpu/drm/nouveau/nouveau_display.c:	u32 pclass = dev->pdev->class >> 8;
drivers/gpu/drm/nouveau/nouveau_pm.c:	struct device *d = &dev->pdev->dev;
drivers/gpu/drm/nouveau/nouveau_pm.c:	struct device *d = &dev->pdev->dev;
drivers/gpu/drm/nouveau/nouveau_pm.c:	hwmon_dev = hwmon_device_register(&dev->pdev->dev);
drivers/gpu/drm/nouveau/nouveau_vga.c:		nouveau_pmops_resume(&pdev->dev);
drivers/gpu/drm/nouveau/nouveau_vga.c:		nouveau_pmops_suspend(&pdev->dev);
drivers/gpu/drm/nouveau/core/engine/graph/nvc0.c:	ret = request_firmware(&fw, f, &device->pdev->dev);
drivers/gpu/drm/nouveau/core/engine/graph/nvc0.c:		ret = request_firmware(&fw, f, &device->pdev->dev);
drivers/gpu/drm/nouveau/core/core/falcon.c:		ret = request_firmware(&fw, name, &device->pdev->dev);
drivers/gpu/drm/nouveau/core/core/falcon.c:		ret = request_firmware(&fw, name, &device->pdev->dev);
drivers/gpu/drm/nouveau/core/core/falcon.c:		ret = request_firmware(&fw, name, &device->pdev->dev);
drivers/gpu/drm/nouveau/core/include/core/device.h:	return device->pdev->device == dev &&
drivers/gpu/drm/nouveau/core/include/core/device.h:	       device->pdev->subsystem_vendor == ven &&
drivers/gpu/drm/nouveau/core/include/core/device.h:	       device->pdev->subsystem_device == sub;
drivers/gpu/drm/nouveau/core/subdev/bios/base.c:		ret = request_firmware(&fw, source, &nv_device(bios)->pdev->dev);
drivers/gpu/drm/nouveau/core/subdev/mc/base.c:	free_irq(device->pdev->irq, pmc);
drivers/gpu/drm/nouveau/core/subdev/mc/base.c:	ret = request_irq(device->pdev->irq, nouveau_mc_intr,
drivers/gpu/drm/nouveau/core/subdev/i2c/base.c:	port->adapter.dev.parent = &device->pdev->dev;
drivers/gpu/drm/nouveau/core/subdev/mxm/base.c:	handle = DEVICE_ACPI_HANDLE(&device->pdev->dev);
drivers/gpu/drm/nouveau/dispnv04/disp.h:	return dev->pdev->device == device &&
drivers/gpu/drm/nouveau/dispnv04/disp.h:		dev->pdev->subsystem_vendor == sub_vendor &&
drivers/gpu/drm/nouveau/dispnv04/disp.h:		dev->pdev->subsystem_device == sub_device;
drivers/gpu/drm/nouveau/nouveau_acpi.c:	if (pdev->vendor == PCI_VENDOR_ID_INTEL)
drivers/gpu/drm/nouveau/nouveau_acpi.c:	if (pdev->bus->number == 0)
drivers/gpu/drm/nouveau/nouveau_acpi.c:	dhandle = DEVICE_ACPI_HANDLE(&pdev->dev);
drivers/gpu/drm/nouveau/nouveau_acpi.c:	dhandle = DEVICE_ACPI_HANDLE(&pdev->dev);
drivers/gpu/drm/nouveau/nouveau_acpi.c:	handle = DEVICE_ACPI_HANDLE(&dev->pdev->dev);
drivers/gpu/drm/nouveau/nouveau_drm.c:	u64 name = (u64)pci_domain_nr(pdev->bus) << 32;
drivers/gpu/drm/nouveau/nouveau_drm.c:	name |= pdev->bus->number << 16;
drivers/gpu/drm/nouveau/nouveau_drm.c:	name |= PCI_SLOT(pdev->devfn) << 8;
drivers/gpu/drm/nouveau/nouveau_drm.c:	return name | PCI_FUNC(pdev->devfn);
drivers/gpu/drm/nouveau/nouveau_drm.c:	boot = pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
drivers/gpu/drm/nouveau/nouveau_fbcon.c:	info = framebuffer_alloc(0, &pdev->dev);
drivers/gpu/drm/gma500/intel_gmbus.c:	gpio->adapter.dev.parent = &dev_priv->dev->pdev->dev;
drivers/gpu/drm/gma500/intel_gmbus.c:		bus->adapter.dev.parent = &dev->pdev->dev;
drivers/gpu/drm/gma500/power.c:	pm_runtime_disable(&dev->pdev->dev);
drivers/gpu/drm/gma500/power.c:	pm_runtime_set_suspended(&dev->pdev->dev);
drivers/gpu/drm/gma500/power.c:		dev_err(&pdev->dev, "pci_enable failed: %d\n", ret);
drivers/gpu/drm/gma500/power.c:		pm_runtime_get(&dev->pdev->dev);
drivers/gpu/drm/gma500/power.c:		pm_runtime_get(&dev->pdev->dev);
drivers/gpu/drm/gma500/power.c:	pm_runtime_put(&dev->pdev->dev);
drivers/gpu/drm/gma500/mdfld_dsi_dpi.c:			dev_err(&dev->pdev->dev, "%s: Pipe enable timeout\n",
drivers/gpu/drm/gma500/mdfld_dsi_dpi.c:			dev_err(&dev->pdev->dev, "%s: Pipe disable timeout\n",
drivers/gpu/drm/gma500/mdfld_dsi_dpi.c:			dev_err(&dev->pdev->dev, "%s: FIFO not empty\n",
drivers/gpu/drm/gma500/mdfld_dsi_dpi.c:			dev_err(&dev->pdev->dev, "%s: DSI PLL lock timeout\n",
drivers/gpu/drm/gma500/framebuffer.c:	struct device *device = &dev->pdev->dev;
drivers/gpu/drm/gma500/psb_intel_display.c:	pm_runtime_forbid(&dev->pdev->dev);
drivers/gpu/drm/gma500/psb_intel_display.c:	pm_runtime_allow(&dev->pdev->dev);
drivers/gpu/drm/gma500/oaktrail_lvds.c:		pm_request_idle(&dev->pdev->dev);
drivers/gpu/drm/gma500/psb_drv.c:	pm_runtime_enable(&dev->pdev->dev);
drivers/gpu/drm/gma500/psb_drv.c:	pm_runtime_set_active(&dev->pdev->dev);
drivers/gpu/drm/gma500/psb_drv.c:		pm_runtime_allow(&dev->pdev->dev);
drivers/gpu/drm/gma500/cdv_intel_lvds.c:			&dev->pdev->dev, "I2C bus registration failed.\n");
drivers/gpu/drm/gma500/cdv_intel_lvds.c:		dev_printk(KERN_ERR, &dev->pdev->dev,
drivers/gpu/drm/gma500/gtt.c:	dev_priv->gtt_mem = &dev->pdev->resource[PSB_GATT_RESOURCE];
drivers/gpu/drm/gma500/psb_intel_sdvo.c:	sdvo->ddc.dev.parent = &dev->pdev->dev;
drivers/gpu/drm/gma500/cdv_intel_crt.c:		dev_printk(KERN_ERR, &dev->pdev->dev, "DDC bus registration "
drivers/gpu/drm/gma500/psb_intel_lvds.c:			&dev->pdev->dev, "I2C bus registration failed.\n");
drivers/gpu/drm/gma500/psb_intel_lvds.c:		dev_printk(KERN_ERR, &dev->pdev->dev,
drivers/gpu/drm/gma500/cdv_intel_display.c:	pm_runtime_forbid(&dev->pdev->dev);
drivers/gpu/drm/gma500/cdv_intel_display.c:	pm_runtime_allow(&dev->pdev->dev);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:			dev_err(&dev->pdev->dev, "GPIOPWMCTRL read failed\n");
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:			dev_warn(&dev->pdev->dev, "GPIOPWMCTRL was not set to system clock (pwmctrl = 0x%02x)\n", pwmctrl);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:			dev_err(&dev->pdev->dev, "GPIOPWMCTRL set failed\n");
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:		dev_err(&dev->pdev->dev, "PWM0CLKDIV set failed\n");
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:		dev_dbg(&dev->pdev->dev, "PWM0CLKDIV set to 0x%04x (%d Hz)\n",
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:	dev_dbg(&dev->pdev->dev, "%s\n", __func__);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:	dev_info(&dev->pdev->dev, "hdisplay(w) = %d\n", mode->hdisplay);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:	dev_info(&dev->pdev->dev, "vdisplay(h) = %d\n", mode->vdisplay);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:	dev_info(&dev->pdev->dev, "HSS = %d\n", mode->hsync_start);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:	dev_info(&dev->pdev->dev, "HSE = %d\n", mode->hsync_end);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:	dev_info(&dev->pdev->dev, "htotal = %d\n", mode->htotal);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:	dev_info(&dev->pdev->dev, "VSS = %d\n", mode->vsync_start);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:	dev_info(&dev->pdev->dev, "VSE = %d\n", mode->vsync_end);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:	dev_info(&dev->pdev->dev, "vtotal = %d\n", mode->vtotal);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:	dev_info(&dev->pdev->dev, "clock = %d\n", mode->clock);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:	dev_dbg(&dev->pdev->dev, "%s\n", __func__);
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:		dev_err(&dev->pdev->dev,
drivers/gpu/drm/gma500/tc35876x-dsi-lvds.c:		dev_err(&dev->pdev->dev,
drivers/gpu/drm/gma500/intel_i2c.c:	chan->adapter.dev.parent = &dev->pdev->dev;
drivers/gpu/host1x/dev.c:	id = of_match_device(host1x_of_match, &pdev->dev);
drivers/gpu/host1x/dev.c:		dev_err(&pdev->dev, "failed to get registers\n");
drivers/gpu/host1x/dev.c:		dev_err(&pdev->dev, "failed to get IRQ\n");
drivers/gpu/host1x/dev.c:	host = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);
drivers/gpu/host1x/dev.c:	host->dev = &pdev->dev;
drivers/gpu/host1x/dev.c:	host->regs = devm_ioremap_resource(&pdev->dev, regs);
drivers/gpu/host1x/dev.c:	host->clk = devm_clk_get(&pdev->dev, NULL);
drivers/gpu/host1x/dev.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/gpu/host1x/dev.c:		dev_err(&pdev->dev, "failed to initialize channel list\n");
drivers/gpu/host1x/dev.c:		dev_err(&pdev->dev, "failed to enable clock\n");
drivers/gpu/host1x/dev.c:		dev_err(&pdev->dev, "failed to initialize syncpts\n");
drivers/gpu/host1x/dev.c:		dev_err(&pdev->dev, "failed to initialize interrupts\n");
drivers/gpu/host1x/drm/dc.c:	struct host1x_drm *host1x = host1x_get_drm_data(pdev->dev.parent);
drivers/gpu/host1x/drm/dc.c:	dc = devm_kzalloc(&pdev->dev, sizeof(*dc), GFP_KERNEL);
drivers/gpu/host1x/drm/dc.c:	dc->dev = &pdev->dev;
drivers/gpu/host1x/drm/dc.c:	dc->clk = devm_clk_get(&pdev->dev, NULL);
drivers/gpu/host1x/drm/dc.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/gpu/host1x/drm/dc.c:	dc->regs = devm_ioremap_resource(&pdev->dev, regs);
drivers/gpu/host1x/drm/dc.c:		dev_err(&pdev->dev, "failed to get IRQ\n");
drivers/gpu/host1x/drm/dc.c:	dc->client.dev = &pdev->dev;
drivers/gpu/host1x/drm/dc.c:		dev_err(&pdev->dev, "failed to probe RGB output: %d\n", err);
drivers/gpu/host1x/drm/dc.c:		dev_err(&pdev->dev, "failed to register host1x client: %d\n",
drivers/gpu/host1x/drm/dc.c:	struct host1x_drm *host1x = host1x_get_drm_data(pdev->dev.parent);
drivers/gpu/host1x/drm/dc.c:		dev_err(&pdev->dev, "failed to unregister host1x client: %d\n",
drivers/gpu/host1x/drm/drm.c:	host1x = devm_kzalloc(&pdev->dev, sizeof(*host1x), GFP_KERNEL);
drivers/gpu/host1x/drm/drm.c:	host1x->dev = &pdev->dev;
drivers/gpu/host1x/drm/drm.c:		dev_err(&pdev->dev, "failed to parse DT: %d\n", err);
drivers/gpu/host1x/drm/drm.c:	host1x_set_drm_data(&pdev->dev, host1x);
drivers/gpu/host1x/drm/hdmi.c:	struct host1x_drm *host1x = host1x_get_drm_data(pdev->dev.parent);
drivers/gpu/host1x/drm/hdmi.c:	hdmi = devm_kzalloc(&pdev->dev, sizeof(*hdmi), GFP_KERNEL);
drivers/gpu/host1x/drm/hdmi.c:	hdmi->dev = &pdev->dev;
drivers/gpu/host1x/drm/hdmi.c:	hdmi->clk = devm_clk_get(&pdev->dev, NULL);
drivers/gpu/host1x/drm/hdmi.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/gpu/host1x/drm/hdmi.c:	hdmi->clk_parent = devm_clk_get(&pdev->dev, "parent");
drivers/gpu/host1x/drm/hdmi.c:		dev_err(&pdev->dev, "failed to setup clocks: %d\n", err);
drivers/gpu/host1x/drm/hdmi.c:	hdmi->vdd = devm_regulator_get(&pdev->dev, "vdd");
drivers/gpu/host1x/drm/hdmi.c:		dev_err(&pdev->dev, "failed to get VDD regulator\n");
drivers/gpu/host1x/drm/hdmi.c:	hdmi->pll = devm_regulator_get(&pdev->dev, "pll");
drivers/gpu/host1x/drm/hdmi.c:		dev_err(&pdev->dev, "failed to get PLL regulator\n");
drivers/gpu/host1x/drm/hdmi.c:	hdmi->output.dev = &pdev->dev;
drivers/gpu/host1x/drm/hdmi.c:	hdmi->regs = devm_ioremap_resource(&pdev->dev, regs);
drivers/gpu/host1x/drm/hdmi.c:	hdmi->client.dev = &pdev->dev;
drivers/gpu/host1x/drm/hdmi.c:		dev_err(&pdev->dev, "failed to register host1x client: %d\n",
drivers/gpu/host1x/drm/hdmi.c:	struct host1x_drm *host1x = host1x_get_drm_data(pdev->dev.parent);
drivers/gpu/host1x/drm/hdmi.c:		dev_err(&pdev->dev, "failed to unregister host1x client: %d\n",
drivers/gpu/host1x/drm/gr2d.c:	struct device *dev = &pdev->dev;
drivers/gpu/host1x/drm/gr2d.c:	struct host1x_drm *host1x = host1x_get_drm_data(pdev->dev.parent);
drivers/gpu/host1x/drm/gr2d.c:		dev_err(&pdev->dev, "failed to unregister client: %d\n", err);
drivers/gpu/vga/vgaarb.c:		if (vgadev->pdev->bus != conflict->pdev->bus) {
drivers/gpu/vga/vgaarb.c:	new_bus = vgadev->pdev->bus;
drivers/gpu/vga/vgaarb.c:			bus = same_bridge_vgadev->pdev->bus;
drivers/gpu/vga/vgaarb.c:					if (bridge == vgadev->pdev->bus->self)
drivers/gpu/vga/vgaarb.c:	if ((pdev->class >> 8) != PCI_CLASS_DISPLAY_VGA)
drivers/gpu/vga/vgaarb.c:	bus = pdev->bus;
drivers/gpu/ion/tegra/tegra_ion.c:	struct ion_platform_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-pcf50633.c:	rtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);
drivers/rtc/rtc-pcf50633.c:	rtc->pcf = dev_to_pcf50633(pdev->dev.parent);
drivers/rtc/rtc-pcf50633.c:	rtc->rtc_dev = devm_rtc_device_register(&pdev->dev, "pcf50633-rtc",
drivers/rtc/rtc-palmas.c:	struct palmas *palmas = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-palmas.c:	palmas_rtc = devm_kzalloc(&pdev->dev, sizeof(struct palmas_rtc),
drivers/rtc/rtc-palmas.c:	ret = palmas_clear_interrupts(&pdev->dev);
drivers/rtc/rtc-palmas.c:		dev_err(&pdev->dev, "clear RTC int failed, err = %d\n", ret);
drivers/rtc/rtc-palmas.c:	palmas_rtc->dev = &pdev->dev;
drivers/rtc/rtc-palmas.c:		dev_err(&pdev->dev, "RTC_CTRL write failed, err = %d\n", ret);
drivers/rtc/rtc-palmas.c:	palmas_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-palmas.c:		dev_err(&pdev->dev, "RTC register failed, err = %d\n", ret);
drivers/rtc/rtc-palmas.c:	ret = devm_request_threaded_irq(&pdev->dev, palmas_rtc->irq, NULL,
drivers/rtc/rtc-palmas.c:			dev_name(&pdev->dev), palmas_rtc);
drivers/rtc/rtc-palmas.c:		dev_err(&pdev->dev, "IRQ request failed, err = %d\n", ret);
drivers/rtc/rtc-palmas.c:	device_set_wakeup_capable(&pdev->dev, 1);
drivers/rtc/rtc-palmas.c:	palmas_rtc_alarm_irq_enable(&pdev->dev, 0);
drivers/rtc/rtc-m48t35.c:	priv = devm_kzalloc(&pdev->dev, sizeof(struct m48t35_priv), GFP_KERNEL);
drivers/rtc/rtc-m48t35.c:	if (!devm_request_mem_region(&pdev->dev, res->start, priv->size,
drivers/rtc/rtc-m48t35.c:				     pdev->name))
drivers/rtc/rtc-m48t35.c:	priv->reg = devm_ioremap(&pdev->dev, priv->baseaddr, priv->size);
drivers/rtc/rtc-m48t35.c:	priv->rtc = devm_rtc_device_register(&pdev->dev, "m48t35",
drivers/rtc/rtc-m48t59.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-m48t59.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-m48t59.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-m48t59.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-m48t59.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-m48t59.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-m48t59.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-m48t59.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-m48t59.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-m48t59.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-m48t59.c:			pdev->dev.platform_data = pdata;
drivers/rtc/rtc-m48t59.c:			IRQF_SHARED, "rtc-m48t59", &pdev->dev);
drivers/rtc/rtc-m48t59.c:		dev_err(&pdev->dev, "Unknown RTC type\n");
drivers/rtc/rtc-m48t59.c:	m48t59->rtc = rtc_device_register(name, &pdev->dev, ops, THIS_MODULE);
drivers/rtc/rtc-m48t59.c:	ret = sysfs_create_bin_file(&pdev->dev.kobj, &m48t59_nvram_attr);
drivers/rtc/rtc-m48t59.c:		free_irq(m48t59->irq, &pdev->dev);
drivers/rtc/rtc-m48t59.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-m48t59.c:	sysfs_remove_bin_file(&pdev->dev.kobj, &m48t59_nvram_attr);
drivers/rtc/rtc-m48t59.c:		free_irq(m48t59->irq, &pdev->dev);
drivers/rtc/rtc-rc5t583.c:	struct rc5t583 *rc5t583 = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-rc5t583.c:	ricoh_rtc = devm_kzalloc(&pdev->dev, sizeof(struct rc5t583_rtc),
drivers/rtc/rtc-rc5t583.c:		dev_err(&pdev->dev, "unable to program rtc_adjust reg\n");
drivers/rtc/rtc-rc5t583.c:		dev_warn(&pdev->dev, "Wake up is not possible as irq = %d\n",
drivers/rtc/rtc-rc5t583.c:	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
drivers/rtc/rtc-rc5t583.c:		"rtc-rc5t583", &pdev->dev);
drivers/rtc/rtc-rc5t583.c:		dev_err(&pdev->dev, "IRQ is not free.\n");
drivers/rtc/rtc-rc5t583.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-rc5t583.c:	ricoh_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-rc5t583.c:		dev_err(&pdev->dev, "RTC device register: err %d\n", ret);
drivers/rtc/rtc-rc5t583.c:	struct rc5t583_rtc *rc5t583_rtc = dev_get_drvdata(&pdev->dev);
drivers/rtc/rtc-ab3100.c:	err = abx500_get_register_interruptible(&pdev->dev, 0,
drivers/rtc/rtc-ab3100.c:		dev_err(&pdev->dev, "unable to read RTC register\n");
drivers/rtc/rtc-ab3100.c:		dev_warn(&pdev->dev, "not default value in RTC reg 0x%x\n",
drivers/rtc/rtc-ab3100.c:		err = abx500_set_register_interruptible(&pdev->dev, 0,
drivers/rtc/rtc-ab3100.c:	rtc = devm_rtc_device_register(&pdev->dev, "ab3100-rtc",
drivers/rtc/rtc-wm831x.c:	struct wm831x_rtc *wm831x_rtc = dev_get_drvdata(&pdev->dev);
drivers/rtc/rtc-wm831x.c:	if (wm831x_rtc->alarm_enabled && device_may_wakeup(&pdev->dev))
drivers/rtc/rtc-wm831x.c:		dev_err(&pdev->dev, "Failed to update RTC alarm: %d\n", ret);
drivers/rtc/rtc-wm831x.c:	struct wm831x_rtc *wm831x_rtc = dev_get_drvdata(&pdev->dev);
drivers/rtc/rtc-wm831x.c:			dev_err(&pdev->dev,
drivers/rtc/rtc-wm831x.c:	struct wm831x_rtc *wm831x_rtc = dev_get_drvdata(&pdev->dev);
drivers/rtc/rtc-wm831x.c:		dev_err(&pdev->dev, "Failed to stop RTC alarm: %d\n", ret);
drivers/rtc/rtc-wm831x.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-wm831x.c:	wm831x_rtc = devm_kzalloc(&pdev->dev, sizeof(*wm831x_rtc), GFP_KERNEL);
drivers/rtc/rtc-wm831x.c:		dev_err(&pdev->dev, "Failed to read RTC control: %d\n", ret);
drivers/rtc/rtc-wm831x.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-wm831x.c:	wm831x_rtc->rtc = devm_rtc_device_register(&pdev->dev, "wm831x",
drivers/rtc/rtc-wm831x.c:	ret = devm_request_threaded_irq(&pdev->dev, alm_irq, NULL,
drivers/rtc/rtc-wm831x.c:		dev_err(&pdev->dev, "Failed to request alarm IRQ %d: %d\n",
drivers/rtc/rtc-v3020.c:	if (pdev->num_resources != 1)
drivers/rtc/rtc-v3020.c:	if (pdev->resource[0].flags != IORESOURCE_MEM)
drivers/rtc/rtc-v3020.c:	chip->ioaddress = ioremap(pdev->resource[0].start, 1);
drivers/rtc/rtc-v3020.c:	struct v3020_platform_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-v3020.c:	chip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);
drivers/rtc/rtc-v3020.c:		dev_info(&pdev->dev, "Chip available at GPIOs "
drivers/rtc/rtc-v3020.c:		dev_info(&pdev->dev, "Chip available at "
drivers/rtc/rtc-v3020.c:			 (unsigned long long)pdev->resource[0].start,
drivers/rtc/rtc-v3020.c:	chip->rtc = devm_rtc_device_register(&pdev->dev, "v3020",
drivers/rtc/rtc-at91sam9.c:		dev_err(&pdev->dev, "need 2 ressources\n");
drivers/rtc/rtc-at91sam9.c:		dev_err(&pdev->dev, "failed to get interrupt resource\n");
drivers/rtc/rtc-at91sam9.c:	rtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);
drivers/rtc/rtc-at91sam9.c:	if (!device_can_wakeup(&pdev->dev))
drivers/rtc/rtc-at91sam9.c:		device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-at91sam9.c:	rtc->rtt = devm_ioremap(&pdev->dev, r->start, resource_size(r));
drivers/rtc/rtc-at91sam9.c:		dev_err(&pdev->dev, "failed to map registers, aborting.\n");
drivers/rtc/rtc-at91sam9.c:	rtc->gpbr = devm_ioremap(&pdev->dev, r_gpbr->start,
drivers/rtc/rtc-at91sam9.c:		dev_err(&pdev->dev, "failed to map gpbr registers, aborting.\n");
drivers/rtc/rtc-at91sam9.c:	rtc->rtcdev = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-at91sam9.c:	ret = devm_request_irq(&pdev->dev, rtc->irq, at91_rtc_interrupt,
drivers/rtc/rtc-at91sam9.c:		dev_dbg(&pdev->dev, "can't share IRQ %d?\n", rtc->irq);
drivers/rtc/rtc-at91sam9.c:		dev_warn(&pdev->dev, "%s: SET TIME!\n",
drivers/rtc/rtc-sh.c:		dev_err(&pdev->dev, "No IRQ resource\n");
drivers/rtc/rtc-sh.c:		dev_err(&pdev->dev, "No IO resource\n");
drivers/rtc/rtc-sh.c:	rtc->res = request_mem_region(res->start, rtc->regsize, pdev->name);
drivers/rtc/rtc-sh.c:	clk_id = pdev->id;
drivers/rtc/rtc-sh.c:	rtc->clk = clk_get(&pdev->dev, clk_name);
drivers/rtc/rtc-sh.c:	if (pdev->dev.platform_data) {
drivers/rtc/rtc-sh.c:		struct sh_rtc_platform_info *pinfo = pdev->dev.platform_data;
drivers/rtc/rtc-sh.c:			dev_err(&pdev->dev,
drivers/rtc/rtc-sh.c:			dev_err(&pdev->dev,
drivers/rtc/rtc-sh.c:			dev_err(&pdev->dev,
drivers/rtc/rtc-sh.c:			dev_err(&pdev->dev,
drivers/rtc/rtc-sh.c:	sh_rtc_irq_set_freq(&pdev->dev, 0);
drivers/rtc/rtc-sh.c:	sh_rtc_irq_set_state(&pdev->dev, 0);
drivers/rtc/rtc-sh.c:	sh_rtc_setaie(&pdev->dev, 0);
drivers/rtc/rtc-sh.c:	sh_rtc_setcie(&pdev->dev, 0);
drivers/rtc/rtc-sh.c:	rtc->rtc_dev = rtc_device_register("sh", &pdev->dev,
drivers/rtc/rtc-sh.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-sh.c:	sh_rtc_irq_set_state(&pdev->dev, 0);
drivers/rtc/rtc-sh.c:	sh_rtc_setaie(&pdev->dev, 0);
drivers/rtc/rtc-sh.c:	sh_rtc_setcie(&pdev->dev, 0);
drivers/rtc/rtc-ds1511.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/rtc/rtc-ds1511.c:	if (!devm_request_mem_region(&pdev->dev, res->start, pdata->size,
drivers/rtc/rtc-ds1511.c:			pdev->name))
drivers/rtc/rtc-ds1511.c:	ds1511_base = devm_ioremap(&pdev->dev, res->start, pdata->size);
drivers/rtc/rtc-ds1511.c:		dev_warn(&pdev->dev, "voltage-low detected.\n");
drivers/rtc/rtc-ds1511.c:		if (devm_request_irq(&pdev->dev, pdata->irq, ds1511_interrupt,
drivers/rtc/rtc-ds1511.c:			IRQF_SHARED, pdev->name, pdev) < 0) {
drivers/rtc/rtc-ds1511.c:			dev_warn(&pdev->dev, "interrupt not available.\n");
drivers/rtc/rtc-ds1511.c:	rtc = devm_rtc_device_register(&pdev->dev, pdev->name, &ds1511_rtc_ops,
drivers/rtc/rtc-ds1511.c:	ret = sysfs_create_bin_file(&pdev->dev.kobj, &ds1511_nvram_attr);
drivers/rtc/rtc-ds1511.c:	sysfs_remove_bin_file(&pdev->dev.kobj, &ds1511_nvram_attr);
drivers/rtc/rtc-wm8350.c:		dev_err(&(wm8350->rtc.pdev->dev),
drivers/rtc/rtc-wm8350.c:	struct wm8350 *wm8350 = dev_get_drvdata(&pdev->dev);
drivers/rtc/rtc-wm8350.c:	if (device_may_wakeup(&wm8350->rtc.pdev->dev) &&
drivers/rtc/rtc-wm8350.c:			dev_err(&pdev->dev, "Failed to stop RTC alarm: %d\n",
drivers/rtc/rtc-wm8350.c:	struct wm8350 *wm8350 = dev_get_drvdata(&pdev->dev);
drivers/rtc/rtc-wm8350.c:			dev_err(&pdev->dev,
drivers/rtc/rtc-wm8350.c:		dev_err(&pdev->dev, "RTC BCD mode not supported\n");
drivers/rtc/rtc-wm8350.c:		dev_err(&pdev->dev, "RTC 12 hour mode not supported\n");
drivers/rtc/rtc-wm8350.c:			dev_err(&pdev->dev, "failed to enable RTC: %d\n", ret);
drivers/rtc/rtc-wm8350.c:			dev_err(&pdev->dev, "failed to start: %d\n", ret);
drivers/rtc/rtc-wm8350.c:			dev_err(&pdev->dev, "failed to start: timeout\n");
drivers/rtc/rtc-wm8350.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-wm8350.c:	wm_rtc->rtc = devm_rtc_device_register(&pdev->dev, "wm8350",
drivers/rtc/rtc-wm8350.c:		dev_err(&pdev->dev, "failed to register RTC: %d\n", ret);
drivers/rtc/rtc-at91rm9200.c:		dev_dbg(&pdev->dev, "%s(): num=%ld, events=0x%02lx\n", __func__,
drivers/rtc/rtc-at91rm9200.c:	if (pdev->dev.of_node) {
drivers/rtc/rtc-at91rm9200.c:		match = of_match_node(at91_rtc_dt_ids, pdev->dev.of_node);
drivers/rtc/rtc-at91rm9200.c:		dev_err(&pdev->dev, "no mmio resource defined\n");
drivers/rtc/rtc-at91rm9200.c:		dev_err(&pdev->dev, "no irq resource defined\n");
drivers/rtc/rtc-at91rm9200.c:		dev_err(&pdev->dev, "failed to map registers, aborting.\n");
drivers/rtc/rtc-at91rm9200.c:		dev_err(&pdev->dev, "IRQ %d already in use.\n", irq);
drivers/rtc/rtc-at91rm9200.c:	if (!device_can_wakeup(&pdev->dev))
drivers/rtc/rtc-at91rm9200.c:		device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-at91rm9200.c:	rtc = rtc_device_register(pdev->name, &pdev->dev,
drivers/rtc/rtc-at91rm9200.c:	dev_info(&pdev->dev, "AT91 Real Time Clock driver.\n");
drivers/rtc/rtc-pxa.c:	struct device *dev = &pdev->dev;
drivers/rtc/rtc-pxa.c:		dev_err(&pdev->dev, "Unable to map pxa RTC I/O memory\n");
drivers/rtc/rtc-pxa.c:	pxa_rtc->rtc = rtc_device_register("pxa-rtc", &pdev->dev, &pxa_rtc_ops,
drivers/rtc/rtc-pxa.c:	struct device *dev = &pdev->dev;
drivers/rtc/rtc-tps6586x.c:	struct device *tps_dev = to_tps6586x_dev(&pdev->dev);
drivers/rtc/rtc-tps6586x.c:	rtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);
drivers/rtc/rtc-tps6586x.c:	rtc->dev = &pdev->dev;
drivers/rtc/rtc-tps6586x.c:		dev_err(&pdev->dev, "unable to start counter\n");
drivers/rtc/rtc-tps6586x.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-tps6586x.c:	rtc->rtc = devm_rtc_device_register(&pdev->dev, dev_name(&pdev->dev),
drivers/rtc/rtc-tps6586x.c:		dev_err(&pdev->dev, "RTC device register: ret %d\n", ret);
drivers/rtc/rtc-tps6586x.c:	ret = devm_request_threaded_irq(&pdev->dev, rtc->irq, NULL,
drivers/rtc/rtc-tps6586x.c:				dev_name(&pdev->dev), rtc);
drivers/rtc/rtc-tps6586x.c:		dev_err(&pdev->dev, "request IRQ(%d) failed with ret %d\n",
drivers/rtc/rtc-tps6586x.c:	struct device *tps_dev = to_tps6586x_dev(&pdev->dev);
drivers/rtc/rtc-bfin.c:	struct device *dev = &pdev->dev;
drivers/rtc/rtc-bfin.c:	rtc->rtc_dev = devm_rtc_device_register(dev, pdev->name, &bfin_rtc_ops,
drivers/rtc/rtc-bfin.c:				pdev->name, dev);
drivers/rtc/rtc-bfin.c:	struct device *dev = &pdev->dev;
drivers/rtc/rtc-rs5c313.c:	struct rtc_device *rtc = devm_rtc_device_register(&pdev->dev, "rs5c313",
drivers/rtc/rtc-ls1x.c:		dev_err(&pdev->dev, "rtc counters not working\n");
drivers/rtc/rtc-ls1x.c:			dev_err(&pdev->dev, "time out\n");
drivers/rtc/rtc-ls1x.c:	rtcdev = devm_rtc_device_register(&pdev->dev, "ls1x-rtc",
drivers/rtc/rtc-at32ap700x.c:	rtc = devm_kzalloc(&pdev->dev, sizeof(struct rtc_at32ap700x),
drivers/rtc/rtc-at32ap700x.c:		dev_dbg(&pdev->dev, "out of memory\n");
drivers/rtc/rtc-at32ap700x.c:		dev_dbg(&pdev->dev, "no mmio resource defined\n");
drivers/rtc/rtc-at32ap700x.c:		dev_dbg(&pdev->dev, "could not get irq\n");
drivers/rtc/rtc-at32ap700x.c:	rtc->regs = devm_ioremap(&pdev->dev, regs->start, resource_size(regs));
drivers/rtc/rtc-at32ap700x.c:		dev_dbg(&pdev->dev, "could not map I/O memory\n");
drivers/rtc/rtc-at32ap700x.c:	ret = devm_request_irq(&pdev->dev, irq, at32_rtc_interrupt, IRQF_SHARED,
drivers/rtc/rtc-at32ap700x.c:		dev_dbg(&pdev->dev, "could not request irq %d\n", irq);
drivers/rtc/rtc-at32ap700x.c:	rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-at32ap700x.c:		dev_dbg(&pdev->dev, "could not register rtc device\n");
drivers/rtc/rtc-at32ap700x.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-at32ap700x.c:	dev_info(&pdev->dev, "Atmel RTC for AT32AP700x at %08lx irq %ld\n",
drivers/rtc/rtc-at32ap700x.c:	device_init_wakeup(&pdev->dev, 0);
drivers/rtc/rtc-mc13xxx.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
drivers/rtc/rtc-mc13xxx.c:	mc13xxx = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-mc13xxx.c:	priv->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-mrst.c:	return vrtc_mrst_do_probe(&pdev->dev,
drivers/rtc/rtc-mrst.c:	rtc_mrst_do_remove(&pdev->dev);
drivers/rtc/rtc-mrst.c:	if (system_state == SYSTEM_POWER_OFF && !mrst_poweroff(&pdev->dev))
drivers/rtc/rtc-tx4939.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/rtc/rtc-tx4939.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
drivers/rtc/rtc-tx4939.c:				     resource_size(res), pdev->name))
drivers/rtc/rtc-tx4939.c:	pdata->rtcreg = devm_ioremap(&pdev->dev, res->start,
drivers/rtc/rtc-tx4939.c:	if (devm_request_irq(&pdev->dev, irq, tx4939_rtc_interrupt,
drivers/rtc/rtc-tx4939.c:			     0, pdev->name, &pdev->dev) < 0)
drivers/rtc/rtc-tx4939.c:	rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-tx4939.c:	ret = sysfs_create_bin_file(&pdev->dev.kobj, &tx4939_rtc_nvram_attr);
drivers/rtc/rtc-tx4939.c:	sysfs_remove_bin_file(&pdev->dev.kobj, &tx4939_rtc_nvram_attr);
drivers/rtc/rtc-max8998.c:	struct max8998_dev *max8998 = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-max8998.c:	info = devm_kzalloc(&pdev->dev, sizeof(struct max8998_rtc_info),
drivers/rtc/rtc-max8998.c:	info->dev = &pdev->dev;
drivers/rtc/rtc-max8998.c:	info->rtc_dev = devm_rtc_device_register(&pdev->dev, "max8998-rtc",
drivers/rtc/rtc-max8998.c:		dev_err(&pdev->dev, "Failed to register RTC device: %d\n", ret);
drivers/rtc/rtc-max8998.c:	ret = devm_request_threaded_irq(&pdev->dev, info->irq, NULL,
drivers/rtc/rtc-max8998.c:		dev_err(&pdev->dev, "Failed to request alarm IRQ: %d: %d\n",
drivers/rtc/rtc-max8998.c:	dev_info(&pdev->dev, "RTC CHIP NAME: %s\n", pdev->id_entry->name);
drivers/rtc/rtc-max8998.c:		dev_warn(&pdev->dev, "LP3974 with RTC REGERR option."
drivers/rtc/rtc-hid-sensor-time.c:		dev_err(&pdev->dev, "bad report ID!\n");
drivers/rtc/rtc-hid-sensor-time.c:			dev_err(&pdev->dev,
drivers/rtc/rtc-hid-sensor-time.c:			dev_err(&pdev->dev,
drivers/rtc/rtc-hid-sensor-time.c:			dev_err(&pdev->dev,
drivers/rtc/rtc-hid-sensor-time.c:			dev_err(&pdev->dev,
drivers/rtc/rtc-hid-sensor-time.c:	struct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;
drivers/rtc/rtc-hid-sensor-time.c:	struct hid_time_state *time_state = devm_kzalloc(&pdev->dev,
drivers/rtc/rtc-hid-sensor-time.c:		dev_err(&pdev->dev, "failed to setup common attributes!\n");
drivers/rtc/rtc-hid-sensor-time.c:		dev_err(&pdev->dev, "failed to setup attributes!\n");
drivers/rtc/rtc-hid-sensor-time.c:		dev_err(&pdev->dev, "register callback failed!\n");
drivers/rtc/rtc-hid-sensor-time.c:	time_state->rtc = devm_rtc_device_register(&pdev->dev,
drivers/rtc/rtc-hid-sensor-time.c:		dev_err(&pdev->dev, "rtc device register failed!\n");
drivers/rtc/rtc-hid-sensor-time.c:	struct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;
drivers/rtc/rtc-bq4802.c:	struct bq4802 *p = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);
drivers/rtc/rtc-bq4802.c:		p->regs = devm_ioremap(&pdev->dev, p->r->start,
drivers/rtc/rtc-bq4802.c:	p->rtc = devm_rtc_device_register(&pdev->dev, "bq4802",
drivers/rtc/rtc-da9052.c:	rtc = devm_kzalloc(&pdev->dev, sizeof(struct da9052_rtc), GFP_KERNEL);
drivers/rtc/rtc-da9052.c:	rtc->da9052 = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-da9052.c:	rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-da9055.c:	rtc = devm_kzalloc(&pdev->dev, sizeof(struct da9055_rtc), GFP_KERNEL);
drivers/rtc/rtc-da9055.c:	rtc->da9055 = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-da9055.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-da9055.c:	rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-da9055.c:	ret = devm_request_threaded_irq(&pdev->dev, alm_irq, NULL,
drivers/rtc/rtc-da9055.c:	struct da9055_rtc *rtc = dev_get_drvdata(&pdev->dev);
drivers/rtc/rtc-da9055.c:	if (!device_may_wakeup(&pdev->dev)) {
drivers/rtc/rtc-da9055.c:			dev_err(&pdev->dev, "Failed to disable RTC ALM\n");
drivers/rtc/rtc-da9055.c:	struct da9055_rtc *rtc = dev_get_drvdata(&pdev->dev);
drivers/rtc/rtc-da9055.c:	if (!device_may_wakeup(&pdev->dev)) {
drivers/rtc/rtc-da9055.c:				dev_err(&pdev->dev,
drivers/rtc/rtc-da9055.c:	struct da9055_rtc *rtc = dev_get_drvdata(&pdev->dev);
drivers/rtc/rtc-da9055.c:		dev_err(&pdev->dev, "Failed to freeze RTC ALMs\n");
drivers/rtc/rtc-jz4740.c:		dev_err(&pdev->dev, "Failed to get platform irq\n");
drivers/rtc/rtc-jz4740.c:		dev_err(&pdev->dev, "Failed to get platform mmio memory\n");
drivers/rtc/rtc-jz4740.c:					pdev->name);
drivers/rtc/rtc-jz4740.c:		dev_err(&pdev->dev, "Failed to request mmio memory region\n");
drivers/rtc/rtc-jz4740.c:		dev_err(&pdev->dev, "Failed to ioremap mmio memory\n");
drivers/rtc/rtc-jz4740.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-jz4740.c:	rtc->rtc = rtc_device_register(pdev->name, &pdev->dev, &jz4740_rtc_ops,
drivers/rtc/rtc-jz4740.c:		dev_err(&pdev->dev, "Failed to register rtc device: %d\n", ret);
drivers/rtc/rtc-jz4740.c:				pdev->name, rtc);
drivers/rtc/rtc-jz4740.c:		dev_err(&pdev->dev, "Failed to request rtc irq: %d\n", ret);
drivers/rtc/rtc-jz4740.c:			dev_err(&pdev->dev, "Could not write write to RTC registers\n");
drivers/rtc/rtc-coh901331.c:	struct coh901331_port *rtap = dev_get_drvdata(&pdev->dev);
drivers/rtc/rtc-coh901331.c:	rtap = devm_kzalloc(&pdev->dev,
drivers/rtc/rtc-coh901331.c:	if (devm_request_mem_region(&pdev->dev, rtap->phybase, rtap->physize,
drivers/rtc/rtc-coh901331.c:	rtap->virtbase = devm_ioremap(&pdev->dev, rtap->phybase, rtap->physize);
drivers/rtc/rtc-coh901331.c:	if (devm_request_irq(&pdev->dev, rtap->irq, coh901331_interrupt, 0,
drivers/rtc/rtc-coh901331.c:	rtap->clk = devm_clk_get(&pdev->dev, NULL);
drivers/rtc/rtc-coh901331.c:		dev_err(&pdev->dev, "could not get clock\n");
drivers/rtc/rtc-coh901331.c:		dev_err(&pdev->dev, "could not enable clock\n");
drivers/rtc/rtc-coh901331.c:	rtap->rtc = devm_rtc_device_register(&pdev->dev, "coh901331",
drivers/rtc/rtc-coh901331.c:	struct coh901331_port *rtap = dev_get_drvdata(&pdev->dev);
drivers/rtc/rtc-ds1302.c:		dev_err(&pdev->dev, "Failed to init communication channel");
drivers/rtc/rtc-ds1302.c:		dev_err(&pdev->dev, "Failed to probe");
drivers/rtc/rtc-ds1302.c:	rtc = devm_rtc_device_register(&pdev->dev, "ds1302",
drivers/rtc/rtc-max8997.c:	struct max8997_dev *max8997 = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-max8997.c:	info = devm_kzalloc(&pdev->dev, sizeof(struct max8997_rtc_info),
drivers/rtc/rtc-max8997.c:	info->dev = &pdev->dev;
drivers/rtc/rtc-max8997.c:		dev_err(&pdev->dev, "Failed to initialize RTC reg:%d\n", ret);
drivers/rtc/rtc-max8997.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-max8997.c:	info->rtc_dev = devm_rtc_device_register(&pdev->dev, "max8997-rtc",
drivers/rtc/rtc-max8997.c:		dev_err(&pdev->dev, "Failed to register RTC device: %d\n", ret);
drivers/rtc/rtc-max8997.c:		dev_err(&pdev->dev, "Failed to create mapping alarm IRQ\n");
drivers/rtc/rtc-max8997.c:	ret = devm_request_threaded_irq(&pdev->dev, virq, NULL,
drivers/rtc/rtc-max8997.c:		dev_err(&pdev->dev, "Failed to request alarm IRQ: %d: %d\n",
drivers/rtc/rtc-nuc900.c:	nuc900_rtc = devm_kzalloc(&pdev->dev, sizeof(struct nuc900_rtc),
drivers/rtc/rtc-nuc900.c:		dev_err(&pdev->dev, "kzalloc nuc900_rtc failed\n");
drivers/rtc/rtc-nuc900.c:	nuc900_rtc->rtc_reg = devm_ioremap_resource(&pdev->dev, res);
drivers/rtc/rtc-nuc900.c:	nuc900_rtc->rtcdev = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-nuc900.c:		dev_err(&pdev->dev, "rtc device register failed\n");
drivers/rtc/rtc-nuc900.c:	if (devm_request_irq(&pdev->dev, nuc900_rtc->irq_num,
drivers/rtc/rtc-nuc900.c:		dev_err(&pdev->dev, "NUC900 RTC request irq failed\n");
drivers/rtc/rtc-vt8500.c:	vt8500_rtc = devm_kzalloc(&pdev->dev,
drivers/rtc/rtc-vt8500.c:		dev_err(&pdev->dev, "No I/O memory resource defined\n");
drivers/rtc/rtc-vt8500.c:		dev_err(&pdev->dev, "No alarm IRQ resource defined\n");
drivers/rtc/rtc-vt8500.c:	vt8500_rtc->res = devm_request_mem_region(&pdev->dev,
drivers/rtc/rtc-vt8500.c:		dev_err(&pdev->dev, "failed to request I/O memory\n");
drivers/rtc/rtc-vt8500.c:	vt8500_rtc->regbase = devm_ioremap(&pdev->dev, vt8500_rtc->res->start,
drivers/rtc/rtc-vt8500.c:		dev_err(&pdev->dev, "Unable to map RTC I/O memory\n");
drivers/rtc/rtc-vt8500.c:	vt8500_rtc->rtc = devm_rtc_device_register(&pdev->dev, "vt8500-rtc",
drivers/rtc/rtc-vt8500.c:		dev_err(&pdev->dev,
drivers/rtc/rtc-vt8500.c:	ret = devm_request_irq(&pdev->dev, vt8500_rtc->irq_alarm,
drivers/rtc/rtc-vt8500.c:		dev_err(&pdev->dev, "can't get irq %i, err %d\n",
drivers/rtc/rtc-au1xxx.c:		dev_err(&pdev->dev, "counters not working; aborting.\n");
drivers/rtc/rtc-au1xxx.c:			dev_err(&pdev->dev, "timeout waiting for access\n");
drivers/rtc/rtc-au1xxx.c:	rtcdev = devm_rtc_device_register(&pdev->dev, "rtc-au1xxx",
drivers/rtc/rtc-msm6242.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
drivers/rtc/rtc-msm6242.c:	priv->regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/rtc/rtc-msm6242.c:	rtc = devm_rtc_device_register(&pdev->dev, "rtc-msm6242",
drivers/rtc/rtc-max77686.c:	struct max77686_dev *max77686 = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-max77686.c:	dev_info(&pdev->dev, "%s\n", __func__);
drivers/rtc/rtc-max77686.c:	info = devm_kzalloc(&pdev->dev, sizeof(struct max77686_rtc_info),
drivers/rtc/rtc-max77686.c:	info->dev = &pdev->dev;
drivers/rtc/rtc-max77686.c:		dev_err(&pdev->dev, "Failed to initialize RTC reg:%d\n", ret);
drivers/rtc/rtc-max77686.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-max77686.c:	info->rtc_dev = devm_rtc_device_register(&pdev->dev, "max77686-rtc",
drivers/rtc/rtc-max77686.c:		dev_info(&pdev->dev, "%s: fail\n", __func__);
drivers/rtc/rtc-max77686.c:		dev_err(&pdev->dev, "Failed to register RTC device: %d\n", ret);
drivers/rtc/rtc-max77686.c:	ret = devm_request_threaded_irq(&pdev->dev, virq, NULL,
drivers/rtc/rtc-max77686.c:		dev_err(&pdev->dev, "Failed to request alarm IRQ: %d: %d\n",
drivers/rtc/rtc-vr41xx.c:	if (pdev->num_resources != 4)
drivers/rtc/rtc-vr41xx.c:	rtc = rtc_device_register(rtc_name, &pdev->dev, &vr41xx_rtc_ops, THIS_MODULE);
drivers/rtc/rtc-vr41xx.c:	dev_info(&pdev->dev, "Real Time Clock of NEC VR4100 series\n");
drivers/rtc/rtc-imxdi.c:	dev_warn(&imxdi->pdev->dev, "WARNING: Register write error!\n");
drivers/rtc/rtc-imxdi.c:	dev_err(&imxdi->pdev->dev,
drivers/rtc/rtc-imxdi.c:		dev_warn(&imxdi->pdev->dev,
drivers/rtc/rtc-imxdi.c:	imxdi = devm_kzalloc(&pdev->dev, sizeof(*imxdi), GFP_KERNEL);
drivers/rtc/rtc-imxdi.c:	if (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),
drivers/rtc/rtc-imxdi.c:				pdev->name))
drivers/rtc/rtc-imxdi.c:	imxdi->ioaddr = devm_ioremap(&pdev->dev, res->start,
drivers/rtc/rtc-imxdi.c:	imxdi->clk = devm_clk_get(&pdev->dev, NULL);
drivers/rtc/rtc-imxdi.c:	rc = devm_request_irq(&pdev->dev, imxdi->irq, dryice_norm_irq,
drivers/rtc/rtc-imxdi.c:			IRQF_SHARED, pdev->name, imxdi);
drivers/rtc/rtc-imxdi.c:		dev_warn(&pdev->dev, "interrupt not available.\n");
drivers/rtc/rtc-imxdi.c:	imxdi->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-starfire.c:	rtc = devm_rtc_device_register(&pdev->dev, "starfire",
drivers/rtc/rtc-pm8xxx.c:						dev_get_platdata(&pdev->dev);
drivers/rtc/rtc-pm8xxx.c:		dev_err(&pdev->dev, "Unable to allocate memory!\n");
drivers/rtc/rtc-pm8xxx.c:		dev_err(&pdev->dev, "Alarm IRQ resource absent!\n");
drivers/rtc/rtc-pm8xxx.c:		dev_err(&pdev->dev, "RTC IO resource absent!\n");
drivers/rtc/rtc-pm8xxx.c:	rtc_dd->rtc_dev = &pdev->dev;
drivers/rtc/rtc-pm8xxx.c:		dev_err(&pdev->dev, "RTC control register read failed!\n");
drivers/rtc/rtc-pm8xxx.c:			dev_err(&pdev->dev, "Write to RTC control register "
drivers/rtc/rtc-pm8xxx.c:	rtc_dd->rtc = rtc_device_register("pm8xxx_rtc", &pdev->dev,
drivers/rtc/rtc-pm8xxx.c:		dev_err(&pdev->dev, "%s: RTC registration failed (%ld)\n",
drivers/rtc/rtc-pm8xxx.c:		dev_err(&pdev->dev, "Request IRQ failed (%d)\n", rc);
drivers/rtc/rtc-pm8xxx.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-pm8xxx.c:	dev_dbg(&pdev->dev, "Probe success !!\n");
drivers/rtc/rtc-pm8xxx.c:	device_init_wakeup(&pdev->dev, 0);
drivers/rtc/rtc-mxc.c:		mxc_rtc_irq_enable(&pdev->dev, RTC_ALM_BIT, 0);
drivers/rtc/rtc-mxc.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/rtc/rtc-mxc.c:	pdata->devtype = pdev->id_entry->driver_data;
drivers/rtc/rtc-mxc.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
drivers/rtc/rtc-mxc.c:				     resource_size(res), pdev->name))
drivers/rtc/rtc-mxc.c:	pdata->ioaddr = devm_ioremap(&pdev->dev, res->start,
drivers/rtc/rtc-mxc.c:	pdata->clk = devm_clk_get(&pdev->dev, NULL);
drivers/rtc/rtc-mxc.c:		dev_err(&pdev->dev, "unable to get clock!\n");
drivers/rtc/rtc-mxc.c:		dev_err(&pdev->dev, "rtc clock is not valid (%lu)\n", rate);
drivers/rtc/rtc-mxc.c:		dev_err(&pdev->dev, "hardware module can't be enabled!\n");
drivers/rtc/rtc-mxc.c:	    devm_request_irq(&pdev->dev, pdata->irq, mxc_rtc_interrupt,
drivers/rtc/rtc-mxc.c:			     IRQF_SHARED, pdev->name, pdev) < 0) {
drivers/rtc/rtc-mxc.c:		dev_warn(&pdev->dev, "interrupt not available.\n");
drivers/rtc/rtc-mxc.c:		device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-mxc.c:	rtc = devm_rtc_device_register(&pdev->dev, pdev->name, &mxc_rtc_ops,
drivers/rtc/rtc-pcap.c:	pcap_rtc = devm_kzalloc(&pdev->dev, sizeof(struct pcap_rtc),
drivers/rtc/rtc-pcap.c:	pcap_rtc->pcap = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-pcap.c:	pcap_rtc->rtc = devm_rtc_device_register(&pdev->dev, "pcap",
drivers/rtc/rtc-pcap.c:	err = devm_request_irq(&pdev->dev, timer_irq, pcap_rtc_irq, 0,
drivers/rtc/rtc-pcap.c:	err = devm_request_irq(&pdev->dev, alarm_irq, pcap_rtc_irq, 0,
drivers/rtc/rtc-ab8500.c:	err = abx500_mask_and_set_register_interruptible(&pdev->dev, AB8500_RTC,
drivers/rtc/rtc-ab8500.c:	err = abx500_get_register_interruptible(&pdev->dev, AB8500_RTC,
drivers/rtc/rtc-ab8500.c:		dev_err(&pdev->dev, "RTC supply failure\n");
drivers/rtc/rtc-ab8500.c:	device_init_wakeup(&pdev->dev, true);
drivers/rtc/rtc-ab8500.c:	rtc = devm_rtc_device_register(&pdev->dev, "ab8500-rtc",
drivers/rtc/rtc-ab8500.c:		dev_err(&pdev->dev, "Registration failed\n");
drivers/rtc/rtc-ab8500.c:	err = devm_request_threaded_irq(&pdev->dev, irq, NULL,
drivers/rtc/rtc-ab8500.c:	err = ab8500_sysfs_rtc_register(&pdev->dev);
drivers/rtc/rtc-ab8500.c:		dev_err(&pdev->dev, "sysfs RTC failed to register\n");
drivers/rtc/rtc-ab8500.c:	ab8500_sysfs_rtc_unregister(&pdev->dev);
drivers/rtc/rtc-dm355evm.c:	rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-dm355evm.c:		dev_err(&pdev->dev, "can't register RTC device, err %ld\n",
drivers/rtc/rtc-tps65910.c:	tps65910 = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-tps65910.c:	tps_rtc = devm_kzalloc(&pdev->dev, sizeof(struct tps65910_rtc),
drivers/rtc/rtc-tps65910.c:	dev_dbg(&pdev->dev, "Enabling rtc-tps65910.\n");
drivers/rtc/rtc-tps65910.c:		dev_warn(&pdev->dev, "Wake up is not possible as irq = %d\n",
drivers/rtc/rtc-tps65910.c:	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
drivers/rtc/rtc-tps65910.c:		dev_name(&pdev->dev), &pdev->dev);
drivers/rtc/rtc-tps65910.c:		dev_err(&pdev->dev, "IRQ is not free.\n");
drivers/rtc/rtc-tps65910.c:	device_set_wakeup_capable(&pdev->dev, 1);
drivers/rtc/rtc-tps65910.c:	tps_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-tps65910.c:		dev_err(&pdev->dev, "RTC device register: err %d\n", ret);
drivers/rtc/rtc-tps65910.c:	tps65910_rtc_alarm_irq_enable(&pdev->dev, 0);
drivers/rtc/rtc-mv.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/rtc/rtc-mv.c:	if (!devm_request_mem_region(&pdev->dev, res->start, size,
drivers/rtc/rtc-mv.c:				     pdev->name))
drivers/rtc/rtc-mv.c:	pdata->ioaddr = devm_ioremap(&pdev->dev, res->start, size);
drivers/rtc/rtc-mv.c:	pdata->clk = devm_clk_get(&pdev->dev, NULL);
drivers/rtc/rtc-mv.c:		dev_err(&pdev->dev, "24 Hours mode not supported.\n");
drivers/rtc/rtc-mv.c:			dev_err(&pdev->dev, "internal RTC not ticking\n");
drivers/rtc/rtc-mv.c:		device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-mv.c:		pdata->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-mv.c:		pdata->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-mv.c:		if (devm_request_irq(&pdev->dev, pdata->irq, mv_rtc_interrupt,
drivers/rtc/rtc-mv.c:				     pdev->name, pdata) < 0) {
drivers/rtc/rtc-mv.c:			dev_warn(&pdev->dev, "interrupt not available.\n");
drivers/rtc/rtc-mv.c:		device_init_wakeup(&pdev->dev, 0);
drivers/rtc/rtc-spear.c:		dev_err(&pdev->dev, "no resource defined\n");
drivers/rtc/rtc-spear.c:	config = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);
drivers/rtc/rtc-spear.c:		dev_err(&pdev->dev, "out of memory\n");
drivers/rtc/rtc-spear.c:		dev_err(&pdev->dev, "no update irq?\n");
drivers/rtc/rtc-spear.c:	status = devm_request_irq(&pdev->dev, irq, spear_rtc_irq, 0, pdev->name,
drivers/rtc/rtc-spear.c:		dev_err(&pdev->dev, "Alarm interrupt IRQ%d already claimed\n",
drivers/rtc/rtc-spear.c:	config->ioaddr = devm_ioremap_resource(&pdev->dev, res);
drivers/rtc/rtc-spear.c:	config->clk = devm_clk_get(&pdev->dev, NULL);
drivers/rtc/rtc-spear.c:	config->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-spear.c:		dev_err(&pdev->dev, "can't register RTC device, err %ld\n",
drivers/rtc/rtc-spear.c:	if (!device_can_wakeup(&pdev->dev))
drivers/rtc/rtc-spear.c:		device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-spear.c:	device_init_wakeup(&pdev->dev, 0);
drivers/rtc/rtc-spear.c:	if (device_may_wakeup(&pdev->dev)) {
drivers/rtc/rtc-spear.c:	if (device_may_wakeup(&pdev->dev)) {
drivers/rtc/rtc-lpc32xx.c:		dev_err(&pdev->dev, "Can't get memory resource\n");
drivers/rtc/rtc-lpc32xx.c:		dev_warn(&pdev->dev, "Can't get interrupt resource\n");
drivers/rtc/rtc-lpc32xx.c:	rtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);
drivers/rtc/rtc-lpc32xx.c:		dev_err(&pdev->dev, "Can't allocate memory\n");
drivers/rtc/rtc-lpc32xx.c:	if (!devm_request_mem_region(&pdev->dev, res->start, size,
drivers/rtc/rtc-lpc32xx.c:				     pdev->name)) {
drivers/rtc/rtc-lpc32xx.c:		dev_err(&pdev->dev, "RTC registers are not free\n");
drivers/rtc/rtc-lpc32xx.c:	rtc->rtc_base = devm_ioremap(&pdev->dev, res->start, size);
drivers/rtc/rtc-lpc32xx.c:		dev_err(&pdev->dev, "Can't map memory\n");
drivers/rtc/rtc-lpc32xx.c:	rtc->rtc = devm_rtc_device_register(&pdev->dev, RTC_NAME,
drivers/rtc/rtc-lpc32xx.c:		dev_err(&pdev->dev, "Can't get RTC\n");
drivers/rtc/rtc-lpc32xx.c:		if (devm_request_irq(&pdev->dev, rtc->irq,
drivers/rtc/rtc-lpc32xx.c:				     0, pdev->name, rtc) < 0) {
drivers/rtc/rtc-lpc32xx.c:			dev_warn(&pdev->dev, "Can't request interrupt.\n");
drivers/rtc/rtc-lpc32xx.c:			device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-lpc32xx.c:		device_init_wakeup(&pdev->dev, 0);
drivers/rtc/rtc-lpc32xx.c:		if (device_may_wakeup(&pdev->dev))
drivers/rtc/rtc-lpc32xx.c:	if (rtc->irq >= 0 && device_may_wakeup(&pdev->dev))
drivers/rtc/rtc-sun4v.c:	rtc = devm_rtc_device_register(&pdev->dev, "sun4v",
drivers/rtc/rtc-snvs.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/rtc/rtc-snvs.c:	data->ioaddr = devm_ioremap_resource(&pdev->dev, res);
drivers/rtc/rtc-snvs.c:	device_init_wakeup(&pdev->dev, true);
drivers/rtc/rtc-snvs.c:	ret = devm_request_irq(&pdev->dev, data->irq, snvs_rtc_irq_handler,
drivers/rtc/rtc-snvs.c:			       IRQF_SHARED, "rtc alarm", &pdev->dev);
drivers/rtc/rtc-snvs.c:		dev_err(&pdev->dev, "failed to request irq %d: %d\n",
drivers/rtc/rtc-snvs.c:	data->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-snvs.c:		dev_err(&pdev->dev, "failed to register rtc: %d\n", ret);
drivers/rtc/rtc-88pm80x.c:	struct pm80x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-88pm80x.c:	pdata = pdev->dev.platform_data;
drivers/rtc/rtc-88pm80x.c:		dev_warn(&pdev->dev, "No platform data!\n");
drivers/rtc/rtc-88pm80x.c:	    devm_kzalloc(&pdev->dev, sizeof(struct pm80x_rtc_info), GFP_KERNEL);
drivers/rtc/rtc-88pm80x.c:		dev_err(&pdev->dev, "No IRQ resource!\n");
drivers/rtc/rtc-88pm80x.c:		dev_err(&pdev->dev, "no regmap!\n");
drivers/rtc/rtc-88pm80x.c:	info->dev = &pdev->dev;
drivers/rtc/rtc-88pm80x.c:	dev_set_drvdata(&pdev->dev, info);
drivers/rtc/rtc-88pm80x.c:	ret = pm80x_rtc_read_time(&pdev->dev, &tm);
drivers/rtc/rtc-88pm80x.c:		dev_err(&pdev->dev, "Failed to read initial time.\n");
drivers/rtc/rtc-88pm80x.c:		ret = pm80x_rtc_set_time(&pdev->dev, &tm);
drivers/rtc/rtc-88pm80x.c:			dev_err(&pdev->dev, "Failed to set initial time.\n");
drivers/rtc/rtc-88pm80x.c:	info->rtc_dev = devm_rtc_device_register(&pdev->dev, "88pm80x-rtc",
drivers/rtc/rtc-88pm80x.c:		dev_err(&pdev->dev, "Failed to register RTC device: %d\n", ret);
drivers/rtc/rtc-88pm80x.c:	if (pdev->dev.parent->platform_data) {
drivers/rtc/rtc-88pm80x.c:		pm80x_pdata = pdev->dev.parent->platform_data;
drivers/rtc/rtc-88pm80x.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-m48t86.c:	struct m48t86_ops *ops = pdev->dev.platform_data;
drivers/rtc/rtc-m48t86.c:	struct m48t86_ops *ops = pdev->dev.platform_data;
drivers/rtc/rtc-m48t86.c:	struct m48t86_ops *ops = pdev->dev.platform_data;
drivers/rtc/rtc-ds2404.c:			dev_err(&pdev->dev, "error mapping gpio %s: %d\n",
drivers/rtc/rtc-ds2404.c:	struct ds2404_platform_data *pdata = pdev->dev.platform_data;
drivers/rtc/rtc-ds2404.c:	chip = devm_kzalloc(&pdev->dev, sizeof(struct ds2404), GFP_KERNEL);
drivers/rtc/rtc-ds2404.c:	dev_info(&pdev->dev, "using GPIOs RST:%d, CLK:%d, DQ:%d\n",
drivers/rtc/rtc-ds2404.c:	chip->rtc = devm_rtc_device_register(&pdev->dev, "ds2404",
drivers/rtc/rtc-ds2404.c:	ds2404_enable_osc(&pdev->dev);
drivers/rtc/rtc-lp8788.c:	return devm_request_threaded_irq(&pdev->dev, rtc->irq, NULL,
drivers/rtc/rtc-lp8788.c:	struct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-lp8788.c:	struct device *dev = &pdev->dev;
drivers/rtc/rtc-sa1100.c:	info = devm_kzalloc(&pdev->dev, sizeof(struct sa1100_rtc), GFP_KERNEL);
drivers/rtc/rtc-sa1100.c:	info->clk = devm_clk_get(&pdev->dev, NULL);
drivers/rtc/rtc-sa1100.c:		dev_err(&pdev->dev, "failed to find rtc clock source\n");
drivers/rtc/rtc-sa1100.c:		dev_warn(&pdev->dev, "warning: "
drivers/rtc/rtc-sa1100.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-sa1100.c:	rtc = devm_rtc_device_register(&pdev->dev, pdev->name, &sa1100_rtc_ops,
drivers/rtc/rtc-ep93xx.c:	ep93xx_rtc = devm_kzalloc(&pdev->dev, sizeof(*ep93xx_rtc), GFP_KERNEL);
drivers/rtc/rtc-ep93xx.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
drivers/rtc/rtc-ep93xx.c:				     resource_size(res), pdev->name))
drivers/rtc/rtc-ep93xx.c:	ep93xx_rtc->mmio_base = devm_ioremap(&pdev->dev, res->start,
drivers/rtc/rtc-ep93xx.c:	pdev->dev.platform_data = ep93xx_rtc;
drivers/rtc/rtc-ep93xx.c:	ep93xx_rtc->rtc = devm_rtc_device_register(&pdev->dev,
drivers/rtc/rtc-ep93xx.c:				pdev->name, &ep93xx_rtc_ops, THIS_MODULE);
drivers/rtc/rtc-ep93xx.c:	err = sysfs_create_group(&pdev->dev.kobj, &ep93xx_rtc_sysfs_files);
drivers/rtc/rtc-ep93xx.c:	pdev->dev.platform_data = NULL;
drivers/rtc/rtc-ep93xx.c:	sysfs_remove_group(&pdev->dev.kobj, &ep93xx_rtc_sysfs_files);
drivers/rtc/rtc-ep93xx.c:	pdev->dev.platform_data = NULL;
drivers/rtc/rtc-davinci.c:	struct device *dev = &pdev->dev;
drivers/rtc/rtc-davinci.c:	davinci_rtc = devm_kzalloc(&pdev->dev, sizeof(struct davinci_rtc), GFP_KERNEL);
drivers/rtc/rtc-davinci.c:				davinci_rtc->base_size, pdev->name);
drivers/rtc/rtc-davinci.c:	davinci_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-davinci.c:	device_init_wakeup(&pdev->dev, 0);
drivers/rtc/rtc-davinci.c:	device_init_wakeup(&pdev->dev, 0);
drivers/rtc/rtc-max8925.c:	struct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-max8925.c:	info = devm_kzalloc(&pdev->dev, sizeof(struct max8925_rtc_info),
drivers/rtc/rtc-max8925.c:	info->dev = &pdev->dev;
drivers/rtc/rtc-max8925.c:	ret = devm_request_threaded_irq(&pdev->dev, info->irq, NULL,
drivers/rtc/rtc-max8925.c:	dev_set_drvdata(&pdev->dev, info);
drivers/rtc/rtc-max8925.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-max8925.c:	info->rtc_dev = devm_rtc_device_register(&pdev->dev, "max8925-rtc",
drivers/rtc/rtc-max8925.c:		dev_err(&pdev->dev, "Failed to register RTC device: %d\n", ret);
drivers/rtc/rtc-max8925.c:	struct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-max8925.c:	struct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-ds1553.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/rtc/rtc-ds1553.c:	if (!devm_request_mem_region(&pdev->dev, res->start, RTC_REG_SIZE,
drivers/rtc/rtc-ds1553.c:			pdev->name))
drivers/rtc/rtc-ds1553.c:	ioaddr = devm_ioremap(&pdev->dev, res->start, RTC_REG_SIZE);
drivers/rtc/rtc-ds1553.c:		dev_warn(&pdev->dev, "voltage-low detected.\n");
drivers/rtc/rtc-ds1553.c:		if (devm_request_irq(&pdev->dev, pdata->irq,
drivers/rtc/rtc-ds1553.c:				0, pdev->name, pdev) < 0) {
drivers/rtc/rtc-ds1553.c:			dev_warn(&pdev->dev, "interrupt not available.\n");
drivers/rtc/rtc-ds1553.c:	rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-ds1553.c:	ret = sysfs_create_bin_file(&pdev->dev.kobj, &ds1553_nvram_attr);
drivers/rtc/rtc-ds1553.c:	sysfs_remove_bin_file(&pdev->dev.kobj, &ds1553_nvram_attr);
drivers/rtc/rtc-ds1742.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/rtc/rtc-ds1742.c:	if (!devm_request_mem_region(&pdev->dev, res->start, pdata->size,
drivers/rtc/rtc-ds1742.c:		pdev->name))
drivers/rtc/rtc-ds1742.c:	ioaddr = devm_ioremap(&pdev->dev, res->start, pdata->size);
drivers/rtc/rtc-ds1742.c:		dev_warn(&pdev->dev, "voltage-low detected.\n");
drivers/rtc/rtc-ds1742.c:	rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-ds1742.c:	ret = sysfs_create_bin_file(&pdev->dev.kobj, &pdata->nvram_attr);
drivers/rtc/rtc-ds1742.c:	sysfs_remove_bin_file(&pdev->dev.kobj, &pdata->nvram_attr);
drivers/rtc/rtc-twl.c:		dev_warn(&pdev->dev, "Power up reset detected.\n");
drivers/rtc/rtc-twl.c:		dev_warn(&pdev->dev, "Pending Alarm interrupt detected.\n");
drivers/rtc/rtc-twl.c:	dev_info(&pdev->dev, "Enabling TWL-RTC\n");
drivers/rtc/rtc-twl.c:		dev_warn(&pdev->dev, "unable to disable interrupt\n");
drivers/rtc/rtc-twl.c:	rtc = rtc_device_register(pdev->name,
drivers/rtc/rtc-twl.c:				  &pdev->dev, &twl_rtc_ops, THIS_MODULE);
drivers/rtc/rtc-twl.c:		dev_err(&pdev->dev, "can't register RTC device, err %ld\n",
drivers/rtc/rtc-twl.c:		dev_err(&pdev->dev, "IRQ is not free.\n");
drivers/rtc/rtc-twl.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-cmos.c:	struct device_node *node = pdev->dev.of_node;
drivers/rtc/rtc-cmos.c:	cmos_wake_setup(&pdev->dev);
drivers/rtc/rtc-cmos.c:	return cmos_do_probe(&pdev->dev,
drivers/rtc/rtc-cmos.c:	cmos_do_remove(&pdev->dev);
drivers/rtc/rtc-cmos.c:	if (system_state == SYSTEM_POWER_OFF && !cmos_poweroff(&pdev->dev))
drivers/rtc/rtc-tegra.c:	info = devm_kzalloc(&pdev->dev, sizeof(struct tegra_rtc_info),
drivers/rtc/rtc-tegra.c:	info->rtc_base = devm_ioremap_resource(&pdev->dev, res);
drivers/rtc/rtc-tegra.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-tegra.c:	info->rtc_dev = devm_rtc_device_register(&pdev->dev,
drivers/rtc/rtc-tegra.c:				dev_name(&pdev->dev), &tegra_rtc_ops,
drivers/rtc/rtc-tegra.c:		dev_err(&pdev->dev, "Unable to register device (err=%d).\n",
drivers/rtc/rtc-tegra.c:	ret = devm_request_irq(&pdev->dev, info->tegra_rtc_irq,
drivers/rtc/rtc-tegra.c:			dev_name(&pdev->dev), &pdev->dev);
drivers/rtc/rtc-tegra.c:		dev_err(&pdev->dev,
drivers/rtc/rtc-tegra.c:	dev_notice(&pdev->dev, "Tegra internal Real Time Clock\n");
drivers/rtc/rtc-tegra.c:	dev_vdbg(&pdev->dev, "disabling interrupts.\n");
drivers/rtc/rtc-tegra.c:	tegra_rtc_alarm_irq_enable(&pdev->dev, 0);
drivers/rtc/rtc-ds1286.c:	priv = devm_kzalloc(&pdev->dev, sizeof(struct ds1286_priv), GFP_KERNEL);
drivers/rtc/rtc-ds1286.c:	priv->rtcregs = devm_ioremap_resource(&pdev->dev, res);
drivers/rtc/rtc-ds1286.c:	rtc = devm_rtc_device_register(&pdev->dev, "ds1286", &ds1286_ops,
drivers/rtc/rtc-stk17ta8.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/rtc/rtc-stk17ta8.c:	if (!devm_request_mem_region(&pdev->dev, res->start, RTC_REG_SIZE,
drivers/rtc/rtc-stk17ta8.c:			pdev->name))
drivers/rtc/rtc-stk17ta8.c:	ioaddr = devm_ioremap(&pdev->dev, res->start, RTC_REG_SIZE);
drivers/rtc/rtc-stk17ta8.c:		dev_warn(&pdev->dev, "voltage-low detected.\n");
drivers/rtc/rtc-stk17ta8.c:		if (devm_request_irq(&pdev->dev, pdata->irq,
drivers/rtc/rtc-stk17ta8.c:				pdev->name, pdev) < 0) {
drivers/rtc/rtc-stk17ta8.c:			dev_warn(&pdev->dev, "interrupt not available.\n");
drivers/rtc/rtc-stk17ta8.c:	pdata->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-stk17ta8.c:	ret = sysfs_create_bin_file(&pdev->dev.kobj, &stk17ta8_nvram_attr);
drivers/rtc/rtc-stk17ta8.c:	sysfs_remove_bin_file(&pdev->dev.kobj, &stk17ta8_nvram_attr);
drivers/rtc/rtc-tps80031.c:	rtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);
drivers/rtc/rtc-tps80031.c:	ret = tps80031_set_bits(pdev->dev.parent, TPS80031_SLAVE_ID1,
drivers/rtc/rtc-tps80031.c:		dev_err(&pdev->dev, "failed to start RTC. err = %d\n", ret);
drivers/rtc/rtc-tps80031.c:	tps80031_rtc_read_time(&pdev->dev, &tm);
drivers/rtc/rtc-tps80031.c:		ret = tps80031_rtc_set_time(&pdev->dev, &tm);
drivers/rtc/rtc-tps80031.c:			dev_err(&pdev->dev,
drivers/rtc/rtc-tps80031.c:	ret = clear_alarm_int_status(&pdev->dev, rtc);
drivers/rtc/rtc-tps80031.c:		dev_err(&pdev->dev, "Clear alarm int failed, err = %d\n", ret);
drivers/rtc/rtc-tps80031.c:	rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-tps80031.c:		dev_err(&pdev->dev, "RTC registration failed, err %d\n", ret);
drivers/rtc/rtc-tps80031.c:	ret = devm_request_threaded_irq(&pdev->dev, rtc->irq, NULL,
drivers/rtc/rtc-tps80031.c:			dev_name(&pdev->dev), rtc);
drivers/rtc/rtc-tps80031.c:		dev_err(&pdev->dev, "request IRQ:%d failed, err = %d\n",
drivers/rtc/rtc-tps80031.c:	device_set_wakeup_capable(&pdev->dev, 1);
drivers/rtc/rtc-stmp3xxx.c:		platform_device_alloc("stmp3xxx_rtc_wdt", rtc_pdev->id);
drivers/rtc/rtc-stmp3xxx.c:		wdt_pdev->dev.parent = &rtc_pdev->dev;
drivers/rtc/rtc-stmp3xxx.c:		wdt_pdev->dev.platform_data = &wdt_pdata;
drivers/rtc/rtc-stmp3xxx.c:	rtc_data = devm_kzalloc(&pdev->dev, sizeof(*rtc_data), GFP_KERNEL);
drivers/rtc/rtc-stmp3xxx.c:		dev_err(&pdev->dev, "failed to get resource\n");
drivers/rtc/rtc-stmp3xxx.c:	rtc_data->io = devm_ioremap(&pdev->dev, r->start, resource_size(r));
drivers/rtc/rtc-stmp3xxx.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/rtc/rtc-stmp3xxx.c:		dev_err(&pdev->dev, "no device onboard\n");
drivers/rtc/rtc-stmp3xxx.c:	rtc_data->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-stmp3xxx.c:	err = devm_request_irq(&pdev->dev, rtc_data->irq_alarm,
drivers/rtc/rtc-stmp3xxx.c:			stmp3xxx_rtc_interrupt, 0, "RTC alarm", &pdev->dev);
drivers/rtc/rtc-stmp3xxx.c:		dev_err(&pdev->dev, "Cannot claim IRQ%d\n",
drivers/rtc/rtc-88pm860x.c:	struct device_node *np = pdev->dev.parent->of_node;
drivers/rtc/rtc-88pm860x.c:		dev_err(&pdev->dev, "failed to find rtc node\n");
drivers/rtc/rtc-88pm860x.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-88pm860x.c:	pdata = pdev->dev.platform_data;
drivers/rtc/rtc-88pm860x.c:	info = devm_kzalloc(&pdev->dev, sizeof(struct pm860x_rtc_info),
drivers/rtc/rtc-88pm860x.c:		dev_err(&pdev->dev, "No IRQ resource!\n");
drivers/rtc/rtc-88pm860x.c:	info->dev = &pdev->dev;
drivers/rtc/rtc-88pm860x.c:	dev_set_drvdata(&pdev->dev, info);
drivers/rtc/rtc-88pm860x.c:	ret = devm_request_threaded_irq(&pdev->dev, info->irq, NULL,
drivers/rtc/rtc-88pm860x.c:	ret = pm860x_rtc_read_time(&pdev->dev, &tm);
drivers/rtc/rtc-88pm860x.c:		dev_err(&pdev->dev, "Failed to read initial time.\n");
drivers/rtc/rtc-88pm860x.c:		ret = pm860x_rtc_set_time(&pdev->dev, &tm);
drivers/rtc/rtc-88pm860x.c:			dev_err(&pdev->dev, "Failed to set initial time.\n");
drivers/rtc/rtc-88pm860x.c:	info->rtc_dev = devm_rtc_device_register(&pdev->dev, "88pm860x-rtc",
drivers/rtc/rtc-88pm860x.c:		dev_err(&pdev->dev, "Failed to register RTC device: %d\n", ret);
drivers/rtc/rtc-88pm860x.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-88pm860x.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-88pm860x.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-omap.c:	of_id = of_match_device(omap_rtc_of_match, &pdev->dev);
drivers/rtc/rtc-omap.c:		pdev->id_entry = of_id->data;
drivers/rtc/rtc-omap.c:		pr_debug("%s: no update irq?\n", pdev->name);
drivers/rtc/rtc-omap.c:		pr_debug("%s: no alarm irq?\n", pdev->name);
drivers/rtc/rtc-omap.c:	rtc_base = devm_ioremap_resource(&pdev->dev, res);
drivers/rtc/rtc-omap.c:	pm_runtime_enable(&pdev->dev);
drivers/rtc/rtc-omap.c:	pm_runtime_get_sync(&pdev->dev);
drivers/rtc/rtc-omap.c:	rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
drivers/rtc/rtc-omap.c:			pdev->name, PTR_ERR(rtc));
drivers/rtc/rtc-omap.c:			pdev->name);
drivers/rtc/rtc-omap.c:	if (devm_request_irq(&pdev->dev, omap_rtc_timer, rtc_irq, 0,
drivers/rtc/rtc-omap.c:			pdev->name, omap_rtc_timer);
drivers/rtc/rtc-omap.c:		(devm_request_irq(&pdev->dev, omap_rtc_alarm, rtc_irq, 0,
drivers/rtc/rtc-omap.c:			pdev->name, omap_rtc_alarm);
drivers/rtc/rtc-omap.c:		pr_info("%s: already running\n", pdev->name);
drivers/rtc/rtc-omap.c:		pr_info("%s: split power mode\n", pdev->name);
drivers/rtc/rtc-omap.c:	pm_runtime_put_sync(&pdev->dev);
drivers/rtc/rtc-omap.c:	pm_runtime_disable(&pdev->dev);
drivers/rtc/rtc-omap.c:	device_init_wakeup(&pdev->dev, 0);
drivers/rtc/rtc-omap.c:	pm_runtime_put_sync(&pdev->dev);
drivers/rtc/rtc-omap.c:	pm_runtime_disable(&pdev->dev);
drivers/rtc/rtc-max8907.c:	struct max8907 *max8907 = dev_get_drvdata(pdev->dev.parent);
drivers/rtc/rtc-max8907.c:	rtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);
drivers/rtc/rtc-max8907.c:	rtc->rtc_dev = devm_rtc_device_register(&pdev->dev, "max8907-rtc",
drivers/rtc/rtc-max8907.c:		dev_err(&pdev->dev, "Failed to register RTC device: %d\n", ret);
drivers/rtc/rtc-max8907.c:	ret = devm_request_threaded_irq(&pdev->dev, rtc->irq, NULL,
drivers/rtc/rtc-max8907.c:		dev_err(&pdev->dev, "Failed to request IRQ%d: %d\n",
drivers/rtc/rtc-s3c.c:			dev_info(&pdev->dev, "rtc disabled, re-enabling\n");
drivers/rtc/rtc-s3c.c:			dev_info(&pdev->dev, "removing RTCCON_CNTSEL\n");
drivers/rtc/rtc-s3c.c:			dev_info(&pdev->dev, "removing RTCCON_CLKRST\n");
drivers/rtc/rtc-s3c.c:	if (pdev->dev.of_node) {
drivers/rtc/rtc-s3c.c:		match = of_match_node(s3c_rtc_dt_match, pdev->dev.of_node);
drivers/rtc/rtc-s3c.c:	dev_dbg(&pdev->dev, "%s: probe=%p\n", __func__, pdev);
drivers/rtc/rtc-s3c.c:		dev_err(&pdev->dev, "no irq for rtc tick\n");
drivers/rtc/rtc-s3c.c:		dev_err(&pdev->dev, "no irq for alarm\n");
drivers/rtc/rtc-s3c.c:	dev_dbg(&pdev->dev, "s3c2410_rtc: tick irq %d, alarm irq %d\n",
drivers/rtc/rtc-s3c.c:	s3c_rtc_base = devm_ioremap_resource(&pdev->dev, res);
drivers/rtc/rtc-s3c.c:	rtc_clk = devm_clk_get(&pdev->dev, "rtc");
drivers/rtc/rtc-s3c.c:		dev_err(&pdev->dev, "failed to find rtc clock source\n");
drivers/rtc/rtc-s3c.c:	dev_dbg(&pdev->dev, "s3c2410_rtc: RTCCON=%02x\n",
drivers/rtc/rtc-s3c.c:	device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-s3c.c:	rtc = devm_rtc_device_register(&pdev->dev, "s3c", &s3c_rtcops,
drivers/rtc/rtc-s3c.c:		dev_err(&pdev->dev, "cannot attach rtc\n");
drivers/rtc/rtc-s3c.c:		dev_warn(&pdev->dev, "warning: invalid RTC value so initializing it\n");
drivers/rtc/rtc-s3c.c:	s3c_rtc_setfreq(&pdev->dev, 1);
drivers/rtc/rtc-s3c.c:	ret = devm_request_irq(&pdev->dev, s3c_rtc_alarmno, s3c_rtc_alarmirq,
drivers/rtc/rtc-s3c.c:		dev_err(&pdev->dev, "IRQ%d error %d\n", s3c_rtc_alarmno, ret);
drivers/rtc/rtc-s3c.c:	ret = devm_request_irq(&pdev->dev, s3c_rtc_tickno, s3c_rtc_tickirq,
drivers/rtc/rtc-s3c.c:		dev_err(&pdev->dev, "IRQ%d error %d\n", s3c_rtc_tickno, ret);
drivers/rtc/rtc-puv3.c:		dev_err(&pdev->dev, "no irq for rtc tick\n");
drivers/rtc/rtc-puv3.c:		dev_err(&pdev->dev, "no irq for alarm\n");
drivers/rtc/rtc-puv3.c:		dev_err(&pdev->dev, "failed to get memory region resource\n");
drivers/rtc/rtc-puv3.c:					  pdev->name);
drivers/rtc/rtc-puv3.c:		dev_err(&pdev->dev, "failed to reserve memory region\n");
drivers/rtc/rtc-puv3.c:	puv3_rtc_enable(&pdev->dev, 1);
drivers/rtc/rtc-puv3.c:	rtc = rtc_device_register("pkunity", &pdev->dev, &puv3_rtcops,
drivers/rtc/rtc-puv3.c:		dev_err(&pdev->dev, "cannot attach rtc\n");
drivers/rtc/rtc-puv3.c:	if (!device_can_wakeup(&pdev->dev))
drivers/rtc/rtc-puv3.c:		device_init_wakeup(&pdev->dev, 1);
drivers/rtc/rtc-puv3.c:	puv3_rtc_enable(&pdev->dev, 0);
drivers/rtc/rtc-ds1216.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
drivers/rtc/rtc-ds1216.c:	priv->ioaddr = devm_ioremap_resource(&pdev->dev, res);
drivers/rtc/rtc-ds1216.c:	priv->rtc = devm_rtc_device_register(&pdev->dev, "ds1216",
drivers/input/keyreset.c:	struct keyreset_platform_data *pdata = pdev->dev.platform_data;
drivers/input/mouse/navpoint.c:					dev_get_platdata(&pdev->dev);
drivers/input/mouse/navpoint.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/input/mouse/navpoint.c:	ssp = pxa_ssp_request(pdata->port, pdev->name);
drivers/input/mouse/navpoint.c:		dev_warn(&pdev->dev, "ssp%d already enabled\n", pdata->port);
drivers/input/mouse/navpoint.c:	navpoint->dev = &pdev->dev;
drivers/input/mouse/navpoint.c:	input->name = pdev->name;
drivers/input/mouse/navpoint.c:	input->dev.parent = &pdev->dev;
drivers/input/mouse/navpoint.c:	error = request_irq(ssp->irq, navpoint_irq, 0, pdev->name, navpoint);
drivers/input/mouse/navpoint.c:	dev_dbg(&pdev->dev, "ssp%d, irq %d\n", pdata->port, ssp->irq);
drivers/input/mouse/navpoint.c:	free_irq(ssp->irq, &pdev->dev);
drivers/input/mouse/navpoint.c:					dev_get_platdata(&pdev->dev);
drivers/input/mouse/gpio_mouse.c:	struct gpio_mouse_platform_data *pdata = pdev->dev.platform_data;
drivers/input/mouse/gpio_mouse.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/input/mouse/gpio_mouse.c:		dev_err(&pdev->dev, "invalid scan time\n");
drivers/input/mouse/gpio_mouse.c:				dev_err(&pdev->dev,
drivers/input/mouse/gpio_mouse.c:				dev_dbg(&pdev->dev, "no left button defined\n");
drivers/input/mouse/gpio_mouse.c:				dev_err(&pdev->dev, "fail %d pin (%d idx)\n",
drivers/input/mouse/gpio_mouse.c:		dev_err(&pdev->dev, "not enough memory for input device\n");
drivers/input/mouse/gpio_mouse.c:	input->name = pdev->name;
drivers/input/mouse/gpio_mouse.c:	input->dev.parent = &pdev->dev;
drivers/input/mouse/gpio_mouse.c:		dev_err(&pdev->dev, "could not register input device\n");
drivers/input/mouse/gpio_mouse.c:	dev_dbg(&pdev->dev, "%d ms scan time, buttons: %s%s%s\n",
drivers/input/mouse/amimouse.c:	dev->name = pdev->name;
drivers/input/mouse/amimouse.c:	dev->dev.parent = &pdev->dev;
drivers/input/mouse/pxa930_trkball.c:		dev_err(&pdev->dev, "failed to get trkball irq\n");
drivers/input/mouse/pxa930_trkball.c:		dev_err(&pdev->dev, "failed to get register memory\n");
drivers/input/mouse/pxa930_trkball.c:	trkball->pdata = pdev->dev.platform_data;
drivers/input/mouse/pxa930_trkball.c:		dev_err(&pdev->dev, "no platform data defined\n");
drivers/input/mouse/pxa930_trkball.c:		dev_err(&pdev->dev, "failed to ioremap registers\n");
drivers/input/mouse/pxa930_trkball.c:			    pdev->name, trkball);
drivers/input/mouse/pxa930_trkball.c:		dev_err(&pdev->dev, "failed to request irq: %d\n", error);
drivers/input/mouse/pxa930_trkball.c:		dev_err(&pdev->dev, "failed to allocate input device\n");
drivers/input/mouse/pxa930_trkball.c:	input->name = pdev->name;
drivers/input/mouse/pxa930_trkball.c:	input->dev.parent = &pdev->dev;
drivers/input/mouse/pxa930_trkball.c:		dev_err(&pdev->dev, "unable to register input device\n");
drivers/input/keyboard/ep93xx_keypad.c:	if (device_may_wakeup(&pdev->dev))
drivers/input/keyboard/ep93xx_keypad.c:	if (device_may_wakeup(&pdev->dev))
drivers/input/keyboard/ep93xx_keypad.c:	keypad->pdata = pdev->dev.platform_data;
drivers/input/keyboard/ep93xx_keypad.c:	res = request_mem_region(res->start, resource_size(res), pdev->name);
drivers/input/keyboard/ep93xx_keypad.c:	keypad->clk = clk_get(&pdev->dev, NULL);
drivers/input/keyboard/ep93xx_keypad.c:	input_dev->name = pdev->name;
drivers/input/keyboard/ep93xx_keypad.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/keyboard/ep93xx_keypad.c:			  0, pdev->name, keypad);
drivers/input/keyboard/ep93xx_keypad.c:	device_init_wakeup(&pdev->dev, 1);
drivers/input/keyboard/lpc32xx-keys.c:		dev_err(&pdev->dev, "failed to get platform I/O memory\n");
drivers/input/keyboard/lpc32xx-keys.c:		dev_err(&pdev->dev, "failed to get platform irq\n");
drivers/input/keyboard/lpc32xx-keys.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/input/keyboard/lpc32xx-keys.c:	error = lpc32xx_parse_dt(&pdev->dev, kscandat);
drivers/input/keyboard/lpc32xx-keys.c:		dev_err(&pdev->dev, "failed to parse device tree\n");
drivers/input/keyboard/lpc32xx-keys.c:		dev_err(&pdev->dev, "could not allocate memory for keymap\n");
drivers/input/keyboard/lpc32xx-keys.c:		dev_err(&pdev->dev, "failed to allocate input device\n");
drivers/input/keyboard/lpc32xx-keys.c:	input->name		= pdev->name;
drivers/input/keyboard/lpc32xx-keys.c:	input->dev.parent	= &pdev->dev;
drivers/input/keyboard/lpc32xx-keys.c:		dev_err(&pdev->dev, "failed to build keymap\n");
drivers/input/keyboard/lpc32xx-keys.c:					     pdev->name);
drivers/input/keyboard/lpc32xx-keys.c:		dev_err(&pdev->dev, "failed to request I/O memory\n");
drivers/input/keyboard/lpc32xx-keys.c:		dev_err(&pdev->dev, "failed to remap I/O memory\n");
drivers/input/keyboard/lpc32xx-keys.c:	kscandat->clk = clk_get(&pdev->dev, NULL);
drivers/input/keyboard/lpc32xx-keys.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/input/keyboard/lpc32xx-keys.c:	error = request_irq(irq, lpc32xx_kscan_irq, 0, pdev->name, kscandat);
drivers/input/keyboard/lpc32xx-keys.c:		dev_err(&pdev->dev, "failed to request irq\n");
drivers/input/keyboard/lpc32xx-keys.c:		dev_err(&pdev->dev, "failed to register input device\n");
drivers/input/keyboard/jornada720_kbd.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/keyboard/matrix_keypad.c:	if (device_may_wakeup(&pdev->dev))
drivers/input/keyboard/matrix_keypad.c:	if (device_may_wakeup(&pdev->dev))
drivers/input/keyboard/matrix_keypad.c:			dev_err(&pdev->dev,
drivers/input/keyboard/matrix_keypad.c:			dev_err(&pdev->dev,
drivers/input/keyboard/matrix_keypad.c:			dev_err(&pdev->dev,
drivers/input/keyboard/matrix_keypad.c:				dev_err(&pdev->dev,
drivers/input/keyboard/matrix_keypad.c:	pdata = dev_get_platdata(&pdev->dev);
drivers/input/keyboard/matrix_keypad.c:		pdata = matrix_keypad_parse_dt(&pdev->dev);
drivers/input/keyboard/matrix_keypad.c:			dev_err(&pdev->dev, "no platform data defined\n");
drivers/input/keyboard/matrix_keypad.c:		dev_err(&pdev->dev, "no keymap data defined\n");
drivers/input/keyboard/matrix_keypad.c:	input_dev->name		= pdev->name;
drivers/input/keyboard/matrix_keypad.c:	input_dev->dev.parent	= &pdev->dev;
drivers/input/keyboard/matrix_keypad.c:		dev_err(&pdev->dev, "failed to build keymap\n");
drivers/input/keyboard/matrix_keypad.c:	device_init_wakeup(&pdev->dev, pdata->wakeup);
drivers/input/keyboard/matrix_keypad.c:	device_init_wakeup(&pdev->dev, 0);
drivers/input/keyboard/tnetv107x-keypad.c:	struct device *dev = &pdev->dev;
drivers/input/keyboard/tnetv107x-keypad.c:	pdata = pdev->dev.platform_data;
drivers/input/keyboard/tnetv107x-keypad.c:				pdev->name)) {
drivers/input/keyboard/tnetv107x-keypad.c:	kp->input_dev->name	  = pdev->name;
drivers/input/keyboard/tnetv107x-keypad.c:	kp->input_dev->dev.parent = &pdev->dev;
drivers/input/keyboard/pxa27x_keypad.c:	if (device_may_wakeup(&pdev->dev))
drivers/input/keyboard/pxa27x_keypad.c:	if (device_may_wakeup(&pdev->dev)) {
drivers/input/keyboard/pxa27x_keypad.c:	struct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;
drivers/input/keyboard/pxa27x_keypad.c:		dev_err(&pdev->dev, "no platform data defined\n");
drivers/input/keyboard/pxa27x_keypad.c:		dev_err(&pdev->dev, "failed to get keypad irq\n");
drivers/input/keyboard/pxa27x_keypad.c:		dev_err(&pdev->dev, "failed to get I/O memory\n");
drivers/input/keyboard/pxa27x_keypad.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/input/keyboard/pxa27x_keypad.c:	res = request_mem_region(res->start, resource_size(res), pdev->name);
drivers/input/keyboard/pxa27x_keypad.c:		dev_err(&pdev->dev, "failed to request I/O memory\n");
drivers/input/keyboard/pxa27x_keypad.c:		dev_err(&pdev->dev, "failed to remap I/O memory\n");
drivers/input/keyboard/pxa27x_keypad.c:	keypad->clk = clk_get(&pdev->dev, NULL);
drivers/input/keyboard/pxa27x_keypad.c:		dev_err(&pdev->dev, "failed to get keypad clock\n");
drivers/input/keyboard/pxa27x_keypad.c:	input_dev->name = pdev->name;
drivers/input/keyboard/pxa27x_keypad.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/keyboard/pxa27x_keypad.c:			    pdev->name, keypad);
drivers/input/keyboard/pxa27x_keypad.c:		dev_err(&pdev->dev, "failed to request IRQ\n");
drivers/input/keyboard/pxa27x_keypad.c:		dev_err(&pdev->dev, "failed to register input device\n");
drivers/input/keyboard/pxa27x_keypad.c:	device_init_wakeup(&pdev->dev, 1);
drivers/input/keyboard/spear-keyboard.c:	struct device_node *np = pdev->dev.of_node;
drivers/input/keyboard/spear-keyboard.c:		dev_err(&pdev->dev, "Missing DT data\n");
drivers/input/keyboard/spear-keyboard.c:		dev_err(&pdev->dev, "DT: Invalid or missing mode\n");
drivers/input/keyboard/spear-keyboard.c:	struct kbd_platform_data *pdata = dev_get_platdata(&pdev->dev);
drivers/input/keyboard/spear-keyboard.c:		dev_err(&pdev->dev, "no keyboard resource defined\n");
drivers/input/keyboard/spear-keyboard.c:		dev_err(&pdev->dev, "not able to get irq for the device\n");
drivers/input/keyboard/spear-keyboard.c:	kbd = devm_kzalloc(&pdev->dev, sizeof(*kbd), GFP_KERNEL);
drivers/input/keyboard/spear-keyboard.c:		dev_err(&pdev->dev, "not enough memory for driver data\n");
drivers/input/keyboard/spear-keyboard.c:	input_dev = devm_input_allocate_device(&pdev->dev);
drivers/input/keyboard/spear-keyboard.c:		dev_err(&pdev->dev, "unable to allocate input device\n");
drivers/input/keyboard/spear-keyboard.c:	kbd->io_base = devm_ioremap_resource(&pdev->dev, res);
drivers/input/keyboard/spear-keyboard.c:	kbd->clk = devm_clk_get(&pdev->dev, NULL);
drivers/input/keyboard/spear-keyboard.c:		dev_err(&pdev->dev, "Failed to build keymap\n");
drivers/input/keyboard/spear-keyboard.c:	error = devm_request_irq(&pdev->dev, irq, spear_kbd_interrupt, 0,
drivers/input/keyboard/spear-keyboard.c:		dev_err(&pdev->dev, "request_irq failed\n");
drivers/input/keyboard/spear-keyboard.c:		dev_err(&pdev->dev, "Unable to register keyboard device\n");
drivers/input/keyboard/spear-keyboard.c:	device_init_wakeup(&pdev->dev, 1);
drivers/input/keyboard/spear-keyboard.c:	device_init_wakeup(&pdev->dev, 0);
drivers/input/keyboard/spear-keyboard.c:	if (device_may_wakeup(&pdev->dev)) {
drivers/input/keyboard/spear-keyboard.c:	if (device_may_wakeup(&pdev->dev)) {
drivers/input/keyboard/twl4030_keypad.c:	struct twl4030_keypad_data *pdata = pdev->dev.platform_data;
drivers/input/keyboard/twl4030_keypad.c:		dev_err(&pdev->dev, "Invalid platform_data\n");
drivers/input/keyboard/twl4030_keypad.c:	kp->dbg_dev = &pdev->dev;
drivers/input/keyboard/twl4030_keypad.c:	input->dev.parent	= &pdev->dev;
drivers/input/keyboard/twl4030_keypad.c:			0, pdev->name, kp);
drivers/input/keyboard/gpio_keys_polled.c:	struct device *dev = &pdev->dev;
drivers/input/keyboard/gpio_keys_polled.c:	input->name = pdev->name;
drivers/input/keyboard/gpio_keys_polled.c:	input->dev.parent = &pdev->dev;
drivers/input/keyboard/gpio_keys_polled.c:	if (!dev_get_platdata(&pdev->dev))
drivers/input/keyboard/gpio_keys_polled.c:	if (!dev_get_platdata(&pdev->dev))
drivers/input/keyboard/samsung-keypad.c:	pm_runtime_get_sync(&keypad->pdev->dev);
drivers/input/keyboard/samsung-keypad.c:	pm_runtime_put(&keypad->pdev->dev);
drivers/input/keyboard/samsung-keypad.c:	pm_runtime_get_sync(&keypad->pdev->dev);
drivers/input/keyboard/samsung-keypad.c:	pm_runtime_put(&keypad->pdev->dev);
drivers/input/keyboard/samsung-keypad.c:	pm_runtime_get_sync(&keypad->pdev->dev);
drivers/input/keyboard/samsung-keypad.c:	pm_runtime_put(&keypad->pdev->dev);
drivers/input/keyboard/samsung-keypad.c:	if (pdev->dev.of_node)
drivers/input/keyboard/samsung-keypad.c:		pdata = samsung_keypad_parse_dt(&pdev->dev);
drivers/input/keyboard/samsung-keypad.c:		pdata = pdev->dev.platform_data;
drivers/input/keyboard/samsung-keypad.c:		dev_err(&pdev->dev, "no platform data defined\n");
drivers/input/keyboard/samsung-keypad.c:		dev_err(&pdev->dev, "no keymap data defined\n");
drivers/input/keyboard/samsung-keypad.c:	keypad = devm_kzalloc(&pdev->dev, sizeof(*keypad) + keymap_size,
drivers/input/keyboard/samsung-keypad.c:	input_dev = devm_input_allocate_device(&pdev->dev);
drivers/input/keyboard/samsung-keypad.c:	keypad->base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/input/keyboard/samsung-keypad.c:	keypad->clk = devm_clk_get(&pdev->dev, "keypad");
drivers/input/keyboard/samsung-keypad.c:		dev_err(&pdev->dev, "failed to get keypad clk\n");
drivers/input/keyboard/samsung-keypad.c:		dev_err(&pdev->dev, "keypad clock prepare failed\n");
drivers/input/keyboard/samsung-keypad.c:	if (pdev->dev.of_node) {
drivers/input/keyboard/samsung-keypad.c:		samsung_keypad_parse_dt_gpio(&pdev->dev, keypad);
drivers/input/keyboard/samsung-keypad.c:		keypad->type = of_device_is_compatible(pdev->dev.of_node,
drivers/input/keyboard/samsung-keypad.c:	input_dev->name = pdev->name;
drivers/input/keyboard/samsung-keypad.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/keyboard/samsung-keypad.c:		dev_err(&pdev->dev, "failed to build keymap\n");
drivers/input/keyboard/samsung-keypad.c:	error = devm_request_threaded_irq(&pdev->dev, keypad->irq, NULL,
drivers/input/keyboard/samsung-keypad.c:					  dev_name(&pdev->dev), keypad);
drivers/input/keyboard/samsung-keypad.c:		dev_err(&pdev->dev, "failed to register keypad interrupt\n");
drivers/input/keyboard/samsung-keypad.c:	device_init_wakeup(&pdev->dev, pdata->wakeup);
drivers/input/keyboard/samsung-keypad.c:	pm_runtime_enable(&pdev->dev);
drivers/input/keyboard/samsung-keypad.c:	if (pdev->dev.of_node) {
drivers/input/keyboard/samsung-keypad.c:		devm_kfree(&pdev->dev, (void *)pdata->keymap_data->keymap);
drivers/input/keyboard/samsung-keypad.c:		devm_kfree(&pdev->dev, (void *)pdata->keymap_data);
drivers/input/keyboard/samsung-keypad.c:		devm_kfree(&pdev->dev, (void *)pdata);
drivers/input/keyboard/samsung-keypad.c:	pm_runtime_disable(&pdev->dev);
drivers/input/keyboard/samsung-keypad.c:	device_init_wakeup(&pdev->dev, 0);
drivers/input/keyboard/samsung-keypad.c:	pm_runtime_disable(&pdev->dev);
drivers/input/keyboard/samsung-keypad.c:	device_init_wakeup(&pdev->dev, 0);
drivers/input/keyboard/samsung-keypad.c:		if (device_may_wakeup(&keypad->pdev->dev))
drivers/input/keyboard/samsung-keypad.c:		if (device_may_wakeup(&keypad->pdev->dev))
drivers/input/keyboard/adp5520-keys.c:	struct adp5520_keys_platform_data *pdata = pdev->dev.platform_data;
drivers/input/keyboard/adp5520-keys.c:	if (pdev->id != ID_ADP5520) {
drivers/input/keyboard/adp5520-keys.c:		dev_err(&pdev->dev, "only ADP5520 supports Keypad\n");
drivers/input/keyboard/adp5520-keys.c:		dev_err(&pdev->dev, "missing platform data\n");
drivers/input/keyboard/adp5520-keys.c:		dev_err(&pdev->dev, "failed to alloc memory\n");
drivers/input/keyboard/adp5520-keys.c:	dev->master = pdev->dev.parent;
drivers/input/keyboard/adp5520-keys.c:	input->name = pdev->name;
drivers/input/keyboard/adp5520-keys.c:	input->dev.parent = &pdev->dev;
drivers/input/keyboard/adp5520-keys.c:		dev_err(&pdev->dev, "unable to register input device\n");
drivers/input/keyboard/adp5520-keys.c:		dev_err(&pdev->dev, "failed to write\n");
drivers/input/keyboard/adp5520-keys.c:		dev_err(&pdev->dev, "failed to register notifier\n");
drivers/input/keyboard/tegra-kbc.c:	match = of_match_device(of_match_ptr(tegra_kbc_of_match), &pdev->dev);
drivers/input/keyboard/tegra-kbc.c:	kbc = devm_kzalloc(&pdev->dev, sizeof(*kbc), GFP_KERNEL);
drivers/input/keyboard/tegra-kbc.c:		dev_err(&pdev->dev, "failed to alloc memory for kbc\n");
drivers/input/keyboard/tegra-kbc.c:	kbc->dev = &pdev->dev;
drivers/input/keyboard/tegra-kbc.c:		dev_err(&pdev->dev, "failed to get I/O memory\n");
drivers/input/keyboard/tegra-kbc.c:		dev_err(&pdev->dev, "failed to get keyboard IRQ\n");
drivers/input/keyboard/tegra-kbc.c:	kbc->idev = devm_input_allocate_device(&pdev->dev);
drivers/input/keyboard/tegra-kbc.c:		dev_err(&pdev->dev, "failed to allocate input device\n");
drivers/input/keyboard/tegra-kbc.c:	kbc->mmio = devm_ioremap_resource(&pdev->dev, res);
drivers/input/keyboard/tegra-kbc.c:	kbc->clk = devm_clk_get(&pdev->dev, NULL);
drivers/input/keyboard/tegra-kbc.c:		dev_err(&pdev->dev, "failed to get keyboard clock\n");
drivers/input/keyboard/tegra-kbc.c:	kbc->idev->name = pdev->name;
drivers/input/keyboard/tegra-kbc.c:	kbc->idev->dev.parent = &pdev->dev;
drivers/input/keyboard/tegra-kbc.c:		dev_err(&pdev->dev, "failed to setup keymap\n");
drivers/input/keyboard/tegra-kbc.c:	err = devm_request_irq(&pdev->dev, kbc->irq, tegra_kbc_isr,
drivers/input/keyboard/tegra-kbc.c:			  IRQF_NO_SUSPEND | IRQF_TRIGGER_HIGH, pdev->name, kbc);
drivers/input/keyboard/tegra-kbc.c:		dev_err(&pdev->dev, "failed to request keyboard IRQ\n");
drivers/input/keyboard/tegra-kbc.c:		dev_err(&pdev->dev, "failed to register input device\n");
drivers/input/keyboard/tegra-kbc.c:	device_init_wakeup(&pdev->dev, kbc->wakeup);
drivers/input/keyboard/tegra-kbc.c:	if (device_may_wakeup(&pdev->dev)) {
drivers/input/keyboard/tegra-kbc.c:	if (device_may_wakeup(&pdev->dev)) {
drivers/input/keyboard/jornada680_kbd.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/keyboard/sh_keysc.c:	dev_dbg(&pdev->dev, "isr!\n");
drivers/input/keyboard/sh_keysc.c:		sh_keysc_map_dbg(&pdev->dev, keys, "keys");
drivers/input/keyboard/sh_keysc.c:	sh_keysc_map_dbg(&pdev->dev, priv->last_keys, "last_keys");
drivers/input/keyboard/sh_keysc.c:	sh_keysc_map_dbg(&pdev->dev, keys0, "keys0");
drivers/input/keyboard/sh_keysc.c:	sh_keysc_map_dbg(&pdev->dev, keys1, "keys1");
drivers/input/keyboard/sh_keysc.c:	if (!pdev->dev.platform_data) {
drivers/input/keyboard/sh_keysc.c:		dev_err(&pdev->dev, "no platform data defined\n");
drivers/input/keyboard/sh_keysc.c:		dev_err(&pdev->dev, "failed to get I/O memory\n");
drivers/input/keyboard/sh_keysc.c:		dev_err(&pdev->dev, "failed to get irq\n");
drivers/input/keyboard/sh_keysc.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/input/keyboard/sh_keysc.c:	memcpy(&priv->pdata, pdev->dev.platform_data, sizeof(priv->pdata));
drivers/input/keyboard/sh_keysc.c:		dev_err(&pdev->dev, "failed to remap I/O memory\n");
drivers/input/keyboard/sh_keysc.c:		dev_err(&pdev->dev, "failed to allocate input device\n");
drivers/input/keyboard/sh_keysc.c:	input->name = pdev->name;
drivers/input/keyboard/sh_keysc.c:	input->dev.parent = &pdev->dev;
drivers/input/keyboard/sh_keysc.c:				     dev_name(&pdev->dev), pdev);
drivers/input/keyboard/sh_keysc.c:		dev_err(&pdev->dev, "failed to request IRQ\n");
drivers/input/keyboard/sh_keysc.c:		dev_err(&pdev->dev, "failed to register input device\n");
drivers/input/keyboard/sh_keysc.c:	pm_runtime_enable(&pdev->dev);
drivers/input/keyboard/sh_keysc.c:	pm_runtime_get_sync(&pdev->dev);
drivers/input/keyboard/sh_keysc.c:	device_init_wakeup(&pdev->dev, 1);
drivers/input/keyboard/sh_keysc.c:	pm_runtime_put_sync(&pdev->dev);
drivers/input/keyboard/sh_keysc.c:	pm_runtime_disable(&pdev->dev);
drivers/input/keyboard/w90p910_keypad.c:						pdev->dev.platform_data;
drivers/input/keyboard/w90p910_keypad.c:		dev_err(&pdev->dev, "no platform data defined\n");
drivers/input/keyboard/w90p910_keypad.c:		dev_err(&pdev->dev, "failed to get keypad irq\n");
drivers/input/keyboard/w90p910_keypad.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/input/keyboard/w90p910_keypad.c:		dev_err(&pdev->dev, "failed to get I/O memory\n");
drivers/input/keyboard/w90p910_keypad.c:	res = request_mem_region(res->start, resource_size(res), pdev->name);
drivers/input/keyboard/w90p910_keypad.c:		dev_err(&pdev->dev, "failed to request I/O memory\n");
drivers/input/keyboard/w90p910_keypad.c:		dev_err(&pdev->dev, "failed to remap I/O memory\n");
drivers/input/keyboard/w90p910_keypad.c:	keypad->clk = clk_get(&pdev->dev, NULL);
drivers/input/keyboard/w90p910_keypad.c:		dev_err(&pdev->dev, "failed to get keypad clock\n");
drivers/input/keyboard/w90p910_keypad.c:	mfp_set_groupi(&pdev->dev);
drivers/input/keyboard/w90p910_keypad.c:	input_dev->name = pdev->name;
drivers/input/keyboard/w90p910_keypad.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/keyboard/w90p910_keypad.c:		dev_err(&pdev->dev, "failed to build keymap\n");
drivers/input/keyboard/w90p910_keypad.c:			    0, pdev->name, keypad);
drivers/input/keyboard/w90p910_keypad.c:		dev_err(&pdev->dev, "failed to request IRQ\n");
drivers/input/keyboard/w90p910_keypad.c:		dev_err(&pdev->dev, "failed to register input device\n");
drivers/input/keyboard/pxa930_rotary.c:	struct pxa930_rotary_platform_data *pdata = pdev->dev.platform_data;
drivers/input/keyboard/pxa930_rotary.c:		dev_err(&pdev->dev, "no irq for rotary controller\n");
drivers/input/keyboard/pxa930_rotary.c:		dev_err(&pdev->dev, "no I/O memory defined\n");
drivers/input/keyboard/pxa930_rotary.c:		dev_err(&pdev->dev, "no platform data defined\n");
drivers/input/keyboard/pxa930_rotary.c:		dev_err(&pdev->dev, "failed to remap IO memory\n");
drivers/input/keyboard/pxa930_rotary.c:		dev_err(&pdev->dev, "failed to allocate input device\n");
drivers/input/keyboard/pxa930_rotary.c:	input_dev->name = pdev->name;
drivers/input/keyboard/pxa930_rotary.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/keyboard/pxa930_rotary.c:		dev_err(&pdev->dev, "failed to request IRQ\n");
drivers/input/keyboard/pxa930_rotary.c:		dev_err(&pdev->dev, "failed to register input device\n");
drivers/input/keyboard/opencores-kbd.c:		dev_err(&pdev->dev, "missing board memory resource\n");
drivers/input/keyboard/opencores-kbd.c:		dev_err(&pdev->dev, "missing board IRQ resource\n");
drivers/input/keyboard/opencores-kbd.c:		dev_err(&pdev->dev, "failed to allocate device structures\n");
drivers/input/keyboard/opencores-kbd.c:	res = request_mem_region(res->start, resource_size(res), pdev->name);
drivers/input/keyboard/opencores-kbd.c:		dev_err(&pdev->dev, "failed to request I/O memory\n");
drivers/input/keyboard/opencores-kbd.c:		dev_err(&pdev->dev, "failed to remap I/O memory\n");
drivers/input/keyboard/opencores-kbd.c:	input->name = pdev->name;
drivers/input/keyboard/opencores-kbd.c:	input->dev.parent = &pdev->dev;
drivers/input/keyboard/opencores-kbd.c:			    IRQF_TRIGGER_RISING, pdev->name, opencores_kbd);
drivers/input/keyboard/opencores-kbd.c:		dev_err(&pdev->dev, "unable to claim irq %d\n", irq);
drivers/input/keyboard/opencores-kbd.c:		dev_err(&pdev->dev, "unable to register input device\n");
drivers/input/keyboard/nomadik-ske-keypad.c:	const struct ske_keypad_platform_data *plat = pdev->dev.platform_data;
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "invalid keypad platform data\n");
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "failed to get keypad irq\n");
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "missing platform resources\n");
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "failed to allocate keypad memory\n");
drivers/input/keyboard/nomadik-ske-keypad.c:	if (!request_mem_region(res->start, resource_size(res), pdev->name)) {
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "failed to request I/O memory\n");
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "failed to remap I/O memory\n");
drivers/input/keyboard/nomadik-ske-keypad.c:	keypad->pclk = clk_get(&pdev->dev, "apb_pclk");
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "failed to get pclk\n");
drivers/input/keyboard/nomadik-ske-keypad.c:	keypad->clk = clk_get(&pdev->dev, NULL);
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "failed to get clk\n");
drivers/input/keyboard/nomadik-ske-keypad.c:	input->dev.parent = &pdev->dev;
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "Failed to build keymap\n");
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "Failed to prepare/enable pclk\n");
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "Failed to prepare/enable clk\n");
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "unable to init keypad hardware\n");
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev, "allocate irq %d failed\n", keypad->irq);
drivers/input/keyboard/nomadik-ske-keypad.c:		dev_err(&pdev->dev,
drivers/input/keyboard/nomadik-ske-keypad.c:		device_init_wakeup(&pdev->dev, true);
drivers/input/keyboard/omap-keypad.c:	struct omap_kp_platform_data *pdata =  pdev->dev.platform_data;
drivers/input/keyboard/omap-keypad.c:	ret = device_create_file(&pdev->dev, &dev_attr_enable);
drivers/input/keyboard/omap-keypad.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/keyboard/omap-keypad.c:	device_remove_file(&pdev->dev, &dev_attr_enable);
drivers/input/keyboard/goldfish_events.c:	addr = devm_ioremap(&pdev->dev, res->start, 4096);
drivers/input/keyboard/goldfish_events.c:	edev = devm_kzalloc(&pdev->dev,
drivers/input/keyboard/goldfish_events.c:	input_dev = devm_input_allocate_device(&pdev->dev);
drivers/input/keyboard/goldfish_events.c:	error = devm_request_irq(&pdev->dev, edev->irq, events_interrupt, 0,
drivers/input/keyboard/gpio_keys.c:	struct device *dev = &pdev->dev;
drivers/input/keyboard/gpio_keys.c:	struct device *dev = &pdev->dev;
drivers/input/keyboard/gpio_keys.c:	input->name = pdata->name ? : pdev->name;
drivers/input/keyboard/gpio_keys.c:	input->dev.parent = &pdev->dev;
drivers/input/keyboard/gpio_keys.c:	error = sysfs_create_group(&pdev->dev.kobj, &gpio_keys_attr_group);
drivers/input/keyboard/gpio_keys.c:	device_init_wakeup(&pdev->dev, wakeup);
drivers/input/keyboard/gpio_keys.c:	sysfs_remove_group(&pdev->dev.kobj, &gpio_keys_attr_group);
drivers/input/keyboard/gpio_keys.c:	if (!dev_get_platdata(&pdev->dev))
drivers/input/keyboard/gpio_keys.c:	sysfs_remove_group(&pdev->dev.kobj, &gpio_keys_attr_group);
drivers/input/keyboard/gpio_keys.c:	device_init_wakeup(&pdev->dev, 0);
drivers/input/keyboard/gpio_keys.c:	if (!dev_get_platdata(&pdev->dev))
drivers/input/keyboard/bf54x-keys.c:	struct bfin_kpad_platform_data *pdata = pdev->dev.platform_data;
drivers/input/keyboard/bf54x-keys.c:		dev_err(&pdev->dev, "no rows, cols or keymap from pdata\n");
drivers/input/keyboard/bf54x-keys.c:		dev_err(&pdev->dev, "invalid keymapsize\n");
drivers/input/keyboard/bf54x-keys.c:		dev_warn(&pdev->dev,
drivers/input/keyboard/bf54x-keys.c:		dev_err(&pdev->dev, "requesting peripherals failed\n");
drivers/input/keyboard/bf54x-keys.c:		dev_err(&pdev->dev, "requesting peripherals failed\n");
drivers/input/keyboard/bf54x-keys.c:		dev_err(&pdev->dev, "unable to claim irq %d\n",
drivers/input/keyboard/bf54x-keys.c:	input->name = pdev->name;
drivers/input/keyboard/bf54x-keys.c:	input->dev.parent = &pdev->dev;
drivers/input/keyboard/bf54x-keys.c:		dev_err(&pdev->dev, "unable to register input device\n");
drivers/input/keyboard/bf54x-keys.c:	device_init_wakeup(&pdev->dev, 1);
drivers/input/keyboard/bf54x-keys.c:	struct bfin_kpad_platform_data *pdata = pdev->dev.platform_data;
drivers/input/keyboard/bf54x-keys.c:	if (device_may_wakeup(&pdev->dev))
drivers/input/keyboard/bf54x-keys.c:	if (device_may_wakeup(&pdev->dev))
drivers/input/keyboard/pmic8xxx-keypad.c:					dev_get_platdata(&pdev->dev);
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "invalid platform data\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "invalid keypad scan time supplied\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "invalid keypad row hold time supplied\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "invalid debounce time supplied\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "no keymap data supplied\n");
drivers/input/keyboard/pmic8xxx-keypad.c:	kp->dev		= &pdev->dev;
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "unable to allocate input device\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "unable to get keypad sense irq\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "unable to get keypad stuck irq\n");
drivers/input/keyboard/pmic8xxx-keypad.c:	kp->input->dev.parent	= &pdev->dev;
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "failed to build keymap\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "unable to initialize keypad controller\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "unable to configure keypad sense lines\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "unable to configure keypad drive lines\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "failed to request keypad sense irq\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "failed to request keypad stuck irq\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "failed to read KEYP_CTRL register\n");
drivers/input/keyboard/pmic8xxx-keypad.c:		dev_err(&pdev->dev, "unable to register keypad input device\n");
drivers/input/keyboard/pmic8xxx-keypad.c:	device_init_wakeup(&pdev->dev, pdata->wakeup);
drivers/input/keyboard/pmic8xxx-keypad.c:	device_init_wakeup(&pdev->dev, 0);
drivers/input/keyboard/tc3589x-keypad.c:	struct tc3589x *tc3589x = dev_get_drvdata(pdev->dev.parent);
drivers/input/keyboard/tc3589x-keypad.c:		dev_err(&pdev->dev, "invalid keypad platform data\n");
drivers/input/keyboard/tc3589x-keypad.c:		dev_err(&pdev->dev, "failed to allocate keypad memory\n");
drivers/input/keyboard/tc3589x-keypad.c:	input->name = pdev->name;
drivers/input/keyboard/tc3589x-keypad.c:	input->dev.parent = &pdev->dev;
drivers/input/keyboard/tc3589x-keypad.c:		dev_err(&pdev->dev, "Failed to build keymap\n");
drivers/input/keyboard/tc3589x-keypad.c:		dev_err(&pdev->dev,
drivers/input/keyboard/tc3589x-keypad.c:		dev_err(&pdev->dev, "Could not register input device\n");
drivers/input/keyboard/tc3589x-keypad.c:	device_init_wakeup(&pdev->dev, plat->enable_wakeup);
drivers/input/keyboard/tc3589x-keypad.c:	device_set_wakeup_capable(&pdev->dev, plat->enable_wakeup);
drivers/input/keyboard/tc3589x-keypad.c:	if (!device_may_wakeup(&pdev->dev))
drivers/input/keyboard/tc3589x-keypad.c:	if (!device_may_wakeup(&pdev->dev))
drivers/input/keyboard/stmpe-keypad.c:	struct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);
drivers/input/keyboard/stmpe-keypad.c:		plat = stmpe_keypad_of_probe(&pdev->dev);
drivers/input/keyboard/stmpe-keypad.c:	keypad = devm_kzalloc(&pdev->dev, sizeof(struct stmpe_keypad),
drivers/input/keyboard/stmpe-keypad.c:	input = devm_input_allocate_device(&pdev->dev);
drivers/input/keyboard/stmpe-keypad.c:	input->dev.parent = &pdev->dev;
drivers/input/keyboard/stmpe-keypad.c:	error = devm_request_threaded_irq(&pdev->dev, irq,
drivers/input/keyboard/stmpe-keypad.c:		dev_err(&pdev->dev, "unable to get irq: %d\n", error);
drivers/input/keyboard/stmpe-keypad.c:		dev_err(&pdev->dev,
drivers/input/keyboard/davinci_keyscan.c:	struct device *dev = &pdev->dev;
drivers/input/keyboard/davinci_keyscan.c:	struct davinci_ks_platform_data *pdata = pdev->dev.platform_data;
drivers/input/keyboard/davinci_keyscan.c:				 pdev->name);
drivers/input/keyboard/davinci_keyscan.c:	key_dev->dev.parent = &pdev->dev;
drivers/input/keyboard/davinci_keyscan.c:			  0, pdev->name, davinci_ks);
drivers/input/keyboard/imx_keypad.c:	const struct matrix_keymap_data *keymap_data = pdev->dev.platform_data;
drivers/input/keyboard/imx_keypad.c:	if (!keymap_data && !pdev->dev.of_node) {
drivers/input/keyboard/imx_keypad.c:		dev_err(&pdev->dev, "no keymap defined\n");
drivers/input/keyboard/imx_keypad.c:		dev_err(&pdev->dev, "no irq defined in platform data\n");
drivers/input/keyboard/imx_keypad.c:		dev_err(&pdev->dev, "no I/O memory defined in platform data\n");
drivers/input/keyboard/imx_keypad.c:	input_dev = devm_input_allocate_device(&pdev->dev);
drivers/input/keyboard/imx_keypad.c:		dev_err(&pdev->dev, "failed to allocate the input device\n");
drivers/input/keyboard/imx_keypad.c:	keypad = devm_kzalloc(&pdev->dev, sizeof(struct imx_keypad),
drivers/input/keyboard/imx_keypad.c:		dev_err(&pdev->dev, "not enough memory for driver data\n");
drivers/input/keyboard/imx_keypad.c:	keypad->mmio_base = devm_ioremap_resource(&pdev->dev, res);
drivers/input/keyboard/imx_keypad.c:	keypad->clk = devm_clk_get(&pdev->dev, NULL);
drivers/input/keyboard/imx_keypad.c:		dev_err(&pdev->dev, "failed to get keypad clock\n");
drivers/input/keyboard/imx_keypad.c:	input_dev->name = pdev->name;
drivers/input/keyboard/imx_keypad.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/keyboard/imx_keypad.c:		dev_err(&pdev->dev, "failed to build keymap\n");
drivers/input/keyboard/imx_keypad.c:	dev_dbg(&pdev->dev, "enabled rows mask: %x\n", keypad->rows_en_mask);
drivers/input/keyboard/imx_keypad.c:	dev_dbg(&pdev->dev, "enabled cols mask: %x\n", keypad->cols_en_mask);
drivers/input/keyboard/imx_keypad.c:	error = devm_request_irq(&pdev->dev, irq, imx_keypad_irq_handler, 0,
drivers/input/keyboard/imx_keypad.c:			    pdev->name, keypad);
drivers/input/keyboard/imx_keypad.c:		dev_err(&pdev->dev, "failed to request IRQ\n");
drivers/input/keyboard/imx_keypad.c:		dev_err(&pdev->dev, "failed to register input device\n");
drivers/input/keyboard/imx_keypad.c:	device_init_wakeup(&pdev->dev, 1);
drivers/input/keyboard/imx_keypad.c:	if (device_may_wakeup(&pdev->dev))
drivers/input/keyboard/imx_keypad.c:	if (device_may_wakeup(&pdev->dev))
drivers/input/keyboard/omap4-keypad.c:				dev_get_platdata(&pdev->dev);
drivers/input/keyboard/omap4-keypad.c:		dev_err(&pdev->dev, "no base address specified\n");
drivers/input/keyboard/omap4-keypad.c:		dev_err(&pdev->dev, "no keyboard irq assigned\n");
drivers/input/keyboard/omap4-keypad.c:		dev_err(&pdev->dev, "keypad_data memory allocation failed\n");
drivers/input/keyboard/omap4-keypad.c:		error = omap4_keypad_parse_dt(&pdev->dev, keypad_data);
drivers/input/keyboard/omap4-keypad.c:	res = request_mem_region(res->start, resource_size(res), pdev->name);
drivers/input/keyboard/omap4-keypad.c:		dev_err(&pdev->dev, "can't request mem region\n");
drivers/input/keyboard/omap4-keypad.c:		dev_err(&pdev->dev, "can't ioremap mem resource\n");
drivers/input/keyboard/omap4-keypad.c:	pm_runtime_enable(&pdev->dev);
drivers/input/keyboard/omap4-keypad.c:	error = pm_runtime_get_sync(&pdev->dev);
drivers/input/keyboard/omap4-keypad.c:		dev_err(&pdev->dev, "pm_runtime_get_sync() failed\n");
drivers/input/keyboard/omap4-keypad.c:		dev_err(&pdev->dev,
drivers/input/keyboard/omap4-keypad.c:	input_dev->name = pdev->name;
drivers/input/keyboard/omap4-keypad.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/keyboard/omap4-keypad.c:		dev_err(&pdev->dev, "Not enough memory for keymap\n");
drivers/input/keyboard/omap4-keypad.c:		dev_err(&pdev->dev, "failed to build keymap\n");
drivers/input/keyboard/omap4-keypad.c:		dev_err(&pdev->dev, "failed to register interrupt\n");
drivers/input/keyboard/omap4-keypad.c:	pm_runtime_put_sync(&pdev->dev);
drivers/input/keyboard/omap4-keypad.c:		dev_err(&pdev->dev, "failed to register input device\n");
drivers/input/keyboard/omap4-keypad.c:	pm_runtime_disable(&pdev->dev);
drivers/input/keyboard/omap4-keypad.c:	pm_runtime_put_sync(&pdev->dev);
drivers/input/keyboard/omap4-keypad.c:	pm_runtime_disable(&pdev->dev);
drivers/input/keyboard/amikbd.c:		dev_err(&pdev->dev, "Not enough memory for input device\n");
drivers/input/keyboard/amikbd.c:	dev->name = pdev->name;
drivers/input/keyboard/amikbd.c:	dev->dev.parent = &pdev->dev;
drivers/input/keyboard/cros_ec_keyb.c:	struct cros_ec_device *ec = dev_get_drvdata(pdev->dev.parent);
drivers/input/keyboard/cros_ec_keyb.c:	np = pdev->dev.of_node;
drivers/input/keyboard/cros_ec_keyb.c:	ckdev = devm_kzalloc(&pdev->dev, sizeof(*ckdev), GFP_KERNEL);
drivers/input/keyboard/cros_ec_keyb.c:	err = matrix_keypad_parse_of_params(&pdev->dev, &ckdev->rows,
drivers/input/keyboard/cros_ec_keyb.c:	idev = devm_input_allocate_device(&pdev->dev);
drivers/input/keyboard/cros_ec_keyb.c:	dev_set_drvdata(&pdev->dev, ckdev);
drivers/input/keyboard/cros_ec_keyb.c:	idev->dev.parent = &pdev->dev;
drivers/input/serio/q40kbd.c:	port->dev.parent = &pdev->dev;
drivers/input/serio/q40kbd.c:		dev_err(&pdev->dev, "Can't get irq %d.\n", Q40_IRQ_KEYBOARD);
drivers/input/serio/altera_ps2.c:	strlcpy(serio->name, dev_name(&pdev->dev), sizeof(serio->name));
drivers/input/serio/altera_ps2.c:	strlcpy(serio->phys, dev_name(&pdev->dev), sizeof(serio->phys));
drivers/input/serio/altera_ps2.c:	serio->dev.parent	= &pdev->dev;
drivers/input/serio/altera_ps2.c:				resource_size(ps2if->iomem_res), pdev->name)) {
drivers/input/serio/altera_ps2.c:	error = request_irq(ps2if->irq, altera_ps2_rxint, 0, pdev->name, ps2if);
drivers/input/serio/altera_ps2.c:		dev_err(&pdev->dev, "could not allocate IRQ %d: %d\n",
drivers/input/serio/altera_ps2.c:	dev_info(&pdev->dev, "base %p, irq %d\n", ps2if->base, ps2if->irq);
drivers/input/serio/arc_ps2.c:	dev_dbg(&pdev->dev, "port%d is allocated (data = 0x%p, status = 0x%p)\n",
drivers/input/serio/arc_ps2.c:		dev_err(&pdev->dev, "no IO memory defined\n");
drivers/input/serio/arc_ps2.c:		dev_err(&pdev->dev, "no IRQ defined\n");
drivers/input/serio/arc_ps2.c:	arc_ps2 = devm_kzalloc(&pdev->dev, sizeof(struct arc_ps2_data),
drivers/input/serio/arc_ps2.c:		dev_err(&pdev->dev, "out of memory\n");
drivers/input/serio/arc_ps2.c:	arc_ps2->addr = devm_ioremap_resource(&pdev->dev, res);
drivers/input/serio/arc_ps2.c:	dev_info(&pdev->dev, "irq = %d, address = 0x%p, ports = %i\n",
drivers/input/serio/arc_ps2.c:		dev_err(&pdev->dev, "device id does not match\n");
drivers/input/serio/arc_ps2.c:	error = devm_request_irq(&pdev->dev, irq, arc_ps2_interrupt,
drivers/input/serio/arc_ps2.c:		dev_err(&pdev->dev, "Could not allocate IRQ\n");
drivers/input/serio/arc_ps2.c:	dev_dbg(&pdev->dev, "interrupt count = %i\n", arc_ps2->total_int);
drivers/input/serio/arc_ps2.c:	dev_dbg(&pdev->dev, "frame error count = %i\n", arc_ps2->frame_error);
drivers/input/serio/arc_ps2.c:	dev_dbg(&pdev->dev, "buffer overflow count = %i\n",
drivers/input/serio/at32psif.c:			dev_err(&psif->pdev->dev, "overrun read error\n");
drivers/input/serio/at32psif.c:		dev_dbg(&psif->pdev->dev, "timeout writing to THR\n");
drivers/input/serio/at32psif.c:		dev_dbg(&psif->pdev->dev, "pclk too fast, "
drivers/input/serio/at32psif.c:		dev_dbg(&pdev->dev, "out of memory\n");
drivers/input/serio/at32psif.c:		dev_dbg(&pdev->dev, "out of memory\n");
drivers/input/serio/at32psif.c:		dev_dbg(&pdev->dev, "no mmio resources defined\n");
drivers/input/serio/at32psif.c:		dev_dbg(&pdev->dev, "could not map I/O memory\n");
drivers/input/serio/at32psif.c:	pclk = clk_get(&pdev->dev, "pclk");
drivers/input/serio/at32psif.c:		dev_dbg(&pdev->dev, "could not get peripheral clock\n");
drivers/input/serio/at32psif.c:		dev_dbg(&pdev->dev, "could not enable pclk\n");
drivers/input/serio/at32psif.c:		dev_dbg(&pdev->dev, "could not get irq\n");
drivers/input/serio/at32psif.c:		dev_dbg(&pdev->dev, "could not request irq %d\n", irq);
drivers/input/serio/at32psif.c:	snprintf(io->name, sizeof(io->name), "AVR32 PS/2 port%d", pdev->id);
drivers/input/serio/at32psif.c:	snprintf(io->phys, sizeof(io->phys), "at32psif/serio%d", pdev->id);
drivers/input/serio/at32psif.c:	io->dev.parent	= &pdev->dev;
drivers/input/serio/at32psif.c:	dev_info(&pdev->dev, "Atmel AVR32 PSIF PS/2 driver on 0x%08x irq %d\n",
drivers/input/gameport/emu10k1-gp.c:	port->dev.parent = &pdev->dev;
drivers/input/touchscreen/88pm860x-ts.c:	struct device_node *np = pdev->dev.parent->of_node;
drivers/input/touchscreen/88pm860x-ts.c:		dev_err(&pdev->dev, "Can't find touch node\n");
drivers/input/touchscreen/88pm860x-ts.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/input/touchscreen/88pm860x-ts.c:	struct pm860x_touch_pdata *pdata = pdev->dev.platform_data;
drivers/input/touchscreen/88pm860x-ts.c:		dev_err(&pdev->dev, "No IRQ resource!\n");
drivers/input/touchscreen/88pm860x-ts.c:			dev_err(&pdev->dev, "failed to get platform data\n");
drivers/input/touchscreen/88pm860x-ts.c:	dev_set_drvdata(&pdev->dev, touch);
drivers/input/touchscreen/88pm860x-ts.c:		dev_err(&pdev->dev, "Failed to allocate input device!\n");
drivers/input/touchscreen/88pm860x-ts.c:	touch->idev->dev.parent = &pdev->dev;
drivers/input/touchscreen/da9034-ts.c:	struct da9034_touch_pdata *pdata = pdev->dev.platform_data;
drivers/input/touchscreen/da9034-ts.c:		dev_err(&pdev->dev, "failed to allocate driver data\n");
drivers/input/touchscreen/da9034-ts.c:	touch->da9034_dev = pdev->dev.parent;
drivers/input/touchscreen/da9034-ts.c:		dev_err(&pdev->dev, "failed to allocate input device\n");
drivers/input/touchscreen/da9034-ts.c:	input_dev->name		= pdev->name;
drivers/input/touchscreen/da9034-ts.c:	input_dev->dev.parent	= &pdev->dev;
drivers/input/touchscreen/pcap_ts.c:	pcap_ts->pcap = dev_get_drvdata(pdev->dev.parent);
drivers/input/touchscreen/pcap_ts.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/touchscreen/stmpe-ts.c:	struct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);
drivers/input/touchscreen/stmpe-ts.c:	struct device_node *np = pdev->dev.of_node;
drivers/input/touchscreen/stmpe-ts.c:	ts = devm_kzalloc(&pdev->dev, sizeof(*ts), GFP_KERNEL);
drivers/input/touchscreen/stmpe-ts.c:	idev = devm_input_allocate_device(&pdev->dev);
drivers/input/touchscreen/stmpe-ts.c:	ts->dev = &pdev->dev;
drivers/input/touchscreen/stmpe-ts.c:	error = devm_request_threaded_irq(&pdev->dev, ts_irq,
drivers/input/touchscreen/stmpe-ts.c:		dev_err(&pdev->dev, "Failed to request IRQ %d\n", ts_irq);
drivers/input/touchscreen/stmpe-ts.c:		dev_err(&pdev->dev, "Could not register input device\n");
drivers/input/touchscreen/da9052_tsi.c:	da9052 = dev_get_drvdata(pdev->dev.parent);
drivers/input/touchscreen/da9052_tsi.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/touchscreen/atmel-wm97xx.c:		dev_dbg(&pdev->dev, "out of memory\n");
drivers/input/touchscreen/atmel-wm97xx.c:		dev_dbg(&pdev->dev, "could not request ac97c irq\n");
drivers/input/touchscreen/s3c2410_ts.c:	struct device *dev = &pdev->dev;
drivers/input/touchscreen/s3c2410_ts.c:	info = pdev->dev.platform_data;
drivers/input/touchscreen/s3c2410_ts.c:	struct s3c2410_ts_mach_info *info = pdev->dev.platform_data;
drivers/input/touchscreen/ucb1400_ts.c:			dev_err(&pdev->dev, "timed out in IRQ probe\n");
drivers/input/touchscreen/ucb1400_ts.c:	struct ucb1400_ts *ucb = pdev->dev.platform_data;
drivers/input/touchscreen/ucb1400_ts.c:			dev_err(&pdev->dev, "IRQ probe failed\n");
drivers/input/touchscreen/ucb1400_ts.c:	dev_dbg(&pdev->dev, "found IRQ %d\n", ucb->irq);
drivers/input/touchscreen/ucb1400_ts.c:	ucb->ts_idev->dev.parent	= &pdev->dev;
drivers/input/touchscreen/ucb1400_ts.c:	dev_dbg(&pdev->dev, "x/y = %d/%d\n", x_res, y_res);
drivers/input/touchscreen/ucb1400_ts.c:		dev_err(&pdev->dev,
drivers/input/touchscreen/ucb1400_ts.c:	struct ucb1400_ts *ucb = pdev->dev.platform_data;
drivers/input/touchscreen/jornada720_ts.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/touchscreen/atmel_tsadcc.c:	struct at91_tsadcc_data *pdata = pdev->dev.platform_data;
drivers/input/touchscreen/atmel_tsadcc.c:		dev_err(&pdev->dev, "no mmio resource defined.\n");
drivers/input/touchscreen/atmel_tsadcc.c:		dev_err(&pdev->dev, "failed to allocate memory.\n");
drivers/input/touchscreen/atmel_tsadcc.c:		dev_err(&pdev->dev, "failed to allocate input device.\n");
drivers/input/touchscreen/atmel_tsadcc.c:		dev_err(&pdev->dev, "no irq ID is designated.\n");
drivers/input/touchscreen/atmel_tsadcc.c:		dev_err(&pdev->dev, "resources is unavailable.\n");
drivers/input/touchscreen/atmel_tsadcc.c:		dev_err(&pdev->dev, "failed to map registers.\n");
drivers/input/touchscreen/atmel_tsadcc.c:			pdev->dev.driver->name, ts_dev);
drivers/input/touchscreen/atmel_tsadcc.c:		dev_err(&pdev->dev, "failed to allocate irq.\n");
drivers/input/touchscreen/atmel_tsadcc.c:	ts_dev->clk = clk_get(&pdev->dev, "tsc_clk");
drivers/input/touchscreen/atmel_tsadcc.c:		dev_err(&pdev->dev, "failed to get ts_clk\n");
drivers/input/touchscreen/atmel_tsadcc.c:		 "%s/input0", dev_name(&pdev->dev));
drivers/input/touchscreen/atmel_tsadcc.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/touchscreen/atmel_tsadcc.c:	dev_info(&pdev->dev, "Master clock is set at: %d Hz\n", prsc);
drivers/input/touchscreen/atmel_tsadcc.c:	dev_info(&pdev->dev, "Prescaler is set at: %d\n", prsc);
drivers/input/touchscreen/atmel_tsadcc.c:	struct atmel_tsadcc *ts_dev = dev_get_drvdata(&pdev->dev);
drivers/input/touchscreen/ti_am335x_tsc.c:	struct ti_tscadc_dev *tscadc_dev = pdev->dev.platform_data;
drivers/input/touchscreen/ti_am335x_tsc.c:		dev_err(&pdev->dev, "Could not find platform data\n");
drivers/input/touchscreen/ti_am335x_tsc.c:		dev_err(&pdev->dev, "failed to allocate memory.\n");
drivers/input/touchscreen/ti_am335x_tsc.c:			  0, pdev->dev.driver->name, ts_dev);
drivers/input/touchscreen/ti_am335x_tsc.c:		dev_err(&pdev->dev, "failed to allocate irq.\n");
drivers/input/touchscreen/ti_am335x_tsc.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/touchscreen/ti_am335x_tsc.c:	struct ti_tscadc_dev *tscadc_dev = pdev->dev.platform_data;
drivers/input/touchscreen/tnetv107x-ts.c:	struct device *dev = &pdev->dev;
drivers/input/touchscreen/tnetv107x-ts.c:				pdev->name)) {
drivers/input/touchscreen/tnetv107x-ts.c:	ts->input_dev->name       = pdev->name;
drivers/input/touchscreen/tnetv107x-ts.c:	ts->input_dev->dev.parent = &pdev->dev;
drivers/input/touchscreen/mc13783_ts.c:	priv->mc13xxx = dev_get_drvdata(pdev->dev.parent);
drivers/input/touchscreen/mc13783_ts.c:	priv->touch = dev_get_platdata(&pdev->dev);
drivers/input/touchscreen/mc13783_ts.c:		dev_err(&pdev->dev, "missing platform data\n");
drivers/input/touchscreen/mc13783_ts.c:	idev->dev.parent = &pdev->dev;
drivers/input/touchscreen/mc13783_ts.c:		dev_err(&pdev->dev,
drivers/input/touchscreen/lpc32xx_ts.c:		dev_err(&pdev->dev, "Can't get memory resource\n");
drivers/input/touchscreen/lpc32xx_ts.c:		dev_err(&pdev->dev, "Can't get interrupt resource\n");
drivers/input/touchscreen/lpc32xx_ts.c:		dev_err(&pdev->dev, "failed allocating memory\n");
drivers/input/touchscreen/lpc32xx_ts.c:	if (!request_mem_region(res->start, size, pdev->name)) {
drivers/input/touchscreen/lpc32xx_ts.c:		dev_err(&pdev->dev, "TSC registers are not free\n");
drivers/input/touchscreen/lpc32xx_ts.c:		dev_err(&pdev->dev, "Can't map memory\n");
drivers/input/touchscreen/lpc32xx_ts.c:	tsc->clk = clk_get(&pdev->dev, NULL);
drivers/input/touchscreen/lpc32xx_ts.c:		dev_err(&pdev->dev, "failed getting clock\n");
drivers/input/touchscreen/lpc32xx_ts.c:	input->dev.parent = &pdev->dev;
drivers/input/touchscreen/lpc32xx_ts.c:			    0, pdev->name, tsc);
drivers/input/touchscreen/lpc32xx_ts.c:		dev_err(&pdev->dev, "failed requesting interrupt\n");
drivers/input/touchscreen/lpc32xx_ts.c:		dev_err(&pdev->dev, "failed registering input device\n");
drivers/input/touchscreen/lpc32xx_ts.c:	device_init_wakeup(&pdev->dev, 1);
drivers/input/touchscreen/lpc32xx_ts.c:	device_init_wakeup(&pdev->dev, 0);
drivers/input/touchscreen/tps6507x-ts.c:	struct tps6507x_dev *tps6507x_dev = dev_get_drvdata(pdev->dev.parent);
drivers/input/touchscreen/wm831x-ts.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/input/touchscreen/wm831x-ts.c:	struct wm831x_pdata *core_pdata = dev_get_platdata(pdev->dev.parent);
drivers/input/touchscreen/wm831x-ts.c:	wm831x_ts = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_ts),
drivers/input/touchscreen/wm831x-ts.c:	input_dev = devm_input_allocate_device(&pdev->dev);
drivers/input/touchscreen/wm831x-ts.c:			dev_err(&pdev->dev, "Unsupported ISEL setting: %d\n",
drivers/input/touchscreen/wm831x-ts.c:		dev_err(&pdev->dev, "Failed to request data IRQ %d: %d\n",
drivers/input/touchscreen/wm831x-ts.c:		dev_err(&pdev->dev, "Failed to request pen down IRQ %d: %d\n",
drivers/input/touchscreen/wm831x-ts.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/touchscreen/intel-mid-touch.c:		dev_err(&pdev->dev, "no interrupt assigned\n");
drivers/input/touchscreen/intel-mid-touch.c:		dev_err(&pdev->dev, "unable to allocate memory\n");
drivers/input/touchscreen/intel-mid-touch.c:	tsdev->dev = &pdev->dev;
drivers/input/touchscreen/intel-mid-touch.c:		dev_err(&pdev->dev, "ADC initialization failed\n");
drivers/input/touchscreen/w90p910_ts.c:				pdev->name)) {
drivers/input/touchscreen/w90p910_ts.c:	w90p910_ts->clk = clk_get(&pdev->dev, NULL);
drivers/input/touchscreen/w90p910_ts.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/misc/cobalt_btns.c:	input->dev.parent = &pdev->dev;
drivers/input/misc/cobalt_btns.c:	dev_set_drvdata(&pdev->dev, bdev);
drivers/input/misc/cobalt_btns.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/input/misc/cobalt_btns.c:	struct device *dev = &pdev->dev;
drivers/input/misc/pcap_keys.c:	pcap_keys->pcap = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/pcap_keys.c:	input_dev->name = pdev->name;
drivers/input/misc/pcap_keys.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/misc/wm831x-on.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/wm831x-on.c:	wm831x_on = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_on),
drivers/input/misc/wm831x-on.c:		dev_err(&pdev->dev, "Can't allocate data\n");
drivers/input/misc/wm831x-on.c:	wm831x_on->dev = devm_input_allocate_device(&pdev->dev);
drivers/input/misc/wm831x-on.c:		dev_err(&pdev->dev, "Can't allocate input dev\n");
drivers/input/misc/wm831x-on.c:	wm831x_on->dev->dev.parent = &pdev->dev;
drivers/input/misc/wm831x-on.c:		dev_err(&pdev->dev, "Unable to request IRQ: %d\n", ret);
drivers/input/misc/wm831x-on.c:		dev_dbg(&pdev->dev, "Can't register input device: %d\n", ret);
drivers/input/misc/mc13783-pwrbutton.c:	struct mc13xxx *mc13783 = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/mc13783-pwrbutton.c:	pdata = dev_get_platdata(&pdev->dev);
drivers/input/misc/mc13783-pwrbutton.c:		dev_err(&pdev->dev, "missing platform data\n");
drivers/input/misc/mc13783-pwrbutton.c:		dev_dbg(&pdev->dev, "Can't allocate power button\n");
drivers/input/misc/mc13783-pwrbutton.c:		dev_dbg(&pdev->dev, "Can't allocate power button\n");
drivers/input/misc/mc13783-pwrbutton.c:			dev_dbg(&pdev->dev, "Can't request irq\n");
drivers/input/misc/mc13783-pwrbutton.c:			dev_dbg(&pdev->dev, "Can't request irq\n");
drivers/input/misc/mc13783-pwrbutton.c:			dev_dbg(&pdev->dev, "Can't request irq: %d\n", err);
drivers/input/misc/mc13783-pwrbutton.c:	pwr->dev.parent = &pdev->dev;
drivers/input/misc/mc13783-pwrbutton.c:		dev_dbg(&pdev->dev, "Can't register power button: %d\n", err);
drivers/input/misc/mc13783-pwrbutton.c:	pdata = dev_get_platdata(&pdev->dev);
drivers/input/misc/gpio_event.c:	event_info = pdev->dev.platform_data;
drivers/input/misc/twl4030-vibra.c:	struct twl4030_vibra_data *pdata = pdev->dev.platform_data;
drivers/input/misc/twl4030-vibra.c:	struct device_node *twl4030_core_node = pdev->dev.parent->of_node;
drivers/input/misc/twl4030-vibra.c:		dev_dbg(&pdev->dev, "platform_data not available\n");
drivers/input/misc/twl4030-vibra.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
drivers/input/misc/twl4030-vibra.c:	info->dev = &pdev->dev;
drivers/input/misc/twl4030-vibra.c:	info->input_dev = devm_input_allocate_device(&pdev->dev);
drivers/input/misc/twl4030-vibra.c:		dev_err(&pdev->dev, "couldn't allocate input device\n");
drivers/input/misc/twl4030-vibra.c:	info->input_dev->dev.parent = pdev->dev.parent;
drivers/input/misc/twl4030-vibra.c:		dev_dbg(&pdev->dev, "couldn't register vibrator to FF\n");
drivers/input/misc/twl4030-vibra.c:		dev_dbg(&pdev->dev, "couldn't register input device\n");
drivers/input/misc/pwm-beeper.c:	unsigned long pwm_id = (unsigned long)pdev->dev.platform_data;
drivers/input/misc/pwm-beeper.c:	beeper->pwm = pwm_get(&pdev->dev, NULL);
drivers/input/misc/pwm-beeper.c:		dev_dbg(&pdev->dev, "unable to request PWM, trying legacy API\n");
drivers/input/misc/pwm-beeper.c:		dev_err(&pdev->dev, "Failed to request pwm device: %d\n", error);
drivers/input/misc/pwm-beeper.c:		dev_err(&pdev->dev, "Failed to allocate input device\n");
drivers/input/misc/pwm-beeper.c:	beeper->input->dev.parent = &pdev->dev;
drivers/input/misc/pwm-beeper.c:		dev_err(&pdev->dev, "Failed to register input device: %d\n", error);
drivers/input/misc/max8997_haptic.c:	struct max8997_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/max8997_haptic.c:		dev_err(&pdev->dev, "no haptic platform data\n");
drivers/input/misc/max8997_haptic.c:		dev_err(&pdev->dev, "unable to allocate memory\n");
drivers/input/misc/max8997_haptic.c:	chip->dev = &pdev->dev;
drivers/input/misc/max8997_haptic.c:			dev_err(&pdev->dev,
drivers/input/misc/max8997_haptic.c:		dev_err(&pdev->dev,
drivers/input/misc/max8997_haptic.c:	chip->regulator = regulator_get(&pdev->dev, "inmotor");
drivers/input/misc/max8997_haptic.c:		dev_err(&pdev->dev,
drivers/input/misc/max8997_haptic.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/misc/max8997_haptic.c:		dev_err(&pdev->dev,
drivers/input/misc/max8997_haptic.c:		dev_err(&pdev->dev,
drivers/input/misc/pcf50633-input.c:	input->pcf = dev_to_pcf50633(pdev->dev.parent);
drivers/input/misc/ab8500-ponkey.c:	struct ab8500 *ab8500 = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/ab8500-ponkey.c:		dev_err(&pdev->dev, "No IRQ for ONKEY_DBF, error=%d\n", irq_dbf);
drivers/input/misc/ab8500-ponkey.c:		dev_err(&pdev->dev, "No IRQ for ONKEY_DBR, error=%d\n", irq_dbr);
drivers/input/misc/ab8500-ponkey.c:	input->dev.parent = &pdev->dev;
drivers/input/misc/pm8xxx-vibrator.c:		dev_err(&pdev->dev, "couldn't allocate memory\n");
drivers/input/misc/pm8xxx-vibrator.c:	vib->dev = &pdev->dev;
drivers/input/misc/pm8xxx-vibrator.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/misc/pm8xxx-vibrator.c:		dev_err(&pdev->dev,
drivers/input/misc/pm8xxx-vibrator.c:		dev_err(&pdev->dev, "couldn't register input device\n");
drivers/input/misc/twl6040-vibra.c:	struct twl6040_vibra_data *pdata = pdev->dev.platform_data;
drivers/input/misc/twl6040-vibra.c:	struct device *twl6040_core_dev = pdev->dev.parent;
drivers/input/misc/twl6040-vibra.c:		dev_err(&pdev->dev, "platform_data not available\n");
drivers/input/misc/twl6040-vibra.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
drivers/input/misc/twl6040-vibra.c:		dev_err(&pdev->dev, "couldn't allocate memory\n");
drivers/input/misc/twl6040-vibra.c:	info->dev = &pdev->dev;
drivers/input/misc/twl6040-vibra.c:	info->twl6040 = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/twl6040-vibra.c:	ret = devm_request_threaded_irq(&pdev->dev, info->irq, NULL,
drivers/input/misc/twl6040-vibra.c:	info->input_dev->dev.parent = pdev->dev.parent;
drivers/input/misc/gpio_tilt_polled.c:	const struct gpio_tilt_platform_data *pdata = pdev->dev.platform_data;
drivers/input/misc/gpio_tilt_polled.c:	struct device *dev = &pdev->dev;
drivers/input/misc/gpio_tilt_polled.c:	input->name = pdev->name;
drivers/input/misc/gpio_tilt_polled.c:	input->dev.parent = &pdev->dev;
drivers/input/misc/sgi_btns.c:	input->dev.parent = &pdev->dev;
drivers/input/misc/sgi_btns.c:	dev_set_drvdata(&pdev->dev, bdev);
drivers/input/misc/sgi_btns.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/input/misc/sgi_btns.c:	struct device *dev = &pdev->dev;
drivers/input/misc/retu-pwrbutton.c:	struct retu_dev *rdev = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/retu-pwrbutton.c:	idev = devm_input_allocate_device(&pdev->dev);
drivers/input/misc/retu-pwrbutton.c:	idev->dev.parent = &pdev->dev;
drivers/input/misc/retu-pwrbutton.c:	error = devm_request_threaded_irq(&pdev->dev, irq,
drivers/input/misc/88pm860x_onkey.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/88pm860x_onkey.c:		dev_err(&pdev->dev, "No IRQ resource!\n");
drivers/input/misc/88pm860x_onkey.c:	info->dev = &pdev->dev;
drivers/input/misc/88pm860x_onkey.c:	info->idev->dev.parent = &pdev->dev;
drivers/input/misc/88pm860x_onkey.c:	device_init_wakeup(&pdev->dev, 1);
drivers/input/misc/88pm860x_onkey.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/88pm860x_onkey.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/apanel.c:	struct apanel *ap = ipdev->private;
drivers/input/misc/apanel.c:	struct input_dev *idev = ipdev->input;
drivers/input/misc/apanel.c:	ipdev->poll = apanel_poll;
drivers/input/misc/apanel.c:	ipdev->poll_interval = POLL_INTERVAL_DEFAULT;
drivers/input/misc/apanel.c:	ipdev->private = ap;
drivers/input/misc/apanel.c:	idev = ipdev->input;
drivers/input/misc/rotary_encoder.c:	struct device *dev = &pdev->dev;
drivers/input/misc/rotary_encoder.c:	input->name = pdev->name;
drivers/input/misc/rotary_encoder.c:	if (!dev_get_platdata(&pdev->dev))
drivers/input/misc/rotary_encoder.c:	if (!dev_get_platdata(&pdev->dev))
drivers/input/misc/rb532_button.c:	poll_dev->input->dev.parent = &pdev->dev;
drivers/input/misc/rb532_button.c:	dev_set_drvdata(&pdev->dev, poll_dev);
drivers/input/misc/rb532_button.c:	struct input_polled_dev *poll_dev = dev_get_drvdata(&pdev->dev);
drivers/input/misc/rb532_button.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/input/misc/da9055_onkey.c:	struct da9055 *da9055 = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/da9055_onkey.c:		dev_err(&pdev->dev,
drivers/input/misc/da9055_onkey.c:	onkey = devm_kzalloc(&pdev->dev, sizeof(*onkey), GFP_KERNEL);
drivers/input/misc/da9055_onkey.c:		dev_err(&pdev->dev, "Failed to allocate memory\n");
drivers/input/misc/da9055_onkey.c:		dev_err(&pdev->dev, "Failed to allocate memory\n");
drivers/input/misc/da9055_onkey.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/misc/da9055_onkey.c:		dev_err(&pdev->dev,
drivers/input/misc/da9055_onkey.c:		dev_err(&pdev->dev, "Unable to register input device, %d\n",
drivers/input/misc/twl4030-pwrbutton.c:		dev_dbg(&pdev->dev, "Can't allocate power button\n");
drivers/input/misc/twl4030-pwrbutton.c:	pwr->dev.parent = &pdev->dev;
drivers/input/misc/twl4030-pwrbutton.c:		dev_dbg(&pdev->dev, "Can't get IRQ for pwrbutton: %d\n", err);
drivers/input/misc/twl4030-pwrbutton.c:		dev_dbg(&pdev->dev, "Can't register power button: %d\n", err);
drivers/input/misc/max8925_onkey.c:	struct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/max8925_onkey.c:		dev_err(&pdev->dev, "No IRQ resource!\n");
drivers/input/misc/max8925_onkey.c:		dev_err(&pdev->dev, "No IRQ resource!\n");
drivers/input/misc/max8925_onkey.c:	info->dev = &pdev->dev;
drivers/input/misc/max8925_onkey.c:	input->dev.parent = &pdev->dev;
drivers/input/misc/max8925_onkey.c:	device_init_wakeup(&pdev->dev, 1);
drivers/input/misc/max8925_onkey.c:	struct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/max8925_onkey.c:	struct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/max8925_onkey.c:	struct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/bfin_rotary.c:	struct bfin_rotary_platform_data *pdata = pdev->dev.platform_data;
drivers/input/misc/bfin_rotary.c:	error = peripheral_request_list(per_cnt, dev_name(&pdev->dev));
drivers/input/misc/bfin_rotary.c:		dev_err(&pdev->dev, "requesting peripherals failed\n");
drivers/input/misc/bfin_rotary.c:	input->name = pdev->name;
drivers/input/misc/bfin_rotary.c:	input->dev.parent = &pdev->dev;
drivers/input/misc/bfin_rotary.c:			    0, dev_name(&pdev->dev), pdev);
drivers/input/misc/bfin_rotary.c:		dev_err(&pdev->dev,
drivers/input/misc/bfin_rotary.c:		dev_err(&pdev->dev,
drivers/input/misc/bfin_rotary.c:	device_init_wakeup(&pdev->dev, 1);
drivers/input/misc/bfin_rotary.c:	if (device_may_wakeup(&pdev->dev))
drivers/input/misc/bfin_rotary.c:	if (device_may_wakeup(&pdev->dev))
drivers/input/misc/pmic8xxx-pwrkey.c:					dev_get_platdata(&pdev->dev);
drivers/input/misc/pmic8xxx-pwrkey.c:		dev_err(&pdev->dev, "power key platform data not supplied\n");
drivers/input/misc/pmic8xxx-pwrkey.c:		dev_err(&pdev->dev, "invalid power key trigger delay\n");
drivers/input/misc/pmic8xxx-pwrkey.c:		dev_dbg(&pdev->dev, "Can't allocate power button\n");
drivers/input/misc/pmic8xxx-pwrkey.c:	pwr->dev.parent = &pdev->dev;
drivers/input/misc/pmic8xxx-pwrkey.c:	err = pm8xxx_readb(pdev->dev.parent, PON_CNTL_1, &pon_cntl);
drivers/input/misc/pmic8xxx-pwrkey.c:		dev_err(&pdev->dev, "failed reading PON_CNTL_1 err=%d\n", err);
drivers/input/misc/pmic8xxx-pwrkey.c:	err = pm8xxx_writeb(pdev->dev.parent, PON_CNTL_1, pon_cntl);
drivers/input/misc/pmic8xxx-pwrkey.c:		dev_err(&pdev->dev, "failed writing PON_CNTL_1 err=%d\n", err);
drivers/input/misc/pmic8xxx-pwrkey.c:		dev_dbg(&pdev->dev, "Can't register power key: %d\n", err);
drivers/input/misc/pmic8xxx-pwrkey.c:		dev_dbg(&pdev->dev, "Can't get %d IRQ for pwrkey: %d\n",
drivers/input/misc/pmic8xxx-pwrkey.c:		dev_dbg(&pdev->dev, "Can't get %d IRQ for pwrkey: %d\n",
drivers/input/misc/pmic8xxx-pwrkey.c:	device_init_wakeup(&pdev->dev, pdata->wakeup);
drivers/input/misc/pmic8xxx-pwrkey.c:	device_init_wakeup(&pdev->dev, 0);
drivers/input/misc/arizona-haptics.c:	struct arizona *arizona = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/arizona-haptics.c:	haptics = devm_kzalloc(&pdev->dev, sizeof(*haptics), GFP_KERNEL);
drivers/input/misc/arizona-haptics.c:	haptics->input_dev->dev.parent = pdev->dev.parent;
drivers/input/misc/dm355evm_keys.c:	keys->dev = &pdev->dev;
drivers/input/misc/dm355evm_keys.c:	input->dev.parent = &pdev->dev;
drivers/input/misc/dm355evm_keys.c:				      dev_name(&pdev->dev), keys);
drivers/input/misc/dm355evm_keys.c:	dev_err(&pdev->dev, "can't register, err %d\n", status);
drivers/input/misc/dm355evm_keys.c: * be able to wake up the system.  When device_may_wakeup(&pdev->dev), call
drivers/input/misc/88pm80x_onkey.c:	struct pm80x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/88pm80x_onkey.c:		dev_err(&pdev->dev, "No IRQ resource!\n");
drivers/input/misc/88pm80x_onkey.c:		dev_err(&pdev->dev, "no regmap!\n");
drivers/input/misc/88pm80x_onkey.c:		dev_err(&pdev->dev, "Failed to allocate input dev\n");
drivers/input/misc/88pm80x_onkey.c:	info->idev->dev.parent = &pdev->dev;
drivers/input/misc/88pm80x_onkey.c:		dev_err(&pdev->dev, "Failed to request IRQ: #%d: %d\n",
drivers/input/misc/88pm80x_onkey.c:		dev_err(&pdev->dev, "Can't register input device: %d\n", err);
drivers/input/misc/88pm80x_onkey.c:	device_init_wakeup(&pdev->dev, 1);
drivers/input/misc/88pm80x_onkey.c:	device_init_wakeup(&pdev->dev, 0);
drivers/input/misc/da9052_onkey.c:	struct da9052 *da9052 = dev_get_drvdata(pdev->dev.parent);
drivers/input/misc/da9052_onkey.c:		dev_err(&pdev->dev, "Failed to get the driver's data\n");
drivers/input/misc/da9052_onkey.c:		dev_err(&pdev->dev, "Failed to allocate memory\n");
drivers/input/misc/da9052_onkey.c:	input_dev->dev.parent = &pdev->dev;
drivers/input/misc/da9052_onkey.c:		dev_err(&pdev->dev, "Unable to register input device, %d\n",
drivers/net/vmxnet3/vmxnet3_drv.c:			tbi->dma_addr = skb_frag_dma_map(&adapter->pdev->dev, frag,
drivers/net/vmxnet3/vmxnet3_drv.c:		err = request_irq(adapter->pdev->irq, vmxnet3_intr, 0,
drivers/net/vmxnet3/vmxnet3_drv.c:		err = request_irq(adapter->pdev->irq, vmxnet3_intr,
drivers/net/vmxnet3/vmxnet3_drv.c:		free_irq(adapter->pdev->irq, adapter->netdev);
drivers/net/vmxnet3/vmxnet3_drv.c:		free_irq(adapter->pdev->irq, adapter->netdev);
drivers/net/vmxnet3/vmxnet3_drv.c:		dev_err(&pdev->dev, "Failed to enable adapter: error %d\n", err);
drivers/net/vmxnet3/vmxnet3_drv.c:			dev_err(&pdev->dev,
drivers/net/vmxnet3/vmxnet3_drv.c:			dev_err(&pdev->dev,
drivers/net/vmxnet3/vmxnet3_drv.c:		dev_err(&pdev->dev,
drivers/net/vmxnet3/vmxnet3_drv.c:		dev_err(&pdev->dev, "Failed to map bar0\n");
drivers/net/vmxnet3/vmxnet3_drv.c:		dev_err(&pdev->dev, "Failed to map bar1\n");
drivers/net/vmxnet3/vmxnet3_drv.c:	dev_info(&adapter->pdev->dev,
drivers/net/vmxnet3/vmxnet3_drv.c:		dev_info(&adapter->pdev->dev,
drivers/net/vmxnet3/vmxnet3_drv.c:	dev_info(&pdev->dev,
drivers/net/vmxnet3/vmxnet3_drv.c:		dev_err(&pdev->dev, "Failed to allocate memory\n");
drivers/net/vmxnet3/vmxnet3_drv.c:		dev_err(&pdev->dev, "Failed to allocate memory\n");
drivers/net/vmxnet3/vmxnet3_drv.c:		dev_err(&pdev->dev,
drivers/net/vmxnet3/vmxnet3_drv.c:		dev_err(&pdev->dev,
drivers/net/vmxnet3/vmxnet3_drv.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/vmxnet3/vmxnet3_drv.c:		dev_dbg(&pdev->dev, "RSS is enabled.\n");
drivers/net/vmxnet3/vmxnet3_drv.c:		dev_err(&pdev->dev, "Failed to register adapter\n");
drivers/net/vmxnet3/vmxnet3_ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
drivers/net/wan/wanxl.c:	switch (pdev->device) {
drivers/net/wan/wanxl.c:		pci_name(pdev), plx_phy, ramsize / 1024, mem_phy, pdev->irq);
drivers/net/wan/wanxl.c:	if (request_irq(pdev->irq, wanxl_intr, IRQF_SHARED, "wanXL", card)) {
drivers/net/wan/wanxl.c:			pci_name(pdev), pdev->irq);
drivers/net/wan/wanxl.c:	card->irq = pdev->irq;
drivers/net/wan/lmc/lmc_main.c:	dev->irq = pdev->irq;
drivers/net/wan/lmc/lmc_main.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/wan/lmc/lmc_main.c:    if ((subdevice = pdev->subsystem_device) == PCI_VENDOR_ID_LMC)
drivers/net/wan/lmc/lmc_main.c:	    subdevice = pdev->subsystem_vendor;
drivers/net/wan/dscc4.c:	        (unsigned long long)pci_resource_start(pdev, 1), pdev->irq);
drivers/net/wan/dscc4.c:	rc = request_irq(pdev->irq, dscc4_irq, IRQF_SHARED, DRV_NAME, priv->root);
drivers/net/wan/dscc4.c:		pr_warn("IRQ %d busy\n", pdev->irq);
drivers/net/wan/dscc4.c:	free_irq(pdev->irq, priv->root);
drivers/net/wan/dscc4.c:	        d->irq = pdev->irq;
drivers/net/wan/dscc4.c:		SET_NETDEV_DEV(d, &pdev->dev);
drivers/net/wan/dscc4.c:	free_irq(pdev->irq, root);
drivers/net/wan/pci200syn.c:		pdev->irq, card->tx_ring_buffers, card->rx_ring_buffers);
drivers/net/wan/pci200syn.c:	if (request_irq(pdev->irq, sca_intr, IRQF_SHARED, "pci200syn", card)) {
drivers/net/wan/pci200syn.c:		pr_warn("could not allocate IRQ%d\n", pdev->irq);
drivers/net/wan/pci200syn.c:	card->irq = pdev->irq;
drivers/net/wan/sbni.c:		if( pdev->vendor != SBNI_PCI_VENDOR &&
drivers/net/wan/sbni.c:		    pdev->device != SBNI_PCI_DEVICE )
drivers/net/wan/sbni.c:		pci_irq_line = pdev->irq;
drivers/net/wan/sbni.c:			if (pdev->subsystem_device != 2)
drivers/net/wan/sbni.c:			SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/wan/ixp4xx_hss.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/wan/ixp4xx_hss.c:	port->id = pdev->id;
drivers/net/wan/ixp4xx_hss.c:	port->dev = &pdev->dev;
drivers/net/wan/ixp4xx_hss.c:	port->plat = pdev->dev.platform_data;
drivers/net/wan/pc300too.c:	if (pdev->device == PCI_DEVICE_ID_PC300_TE_1 ||
drivers/net/wan/pc300too.c:	    pdev->device == PCI_DEVICE_ID_PC300_TE_2)
drivers/net/wan/pc300too.c:	if (pdev->device == PCI_DEVICE_ID_PC300_RX_1 ||
drivers/net/wan/pc300too.c:	    pdev->device == PCI_DEVICE_ID_PC300_TE_1)
drivers/net/wan/pc300too.c:		ramsize / 1024, ramphys, pdev->irq,
drivers/net/wan/pc300too.c:	if (request_irq(pdev->irq, sca_intr, IRQF_SHARED, "pc300", card)) {
drivers/net/wan/pc300too.c:		pr_warn("could not allocate IRQ%d\n", pdev->irq);
drivers/net/wan/pc300too.c:	card->irq = pdev->irq;
drivers/net/wan/farsync.c:			if ((pdev->devfn) >> 3 == fst_excluded_list[i]) {
drivers/net/wan/farsync.c:					(pdev->devfn) >> 3);
drivers/net/wan/farsync.c:	if (request_irq(pdev->irq, fst_intr, IRQF_SHARED, FST_DEV_NAME, card)) {
drivers/net/wan/farsync.c:	card->irq = pdev->irq;
drivers/net/ntb_netdev.c:	dev_info(&pdev->dev, "%s created\n", ndev->name);
drivers/net/phy/mdio-mux-mmioreg.c:	struct device_node *np2, *np = pdev->dev.of_node;
drivers/net/phy/mdio-mux-mmioreg.c:	dev_dbg(&pdev->dev, "probing node %s\n", np->full_name);
drivers/net/phy/mdio-mux-mmioreg.c:	s = devm_kzalloc(&pdev->dev, sizeof(*s), GFP_KERNEL);
drivers/net/phy/mdio-mux-mmioreg.c:		dev_err(&pdev->dev, "could not obtain memory map for node %s\n",
drivers/net/phy/mdio-mux-mmioreg.c:		dev_err(&pdev->dev, "only 8-bit registers are supported\n");
drivers/net/phy/mdio-mux-mmioreg.c:		dev_err(&pdev->dev, "missing or invalid mux-mask property\n");
drivers/net/phy/mdio-mux-mmioreg.c:		dev_err(&pdev->dev, "only 8-bit registers are supported\n");
drivers/net/phy/mdio-mux-mmioreg.c:			dev_err(&pdev->dev, "mdio-mux child node %s is "
drivers/net/phy/mdio-mux-mmioreg.c:			dev_err(&pdev->dev, "mdio-mux child node %s has "
drivers/net/phy/mdio-mux-mmioreg.c:	ret = mdio_mux_init(&pdev->dev, mdio_mux_mmioreg_switch_fn,
drivers/net/phy/mdio-mux-mmioreg.c:		dev_err(&pdev->dev, "failed to register mdio-mux bus %s\n",
drivers/net/phy/mdio-mux-mmioreg.c:	pdev->dev.platform_data = s;
drivers/net/phy/mdio-mux-mmioreg.c:	struct mdio_mux_mmioreg_state *s = dev_get_platdata(&pdev->dev);
drivers/net/phy/mdio-octeon.c:	bus = devm_kzalloc(&pdev->dev, sizeof(*bus), GFP_KERNEL);
drivers/net/phy/mdio-octeon.c:		dev_err(&pdev->dev, "found no memory resource\n");
drivers/net/phy/mdio-octeon.c:	if (!devm_request_mem_region(&pdev->dev, bus->mdio_phys, bus->regsize,
drivers/net/phy/mdio-octeon.c:		dev_err(&pdev->dev, "request_mem_region failed\n");
drivers/net/phy/mdio-octeon.c:		(u64)devm_ioremap(&pdev->dev, bus->mdio_phys, bus->regsize);
drivers/net/phy/mdio-octeon.c:	bus->mii_bus->parent = &pdev->dev;
drivers/net/phy/mdio-octeon.c:	dev_set_drvdata(&pdev->dev, bus);
drivers/net/phy/mdio-octeon.c:	err = of_mdiobus_register(bus->mii_bus, pdev->dev.of_node);
drivers/net/phy/mdio-octeon.c:	dev_info(&pdev->dev, "Version " DRV_VERSION "\n");
drivers/net/phy/mdio-octeon.c:	bus = dev_get_drvdata(&pdev->dev);
drivers/net/phy/mdio-mux-gpio.c:	if (!pdev->dev.of_node)
drivers/net/phy/mdio-mux-gpio.c:	num_gpios = of_gpio_count(pdev->dev.of_node);
drivers/net/phy/mdio-mux-gpio.c:	s = devm_kzalloc(&pdev->dev, sizeof(*s), GFP_KERNEL);
drivers/net/phy/mdio-mux-gpio.c:		int gpio = of_get_gpio_flags(pdev->dev.of_node, n, &f);
drivers/net/phy/mdio-mux-gpio.c:	r = mdio_mux_init(&pdev->dev,
drivers/net/phy/mdio-mux-gpio.c:		pdev->dev.platform_data = s;
drivers/net/phy/mdio-mux-gpio.c:	struct mdio_mux_gpio_state *s = pdev->dev.platform_data;
drivers/net/phy/fixed.c:	fmb->mii_bus->parent = &pdev->dev;
drivers/net/phy/mdio-gpio.c:	struct device_node *np = pdev->dev.of_node;
drivers/net/phy/mdio-gpio.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/net/phy/mdio-gpio.c:	if (pdev->dev.of_node) {
drivers/net/phy/mdio-gpio.c:		bus_id = of_alias_get_id(pdev->dev.of_node, "mdio-gpio");
drivers/net/phy/mdio-gpio.c:		pdata = pdev->dev.platform_data;
drivers/net/phy/mdio-gpio.c:		bus_id = pdev->id;
drivers/net/phy/mdio-gpio.c:	new_bus = mdio_gpio_bus_init(&pdev->dev, pdata, bus_id);
drivers/net/phy/mdio-gpio.c:	if (pdev->dev.of_node)
drivers/net/phy/mdio-gpio.c:		ret = of_mdiobus_register(new_bus, pdev->dev.of_node);
drivers/net/phy/mdio-gpio.c:		mdio_gpio_bus_deinit(&pdev->dev);
drivers/net/phy/mdio-gpio.c:	mdio_gpio_bus_destroy(&pdev->dev);
drivers/net/ieee802154/fakelb.c:		err = fakelb_add_one(&pdev->dev, priv);
drivers/net/ieee802154/fakelb.c:	dev_info(&pdev->dev, "added ieee802154 hardware\n");
drivers/net/ieee802154/fakehard.c:	wpan_phy_set_dev(phy, &pdev->dev);
drivers/net/ieee802154/fakehard.c:	dev_info(&pdev->dev, "Added ieee802154 HardMAC hardware\n");
drivers/net/hippi/rrunner.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/hippi/rrunner.c:	       pdev->irq, pci_latency);
drivers/net/hippi/rrunner.c:	if (request_irq(pdev->irq, rr_interrupt, IRQF_SHARED, dev->name, dev)) {
drivers/net/hippi/rrunner.c:		       dev->name, pdev->irq);
drivers/net/hippi/rrunner.c:	free_irq(pdev->irq, dev);
drivers/net/sb1000.c:	serial_number = pdev->card->serial;
drivers/net/sb1000.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/irda/vlsi_ir.c:		   pci_name(pdev), (int)pdev->vendor, (int)pdev->device);
drivers/net/irda/vlsi_ir.c:	seq_printf(seq, "pci-power-state: %u\n", (unsigned) pdev->current_state);
drivers/net/irda/vlsi_ir.c:		   pdev->irq, (unsigned)pci_resource_start(pdev, 0), (unsigned long long)pdev->dma_mask);
drivers/net/irda/vlsi_ir.c:		if (idev->pdev->current_state == 0)
drivers/net/irda/vlsi_ir.c:	ndev->irq = idev->pdev->irq;
drivers/net/irda/vlsi_ir.c:	ndev->irq = pdev->irq;
drivers/net/irda/vlsi_ir.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/irda/vlsi_ir.c:		pdev->current_state = 0; /* hw must be running now */
drivers/net/irda/vlsi_ir.c: * operations on our own (particularly reflecting the pdev->current_state)
drivers/net/irda/vlsi_ir.c:	if (pdev->current_state != 0) {			/* already suspended */
drivers/net/irda/vlsi_ir.c:		if (state.event > pdev->current_state) {	/* simply go deeper */
drivers/net/irda/vlsi_ir.c:			pdev->current_state = state.event;
drivers/net/irda/vlsi_ir.c:			IRDA_ERROR("%s - %s: invalid suspend request %u -> %u\n", __func__, pci_name(pdev), pdev->current_state, state.event);
drivers/net/irda/vlsi_ir.c:	pdev->current_state = state.event;
drivers/net/irda/vlsi_ir.c:	if (pdev->current_state == 0) {
drivers/net/irda/vlsi_ir.c:	pdev->current_state = PM_EVENT_ON;
drivers/net/irda/vlsi_ir.c:		 * - pci layer initially setting pdev->current_state = 4 (unknown)
drivers/net/irda/vlsi_ir.c:		 * now we explicitly set pdev->current_state = 0 after enabling the
drivers/net/irda/sa1100_ir.c:	if (!pdev->dev.platform_data)
drivers/net/irda/sa1100_ir.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/irda/sa1100_ir.c:	si->dev = &pdev->dev;
drivers/net/irda/sa1100_ir.c:	si->pdata = pdev->dev.platform_data;
drivers/net/irda/sh_sir.c:		dev_err(&pdev->dev, "Not enough platform resources.\n");
drivers/net/irda/sh_sir.c:		dev_err(&pdev->dev, "Unable to ioremap.\n");
drivers/net/irda/sh_sir.c:	snprintf(clk_name, sizeof(clk_name), "irda%d", pdev->id);
drivers/net/irda/sh_sir.c:	self->clk = clk_get(&pdev->dev, clk_name);
drivers/net/irda/sh_sir.c:		dev_err(&pdev->dev, "cannot get clock \"%s\"\n", clk_name);
drivers/net/irda/sh_sir.c:		dev_warn(&pdev->dev, "Unable to attach sh_sir interrupt\n");
drivers/net/irda/sh_sir.c:	dev_info(&pdev->dev, "SuperH IrDA probed\n");
drivers/net/irda/au1k_ir.c:	aup->platdata = pdev->dev.platform_data;
drivers/net/irda/au1k_ir.c:					 pdev->name);
drivers/net/irda/pxaficp_ir.c:	if (!pdev->dev.platform_data)
drivers/net/irda/pxaficp_ir.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/irda/pxaficp_ir.c:	si->dev = &pdev->dev;
drivers/net/irda/pxaficp_ir.c:	si->pdata = pdev->dev.platform_data;
drivers/net/irda/pxaficp_ir.c:	si->sir_clk = clk_get(&pdev->dev, "UARTCLK");
drivers/net/irda/pxaficp_ir.c:	si->fir_clk = clk_get(&pdev->dev, "FICPCLK");
drivers/net/irda/pxaficp_ir.c:		dev_set_drvdata(&pdev->dev, dev);
drivers/net/irda/sh_irda.c:	pm_runtime_get_sync(&self->pdev->dev);
drivers/net/irda/sh_irda.c:	pm_runtime_put_sync(&self->pdev->dev);
drivers/net/irda/sh_irda.c:	pm_runtime_put_sync(&self->pdev->dev);
drivers/net/irda/sh_irda.c:		dev_err(&pdev->dev, "Not enough platform resources.\n");
drivers/net/irda/sh_irda.c:		dev_err(&pdev->dev, "Unable to ioremap.\n");
drivers/net/irda/sh_irda.c:	pm_runtime_enable(&pdev->dev);
drivers/net/irda/sh_irda.c:		dev_warn(&pdev->dev, "Unable to attach sh_irda interrupt\n");
drivers/net/irda/sh_irda.c:	dev_info(&pdev->dev, "SuperH IrDA probed\n");
drivers/net/irda/sh_irda.c:	pm_runtime_disable(&pdev->dev);
drivers/net/irda/sh_irda.c:	pm_runtime_disable(&pdev->dev);
drivers/net/irda/via-ircc.c:		dma_alloc_coherent(&pdev->dev, self->rx_buff.truesize,
drivers/net/irda/via-ircc.c:		dma_alloc_coherent(&pdev->dev, self->tx_buff.truesize,
drivers/net/irda/via-ircc.c:	dma_free_coherent(&pdev->dev, self->tx_buff.truesize,
drivers/net/irda/via-ircc.c:	dma_free_coherent(&pdev->dev, self->rx_buff.truesize,
drivers/net/irda/via-ircc.c:		dma_free_coherent(&pdev->dev, self->tx_buff.truesize,
drivers/net/irda/via-ircc.c:		dma_free_coherent(&pdev->dev, self->rx_buff.truesize,
drivers/net/irda/bfin_sir.c:	for (i = 0; i < pdev->num_resources; i++) {
drivers/net/irda/bfin_sir.c:		res = &pdev->resource[i];
drivers/net/irda/bfin_sir.c:	if (pdev->id >= 0 && pdev->id < ARRAY_SIZE(per) && \
drivers/net/irda/bfin_sir.c:				per[pdev->id][3] == pdev->id) {
drivers/net/irda/bfin_sir.c:		err = peripheral_request_list(per[pdev->id], DRIVER_NAME);
drivers/net/irda/bfin_sir.c:		dev_err(&pdev->dev, "Invalid pdev id, please check board file\n");
drivers/net/irda/bfin_sir.c:	self->dev = &pdev->dev;
drivers/net/irda/bfin_sir.c:		dev_warn(&pdev->dev, "Invalid maximum baud rate, using 9600\n");
drivers/net/irda/bfin_sir.c:		peripheral_free_list(per[pdev->id]);
drivers/net/hamradio/baycom_par.c:	struct parport *pp = bc->pdev->port;
drivers/net/hamradio/baycom_par.c:	struct parport *pp = bc->pdev->port;
drivers/net/hamradio/baycom_par.c:	pp = bc->pdev->port;
drivers/net/hamradio/baycom_par.c:	pp = bc->pdev->port;
drivers/net/hamradio/baycom_epp.c:	sprintf(portarg, "%ld", bc->pdev->port->base);
drivers/net/hamradio/baycom_epp.c:	struct parport *pp = bc->pdev->port;
drivers/net/hamradio/baycom_epp.c:	struct parport *pp = bc->pdev->port;
drivers/net/hamradio/baycom_epp.c:	pp = bc->pdev->port;
drivers/net/hamradio/baycom_epp.c:	struct parport *pp = bc->pdev->port;
drivers/net/hamradio/yam.c:		err = request_firmware(&fw, fw_name[predef], &pdev->dev);
drivers/net/ethernet/renesas/sh_eth.c:	pm_runtime_get_sync(&mdp->pdev->dev);
drivers/net/ethernet/renesas/sh_eth.c:	pm_runtime_put_sync(&mdp->pdev->dev);
drivers/net/ethernet/renesas/sh_eth.c:	pm_runtime_put_sync(&mdp->pdev->dev);
drivers/net/ethernet/renesas/sh_eth.c:	pm_runtime_get_sync(&mdp->pdev->dev);
drivers/net/ethernet/renesas/sh_eth.c:	pm_runtime_put_sync(&mdp->pdev->dev);
drivers/net/ethernet/renesas/sh_eth.c:		mdp->pdev->name, id);
drivers/net/ethernet/renesas/sh_eth.c:	struct sh_eth_plat_data *pd = pdev->dev.platform_data;
drivers/net/ethernet/renesas/sh_eth.c:		dev_err(&pdev->dev, "invalid resource\n");
drivers/net/ethernet/renesas/sh_eth.c:	devno = pdev->id;
drivers/net/ethernet/renesas/sh_eth.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/renesas/sh_eth.c:	mdp->addr = devm_ioremap_resource(&pdev->dev, res);
drivers/net/ethernet/renesas/sh_eth.c:	pm_runtime_enable(&pdev->dev);
drivers/net/ethernet/renesas/sh_eth.c:	pm_runtime_resume(&pdev->dev);
drivers/net/ethernet/renesas/sh_eth.c:		dev_warn(&pdev->dev,
drivers/net/ethernet/renesas/sh_eth.c:		mdp->tsu_addr = devm_ioremap_resource(&pdev->dev, rtsu);
drivers/net/ethernet/renesas/sh_eth.c:	ret = sh_mdio_init(ndev, pdev->id, pd);
drivers/net/ethernet/renesas/sh_eth.c:	pm_runtime_disable(&pdev->dev);
drivers/net/ethernet/marvell/mv643xx_eth.c:	struct mv643xx_eth_shared_platform_data *pd = pdev->dev.platform_data;
drivers/net/ethernet/marvell/mv643xx_eth.c:	msp = devm_kzalloc(&pdev->dev, sizeof(*msp), GFP_KERNEL);
drivers/net/ethernet/marvell/mv643xx_eth.c:	msp->clk = devm_clk_get(&pdev->dev, NULL);
drivers/net/ethernet/marvell/mv643xx_eth.c:	pd = pdev->dev.platform_data;
drivers/net/ethernet/marvell/mv643xx_eth.c:		dev_err(&pdev->dev, "no mv643xx_eth_platform_data\n");
drivers/net/ethernet/marvell/mv643xx_eth.c:		dev_err(&pdev->dev, "no mv643xx_eth_platform_data->shared\n");
drivers/net/ethernet/marvell/mv643xx_eth.c:	mp->clk = devm_clk_get(&pdev->dev, NULL);
drivers/net/ethernet/marvell/mv643xx_eth.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/marvell/mvneta.c:	struct device_node *dn = pdev->dev.of_node;
drivers/net/ethernet/marvell/mvneta.c:		dev_err(&pdev->dev, "Invalid rxq_def argument: %d\n", rxq_def);
drivers/net/ethernet/marvell/mvneta.c:		dev_err(&pdev->dev, "no associated PHY\n");
drivers/net/ethernet/marvell/mvneta.c:		dev_err(&pdev->dev, "incorrect phy-mode\n");
drivers/net/ethernet/marvell/mvneta.c:	pp->clk = devm_clk_get(&pdev->dev, NULL);
drivers/net/ethernet/marvell/mvneta.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/marvell/mvneta.c:		dev_err(&pdev->dev, "can't init eth hal\n");
drivers/net/ethernet/marvell/mvneta.c:		dev_err(&pdev->dev, "failed to register\n");
drivers/net/ethernet/marvell/pxa168_eth.c:	clk = clk_get(&pdev->dev, "MFUCLK");
drivers/net/ethernet/marvell/pxa168_eth.c:	pep->pd = pdev->dev.platform_data;
drivers/net/ethernet/marvell/pxa168_eth.c:		pdev->name, pdev->id);
drivers/net/ethernet/marvell/pxa168_eth.c:	pep->smi_bus->parent = &pdev->dev;
drivers/net/ethernet/marvell/pxa168_eth.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/marvell/skge.c:	    !device_can_wakeup(&hw->pdev->dev))
drivers/net/ethernet/marvell/skge.c:	device_set_wakeup_enable(&hw->pdev->dev, skge->wol);
drivers/net/ethernet/marvell/skge.c:		dev_err(&hw->pdev->dev, "pci_alloc_consistent region crosses 4G boundary\n");
drivers/net/ethernet/marvell/skge.c:		err = request_irq(hw->pdev->irq, skge_intr, IRQF_SHARED,
drivers/net/ethernet/marvell/skge.c:				   hw->pdev->irq, err);
drivers/net/ethernet/marvell/skge.c:		free_irq(hw->pdev->irq, hw);
drivers/net/ethernet/marvell/skge.c:			map = skb_frag_dma_map(&hw->pdev->dev, frag, 0,
drivers/net/ethernet/marvell/skge.c:		dev_err(&pdev->dev, "Ram read data parity error\n");
drivers/net/ethernet/marvell/skge.c:		dev_err(&pdev->dev, "Ram write data parity error\n");
drivers/net/ethernet/marvell/skge.c:		dev_err(&pdev->dev, "%s: receive queue parity error\n",
drivers/net/ethernet/marvell/skge.c:		dev_err(&pdev->dev, "%s: receive queue parity error\n",
drivers/net/ethernet/marvell/skge.c:		dev_err(&pdev->dev, "PCI error cmd=%#x status=%#x\n",
drivers/net/ethernet/marvell/skge.c:			dev_warn(&hw->pdev->dev, "unable to clear error (so ignoring them)\n");
drivers/net/ethernet/marvell/skge.c:			dev_err(&hw->pdev->dev, "unsupported phy type 0x%x\n",
drivers/net/ethernet/marvell/skge.c:		dev_err(&hw->pdev->dev, "Genesis chip detected but not configured\n");
drivers/net/ethernet/marvell/skge.c:		dev_err(&hw->pdev->dev, "unsupported chip type 0x%x\n",
drivers/net/ethernet/marvell/skge.c:			dev_warn(&hw->pdev->dev, "stuck hardware sensor bit\n");
drivers/net/ethernet/marvell/skge.c:	SET_NETDEV_DEV(dev, &hw->pdev->dev);
drivers/net/ethernet/marvell/skge.c:	dev->irq = hw->pdev->irq;
drivers/net/ethernet/marvell/skge.c:	if (device_can_wakeup(&hw->pdev->dev)) {
drivers/net/ethernet/marvell/skge.c:		device_set_wakeup_enable(&hw->pdev->dev, skge->wol);
drivers/net/ethernet/marvell/skge.c:		dev_err(&pdev->dev, "cannot enable PCI device\n");
drivers/net/ethernet/marvell/skge.c:		dev_err(&pdev->dev, "cannot obtain PCI resources\n");
drivers/net/ethernet/marvell/skge.c:		dev_err(&pdev->dev, "no usable DMA configuration\n");
drivers/net/ethernet/marvell/skge.c:		dev_err(&pdev->dev, "cannot map device registers\n");
drivers/net/ethernet/marvell/skge.c:		(unsigned long long)pci_resource_start(pdev, 0), pdev->irq,
drivers/net/ethernet/marvell/skge.c:		dev_warn(&pdev->dev, "bad (zero?) ethernet address in rom\n");
drivers/net/ethernet/marvell/skge.c:		dev_err(&pdev->dev, "cannot register net device\n");
drivers/net/ethernet/marvell/skge.c:			dev_err(&pdev->dev, "cannot register second net device\n");
drivers/net/ethernet/marvell/skge.c:		err = request_irq(pdev->irq, skge_intr, IRQF_SHARED,
drivers/net/ethernet/marvell/skge.c:			dev_err(&pdev->dev, "cannot assign irq %d\n",
drivers/net/ethernet/marvell/skge.c:				pdev->irq);
drivers/net/ethernet/marvell/skge.c:		free_irq(pdev->irq, hw);
drivers/net/ethernet/marvell/skge.c:		free_irq(pdev->irq, hw);
drivers/net/ethernet/marvell/skge.c:	pci_wake_from_d3(pdev, device_may_wakeup(&pdev->dev));
drivers/net/ethernet/marvell/mvmdio.c:		dev_err(&pdev->dev, "No SMI register address given\n");
drivers/net/ethernet/marvell/mvmdio.c:		dev_err(&pdev->dev, "Cannot allocate MDIO bus\n");
drivers/net/ethernet/marvell/mvmdio.c:		 dev_name(&pdev->dev));
drivers/net/ethernet/marvell/mvmdio.c:	bus->parent = &pdev->dev;
drivers/net/ethernet/marvell/mvmdio.c:	dev->regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));
drivers/net/ethernet/marvell/mvmdio.c:		dev_err(&pdev->dev, "Unable to remap SMI register\n");
drivers/net/ethernet/marvell/mvmdio.c:	dev->clk = devm_clk_get(&pdev->dev, NULL);
drivers/net/ethernet/marvell/mvmdio.c:		ret = devm_request_irq(&pdev->dev, dev->err_interrupt,
drivers/net/ethernet/marvell/mvmdio.c:					IRQF_SHARED, pdev->name, dev);
drivers/net/ethernet/marvell/mvmdio.c:	if (pdev->dev.of_node)
drivers/net/ethernet/marvell/mvmdio.c:		ret = of_mdiobus_register(bus, pdev->dev.of_node);
drivers/net/ethernet/marvell/mvmdio.c:		dev_err(&pdev->dev, "Cannot register MDIO bus (%d)\n", ret);
drivers/net/ethernet/marvell/sky2.c:	dev_warn(&hw->pdev->dev, "%s: phy write timeout\n", hw->dev[port]->name);
drivers/net/ethernet/marvell/sky2.c:	dev_err(&hw->pdev->dev, "%s: phy I/O error\n", hw->dev[port]->name);
drivers/net/ethernet/marvell/sky2.c:	dev_warn(&hw->pdev->dev, "%s: phy read timeout\n", hw->dev[port]->name);
drivers/net/ethernet/marvell/sky2.c:	dev_err(&hw->pdev->dev, "%s: phy I/O error\n", hw->dev[port]->name);
drivers/net/ethernet/marvell/sky2.c:		re->frag_addr[i] = skb_frag_dma_map(&pdev->dev, frag, 0,
drivers/net/ethernet/marvell/sky2.c:		if (dma_mapping_error(&pdev->dev, re->frag_addr[i]))
drivers/net/ethernet/marvell/sky2.c:		dev_warn(&pdev->dev, "%s: rx mapping error\n",
drivers/net/ethernet/marvell/sky2.c:	err = request_irq(pdev->irq, sky2_intr,
drivers/net/ethernet/marvell/sky2.c:		dev_err(&pdev->dev, "cannot assign irq %d\n", pdev->irq);
drivers/net/ethernet/marvell/sky2.c:		mapping = skb_frag_dma_map(&hw->pdev->dev, frag, 0,
drivers/net/ethernet/marvell/sky2.c:		if (dma_mapping_error(&hw->pdev->dev, mapping))
drivers/net/ethernet/marvell/sky2.c:		dev_warn(&hw->pdev->dev, "%s: tx mapping error\n", dev->name);
drivers/net/ethernet/marvell/sky2.c:		free_irq(hw->pdev->irq, hw);
drivers/net/ethernet/marvell/sky2.c:		synchronize_irq(hw->pdev->irq);
drivers/net/ethernet/marvell/sky2.c:	synchronize_irq(hw->pdev->irq);
drivers/net/ethernet/marvell/sky2.c:		dev_notice(&sky2->hw->pdev->dev,
drivers/net/ethernet/marvell/sky2.c:			dev_err(&pdev->dev, "PCI hardware error (0x%x)\n",
drivers/net/ethernet/marvell/sky2.c:			dev_err(&pdev->dev, "PCI Express error (0x%x)\n", err);
drivers/net/ethernet/marvell/sky2.c:	dev_err(&hw->pdev->dev, "%s: descriptor error q=%#x get=%u put=%u\n",
drivers/net/ethernet/marvell/sky2.c:		dev_warn(&hw->pdev->dev, "error interrupt status=%#x\n", status);
drivers/net/ethernet/marvell/sky2.c:			dev_err(&hw->pdev->dev, "unsupported revision Yukon-EC rev A1\n");
drivers/net/ethernet/marvell/sky2.c:		dev_err(&hw->pdev->dev, "unsupported chip type 0x%x\n",
drivers/net/ethernet/marvell/sky2.c:			dev_info(&pdev->dev, "ignoring stuck error report bit\n");
drivers/net/ethernet/marvell/sky2.c:			sky2_pci_write16(hw, pdev->pcie_cap + PCI_EXP_LNKCTL,
drivers/net/ethernet/marvell/sky2.c:		synchronize_irq(hw->pdev->irq);
drivers/net/ethernet/marvell/sky2.c:	    !device_can_wakeup(&hw->pdev->dev))
drivers/net/ethernet/marvell/sky2.c:	device_set_wakeup_enable(&hw->pdev->dev, enable_wakeup);
drivers/net/ethernet/marvell/sky2.c:			dev_err(&hw->pdev->dev, "VPD cycle timed out\n");
drivers/net/ethernet/marvell/sky2.c:	SET_NETDEV_DEV(dev, &hw->pdev->dev);
drivers/net/ethernet/marvell/sky2.c:	dev->irq = hw->pdev->irq;
drivers/net/ethernet/marvell/sky2.c:	err = request_irq(pdev->irq, sky2_test_intr, 0, DRV_NAME, hw);
drivers/net/ethernet/marvell/sky2.c:		dev_err(&pdev->dev, "cannot assign irq %d\n", pdev->irq);
drivers/net/ethernet/marvell/sky2.c:		dev_info(&pdev->dev, "No interrupt generated using MSI, "
drivers/net/ethernet/marvell/sky2.c:	free_irq(pdev->irq, hw);
drivers/net/ethernet/marvell/sky2.c:		dev_err(&pdev->dev, "cannot enable PCI device\n");
drivers/net/ethernet/marvell/sky2.c:		dev_err(&pdev->dev, "PCI read config failed\n");
drivers/net/ethernet/marvell/sky2.c:		dev_err(&pdev->dev, "PCI configuration read error\n");
drivers/net/ethernet/marvell/sky2.c:		dev_err(&pdev->dev, "cannot obtain PCI resources\n");
drivers/net/ethernet/marvell/sky2.c:			dev_err(&pdev->dev, "unable to obtain 64 bit DMA "
drivers/net/ethernet/marvell/sky2.c:			dev_err(&pdev->dev, "no usable DMA configuration\n");
drivers/net/ethernet/marvell/sky2.c:		dev_err(&pdev->dev, "PCI write config failed\n");
drivers/net/ethernet/marvell/sky2.c:	wol_default = device_may_wakeup(&pdev->dev) ? WAKE_MAGIC : 0;
drivers/net/ethernet/marvell/sky2.c:		dev_err(&pdev->dev, "cannot map device registers\n");
drivers/net/ethernet/marvell/sky2.c:	dev_info(&pdev->dev, "Yukon-2 %s chip revision %d\n",
drivers/net/ethernet/marvell/sky2.c:		dev_err(&pdev->dev, "cannot register net device\n");
drivers/net/ethernet/marvell/sky2.c:			dev_err(&pdev->dev, "cannot register second net device\n");
drivers/net/ethernet/marvell/sky2.c:	pdev->d3_delay = 150;
drivers/net/ethernet/marvell/sky2.c:		free_irq(pdev->irq, hw);
drivers/net/ethernet/marvell/sky2.c:		dev_err(&pdev->dev, "PCI write config failed\n");
drivers/net/ethernet/marvell/sky2.c:	dev_err(&pdev->dev, "resume failed (%d)\n", err);
drivers/net/ethernet/marvell/sky2.c:	sky2_suspend(&pdev->dev);
drivers/net/ethernet/marvell/sky2.c:	pci_wake_from_d3(pdev, device_may_wakeup(&pdev->dev));
drivers/net/ethernet/freescale/fec_ptp.c:	fep->ptp_clock = ptp_clock_register(&fep->ptp_caps, &pdev->dev);
drivers/net/ethernet/freescale/xgmac_mdio.c:	struct device_node *np = pdev->dev.of_node;
drivers/net/ethernet/freescale/xgmac_mdio.c:		dev_err(&pdev->dev, "could not obtain address\n");
drivers/net/ethernet/freescale/xgmac_mdio.c:	bus->parent = &pdev->dev;
drivers/net/ethernet/freescale/xgmac_mdio.c:		dev_err(&pdev->dev, "cannot register MDIO bus\n");
drivers/net/ethernet/freescale/xgmac_mdio.c:	dev_set_drvdata(&pdev->dev, bus);
drivers/net/ethernet/freescale/xgmac_mdio.c:	struct mii_bus *bus = dev_get_drvdata(&pdev->dev);
drivers/net/ethernet/freescale/fsl_pq_mdio.c:		of_match_device(fsl_pq_mdio_match, &pdev->dev);
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	struct device_node *np = pdev->dev.of_node;
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	dev_dbg(&pdev->dev, "found %s compatible node\n", id->compatible);
drivers/net/ethernet/freescale/fsl_pq_mdio.c:		dev_err(&pdev->dev, "could not obtain address information\n");
drivers/net/ethernet/freescale/fsl_pq_mdio.c:		dev_err(&pdev->dev, "invalid register map\n");
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	new_bus->parent = &pdev->dev;
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	dev_set_drvdata(&pdev->dev, new_bus);
drivers/net/ethernet/freescale/fsl_pq_mdio.c:				dev_dbg(&pdev->dev, "found TBI PHY node %s\n",
drivers/net/ethernet/freescale/fsl_pq_mdio.c:				dev_err(&pdev->dev,
drivers/net/ethernet/freescale/fsl_pq_mdio.c:		dev_err(&pdev->dev, "cannot register %s as MDIO bus\n",
drivers/net/ethernet/freescale/fsl_pq_mdio.c:	struct device *device = &pdev->dev;
drivers/net/ethernet/freescale/fec_main.c:	bdp->cbd_bufaddr = dma_map_single(&fep->pdev->dev, bufaddr,
drivers/net/ethernet/freescale/fec_main.c:		dma_unmap_single(&fep->pdev->dev, bdp->cbd_bufaddr,
drivers/net/ethernet/freescale/fec_main.c:		dma_unmap_single(&fep->pdev->dev, bdp->cbd_bufaddr,
drivers/net/ethernet/freescale/fec_main.c:		bdp->cbd_bufaddr = dma_map_single(&fep->pdev->dev, data,
drivers/net/ethernet/freescale/fec_main.c:	struct fec_platform_data *pdata = fep->pdev->dev.platform_data;
drivers/net/ethernet/freescale/fec_main.c:		struct device_node *np = fep->pdev->dev.of_node;
drivers/net/ethernet/freescale/fec_main.c:		pdev->name, fep->dev_id + 1);
drivers/net/ethernet/freescale/fec_main.c:	fep->mii_bus->parent = &pdev->dev;
drivers/net/ethernet/freescale/fec_main.c:	strlcpy(info->driver, fep->pdev->dev.driver->name,
drivers/net/ethernet/freescale/fec_main.c:			dma_unmap_single(&fep->pdev->dev, bdp->cbd_bufaddr,
drivers/net/ethernet/freescale/fec_main.c:		bdp->cbd_bufaddr = dma_map_single(&fep->pdev->dev, skb->data,
drivers/net/ethernet/freescale/fec_main.c:	struct device_node *np = pdev->dev.of_node;
drivers/net/ethernet/freescale/fec_main.c:	err = devm_gpio_request_one(&pdev->dev, phy_reset,
drivers/net/ethernet/freescale/fec_main.c:		dev_err(&pdev->dev, "failed to get phy-reset-gpios: %d\n", err);
drivers/net/ethernet/freescale/fec_main.c:	of_id = of_match_device(fec_dt_ids, &pdev->dev);
drivers/net/ethernet/freescale/fec_main.c:		pdev->id_entry = of_id->data;
drivers/net/ethernet/freescale/fec_main.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/freescale/fec_main.c:	if (pdev->id_entry &&
drivers/net/ethernet/freescale/fec_main.c:	    (pdev->id_entry->driver_data & FEC_QUIRK_HAS_GBIT))
drivers/net/ethernet/freescale/fec_main.c:	fep->hwp = devm_request_and_ioremap(&pdev->dev, r);
drivers/net/ethernet/freescale/fec_main.c:	ret = of_get_phy_mode(pdev->dev.of_node);
drivers/net/ethernet/freescale/fec_main.c:		pdata = pdev->dev.platform_data;
drivers/net/ethernet/freescale/fec_main.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/net/ethernet/freescale/fec_main.c:	fep->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
drivers/net/ethernet/freescale/fec_main.c:	fep->clk_ahb = devm_clk_get(&pdev->dev, "ahb");
drivers/net/ethernet/freescale/fec_main.c:	fep->clk_enet_out = devm_clk_get(&pdev->dev, "enet_out");
drivers/net/ethernet/freescale/fec_main.c:	fep->clk_ptp = devm_clk_get(&pdev->dev, "ptp");
drivers/net/ethernet/freescale/fec_main.c:		pdev->id_entry->driver_data & FEC_QUIRK_HAS_BUFDESC_EX;
drivers/net/ethernet/freescale/fec_main.c:	reg_phy = devm_regulator_get(&pdev->dev, "phy");
drivers/net/ethernet/freescale/fec_main.c:			dev_err(&pdev->dev,
drivers/net/ethernet/freescale/fec_main.c:		ret = request_irq(irq, fec_enet_interrupt, IRQF_DISABLED, pdev->name, ndev);
drivers/net/ethernet/pasemi/pasemi_mac.c:	int devfn = pdev->devfn;
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_dbg(&pdev->dev,
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_warn(&pdev->dev,
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_warn(&pdev->dev,
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_err(&mac->pdev->dev, "Can't allocate checksum channel\n");
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_err(&mac->pdev->dev, "Can't allocate RX channel\n");
drivers/net/ethernet/pasemi/pasemi_mac.c:	ring->buffers = dma_alloc_coherent(&mac->dma_pdev->dev,
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_err(&mac->pdev->dev, "Can't allocate TX channel\n");
drivers/net/ethernet/pasemi/pasemi_mac.c:	dma_free_coherent(&mac->dma_pdev->dev, RX_RING_SIZE * sizeof(u64),
drivers/net/ethernet/pasemi/pasemi_mac.c:			dev_warn(&mac->pdev->dev,
drivers/net/ethernet/pasemi/pasemi_mac.c:			dev_warn(&mac->pdev->dev,
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_err(&mac->pdev->dev, "request_irq of irq %d failed: %d\n",
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_err(&mac->pdev->dev, "request_irq of irq %d failed: %d\n",
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_err(&mac->dma_pdev->dev,
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_err(&mac->dma_pdev->dev,
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_err(&mac->dma_pdev->dev,
drivers/net/ethernet/pasemi/pasemi_mac.c:		map[i + 1] = skb_frag_dma_map(&mac->dma_pdev->dev, frag, 0,
drivers/net/ethernet/pasemi/pasemi_mac.c:		if (dma_mapping_error(&mac->dma_pdev->dev, map[i + 1])) {
drivers/net/ethernet/pasemi/pasemi_mac.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_err(&mac->pdev->dev, "Can't find DMA Controller\n");
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_err(&mac->pdev->dev, "Can't find I/O Bridge\n");
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_err(&mac->pdev->dev, "Can't map DMA interface\n");
drivers/net/ethernet/pasemi/pasemi_mac.c:	switch (pdev->device) {
drivers/net/ethernet/pasemi/pasemi_mac.c:		dev_err(&mac->pdev->dev, "register_netdev failed with error %d\n",
drivers/net/ethernet/lantiq_etop.c:		priv->pdev->name, priv->pdev->id);
drivers/net/ethernet/lantiq_etop.c:		dev_err(&pdev->dev, "failed to get etop resource\n");
drivers/net/ethernet/lantiq_etop.c:	res = devm_request_mem_region(&pdev->dev, res->start,
drivers/net/ethernet/lantiq_etop.c:		resource_size(res), dev_name(&pdev->dev));
drivers/net/ethernet/lantiq_etop.c:		dev_err(&pdev->dev, "failed to request etop resource\n");
drivers/net/ethernet/lantiq_etop.c:	ltq_etop_membase = devm_ioremap_nocache(&pdev->dev,
drivers/net/ethernet/lantiq_etop.c:		dev_err(&pdev->dev, "failed to remap etop engine %d\n",
drivers/net/ethernet/lantiq_etop.c:			pdev->id);
drivers/net/ethernet/lantiq_etop.c:	priv->pldata = dev_get_platdata(&pdev->dev);
drivers/net/ethernet/chelsio/cxgb/cxgb2.c:	err = request_irq(adapter->pdev->irq, t1_interrupt,
drivers/net/ethernet/chelsio/cxgb/cxgb2.c:	free_irq(adapter->pdev->irq, adapter);
drivers/net/ethernet/chelsio/cxgb/cxgb2.c:	t1_interrupt(adapter->pdev->irq, adapter);
drivers/net/ethernet/chelsio/cxgb/cxgb2.c:		SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/chelsio/cxgb/cxgb2.c:		netdev->irq = pdev->irq;
drivers/net/ethernet/chelsio/cxgb/sge.c:		mapping = skb_frag_dma_map(&adapter->pdev->dev, frag, 0,
drivers/net/ethernet/chelsio/cxgb/pm3393.c:		dev_dbg(&cmac->adapter->pdev->dev, "PM3393 intr cause 0x%x\n",
drivers/net/ethernet/chelsio/cxgb/pm3393.c:			dev_dbg(&adapter->pdev->dev,
drivers/net/ethernet/chelsio/cxgb/subr.c:			dev_dbg(&adapter->pdev->dev,
drivers/net/ethernet/chelsio/cxgb/subr.c:				dev_info(&adapter->pdev->dev, "XPAK %s\n",
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		free_irq(adapter->pdev->irq, adapter);
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:	ret = request_firmware(&fw, buf, &adapter->pdev->dev);
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:	struct device *dev = &adap->pdev->dev;
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:	struct device *dev = &adap->pdev->dev;
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:	} else if ((err = request_irq(adap->pdev->irq,
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:			t.vector = adapter->pdev->irq;
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:				dev_err(&adapter->pdev->dev,
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		dev_info(&adap->pdev->dev,
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		dev_err(&pdev->dev, "cannot enable PCI device\n");
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		dev_info(&pdev->dev, "cannot obtain PCI resources\n");
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:			dev_err(&pdev->dev, "unable to obtain 64-bit DMA for "
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		dev_err(&pdev->dev, "no usable DMA configuration\n");
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		dev_err(&pdev->dev, "cannot allocate nofail buffer\n");
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		dev_err(&pdev->dev, "cannot map device registers\n");
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		netdev->irq = pdev->irq;
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:			dev_warn(&pdev->dev,
drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c:		dev_err(&pdev->dev, "could not register any net devices\n");
drivers/net/ethernet/chelsio/cxgb3/sge.c:	void *p = dma_alloc_coherent(&pdev->dev, len, phys, GFP_KERNEL);
drivers/net/ethernet/chelsio/cxgb3/sge.c:			dma_free_coherent(&pdev->dev, len, p, *phys);
drivers/net/ethernet/chelsio/cxgb3/sge.c:			dma_free_coherent(&pdev->dev,
drivers/net/ethernet/chelsio/cxgb3/sge.c:			dma_free_coherent(&pdev->dev,
drivers/net/ethernet/chelsio/cxgb3/sge.c:		dma_free_coherent(&pdev->dev,
drivers/net/ethernet/chelsio/cxgb3/sge.c:		mapping = skb_frag_dma_map(&pdev->dev, frag, 0, skb_frag_size(frag),
drivers/net/ethernet/chelsio/cxgb3/sge.c:		dev_err(&adap->pdev->dev,
drivers/net/ethernet/chelsio/cxgb3/common.h:#define CH_ERR(adap, fmt, ...)   dev_err(&adap->pdev->dev, fmt, ##__VA_ARGS__)
drivers/net/ethernet/chelsio/cxgb3/common.h:#define CH_WARN(adap, fmt, ...)  dev_warn(&adap->pdev->dev, fmt, ##__VA_ARGS__)
drivers/net/ethernet/chelsio/cxgb3/common.h:#define CH_ALERT(adap, fmt, ...) dev_alert(&adap->pdev->dev, fmt, ##__VA_ARGS__)
drivers/net/ethernet/chelsio/cxgb3/common.h:		dev_printk(KERN_##level, &adapter->pdev->dev, fmt, \
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		err = request_irq(adap->pdev->irq, t4_intr_handler(adap),
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		free_irq(adapter->pdev->irq, adapter);
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		       adapter->pdev->device);
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:	if (is_bypass_device(adap->pdev->device))
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		dev_err(&pdev->dev, "cannot reenable PCI device after reset\n");
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		dev_info(&pdev->dev, "cannot obtain PCI resources\n");
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:	func = PCI_FUNC(pdev->devfn);
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		dev_err(&pdev->dev, "cannot enable PCI device\n");
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:			dev_err(&pdev->dev, "unable to obtain 64-bit DMA for "
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:			dev_err(&pdev->dev, "no usable DMA configuration\n");
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		dev_err(&pdev->dev, "cannot map device registers\n");
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:	adapter->pdev_dev = &pdev->dev;
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:			dev_err(&pdev->dev,
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:			dev_err(&pdev->dev, "cannot map device bar2 region\n");
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		netdev->irq = pdev->irq;
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		dev_warn(&pdev->dev, "could not allocate L2T, continuing\n");
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		dev_warn(&pdev->dev, "could not allocate TID table, "
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		dev_err(&pdev->dev, "could not register any net devices\n");
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:		dev_warn(&pdev->dev, "only %d net devices registered\n", i);
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:	pdev->needs_freset = 1;
drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:			dev_info(&pdev->dev,
drivers/net/ethernet/chelsio/cxgb4/t4_hw.c:	if (adap->pdev->error_state != pci_channel_io_normal)
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:		err = request_irq(adapter->pdev->irq,
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:		free_irq(adapter->pdev->irq, adapter);
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:	switch (adapter->pdev->device >> 12) {
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:		dev_err(&pdev->dev, "cannot enable PCI device\n");
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:		dev_err(&pdev->dev, "cannot obtain PCI resources\n");
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:			dev_err(&pdev->dev, "unable to obtain 64-bit DMA for"
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:			dev_err(&pdev->dev, "no usable DMA configuration\n");
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:	adapter->pdev_dev = &pdev->dev;
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:		dev_err(&pdev->dev, "cannot map device registers\n");
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:			dev_err(&pdev->dev, "cannot allocate VI for port %d:"
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:		SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:		netdev->irq = pdev->irq;
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:			dev_err(&pdev->dev, "cannot initialize port %d\n",
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:			dev_warn(&pdev->dev, "cannot register net device %s,"
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:		dev_err(&pdev->dev, "could not register any net devices\n");
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:			dev_warn(&pdev->dev, "could not create debugfs"
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:			dev_err(&pdev->dev, "Unable to allocate %s interrupts;"
drivers/net/ethernet/neterion/s2io.c:		dev_name(&nic->pdev->dev), (unsigned long long)tmp_p_addr);
drivers/net/ethernet/neterion/s2io.c:			if (tdev->bus == s2io_pdev->bus->parent) {
drivers/net/ethernet/neterion/s2io.c:	if ((nic->device_type == XFRAME_I_DEVICE) && (nic->pdev->revision < 4))
drivers/net/ethernet/neterion/s2io.c:		if ((!herc && (sp->pdev->revision >= 4)) || herc) {
drivers/net/ethernet/neterion/s2io.c:		if ((!herc && (sp->pdev->revision >= 4)) || herc) {
drivers/net/ethernet/neterion/s2io.c:	subid = nic->pdev->subsystem_device;
drivers/net/ethernet/neterion/s2io.c:	const int irq = nic->pdev->irq;
drivers/net/ethernet/neterion/s2io.c:	subid = sp->pdev->subsystem_device;
drivers/net/ethernet/neterion/s2io.c:			  sp->dev->name, pci_name(pdev), pdev->irq);
drivers/net/ethernet/neterion/s2io.c:	free_irq(sp->pdev->irq, sp->dev);
drivers/net/ethernet/neterion/s2io.c:		txdp->Buffer_Pointer = (u64)skb_frag_dma_map(&sp->pdev->dev,
drivers/net/ethernet/neterion/s2io.c:	regs->version = sp->pdev->subsystem_device;
drivers/net/ethernet/neterion/s2io.c:	u16 subid = sp->pdev->subsystem_device;
drivers/net/ethernet/neterion/s2io.c:	u16 subid = sp->pdev->subsystem_device;
drivers/net/ethernet/neterion/s2io.c:	eeprom->magic = sp->pdev->vendor | (sp->pdev->device << 16);
drivers/net/ethernet/neterion/s2io.c:	if (eeprom->magic != (sp->pdev->vendor | (sp->pdev->device << 16))) {
drivers/net/ethernet/neterion/s2io.c:			  (sp->pdev->vendor | (sp->pdev->device << 16)),
drivers/net/ethernet/neterion/s2io.c:	subid = nic->pdev->subsystem_device;
drivers/net/ethernet/neterion/s2io.c:		err = request_irq(sp->pdev->irq, s2io_isr, IRQF_SHARED,
drivers/net/ethernet/neterion/s2io.c:	    ((pdev->device != PCI_DEVICE_ID_HERC_WIN) &&
drivers/net/ethernet/neterion/s2io.c:	     (pdev->device != PCI_DEVICE_ID_HERC_UNI))) {
drivers/net/ethernet/neterion/s2io.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/neterion/s2io.c:	if ((pdev->device == PCI_DEVICE_ID_HERC_WIN) ||
drivers/net/ethernet/neterion/s2io.c:	    (pdev->device == PCI_DEVICE_ID_HERC_UNI))
drivers/net/ethernet/neterion/s2io.c:	subid = sp->pdev->subsystem_device;
drivers/net/ethernet/neterion/s2io.c:		  sp->product_name, pdev->revision);
drivers/net/ethernet/neterion/vxge/vxge-ethtool.c:	regs->version = vdev->pdev->subsystem_device;
drivers/net/ethernet/neterion/vxge/vxge-main.c:		dma_pointer = (u64)skb_frag_dma_map(&fifo->pdev->dev, frag,
drivers/net/ethernet/neterion/vxge/vxge-main.c:		if (unlikely(dma_mapping_error(&fifo->pdev->dev, dma_pointer)))
drivers/net/ethernet/neterion/vxge/vxge-main.c:	const int irq = pdev->irq;
drivers/net/ethernet/neterion/vxge/vxge-main.c:			synchronize_irq(vdev->pdev->irq);
drivers/net/ethernet/neterion/vxge/vxge-main.c:			free_irq(vdev->pdev->irq, vdev);
drivers/net/ethernet/neterion/vxge/vxge-main.c:	int pci_fun = PCI_FUNC(vdev->pdev->devfn);
drivers/net/ethernet/neterion/vxge/vxge-main.c:		ret = request_irq((int) vdev->pdev->irq,
drivers/net/ethernet/neterion/vxge/vxge-main.c:				VXGE_DRIVER_NAME, "IRQ", vdev->pdev->irq);
drivers/net/ethernet/neterion/vxge/vxge-main.c:			"IRQ", vdev->pdev->irq);
drivers/net/ethernet/neterion/vxge/vxge-main.c:	vdev->titan1 = (vdev->pdev->revision == VXGE_HW_TITAN1_PCI_REVISION);
drivers/net/ethernet/neterion/vxge/vxge-main.c:	SET_NETDEV_DEV(ndev, &vdev->pdev->dev);
drivers/net/ethernet/neterion/vxge/vxge-main.c:	ret = request_firmware(&fw, fw_name, &vdev->pdev->dev);
drivers/net/ethernet/neterion/vxge/vxge-main.c:	if (((bus != pdev->bus->number) || (device != PCI_SLOT(pdev->devfn))) &&
drivers/net/ethernet/neterion/vxge/vxge-main.c:	    !pdev->is_virtfn)
drivers/net/ethernet/neterion/vxge/vxge-main.c:	bus = pdev->bus->number;
drivers/net/ethernet/neterion/vxge/vxge-main.c:	device = PCI_SLOT(pdev->devfn);
drivers/net/ethernet/davicom/dm9000.c:	struct dm9000_plat_data *pdata = pdev->dev.platform_data;
drivers/net/ethernet/davicom/dm9000.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/davicom/dm9000.c:	dev_dbg(&pdev->dev, "dm9000_probe()\n");
drivers/net/ethernet/davicom/dm9000.c:	db->dev = &pdev->dev;
drivers/net/ethernet/davicom/dm9000.c:					  pdev->name);
drivers/net/ethernet/davicom/dm9000.c:					  pdev->name);
drivers/net/ethernet/davicom/dm9000.c:	dev_dbg(&pdev->dev, "released and freed device\n");
drivers/net/ethernet/intel/e1000e/80003es2lan.c:	switch (hw->adapter->pdev->device) {
drivers/net/ethernet/intel/e1000e/netdev.c:		dev_info(&adapter->pdev->dev, "Net device Info\n");
drivers/net/ethernet/intel/e1000e/netdev.c:	dev_info(&adapter->pdev->dev, "Register Dump\n");
drivers/net/ethernet/intel/e1000e/netdev.c:	dev_info(&adapter->pdev->dev, "Tx Ring Summary\n");
drivers/net/ethernet/intel/e1000e/netdev.c:	dev_info(&adapter->pdev->dev, "Tx Ring Dump\n");
drivers/net/ethernet/intel/e1000e/netdev.c:	dev_info(&adapter->pdev->dev, "Rx Ring Summary\n");
drivers/net/ethernet/intel/e1000e/netdev.c:	dev_info(&adapter->pdev->dev, "Rx Ring Dump\n");
drivers/net/ethernet/intel/e1000e/netdev.c:		buffer_info->dma = dma_map_single(&pdev->dev, skb->data,
drivers/net/ethernet/intel/e1000e/netdev.c:		if (dma_mapping_error(&pdev->dev, buffer_info->dma)) {
drivers/net/ethernet/intel/e1000e/netdev.c:			dev_err(&pdev->dev, "Rx DMA map failed\n");
drivers/net/ethernet/intel/e1000e/netdev.c:				ps_page->dma = dma_map_page(&pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:				if (dma_mapping_error(&pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:					dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:		buffer_info->dma = dma_map_single(&pdev->dev, skb->data,
drivers/net/ethernet/intel/e1000e/netdev.c:		if (dma_mapping_error(&pdev->dev, buffer_info->dma)) {
drivers/net/ethernet/intel/e1000e/netdev.c:			dev_err(&pdev->dev, "Rx DMA map failed\n");
drivers/net/ethernet/intel/e1000e/netdev.c:			buffer_info->dma = dma_map_page(&pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:			if (dma_mapping_error(&pdev->dev, buffer_info->dma)) {
drivers/net/ethernet/intel/e1000e/netdev.c:		dma_unmap_single(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000e/netdev.c:			dma_unmap_page(&adapter->pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000e/netdev.c:			dma_unmap_single(&adapter->pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000e/netdev.c:		dma_unmap_single(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000e/netdev.c:				dma_sync_single_for_cpu(&pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:				dma_sync_single_for_device(&pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:			dma_unmap_page(&pdev->dev, ps_page->dma, PAGE_SIZE,
drivers/net/ethernet/intel/e1000e/netdev.c:		dma_unmap_page(&pdev->dev, buffer_info->dma, PAGE_SIZE,
drivers/net/ethernet/intel/e1000e/netdev.c:				dma_unmap_single(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000e/netdev.c:				dma_unmap_page(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000e/netdev.c:				dma_unmap_single(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000e/netdev.c:			dma_unmap_page(&pdev->dev, ps_page->dma, PAGE_SIZE,
drivers/net/ethernet/intel/e1000e/netdev.c:		err = request_irq(adapter->pdev->irq, e1000_intr_msi, 0,
drivers/net/ethernet/intel/e1000e/netdev.c:	err = request_irq(adapter->pdev->irq, e1000_intr, IRQF_SHARED,
drivers/net/ethernet/intel/e1000e/netdev.c:	free_irq(adapter->pdev->irq, netdev);
drivers/net/ethernet/intel/e1000e/netdev.c:		synchronize_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/e1000e/netdev.c:	ring->desc = dma_alloc_coherent(&pdev->dev, ring->size, &ring->dma,
drivers/net/ethernet/intel/e1000e/netdev.c:	dma_free_coherent(&pdev->dev, tx_ring->size, tx_ring->desc,
drivers/net/ethernet/intel/e1000e/netdev.c:	dma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,
drivers/net/ethernet/intel/e1000e/netdev.c:				dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:	err = request_irq(adapter->pdev->irq, e1000_intr_msi_test, 0,
drivers/net/ethernet/intel/e1000e/netdev.c:	free_irq(adapter->pdev->irq, netdev);
drivers/net/ethernet/intel/e1000e/netdev.c:	pm_runtime_get_sync(&pdev->dev);
drivers/net/ethernet/intel/e1000e/netdev.c:	pm_runtime_put(&pdev->dev);
drivers/net/ethernet/intel/e1000e/netdev.c:	pm_runtime_put_sync(&pdev->dev);
drivers/net/ethernet/intel/e1000e/netdev.c:	pm_runtime_get_sync(&pdev->dev);
drivers/net/ethernet/intel/e1000e/netdev.c:	pm_runtime_put_sync(&pdev->dev);
drivers/net/ethernet/intel/e1000e/netdev.c:		pm_runtime_get_sync(&adapter->pdev->dev);
drivers/net/ethernet/intel/e1000e/netdev.c:		pm_runtime_put_sync(&adapter->pdev->dev);
drivers/net/ethernet/intel/e1000e/netdev.c:		buffer_info->dma = dma_map_single(&pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:		if (dma_mapping_error(&pdev->dev, buffer_info->dma))
drivers/net/ethernet/intel/e1000e/netdev.c:			buffer_info->dma = skb_frag_dma_map(&pdev->dev, frag,
drivers/net/ethernet/intel/e1000e/netdev.c:			if (dma_mapping_error(&pdev->dev, buffer_info->dma))
drivers/net/ethernet/intel/e1000e/netdev.c:	dev_err(&pdev->dev, "Tx DMA map failed\n");
drivers/net/ethernet/intel/e1000e/netdev.c:		struct pci_dev *us_dev = pdev->bus->self;
drivers/net/ethernet/intel/e1000e/netdev.c:	if (pdev->bus->self)
drivers/net/ethernet/intel/e1000e/netdev.c:		pcie_capability_clear_word(pdev->bus->self, PCI_EXP_LNKCTL,
drivers/net/ethernet/intel/e1000e/netdev.c:	dev_info(&pdev->dev, "Disabling ASPM %s %s\n",
drivers/net/ethernet/intel/e1000e/netdev.c:		e1000_intr_msix(adapter->pdev->irq, netdev);
drivers/net/ethernet/intel/e1000e/netdev.c:		disable_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/e1000e/netdev.c:		e1000_intr_msi(adapter->pdev->irq, netdev);
drivers/net/ethernet/intel/e1000e/netdev.c:		enable_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/e1000e/netdev.c:		disable_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/e1000e/netdev.c:		e1000_intr(adapter->pdev->irq, netdev);
drivers/net/ethernet/intel/e1000e/netdev.c:		enable_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/e1000e/netdev.c:		dev_err(&pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:		pdev->state_saved = true;
drivers/net/ethernet/intel/e1000e/netdev.c:			dev_err(&pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:	err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/net/ethernet/intel/e1000e/netdev.c:		err = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/net/ethernet/intel/e1000e/netdev.c:		err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/net/ethernet/intel/e1000e/netdev.c:			err = dma_set_coherent_mask(&pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:				dev_err(&pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/intel/e1000e/netdev.c:	netdev->irq = pdev->irq;
drivers/net/ethernet/intel/e1000e/netdev.c:		dev_info(&pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:			dev_err(&pdev->dev, "The NVM Checksum Is Not Valid\n");
drivers/net/ethernet/intel/e1000e/netdev.c:		dev_err(&pdev->dev,
drivers/net/ethernet/intel/e1000e/netdev.c:		dev_err(&pdev->dev, "Invalid MAC Address: %pM\n",
drivers/net/ethernet/intel/e1000e/netdev.c:		device_wakeup_enable(&pdev->dev);
drivers/net/ethernet/intel/e1000e/netdev.c:		pm_runtime_put_noidle(&pdev->dev);
drivers/net/ethernet/intel/e1000e/netdev.c:		pm_runtime_get_noresume(&pdev->dev);
drivers/net/ethernet/intel/e1000e/ethtool.c:	regs->version = (1 << 24) | (adapter->pdev->revision << 16) |
drivers/net/ethernet/intel/e1000e/ethtool.c:	    adapter->pdev->device;
drivers/net/ethernet/intel/e1000e/ethtool.c:	eeprom->magic = adapter->pdev->vendor | (adapter->pdev->device << 16);
drivers/net/ethernet/intel/e1000e/ethtool.c:	    (adapter->pdev->vendor | (adapter->pdev->device << 16)))
drivers/net/ethernet/intel/e1000e/ethtool.c:	u32 irq = adapter->pdev->irq;
drivers/net/ethernet/intel/e1000e/ethtool.c:				dma_unmap_single(&pdev->dev,
drivers/net/ethernet/intel/e1000e/ethtool.c:				dma_unmap_single(&pdev->dev,
drivers/net/ethernet/intel/e1000e/ethtool.c:		dma_free_coherent(&pdev->dev, tx_ring->size, tx_ring->desc,
drivers/net/ethernet/intel/e1000e/ethtool.c:		dma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,
drivers/net/ethernet/intel/e1000e/ethtool.c:	tx_ring->desc = dma_alloc_coherent(&pdev->dev, tx_ring->size,
drivers/net/ethernet/intel/e1000e/ethtool.c:		    dma_map_single(&pdev->dev, skb->data, skb->len,
drivers/net/ethernet/intel/e1000e/ethtool.c:		if (dma_mapping_error(&pdev->dev,
drivers/net/ethernet/intel/e1000e/ethtool.c:	rx_ring->desc = dma_alloc_coherent(&pdev->dev, rx_ring->size,
drivers/net/ethernet/intel/e1000e/ethtool.c:		    dma_map_single(&pdev->dev, skb->data, 2048,
drivers/net/ethernet/intel/e1000e/ethtool.c:		if (dma_mapping_error(&pdev->dev,
drivers/net/ethernet/intel/e1000e/ethtool.c:			dma_sync_single_for_device(&pdev->dev,
drivers/net/ethernet/intel/e1000e/ethtool.c:			dma_sync_single_for_cpu(&pdev->dev,
drivers/net/ethernet/intel/e1000e/ethtool.c:	    !device_can_wakeup(&adapter->pdev->dev))
drivers/net/ethernet/intel/e1000e/ethtool.c:	    !device_can_wakeup(&adapter->pdev->dev) ||
drivers/net/ethernet/intel/e1000e/ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
drivers/net/ethernet/intel/e1000e/ich8lan.c:	if ((hw->adapter->pdev->device == E1000_DEV_ID_PCH_LPTLP_I218_LM) ||
drivers/net/ethernet/intel/e1000e/ich8lan.c:	    (hw->adapter->pdev->device == E1000_DEV_ID_PCH_LPTLP_I218_V)) {
drivers/net/ethernet/intel/e1000e/ich8lan.c:		if ((hw->adapter->pdev->device == E1000_DEV_ID_ICH8_IGP_AMT) ||
drivers/net/ethernet/intel/e1000e/ich8lan.c:		    (hw->adapter->pdev->device == E1000_DEV_ID_ICH8_IGP_C)) {
drivers/net/ethernet/intel/e1000e/ich8lan.c:		u16 phy_reg, device_id = hw->adapter->pdev->device;
drivers/net/ethernet/intel/e1000e/82571.c:	switch (hw->adapter->pdev->device) {
drivers/net/ethernet/intel/e1000e/82571.c:	switch (pdev->device) {
drivers/net/ethernet/intel/e1000e/82571.c:		if (((pdev->device == E1000_DEV_ID_82571EB_FIBER) ||
drivers/net/ethernet/intel/e1000e/82571.c:		     (pdev->device == E1000_DEV_ID_82571EB_SERDES) ||
drivers/net/ethernet/intel/e1000e/82571.c:		     (pdev->device == E1000_DEV_ID_82571EB_COPPER)) &&
drivers/net/ethernet/intel/e1000e/82571.c:		if (pdev->device == E1000_DEV_ID_82571EB_SERDES_QUAD)
drivers/net/ethernet/intel/e1000e/82571.c:		if (pdev->device == E1000_DEV_ID_82573L) {
drivers/net/ethernet/intel/e1000e/param.c:			dev_info(&adapter->pdev->dev, "%s Enabled\n",
drivers/net/ethernet/intel/e1000e/param.c:			dev_info(&adapter->pdev->dev, "%s Disabled\n",
drivers/net/ethernet/intel/e1000e/param.c:			dev_info(&adapter->pdev->dev, "%s set to %i\n",
drivers/net/ethernet/intel/e1000e/param.c:					dev_info(&adapter->pdev->dev, "%s\n",
drivers/net/ethernet/intel/e1000e/param.c:	dev_info(&adapter->pdev->dev, "Invalid %s value specified (%i) %s\n",
drivers/net/ethernet/intel/e1000e/param.c:		dev_notice(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/param.c:		dev_notice(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/param.c:				dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/param.c:			dev_info(&adapter->pdev->dev, "%s turned off\n",
drivers/net/ethernet/intel/e1000e/param.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/param.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/param.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/param.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/e1000e/mac.c:	cap_offset = adapter->pdev->pcie_cap;
drivers/net/ethernet/intel/e1000e/ptp.c:						&adapter->pdev->dev);
drivers/net/ethernet/intel/e100.c:	nic->mac = (nic->flags & ich) ? mac_82559_D101M : nic->pdev->revision;
drivers/net/ethernet/intel/e100.c:		err = request_firmware(&fw, fw_name, &nic->pdev->dev);
drivers/net/ethernet/intel/e100.c:	e100_intr(nic->pdev->irq, netdev);
drivers/net/ethernet/intel/e100.c:	return (nic->pdev->device >= 0x1050) && (nic->pdev->device <= 0x1057) &&
drivers/net/ethernet/intel/e100.c:	if ((err = request_irq(nic->pdev->irq, e100_intr, IRQF_SHARED,
drivers/net/ethernet/intel/e100.c:	free_irq(nic->pdev->irq, nic->netdev);
drivers/net/ethernet/intel/e100.c:	regs->version = (1 << 24) | nic->pdev->revision;
drivers/net/ethernet/intel/e100.c:	    !device_can_wakeup(&nic->pdev->dev))
drivers/net/ethernet/intel/e100.c:	device_set_wakeup_enable(&nic->pdev->dev, wol->wolopts);
drivers/net/ethernet/intel/e100.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/intel/e100.c:		device_set_wakeup_enable(&pdev->dev, true);
drivers/net/ethernet/intel/e100.c:		   pdev->irq, netdev->dev_addr);
drivers/net/ethernet/intel/e100.c:	if (0 != PCI_FUNC(pdev->devfn))
drivers/net/ethernet/intel/igb/igb_main.c:		dev_info(&adapter->pdev->dev, "Net device Info\n");
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&adapter->pdev->dev, "Register Dump\n");
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&adapter->pdev->dev, "TX Rings Summary\n");
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&adapter->pdev->dev, "TX Rings Dump\n");
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&adapter->pdev->dev, "RX Rings Summary\n");
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&adapter->pdev->dev, "RX Rings Dump\n");
drivers/net/ethernet/intel/igb/igb_main.c:		dev_info(&adapter->pdev->dev, "IOV Disabled\n");
drivers/net/ethernet/intel/igb/igb_main.c:		ring->dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/igb/igb_main.c:		ring->dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "Unable to allocate memory for vectors\n");
drivers/net/ethernet/intel/igb/igb_main.c:		err = request_irq(pdev->irq, igb_intr_msi, 0,
drivers/net/ethernet/intel/igb/igb_main.c:	err = request_irq(pdev->irq, igb_intr, IRQF_SHARED,
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "Error %d getting interrupt\n",
drivers/net/ethernet/intel/igb/igb_main.c:		free_irq(adapter->pdev->irq, adapter);
drivers/net/ethernet/intel/igb/igb_main.c:		synchronize_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "Hardware Error\n");
drivers/net/ethernet/intel/igb/igb_main.c:	adapter->i2c_adap.dev.parent = &adapter->pdev->dev;
drivers/net/ethernet/intel/igb/igb_main.c:	if (pdev->is_virtfn) {
drivers/net/ethernet/intel/igb/igb_main.c:			pci_name(pdev), pdev->vendor, pdev->device);
drivers/net/ethernet/intel/igb/igb_main.c:	err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/net/ethernet/intel/igb/igb_main.c:		err = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/net/ethernet/intel/igb/igb_main.c:		err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/net/ethernet/intel/igb/igb_main.c:			err = dma_set_coherent_mask(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:				dev_err(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/intel/igb/igb_main.c:	hw->vendor_id = pdev->vendor;
drivers/net/ethernet/intel/igb/igb_main.c:	hw->device_id = pdev->device;
drivers/net/ethernet/intel/igb/igb_main.c:	hw->revision_id = pdev->revision;
drivers/net/ethernet/intel/igb/igb_main.c:	hw->subsystem_vendor_id = pdev->subsystem_vendor;
drivers/net/ethernet/intel/igb/igb_main.c:	hw->subsystem_device_id = pdev->subsystem_device;
drivers/net/ethernet/intel/igb/igb_main.c:		dev_info(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:			dev_err(&pdev->dev, "The NVM Checksum Is Not Valid\n");
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "NVM Read Error\n");
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "Invalid MAC Address\n");
drivers/net/ethernet/intel/igb/igb_main.c:	switch (pdev->device) {
drivers/net/ethernet/intel/igb/igb_main.c:		if (!device_can_wakeup(&adapter->pdev->dev))
drivers/net/ethernet/intel/igb/igb_main.c:	    (pdev->subsystem_vendor == PCI_VENDOR_ID_HP)) {
drivers/net/ethernet/intel/igb/igb_main.c:	device_set_wakeup_enable(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "failed to init i2c interface\n");
drivers/net/ethernet/intel/igb/igb_main.c:	if (dca_add_requester(&pdev->dev) == 0) {
drivers/net/ethernet/intel/igb/igb_main.c:		dev_info(&pdev->dev, "DCA enabled\n");
drivers/net/ethernet/intel/igb/igb_main.c:			dev_err(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&pdev->dev, "Intel(R) Gigabit Ethernet Network Connection\n");
drivers/net/ethernet/intel/igb/igb_main.c:		dev_info(&pdev->dev, "%s: (PCIe:%s:%s) %pM\n",
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&pdev->dev, "%s: PBA No: %s\n", netdev->name, part_str);
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:	pm_runtime_put_noidle(&pdev->dev);
drivers/net/ethernet/intel/igb/igb_main.c:			dev_warn(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:		dev_info(&pdev->dev, "IOV Disabled\n");
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&pdev->dev, "%d VFs allocated\n",
drivers/net/ethernet/intel/igb/igb_main.c:	pm_runtime_get_noresume(&pdev->dev);
drivers/net/ethernet/intel/igb/igb_main.c:		dev_info(&pdev->dev, "DCA disabled\n");
drivers/net/ethernet/intel/igb/igb_main.c:		dca_remove_requester(&pdev->dev);
drivers/net/ethernet/intel/igb/igb_main.c:			dev_warn(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:			dev_warn(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "Unable to allocate memory for queues\n");
drivers/net/ethernet/intel/igb/igb_main.c:		pm_runtime_get_sync(&pdev->dev);
drivers/net/ethernet/intel/igb/igb_main.c:		pm_runtime_put(&pdev->dev);
drivers/net/ethernet/intel/igb/igb_main.c:		pm_runtime_put(&pdev->dev);
drivers/net/ethernet/intel/igb/igb_main.c:		pm_runtime_get_sync(&pdev->dev);
drivers/net/ethernet/intel/igb/igb_main.c:		pm_runtime_put_sync(&pdev->dev);
drivers/net/ethernet/intel/igb/igb_main.c:			dev_err(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:			dev_err(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "Invalid MTU setting\n");
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "MTU > 9216 not supported.\n");
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&pdev->dev, "changing MTU from %d to %d\n",
drivers/net/ethernet/intel/igb/igb_main.c:	u32 rxctrl = dca3_get_tag(&adapter->pdev->dev, cpu);
drivers/net/ethernet/intel/igb/igb_main.c:			dev_info(&pdev->dev, "DCA enabled\n");
drivers/net/ethernet/intel/igb/igb_main.c:			dev_info(&pdev->dev, "DCA disabled\n");
drivers/net/ethernet/intel/igb/igb_main.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "Error receiving message from VF\n");
drivers/net/ethernet/intel/igb/igb_main.c:			dev_warn(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:			dev_warn(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "Unhandled Msg %08x\n", msgbuf[0]);
drivers/net/ethernet/intel/igb/igb_main.c:	dev_err(&pdev->dev, "Unsupported Speed/Duplex configuration\n");
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "Unable to allocate memory for queues\n");
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev, "Unable to allocate memory for queues\n");
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:			dev_err(&pdev->dev, "igb_up failed after reset\n");
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&adapter->pdev->dev, "setting MAC %pM on VF %d\n", mac, vf);
drivers/net/ethernet/intel/igb/igb_main.c:	dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_main.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_ptp.c:		dev_warn(&adapter->pdev->dev, "clearing Tx timestamp hang");
drivers/net/ethernet/intel/igb/igb_ptp.c:		dev_warn(&adapter->pdev->dev, "clearing Rx timestamp hang");
drivers/net/ethernet/intel/igb/igb_ptp.c:						&adapter->pdev->dev);
drivers/net/ethernet/intel/igb/igb_ptp.c:		dev_err(&adapter->pdev->dev, "ptp_clock_register failed\n");
drivers/net/ethernet/intel/igb/igb_ptp.c:		dev_info(&adapter->pdev->dev, "added PHC on %s\n",
drivers/net/ethernet/intel/igb/igb_ptp.c:		dev_info(&adapter->pdev->dev, "removed PHC on %s\n",
drivers/net/ethernet/intel/igb/igb_ethtool.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_ethtool.c:			dev_err(&adapter->pdev->dev, "forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\n");
drivers/net/ethernet/intel/igb/igb_ethtool.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_ethtool.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_ethtool.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_ethtool.c:	u32 irq = adapter->pdev->irq;
drivers/net/ethernet/intel/igb/igb_ethtool.c:	dev_info(&adapter->pdev->dev, "testing %s interrupt\n",
drivers/net/ethernet/intel/igb/igb_ethtool.c:	tx_ring->dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/igb/igb_ethtool.c:	rx_ring->dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/igb/igb_ethtool.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_ethtool.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_ethtool.c:		dev_info(&adapter->pdev->dev, "offline testing starting\n");
drivers/net/ethernet/intel/igb/igb_ethtool.c:		dev_info(&adapter->pdev->dev, "online testing starting\n");
drivers/net/ethernet/intel/igb/igb_ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
drivers/net/ethernet/intel/igb/igb_ethtool.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_ethtool.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_ethtool.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_ethtool.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_ethtool.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_ethtool.c:	pm_runtime_get_sync(&adapter->pdev->dev);
drivers/net/ethernet/intel/igb/igb_ethtool.c:	pm_runtime_put(&adapter->pdev->dev);
drivers/net/ethernet/intel/igb/igb_hwmon.c:	rc = device_create_file(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_hwmon.c:		device_remove_file(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_hwmon.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/igb/igb_hwmon.c:	igb_hwmon->device = hwmon_device_register(&adapter->pdev->dev);
drivers/net/ethernet/intel/e1000/e1000.h:	dev_info(&adapter->pdev->dev, format, ## arg)
drivers/net/ethernet/intel/e1000/e1000.h:	dev_warn(&adapter->pdev->dev, format, ## arg)
drivers/net/ethernet/intel/e1000/e1000.h:	dev_err(&adapter->pdev->dev, format, ## arg)
drivers/net/ethernet/intel/e1000/e1000_main.c:	err = request_irq(adapter->pdev->irq, handler, irq_flags, netdev->name,
drivers/net/ethernet/intel/e1000/e1000_main.c:	free_irq(adapter->pdev->irq, netdev);
drivers/net/ethernet/intel/e1000/e1000_main.c:	synchronize_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/e1000/e1000_main.c:	switch (pdev->device) {
drivers/net/ethernet/intel/e1000/e1000_main.c:	hw->vendor_id = pdev->vendor;
drivers/net/ethernet/intel/e1000/e1000_main.c:	hw->device_id = pdev->device;
drivers/net/ethernet/intel/e1000/e1000_main.c:	hw->subsystem_vendor_id = pdev->subsystem_vendor;
drivers/net/ethernet/intel/e1000/e1000_main.c:	hw->subsystem_id = pdev->subsystem_device;
drivers/net/ethernet/intel/e1000/e1000_main.c:	hw->revision_id = pdev->revision;
drivers/net/ethernet/intel/e1000/e1000_main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/intel/e1000/e1000_main.c:	    !dma_set_mask(&pdev->dev, DMA_BIT_MASK(64))) {
drivers/net/ethernet/intel/e1000/e1000_main.c:		dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/net/ethernet/intel/e1000/e1000_main.c:		err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/net/ethernet/intel/e1000/e1000_main.c:		dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/net/ethernet/intel/e1000/e1000_main.c:	switch (pdev->device) {
drivers/net/ethernet/intel/e1000/e1000_main.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
drivers/net/ethernet/intel/e1000/e1000_main.c:	txdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
drivers/net/ethernet/intel/e1000/e1000_main.c:		txdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size,
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_free_coherent(&pdev->dev, txdr->size, olddesc,
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_free_coherent(&pdev->dev, txdr->size, txdr->desc,
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_free_coherent(&pdev->dev, txdr->size, olddesc,
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_free_coherent(&pdev->dev, txdr->size, olddesc,
drivers/net/ethernet/intel/e1000/e1000_main.c:	rxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,
drivers/net/ethernet/intel/e1000/e1000_main.c:		rxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size,
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_free_coherent(&pdev->dev, rxdr->size, olddesc,
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_free_coherent(&pdev->dev, rxdr->size, rxdr->desc,
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_free_coherent(&pdev->dev, rxdr->size, olddesc,
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_free_coherent(&pdev->dev, rxdr->size, olddesc,
drivers/net/ethernet/intel/e1000/e1000_main.c:	dma_free_coherent(&pdev->dev, tx_ring->size, tx_ring->desc,
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_unmap_page(&adapter->pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_unmap_single(&adapter->pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000/e1000_main.c:	dma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_unmap_single(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_unmap_page(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000/e1000_main.c:		buffer_info->dma = dma_map_single(&pdev->dev,
drivers/net/ethernet/intel/e1000/e1000_main.c:		if (dma_mapping_error(&pdev->dev, buffer_info->dma))
drivers/net/ethernet/intel/e1000/e1000_main.c:			buffer_info->dma = skb_frag_dma_map(&pdev->dev, frag,
drivers/net/ethernet/intel/e1000/e1000_main.c:			if (dma_mapping_error(&pdev->dev, buffer_info->dma))
drivers/net/ethernet/intel/e1000/e1000_main.c:	dev_err(&pdev->dev, "TX DMA map failed\n");
drivers/net/ethernet/intel/e1000/e1000_main.c:		dma_unmap_page(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000/e1000_main.c:		dma_unmap_single(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000/e1000_main.c:			buffer_info->dma = dma_map_page(&pdev->dev,
drivers/net/ethernet/intel/e1000/e1000_main.c:			if (dma_mapping_error(&pdev->dev, buffer_info->dma)) {
drivers/net/ethernet/intel/e1000/e1000_main.c:		buffer_info->dma = dma_map_single(&pdev->dev,
drivers/net/ethernet/intel/e1000/e1000_main.c:		if (dma_mapping_error(&pdev->dev, buffer_info->dma)) {
drivers/net/ethernet/intel/e1000/e1000_main.c:			dma_unmap_single(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/e1000/e1000_main.c:	disable_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/e1000/e1000_main.c:	e1000_intr(adapter->pdev->irq, netdev);
drivers/net/ethernet/intel/e1000/e1000_main.c:	enable_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:	u32 irq = adapter->pdev->irq;
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:				dma_unmap_single(&pdev->dev,
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:				dma_unmap_single(&pdev->dev,
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:		dma_free_coherent(&pdev->dev, txdr->size, txdr->desc,
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:		dma_free_coherent(&pdev->dev, rxdr->size, rxdr->desc,
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:	txdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:			dma_map_single(&pdev->dev, skb->data, skb->len,
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:		if (dma_mapping_error(&pdev->dev, txdr->buffer_info[i].dma)) {
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:	rxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:			dma_map_single(&pdev->dev, skb->data,
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:		if (dma_mapping_error(&pdev->dev, rxdr->buffer_info[i].dma)) {
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:			dma_sync_single_for_device(&pdev->dev,
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:			dma_sync_single_for_cpu(&pdev->dev,
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:	    !device_can_wakeup(&adapter->pdev->dev))
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:	    !device_can_wakeup(&adapter->pdev->dev))
drivers/net/ethernet/intel/e1000/e1000_ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	synchronize_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	err = request_irq(adapter->pdev->irq, ixgb_intr, irq_flags,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	free_irq(adapter->pdev->irq, netdev);
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/net/ethernet/intel/ixgb/ixgb_main.c:		err = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/net/ethernet/intel/ixgb/ixgb_main.c:		err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/net/ethernet/intel/ixgb/ixgb_main.c:			err = dma_set_coherent_mask(&pdev->dev,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	hw->vendor_id = pdev->vendor;
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	hw->device_id = pdev->device;
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	hw->subsystem_vendor_id = pdev->subsystem_vendor;
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	hw->subsystem_id = pdev->subsystem_device;
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	txdr->desc = dma_alloc_coherent(&pdev->dev, txdr->size, &txdr->dma,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	rxdr->desc = dma_alloc_coherent(&pdev->dev, rxdr->size, &rxdr->dma,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	dma_free_coherent(&pdev->dev, adapter->tx_ring.size,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:			dma_unmap_page(&adapter->pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:			dma_unmap_single(&adapter->pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	dma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:			dma_unmap_single(&pdev->dev,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:		buffer_info->dma = dma_map_single(&pdev->dev,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:		if (dma_mapping_error(&pdev->dev, buffer_info->dma))
drivers/net/ethernet/intel/ixgb/ixgb_main.c:				skb_frag_dma_map(&pdev->dev, frag, offset, size,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:			if (dma_mapping_error(&pdev->dev, buffer_info->dma))
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	dev_err(&pdev->dev, "TX DMA map failed\n");
drivers/net/ethernet/intel/ixgb/ixgb_main.c:		dma_unmap_single(&pdev->dev,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:		buffer_info->dma = dma_map_single(&pdev->dev,
drivers/net/ethernet/intel/ixgb/ixgb_main.c:		if (dma_mapping_error(&pdev->dev, buffer_info->dma)) {
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	disable_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	ixgb_intr(adapter->pdev->irq, dev);
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	enable_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/ixgb/ixgb_main.c:	if (0 != PCI_FUNC (pdev->devfn))
drivers/net/ethernet/intel/igbvf/netdev.c:				dma_map_page(&pdev->dev, buffer_info->page,
drivers/net/ethernet/intel/igbvf/netdev.c:			if (dma_mapping_error(&pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:				dev_err(&pdev->dev, "RX DMA map failed\n");
drivers/net/ethernet/intel/igbvf/netdev.c:			buffer_info->dma = dma_map_single(&pdev->dev, skb->data,
drivers/net/ethernet/intel/igbvf/netdev.c:			if (dma_mapping_error(&pdev->dev, buffer_info->dma)) {
drivers/net/ethernet/intel/igbvf/netdev.c:				dev_err(&pdev->dev, "RX DMA map failed\n");
drivers/net/ethernet/intel/igbvf/netdev.c:			dma_unmap_single(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/igbvf/netdev.c:			dma_unmap_single(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/igbvf/netdev.c:			dma_unmap_page(&pdev->dev, buffer_info->page_dma,
drivers/net/ethernet/intel/igbvf/netdev.c:			dma_unmap_page(&adapter->pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:			dma_unmap_single(&adapter->pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:	tx_ring->desc = dma_alloc_coherent(&pdev->dev, tx_ring->size,
drivers/net/ethernet/intel/igbvf/netdev.c:	dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:	rx_ring->desc = dma_alloc_coherent(&pdev->dev, rx_ring->size,
drivers/net/ethernet/intel/igbvf/netdev.c:	dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:	dma_free_coherent(&pdev->dev, tx_ring->size, tx_ring->desc,
drivers/net/ethernet/intel/igbvf/netdev.c:				dma_unmap_single(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/igbvf/netdev.c:				dma_unmap_single(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/intel/igbvf/netdev.c:				dma_unmap_page(&pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:	dma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,
drivers/net/ethernet/intel/igbvf/netdev.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:	dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:		dev_err(&adapter->pdev->dev, "Failed to add vlan id %d\n", vid);
drivers/net/ethernet/intel/igbvf/netdev.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:		dev_err(&adapter->pdev->dev, "PF still resetting\n");
drivers/net/ethernet/intel/igbvf/netdev.c:	dev_info(&adapter->pdev->dev, "Link is Up %d Mbps %s Duplex\n",
drivers/net/ethernet/intel/igbvf/netdev.c:			dev_info(&adapter->pdev->dev, "Link is Down\n");
drivers/net/ethernet/intel/igbvf/netdev.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:	buffer_info->dma = dma_map_single(&pdev->dev, skb->data, len,
drivers/net/ethernet/intel/igbvf/netdev.c:	if (dma_mapping_error(&pdev->dev, buffer_info->dma))
drivers/net/ethernet/intel/igbvf/netdev.c:		buffer_info->dma = skb_frag_dma_map(&pdev->dev, frag, 0, len,
drivers/net/ethernet/intel/igbvf/netdev.c:		if (dma_mapping_error(&pdev->dev, buffer_info->dma))
drivers/net/ethernet/intel/igbvf/netdev.c:	dev_err(&pdev->dev, "TX DMA map failed\n");
drivers/net/ethernet/intel/igbvf/netdev.c:		dev_err(&adapter->pdev->dev, "Invalid MTU setting\n");
drivers/net/ethernet/intel/igbvf/netdev.c:		dev_err(&adapter->pdev->dev, "MTU > 9216 not supported.\n");
drivers/net/ethernet/intel/igbvf/netdev.c:	dev_info(&adapter->pdev->dev, "changing MTU from %d to %d\n",
drivers/net/ethernet/intel/igbvf/netdev.c:		dev_err(&pdev->dev, "Cannot enable PCI device from suspend\n");
drivers/net/ethernet/intel/igbvf/netdev.c:	disable_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/igbvf/netdev.c:	enable_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/igbvf/netdev.c:		dev_err(&pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:			dev_err(&pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:		dev_info(&pdev->dev, "Intel(R) I350 Virtual Function\n");
drivers/net/ethernet/intel/igbvf/netdev.c:		dev_info(&pdev->dev, "Intel(R) 82576 Virtual Function\n");
drivers/net/ethernet/intel/igbvf/netdev.c:	dev_info(&pdev->dev, "Address: %pM\n", netdev->dev_addr);
drivers/net/ethernet/intel/igbvf/netdev.c:	err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/net/ethernet/intel/igbvf/netdev.c:		err = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/net/ethernet/intel/igbvf/netdev.c:		err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/net/ethernet/intel/igbvf/netdev.c:			err = dma_set_coherent_mask(&pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:				dev_err(&pdev->dev, "No usable DMA "
drivers/net/ethernet/intel/igbvf/netdev.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/intel/igbvf/netdev.c:	hw->vendor_id = pdev->vendor;
drivers/net/ethernet/intel/igbvf/netdev.c:	hw->device_id = pdev->device;
drivers/net/ethernet/intel/igbvf/netdev.c:	hw->subsystem_vendor_id = pdev->subsystem_vendor;
drivers/net/ethernet/intel/igbvf/netdev.c:	hw->subsystem_device_id = pdev->subsystem_device;
drivers/net/ethernet/intel/igbvf/netdev.c:	hw->revision_id = pdev->revision;
drivers/net/ethernet/intel/igbvf/netdev.c:		dev_info(&pdev->dev,
drivers/net/ethernet/intel/igbvf/netdev.c:			dev_info(&pdev->dev, "Error reading MAC address.\n");
drivers/net/ethernet/intel/igbvf/netdev.c:			dev_info(&pdev->dev, "MAC address not assigned by administrator.\n");
drivers/net/ethernet/intel/igbvf/netdev.c:		dev_info(&pdev->dev, "Assigning random MAC address.\n");
drivers/net/ethernet/intel/igbvf/ethtool.c:	regs->version = (1 << 24) | (adapter->pdev->revision << 16) |
drivers/net/ethernet/intel/igbvf/ethtool.c:			adapter->pdev->device;
drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c:	u32 irq = adapter->pdev->irq;
drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c:	tx_ring->dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c:	rx_ring->dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c:	    !device_can_wakeup(&adapter->pdev->dev))
drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	parent_bus = adapter->pdev->bus->parent;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		dev_info(&adapter->pdev->dev, "Net device Info\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	dev_info(&adapter->pdev->dev, "Register Dump\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	dev_info(&adapter->pdev->dev, "TX Rings Summary\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	dev_info(&adapter->pdev->dev, "TX Rings Dump\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	dev_info(&adapter->pdev->dev, "RX Rings Summary\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	dev_info(&adapter->pdev->dev, "RX Rings Dump\n");
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		err = request_irq(adapter->pdev->irq, ixgbe_intr, 0,
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		err = request_irq(adapter->pdev->irq, ixgbe_intr, IRQF_SHARED,
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		free_irq(adapter->pdev->irq, adapter);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		synchronize_irq(adapter->pdev->irq);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	hw->vendor_id = pdev->vendor;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	hw->device_id = pdev->device;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	hw->revision_id = pdev->revision;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	hw->subsystem_vendor_id = pdev->subsystem_vendor;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	hw->subsystem_device_id = pdev->subsystem_device;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		ixgbe_intr(adapter->pdev->irq, netdev);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	if (pdev->is_virtfn) {
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		     pci_name(pdev), pdev->vendor, pdev->device);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	if (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(64)) &&
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	    !dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64))) {
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:			err = dma_set_coherent_mask(&pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:				dev_err(&pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	hw->wol_enabled = ixgbe_wol_supported(adapter, pdev->device,
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:						pdev->subsystem_device);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	if (dca_add_requester(&pdev->dev) == 0) {
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:		dca_remove_requester(&pdev->dev);
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	bdev = pdev->bus->self;
drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:	if ((pf_func & 1) == (pdev->devfn & 1)) {
drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c:						&adapter->pdev->dev);
drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c:	rc = device_create_file(&adapter->pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c:		device_remove_file(&adapter->pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c:	ixgbe_hwmon->device = hwmon_device_register(&adapter->pdev->dev);
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	dev_info(&adapter->pdev->dev, "setting MAC %pM on VF %d\n", mac, vf);
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:	dev_info(&adapter->pdev->dev, "Reload the VF driver to make this"
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		dev_warn(&adapter->pdev->dev, "The VF MAC address has been set,"
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		dev_warn(&adapter->pdev->dev, "Bring the PF device up before"
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c:		dma_unmap_sg(&adapter->pdev->dev, ddp->sgl, ddp->sgc,
drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c:	dmacount = dma_map_sg(&adapter->pdev->dev, sgl, sgc, DMA_FROM_DEVICE);
drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c:	dma_unmap_sg(&adapter->pdev->dev, sgl, sgc, DMA_FROM_DEVICE);
drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c:		dma_unmap_sg(&adapter->pdev->dev, ddp->sgl,
drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c:	dma_unmap_single(&adapter->pdev->dev,
drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c:		ring->dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c:		ring->dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/ixgbe/ixgbe_common.h:	dev_info(&adapter->pdev->dev, format, ## arg)
drivers/net/ethernet/intel/ixgbe/ixgbe_common.h:	dev_warn(&adapter->pdev->dev, format, ## arg)
drivers/net/ethernet/intel/ixgbe/ixgbe_common.h:	dev_err(&adapter->pdev->dev, format, ## arg)
drivers/net/ethernet/intel/ixgbe/ixgbe_common.h:	dev_notice(&adapter->pdev->dev, format, ## arg)
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:			bi->dma = dma_map_single(&pdev->dev, skb->data,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:			if (dma_mapping_error(&pdev->dev, bi->dma)) {
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:				dev_err(&pdev->dev, "RX DMA map failed\n");
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:			dma_unmap_single(&pdev->dev, rx_buffer_info->dma,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:			dev_info(&pdev->dev,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:		rx_ring[i].dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:			dma_unmap_single(&pdev->dev, rx_buffer_info->dma,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:		adapter->tx_ring[i].dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:		adapter->rx_ring[i].dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	hw->vendor_id = pdev->vendor;
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	hw->device_id = pdev->device;
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	hw->revision_id = pdev->revision;
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	hw->subsystem_vendor_id = pdev->subsystem_vendor;
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	hw->subsystem_device_id = pdev->subsystem_device;
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:		dev_info(&pdev->dev,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:			dev_info(&pdev->dev, "Error reading MAC address\n");
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:			dev_info(&pdev->dev,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:		dev_info(&pdev->dev, "Assigning random MAC address\n");
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:			dev_info(&adapter->pdev->dev, "NIC Link is Down\n");
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	dma_free_coherent(&pdev->dev, tx_ring->size, tx_ring->desc,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	tx_ring->desc = dma_alloc_coherent(&pdev->dev, tx_ring->size,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	rx_ring->desc = dma_alloc_coherent(&pdev->dev, rx_ring->size,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	dma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:		rx_ring[i].dev = &adapter->pdev->dev;
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:		dev_err(&pdev->dev, "Cannot enable PCI device from suspend\n");
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:		dev_err(&pdev->dev, "Cannot initialize interrupts\n");
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	if (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(64)) &&
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	    !dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64))) {
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:		err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:			err = dma_set_coherent_mask(&pdev->dev,
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:				dev_err(&pdev->dev, "No usable DMA "
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:		dev_err(&pdev->dev, "pci_request_regions failed 0x%x\n", err);
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/silan/sc92031.c:	synchronize_irq(priv->pdev->irq);
drivers/net/ethernet/silan/sc92031.c:	err = request_irq(pdev->irq, sc92031_interrupt,
drivers/net/ethernet/silan/sc92031.c:	free_irq(pdev->irq, dev);
drivers/net/ethernet/silan/sc92031.c:	const int irq = priv->pdev->irq;
drivers/net/ethernet/silan/sc92031.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/silan/sc92031.c:	       pdev->irq);
drivers/net/ethernet/cirrus/ep93xx_eth.c:	data = pdev->dev.platform_data;
drivers/net/ethernet/cirrus/ep93xx_eth.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/cirrus/ep93xx_eth.c:				     dev_name(&pdev->dev));
drivers/net/ethernet/cirrus/ep93xx_eth.c:		dev_err(&pdev->dev, "Could not reserve memory region\n");
drivers/net/ethernet/cirrus/ep93xx_eth.c:		dev_err(&pdev->dev, "Failed to ioremap ethernet registers\n");
drivers/net/ethernet/cirrus/ep93xx_eth.c:		dev_err(&pdev->dev, "Failed to register netdev\n");
drivers/net/ethernet/packetengines/yellowfin.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/packetengines/yellowfin.c:	irq = pdev->irq;
drivers/net/ethernet/packetengines/hamachi.c:	irq = pdev->irq;
drivers/net/ethernet/packetengines/hamachi.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/tehuti/tehuti.c:		rc = request_firmware(&fw, "tehuti/bdx.bin", &priv->pdev->dev);
drivers/net/ethernet/tehuti/tehuti.c:	rc = request_irq(priv->pdev->irq, bdx_isr_napi, BDX_IRQ_TYPE,
drivers/net/ethernet/tehuti/tehuti.c:	free_irq(priv->pdev->irq, priv->ndev);
drivers/net/ethernet/tehuti/tehuti.c:	RET((priv->pdev->device == 0x3009)
drivers/net/ethernet/tehuti/tehuti.c:		db->wptr->addr.dma = skb_frag_dma_map(&priv->pdev->dev, frag,
drivers/net/ethernet/tehuti/tehuti.c:	if (pdev->irq < 2) {
drivers/net/ethernet/tehuti/tehuti.c:		pr_err("invalid irq (%d)\n", pdev->irq);
drivers/net/ethernet/tehuti/tehuti.c:	if (pdev->device == 0x3014)
drivers/net/ethernet/tehuti/tehuti.c:		SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/sgi/meth.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/sgi/ioc3-eth.c:	struct pci_dev *dev = pci_get_slot(pdev->bus, PCI_DEVFN(slot, 0));
drivers/net/ethernet/sgi/ioc3-eth.c:	return pdev->bus->parent == NULL &&
drivers/net/ethernet/sgi/ioc3-eth.c:	if (ioc3_is_menet(pdev) && PCI_SLOT(pdev->devfn) == 3)
drivers/net/ethernet/sgi/ioc3-eth.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/sgi/ioc3-eth.c:	dev->irq = pdev->irq;
drivers/net/ethernet/korina.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/adi/bfin_mac.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/adi/bfin_mac.c:		dev_err(&pdev->dev, "Cannot detect Blackfin on-chip ethernet MAC controller!\n");
drivers/net/ethernet/adi/bfin_mac.c:	if (!pdev->dev.platform_data) {
drivers/net/ethernet/adi/bfin_mac.c:		dev_err(&pdev->dev, "Cannot get platform device bfin_mii_bus!\n");
drivers/net/ethernet/adi/bfin_mac.c:	pd = pdev->dev.platform_data;
drivers/net/ethernet/adi/bfin_mac.c:		dev_err(&pdev->dev, "Cannot get mii_bus!\n");
drivers/net/ethernet/adi/bfin_mac.c:		dev_err(&pdev->dev, "MII Probe failed!\n");
drivers/net/ethernet/adi/bfin_mac.c:		dev_err(&pdev->dev, "Cannot request Blackfin MAC RX IRQ!\n");
drivers/net/ethernet/adi/bfin_mac.c:		dev_err(&pdev->dev, "Cannot register net device!\n");
drivers/net/ethernet/adi/bfin_mac.c:	rc = bfin_phc_init(ndev, &pdev->dev);
drivers/net/ethernet/adi/bfin_mac.c:		dev_err(&pdev->dev, "Cannot register PHC device!\n");
drivers/net/ethernet/adi/bfin_mac.c:	mii_bus_pd = dev_get_platdata(&pdev->dev);
drivers/net/ethernet/adi/bfin_mac.c:		dev_err(&pdev->dev, "No peripherals in platform data!\n");
drivers/net/ethernet/adi/bfin_mac.c:		dev_err(&pdev->dev, "Requesting peripherals failed!\n");
drivers/net/ethernet/adi/bfin_mac.c:	miibus->parent = &pdev->dev;
drivers/net/ethernet/adi/bfin_mac.c:		pdev->name, pdev->id);
drivers/net/ethernet/adi/bfin_mac.c:		dev_err(&pdev->dev, "Invalid number (%i) of phydevs\n",
drivers/net/ethernet/adi/bfin_mac.c:			dev_err(&pdev->dev,
drivers/net/ethernet/adi/bfin_mac.c:		dev_err(&pdev->dev, "Cannot register MDIO bus!\n");
drivers/net/ethernet/adi/bfin_mac.c:		dev_get_platdata(&pdev->dev);
drivers/net/ethernet/toshiba/tc35815.c:		dev_printk(KERN_DEBUG, &pdev->dev,
drivers/net/ethernet/toshiba/tc35815.c:	if (!pdev->irq) {
drivers/net/ethernet/toshiba/tc35815.c:		dev_warn(&pdev->dev, "no IRQ assigned.\n");
drivers/net/ethernet/toshiba/tc35815.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/toshiba/tc35815.c:	dev->irq = pdev->irq;
drivers/net/ethernet/toshiba/tc35815.c:		dev_warn(&pdev->dev, "not valid ether addr\n");
drivers/net/ethernet/toshiba/spider_net.c:	dma_free_coherent(&card->pdev->dev, chain->num_desc,
drivers/net/ethernet/toshiba/spider_net.c:	chain->hwring = dma_alloc_coherent(&card->pdev->dev, alloc_size,
drivers/net/ethernet/toshiba/spider_net.c:			     SPIDER_NET_FIRMWARE_NAME, &card->pdev->dev) == 0) {
drivers/net/ethernet/toshiba/spider_net.c:	SET_NETDEV_DEV(netdev, &card->pdev->dev);
drivers/net/ethernet/toshiba/spider_net.c:	netdev->irq = card->pdev->irq;
drivers/net/ethernet/toshiba/spider_net.c:	netdev->irq = card->pdev->irq;
drivers/net/ethernet/toshiba/spider_net.c:		dev_err(&pdev->dev, "Couldn't enable PCI device\n");
drivers/net/ethernet/toshiba/spider_net.c:		dev_err(&pdev->dev,
drivers/net/ethernet/toshiba/spider_net.c:		dev_err(&pdev->dev,
drivers/net/ethernet/toshiba/spider_net.c:		dev_err(&pdev->dev,
drivers/net/ethernet/toshiba/spider_net.c:		dev_err(&pdev->dev,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_ethtool.c:	regs->version = 0x1000000 | (__u32)pdev->revision << 16 | pdev->device;
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	free_irq(adapter->pdev->irq, netdev);
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	synchronize_irq(adapter->pdev->irq);
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:		dma_unmap_single(&adapter->pdev->dev, buffer_info->dma,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:		dma_unmap_single(&adapter->pdev->dev, buffer_info->dma,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	buffer_info->dma = dma_map_single(&adapter->pdev->dev, tmp_skb->data,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	if (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) {
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	if ((pdev->error_state) && (pdev->error_state != pci_channel_io_normal))
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:		buffer_info->dma = dma_map_single(&pdev->dev,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:		if (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) {
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	rx_ring->rx_buff_pool = dma_alloc_coherent(&pdev->dev, size,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:			dma_unmap_single(&adapter->pdev->dev, buffer_info->dma,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:		dma_unmap_single(&pdev->dev, buffer_info->dma,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	tx_ring->desc = dma_alloc_coherent(&pdev->dev, tx_ring->size,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	rx_ring->desc =	dma_alloc_coherent(&pdev->dev, rx_ring->size,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	err = request_irq(adapter->pdev->irq, &pch_gbe_intr,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	if ((pdev->error_state) && (pdev->error_state != pci_channel_io_normal))
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	disable_irq(adapter->pdev->irq);
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	pch_gbe_intr(adapter->pdev->irq, netdev);
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	enable_irq(adapter->pdev->irq);
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:				dev_err(&pdev->dev, "ERR: No usable DMA "
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:		dev_err(&pdev->dev, "Can't ioremap\n");
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	adapter->ptp_pdev = pci_get_bus_and_slot(adapter->pdev->bus->number,
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:		dev_err(&pdev->dev, "PHY initialize error\n");
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:		dev_err(&pdev->dev, "MAC address Read Error\n");
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:		dev_err(&pdev->dev, "Invalid MAC address, "
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	dev_info(&pdev->dev, "MAC address : %pM\n", netdev->dev_addr);
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	dev_dbg(&pdev->dev, "PCH Network Connection\n");
drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c:	device_set_wakeup_enable(&pdev->dev, 1);
drivers/net/ethernet/cadence/macb.c:	pdata = bp->pdev->dev.platform_data;
drivers/net/ethernet/cadence/macb.c:	pdata = dev_get_platdata(&bp->pdev->dev);
drivers/net/ethernet/cadence/macb.c:		ret = devm_gpio_request(&bp->pdev->dev, pdata->phy_irq_pin, "phy int");
drivers/net/ethernet/cadence/macb.c:		bp->pdev->name, bp->pdev->id);
drivers/net/ethernet/cadence/macb.c:	pdata = bp->pdev->dev.platform_data;
drivers/net/ethernet/cadence/macb.c:		dma_unmap_single(&bp->pdev->dev, tx_skb->mapping, skb->len,
drivers/net/ethernet/cadence/macb.c:		dma_unmap_single(&bp->pdev->dev, tx_skb->mapping, skb->len,
drivers/net/ethernet/cadence/macb.c:	mapping = dma_map_single(&bp->pdev->dev, skb->data,
drivers/net/ethernet/cadence/macb.c:		dma_free_coherent(&bp->pdev->dev, RX_RING_BYTES,
drivers/net/ethernet/cadence/macb.c:		dma_free_coherent(&bp->pdev->dev, TX_RING_BYTES,
drivers/net/ethernet/cadence/macb.c:		dma_free_coherent(&bp->pdev->dev,
drivers/net/ethernet/cadence/macb.c:	bp->rx_ring = dma_alloc_coherent(&bp->pdev->dev, size,
drivers/net/ethernet/cadence/macb.c:	bp->tx_ring = dma_alloc_coherent(&bp->pdev->dev, size,
drivers/net/ethernet/cadence/macb.c:	bp->rx_buffers = dma_alloc_coherent(&bp->pdev->dev, size,
drivers/net/ethernet/cadence/macb.c:		dev_err(&pdev->dev, "no mmio resource defined\n");
drivers/net/ethernet/cadence/macb.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/net/ethernet/cadence/macb.c:		dev_warn(&pdev->dev, "No pinctrl provided\n");
drivers/net/ethernet/cadence/macb.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/cadence/macb.c:	bp->pclk = clk_get(&pdev->dev, "pclk");
drivers/net/ethernet/cadence/macb.c:		dev_err(&pdev->dev, "failed to get macb_clk\n");
drivers/net/ethernet/cadence/macb.c:	bp->hclk = clk_get(&pdev->dev, "hclk");
drivers/net/ethernet/cadence/macb.c:		dev_err(&pdev->dev, "failed to get hclk\n");
drivers/net/ethernet/cadence/macb.c:		dev_err(&pdev->dev, "failed to map registers, aborting.\n");
drivers/net/ethernet/cadence/macb.c:		dev_err(&pdev->dev, "Unable to request IRQ %d (error %d)\n",
drivers/net/ethernet/cadence/macb.c:	mac = of_get_mac_address(pdev->dev.of_node);
drivers/net/ethernet/cadence/macb.c:	err = of_get_phy_mode(pdev->dev.of_node);
drivers/net/ethernet/cadence/macb.c:		pdata = pdev->dev.platform_data;
drivers/net/ethernet/cadence/macb.c:		dev_err(&pdev->dev, "Cannot register net device, aborting.\n");
drivers/net/ethernet/cadence/at91_ether.c:	lp->rx_ring = dma_alloc_coherent(&lp->pdev->dev,
drivers/net/ethernet/cadence/at91_ether.c:	lp->rx_buffers = dma_alloc_coherent(&lp->pdev->dev,
drivers/net/ethernet/cadence/at91_ether.c:		dma_free_coherent(&lp->pdev->dev,
drivers/net/ethernet/cadence/at91_ether.c:	dma_free_coherent(&lp->pdev->dev,
drivers/net/ethernet/cadence/at91_ether.c:	dma_free_coherent(&lp->pdev->dev,
drivers/net/ethernet/cadence/at91_ether.c:	struct macb_platform_data *board_data = pdev->dev.platform_data;
drivers/net/ethernet/cadence/at91_ether.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/net/ethernet/cadence/at91_ether.c:		dev_warn(&pdev->dev, "No pinctrl provided\n");
drivers/net/ethernet/cadence/at91_ether.c:	lp->regs = devm_ioremap(&pdev->dev, regs->start, resource_size(regs));
drivers/net/ethernet/cadence/at91_ether.c:	lp->pclk = devm_clk_get(&pdev->dev, "ether_clk");
drivers/net/ethernet/cadence/at91_ether.c:	res = devm_request_irq(&pdev->dev, dev->irq, at91ether_interrupt, 0, dev->name, dev);
drivers/net/ethernet/cadence/at91_ether.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/cadence/at91_ether.c:	mac = of_get_mac_address(pdev->dev.of_node);
drivers/net/ethernet/cadence/at91_ether.c:	res = of_get_phy_mode(pdev->dev.of_node);
drivers/net/ethernet/3com/3c509.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/3com/3c509.c:	return el3_suspend(&pdev->dev, state);
drivers/net/ethernet/3com/3c509.c:	return el3_resume(&pdev->dev);
drivers/net/ethernet/3com/3c59x.c:	rc = vortex_probe1(&pdev->dev, ioaddr, pdev->irq,
drivers/net/ethernet/3com/3c59x.c:	/* if we are a PCI driver, we store info in pdev->driver_data
drivers/net/ethernet/3com/typhoon.c:	err = request_firmware(&typhoon_fw, FIRMWARE_NAME, &tp->pdev->dev);
drivers/net/ethernet/3com/typhoon.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/3com/typhoon.c:	dev->irq = pdev->irq;
drivers/net/ethernet/cisco/enic/enic_main.c:	return enic->pdev->device == PCI_DEVICE_ID_CISCO_VIC_ENET_DYN;
drivers/net/ethernet/cisco/enic/enic_main.c:	return enic->pdev->device == PCI_DEVICE_ID_CISCO_VIC_ENET_VF;
drivers/net/ethernet/cisco/enic/enic_main.c:			skb_frag_dma_map(&enic->pdev->dev,
drivers/net/ethernet/cisco/enic/enic_main.c:			dma_addr = skb_frag_dma_map(&enic->pdev->dev, frag,
drivers/net/ethernet/cisco/enic/enic_main.c:		free_irq(enic->pdev->irq, netdev);
drivers/net/ethernet/cisco/enic/enic_main.c:		free_irq(enic->pdev->irq, enic);
drivers/net/ethernet/cisco/enic/enic_main.c:		err = request_irq(enic->pdev->irq, enic_isr_legacy,
drivers/net/ethernet/cisco/enic/enic_main.c:		err = request_irq(enic->pdev->irq, enic_isr_msi,
drivers/net/ethernet/cisco/enic/enic_main.c:		synchronize_irq(enic->pdev->irq);
drivers/net/ethernet/cisco/enic/enic_main.c:		enic_isr_msi(enic->pdev->irq, enic);
drivers/net/ethernet/cisco/enic/enic_main.c:		enic_isr_legacy(enic->pdev->irq, netdev);
drivers/net/ethernet/cisco/enic/enic_main.c:	struct device *dev = &pdev->dev;
drivers/net/ethernet/cisco/enic/enic_main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/cisco/enic/enic.h:	return &(enic->pdev->dev);
drivers/net/ethernet/ethoc.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/ethoc.c:		dev_err(&pdev->dev, "cannot obtain I/O memory space\n");
drivers/net/ethernet/ethoc.c:	mmio = devm_request_mem_region(&pdev->dev, res->start,
drivers/net/ethernet/ethoc.c:		dev_err(&pdev->dev, "cannot request I/O memory space\n");
drivers/net/ethernet/ethoc.c:		mem = devm_request_mem_region(&pdev->dev, res->start,
drivers/net/ethernet/ethoc.c:			dev_err(&pdev->dev, "cannot request memory space\n");
drivers/net/ethernet/ethoc.c:		dev_err(&pdev->dev, "cannot obtain IRQ\n");
drivers/net/ethernet/ethoc.c:	priv->iobase = devm_ioremap_nocache(&pdev->dev, netdev->base_addr,
drivers/net/ethernet/ethoc.c:		dev_err(&pdev->dev, "cannot remap I/O memory space\n");
drivers/net/ethernet/ethoc.c:		priv->membase = devm_ioremap_nocache(&pdev->dev,
drivers/net/ethernet/ethoc.c:			dev_err(&pdev->dev, "cannot remap memory space\n");
drivers/net/ethernet/ethoc.c:		priv->membase = dmam_alloc_coherent(&pdev->dev,
drivers/net/ethernet/ethoc.c:			dev_err(&pdev->dev, "cannot allocate %dB buffer\n",
drivers/net/ethernet/ethoc.c:	dev_dbg(&pdev->dev, "ethoc: num_tx: %d num_rx: %d\n",
drivers/net/ethernet/ethoc.c:	priv->vma = devm_kzalloc(&pdev->dev, num_bd*sizeof(void *), GFP_KERNEL);
drivers/net/ethernet/ethoc.c:	if (pdev->dev.platform_data) {
drivers/net/ethernet/ethoc.c:		struct ethoc_platform_data *pdata = pdev->dev.platform_data;
drivers/net/ethernet/ethoc.c:		mac = of_get_property(pdev->dev.of_node,
drivers/net/ethernet/ethoc.c:			priv->mdio->name, pdev->id);
drivers/net/ethernet/dec/tulip/de2104x.c:	const int irq = de->pdev->irq;
drivers/net/ethernet/dec/tulip/de2104x.c:	free_irq(de->pdev->irq, dev);
drivers/net/ethernet/dec/tulip/de2104x.c:	const int irq = de->pdev->irq;
drivers/net/ethernet/dec/tulip/de2104x.c:			if (de->pdev->revision < 0x20)
drivers/net/ethernet/dec/tulip/de2104x.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/dec/tulip/de2104x.c:	if (pdev->irq < 2) {
drivers/net/ethernet/dec/tulip/de2104x.c:		       pdev->irq, pci_name(pdev));
drivers/net/ethernet/dec/tulip/de2104x.c:		    regs, dev->dev_addr, pdev->irq);
drivers/net/ethernet/dec/tulip/de2104x.c:		const int irq = pdev->irq;
drivers/net/ethernet/dec/tulip/uli526x.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/dec/tulip/uli526x.c:		    dev->dev_addr, pdev->irq);
drivers/net/ethernet/dec/tulip/uli526x.c:	ret = request_irq(db->pdev->irq, uli526x_interrupt, IRQF_SHARED,
drivers/net/ethernet/dec/tulip/uli526x.c:	free_irq(db->pdev->irq, dev);
drivers/net/ethernet/dec/tulip/uli526x.c:	uli526x_interrupt(db->pdev->irq, dev);
drivers/net/ethernet/dec/tulip/winbond-840.c:	irq = pdev->irq;
drivers/net/ethernet/dec/tulip/winbond-840.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/dec/tulip/interrupt.c:			if (dma_mapping_error(&tp->pdev->dev, mapping)) {
drivers/net/ethernet/dec/tulip/de4x5.c:    list_for_each_entry(this_dev, &pdev->bus->devices, bus_list) {
drivers/net/ethernet/dec/tulip/de4x5.c:	dev_num = PCI_SLOT(pdev->devfn);
drivers/net/ethernet/dec/tulip/de4x5.c:	pb = pdev->bus->number;
drivers/net/ethernet/dec/tulip/de4x5.c:	vendor = pdev->vendor;
drivers/net/ethernet/dec/tulip/de4x5.c:	device = pdev->device << 8;
drivers/net/ethernet/dec/tulip/de4x5.c:	lp->cfrv = pdev->revision;
drivers/net/ethernet/dec/tulip/de4x5.c:	irq = pdev->irq;
drivers/net/ethernet/dec/tulip/de4x5.c:	if ((error = de4x5_hw_init(dev, iobase, &pdev->dev))) {
drivers/net/ethernet/dec/tulip/de4x5.c:	dev = dev_get_drvdata(&pdev->dev);
drivers/net/ethernet/dec/tulip/dmfe.c:	if ((ent->driver_data == PCI_DM9100_ID && pdev->revision >= 0x30) ||
drivers/net/ethernet/dec/tulip/dmfe.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/dec/tulip/dmfe.c:	db->chip_revision = pdev->revision;
drivers/net/ethernet/dec/tulip/dmfe.c:		 pci_name(pdev), dev->dev_addr, pdev->irq);
drivers/net/ethernet/dec/tulip/dmfe.c:	const int irq = db->pdev->irq;
drivers/net/ethernet/dec/tulip/dmfe.c:	free_irq(db->pdev->irq, dev);
drivers/net/ethernet/dec/tulip/dmfe.c:	const int irq = db->pdev->irq;
drivers/net/ethernet/dec/tulip/xircom_cb.c:	struct device *d = &pdev->dev;
drivers/net/ethernet/dec/tulip/xircom_cb.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/dec/tulip/xircom_cb.c:		    pdev->revision, pdev->irq);
drivers/net/ethernet/dec/tulip/xircom_cb.c:	struct device *d = &pdev->dev;
drivers/net/ethernet/dec/tulip/xircom_cb.c:	const int irq = xp->pdev->irq;
drivers/net/ethernet/dec/tulip/xircom_cb.c:	free_irq(card->pdev->irq, dev);
drivers/net/ethernet/dec/tulip/xircom_cb.c:	const int irq = xp->pdev->irq;
drivers/net/ethernet/dec/tulip/tulip_core.c:		netdev_dbg(dev, "tulip_up(), irq==%d\n", tp->pdev->irq);
drivers/net/ethernet/dec/tulip/tulip_core.c:	retval = request_irq(tp->pdev->irq, tulip_interrupt, IRQF_SHARED,
drivers/net/ethernet/dec/tulip/tulip_core.c:	free_irq (tp->pdev->irq, dev);
drivers/net/ethernet/dec/tulip/tulip_core.c:	device_set_wakeup_enable(&tp->pdev->dev, tp->wolinfo.wolopts);
drivers/net/ethernet/dec/tulip/tulip_core.c:	if (pdev->vendor == 0x1282 && pdev->device == 0x9102)
drivers/net/ethernet/dec/tulip/tulip_core.c:        if (pdev->subsystem_vendor == PCI_VENDOR_ID_LMC) {
drivers/net/ethernet/dec/tulip/tulip_core.c:	} else if (pdev->subsystem_vendor == PCI_VENDOR_ID_SBE &&
drivers/net/ethernet/dec/tulip/tulip_core.c:		   (pdev->subsystem_device == PCI_SUBDEVICE_ID_SBE_T3E3 ||
drivers/net/ethernet/dec/tulip/tulip_core.c:		    pdev->subsystem_device == PCI_SUBDEVICE_ID_SBE_2T3E3_P0 ||
drivers/net/ethernet/dec/tulip/tulip_core.c:		    pdev->subsystem_device == PCI_SUBDEVICE_ID_SBE_2T3E3_P1)) {
drivers/net/ethernet/dec/tulip/tulip_core.c:		if (pdev->vendor == 0x1282 && pdev->device == 0x9100 &&
drivers/net/ethernet/dec/tulip/tulip_core.c:		    pdev->revision < 0x30) {
drivers/net/ethernet/dec/tulip/tulip_core.c:	irq = pdev->irq;
drivers/net/ethernet/dec/tulip/tulip_core.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/dec/tulip/tulip_core.c:	tp->revision = pdev->revision;
drivers/net/ethernet/dec/tulip/tulip_core.c:	if (pdev->subsystem_vendor == PCI_VENDOR_ID_HP) {
drivers/net/ethernet/dec/tulip/tulip_core.c:		switch (pdev->subsystem_device) {
drivers/net/ethernet/dec/tulip/tulip_core.c:               if ((pdev->bus->number == 0) &&
drivers/net/ethernet/dec/tulip/tulip_core.c:                   ((PCI_SLOT(pdev->devfn) == 7) ||
drivers/net/ethernet/dec/tulip/tulip_core.c:                    (PCI_SLOT(pdev->devfn) == 12))) {
drivers/net/ethernet/dec/tulip/tulip_core.c:		 chip_name, pdev->revision,
drivers/net/ethernet/dec/tulip/tulip_core.c:	free_irq(tp->pdev->irq, dev);
drivers/net/ethernet/dec/tulip/tulip_core.c:	retval = request_irq(pdev->irq, tulip_interrupt, IRQF_SHARED,
drivers/net/ethernet/dec/tulip/tulip_core.c:	const int irq = tp->pdev->irq;
drivers/net/ethernet/apple/macmace.c:	mp->device = &pdev->dev;
drivers/net/ethernet/apple/macmace.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dev_err(&mgp->pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	dev_err(&mgp->pdev->dev, "command %d timed out, result = %d\n",
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	dev_err(&mgp->pdev->dev, "failed to parse eeprom_strings\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&mgp->pdev->dev, "dummy rdma %s failed\n",
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	struct device *dev = &mgp->pdev->dev;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	struct device *dev = &mgp->pdev->dev;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	struct device *dev = &mgp->pdev->dev;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&mgp->pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_warn(&mgp->pdev->dev, "hotplug firmware loading failed\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dev_err(&mgp->pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_info(&mgp->pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dev_warn(&mgp->pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dev_warn(&mgp->pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dev_warn(&mgp->pdev->dev, "via hotplug\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&mgp->pdev->dev, "handoff failed\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_warn(&mgp->pdev->dev, "DMA %s benchmark failed: %d\n",
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&mgp->pdev->dev, "failed reset\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dev_err(&mgp->pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dev_err(&mgp->pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&mgp->pdev->dev, "failed set interrupt parameters\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		tag = dca3_get_tag(&ss->mgp->pdev->dev, cpu);
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev, "dca disabled by administrator\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	err = dca_add_requester(&pdev->dev);
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dev_err(&pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	dca_remove_requester(&pdev->dev);
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	data[i++] = (unsigned int)mgp->pdev->irq;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	struct device *dev = &mgp->pdev->dev;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:				dev_err(&pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:				dev_err(&pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:				dev_err(&pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		status = request_irq(pdev->irq, myri10ge_intr, IRQF_SHARED,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dev_err(&pdev->dev, "failed to allocate IRQ\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		free_irq(pdev->irq, &mgp->ss[0]);
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		bus = skb_frag_dma_map(&mgp->pdev->dev, frag, 0, len,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	struct pci_dev *bridge = mgp->pdev->bus->self;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	struct device *dev = &mgp->pdev->dev;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	struct device *dev = &pdev->dev;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dev_info(&mgp->pdev->dev, "PCIE x%d Link\n",
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dev_info(&mgp->pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dev_info(&mgp->pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_info(&mgp->pdev->dev, "overriding firmware to %s\n",
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	struct pci_dev *bridge = pdev->bus->self;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev, "failed to enable device\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dma_free_coherent(&pdev->dev, bytes,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			dma_free_coherent(&pdev->dev, bytes,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		ss->rx_done.entry = dma_alloc_coherent(&pdev->dev, bytes,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		ss->fw_stats = dma_alloc_coherent(&pdev->dev, bytes,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_info(&mgp->pdev->dev, "overriding rss firmware to %s\n",
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_info(&pdev->dev, "Rss firmware not found\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&mgp->pdev->dev, "failed reset\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&mgp->pdev->dev, "failed MXGEFW_CMD_SET_INTRQ_SIZE\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	struct device *dev = &pdev->dev;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev, "pci_enable_device call failed\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev, "Error %d writing PCI_EXP_DEVCTL\n",
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev, "Error %d setting DMA mask\n", status);
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	mgp->cmd = dma_alloc_coherent(&pdev->dev, sizeof(*mgp->cmd),
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev, "ioremap failed for %ld bytes at 0x%lx\n",
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev, "failed to load firmware\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev, "failed to alloc slice state\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev, "failed reset\n");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev, "register_netdev failed: %d\n", status);
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			 pdev->irq, mgp->tx_boundary, mgp->fw_name,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		dev_err(&pdev->dev,
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	dma_free_coherent(&pdev->dev, sizeof(*mgp->cmd),
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	dma_free_coherent(&pdev->dev, sizeof(*mgp->cmd),
drivers/net/ethernet/sis/sis900.c:	free_irq(pdev->irq, net_dev);
drivers/net/ethernet/sis/sis190.c:	rc = request_irq(pdev->irq, sis190_irq, IRQF_SHARED, dev->name, dev);
drivers/net/ethernet/sis/sis190.c:	free_irq(pdev->irq, dev);
drivers/net/ethernet/sis/sis190.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/sis/sis190.c:			    ioaddr, pdev->irq, dev->dev_addr);
drivers/net/ethernet/hp/hp100.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c:	struct device_node *np = pdev->dev.of_node;
drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c:	device = of_match_device(stmmac_dt_ids, &pdev->dev);
drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c:		dev_warn(&pdev->dev, "snps,phy-addr property is deprecated\n");
drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c:			devm_kzalloc(&pdev->dev,
drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c:		dma_cfg = devm_kzalloc(&pdev->dev, sizeof(*dma_cfg),
drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c:	 struct device *dev = &pdev->dev;
drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c:	plat_dat = dev_get_platdata(&pdev->dev);
drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c:	if (pdev->dev.of_node) {
drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c:			plat_dat = devm_kzalloc(&pdev->dev,
drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c:	priv = stmmac_dvr_probe(&(pdev->dev), plat_dat, addr);
drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c:	dwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);
drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c:	dwmac->reg = devm_ioremap_resource(&pdev->dev, res);
drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c:	priv = stmmac_dvr_probe(&(pdev->dev), &plat_dat, addr);
drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c:	priv->dev->irq = pdev->irq;
drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c:	priv->wol_irq = pdev->irq;
drivers/net/ethernet/emulex/benet/be_ethtool.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_ethtool.c:		dev_warn(&adapter->pdev->dev, "Pause param set failed.\n");
drivers/net/ethernet/emulex/benet/be_ethtool.c:		dev_warn(&adapter->pdev->dev, "WOL not supported\n");
drivers/net/ethernet/emulex/benet/be_ethtool.c:	ddrdma_cmd.va = dma_alloc_coherent(&adapter->pdev->dev, ddrdma_cmd.size,
drivers/net/ethernet/emulex/benet/be_ethtool.c:	dma_free_coherent(&adapter->pdev->dev, ddrdma_cmd.size, ddrdma_cmd.va,
drivers/net/ethernet/emulex/benet/be_ethtool.c:		dev_err(&adapter->pdev->dev, "Self test not supported\n");
drivers/net/ethernet/emulex/benet/be_ethtool.c:	eeprom->magic = BE_VENDOR_ID | (adapter->pdev->device<<16);
drivers/net/ethernet/emulex/benet/be_ethtool.c:	eeprom_cmd.va = dma_alloc_coherent(&adapter->pdev->dev, eeprom_cmd.size,
drivers/net/ethernet/emulex/benet/be_ethtool.c:	dma_free_coherent(&adapter->pdev->dev, eeprom_cmd.size, eeprom_cmd.va,
drivers/net/ethernet/emulex/benet/be_ethtool.c:		dev_err(&adapter->pdev->dev, "Operation not supported\n");
drivers/net/ethernet/emulex/benet/be_ethtool.c:		dev_err(&adapter->pdev->dev, "%s: Memory allocation failure\n",
drivers/net/ethernet/emulex/benet/be_ethtool.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_ethtool.c:		dev_err(&adapter->pdev->dev, "Message level get failed\n");
drivers/net/ethernet/emulex/benet/be_ethtool.c:		dev_err(&adapter->pdev->dev, "Operation not supported\n");
drivers/net/ethernet/emulex/benet/be_ethtool.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_ethtool.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be.h:	switch (pdev->device) {
drivers/net/ethernet/emulex/benet/be.h:#define lancer_chip(adapter)	(adapter->pdev->device == OC_DEVICE_ID3 || \
drivers/net/ethernet/emulex/benet/be.h:				 adapter->pdev->device == OC_DEVICE_ID4)
drivers/net/ethernet/emulex/benet/be.h:#define skyhawk_chip(adapter)	(adapter->pdev->device == OC_DEVICE_ID5 || \
drivers/net/ethernet/emulex/benet/be.h:				 adapter->pdev->device == OC_DEVICE_ID6)
drivers/net/ethernet/emulex/benet/be.h:#define BE3_chip(adapter)	(adapter->pdev->device == BE_DEVICE_ID2 || \
drivers/net/ethernet/emulex/benet/be.h:				 adapter->pdev->device == OC_DEVICE_ID2)
drivers/net/ethernet/emulex/benet/be.h:#define BE2_chip(adapter)	(adapter->pdev->device == BE_DEVICE_ID1 || \
drivers/net/ethernet/emulex/benet/be.h:				 adapter->pdev->device == OC_DEVICE_ID1)
drivers/net/ethernet/emulex/benet/be.h:	switch (pdev->subsystem_device) {
drivers/net/ethernet/emulex/benet/be_cmds.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_cmds.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_warn(&adapter->pdev->dev, "Unknown grp5 event!\n");
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_warn(&adapter->pdev->dev, "Unknown debug event\n");
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_err(&adapter->pdev->dev, "FW not responding\n");
drivers/net/ethernet/emulex/benet/be_cmds.c:			dev_err(&adapter->pdev->dev, "FW not responding\n");
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_err(&adapter->pdev->dev, "invalid mailbox completion\n");
drivers/net/ethernet/emulex/benet/be_cmds.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_warn(&adapter->pdev->dev, "Upgrade to F/W ver 2.102.235.0 "
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_cmds.c:			dev_err(&adapter->pdev->dev, "FAT Table Retrieve error\n");
drivers/net/ethernet/emulex/benet/be_cmds.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_err(&adapter->pdev->dev, "Memory alloc failure\n");
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_cmds.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_cmds.c:	cmd.va = dma_alloc_coherent(&adapter->pdev->dev, cmd.size,
drivers/net/ethernet/emulex/benet/be_cmds.c:	dma_free_coherent(&adapter->pdev->dev, cmd.size,
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_err(&adapter->pdev->dev, "Memory alloc failure\n");
drivers/net/ethernet/emulex/benet/be_cmds.c:		dev_err(&adapter->pdev->dev, "Memory alloc failure\n");
drivers/net/ethernet/emulex/benet/be_main.c:		dma_free_coherent(&adapter->pdev->dev, mem->size, mem->va,
drivers/net/ethernet/emulex/benet/be_main.c:	mem->va = dma_alloc_coherent(&adapter->pdev->dev, mem->size, &mem->dma,
drivers/net/ethernet/emulex/benet/be_main.c:	dev_err(&adapter->pdev->dev, "MAC %pM set Failed\n", addr->sa_data);
drivers/net/ethernet/emulex/benet/be_main.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/emulex/benet/be_main.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:	dev_info(&adapter->pdev->dev, "MTU changed from %d to %d bytes\n",
drivers/net/ethernet/emulex/benet/be_main.c:		dev_info(&adapter->pdev->dev, "Exhausted VLAN HW filters.\n");
drivers/net/ethernet/emulex/benet/be_main.c:		dev_info(&adapter->pdev->dev, "Disabling HW VLAN filtering.\n");
drivers/net/ethernet/emulex/benet/be_main.c:		dev_info(&adapter->pdev->dev, "Exhausted multicast HW filters.\n");
drivers/net/ethernet/emulex/benet/be_main.c:		dev_info(&adapter->pdev->dev, "Disabling HW multicast filtering.\n");
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev, "MAC %pM set on VF %d Failed\n",
drivers/net/ethernet/emulex/benet/be_main.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:	dev = pci_get_device(pdev->vendor, PCI_ANY_ID, NULL);
drivers/net/ethernet/emulex/benet/be_main.c:		dev = pci_get_device(pdev->vendor, PCI_ANY_ID, dev);
drivers/net/ethernet/emulex/benet/be_main.c:		dma_unmap_page(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:			page_dmaaddr = dma_map_page(&adapter->pdev->dev, pagep,
drivers/net/ethernet/emulex/benet/be_main.c:		unmap_tx_frag(&adapter->pdev->dev, wrb,
drivers/net/ethernet/emulex/benet/be_main.c:				dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:			dev_err(&adapter->pdev->dev, "%d pending tx-compls\n",
drivers/net/ethernet/emulex/benet/be_main.c:	dev_info(&adapter->pdev->dev, "created %d TX queue(s)\n",
drivers/net/ethernet/emulex/benet/be_main.c:	dev_info(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:				dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:				dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/emulex/benet/be_main.c:	dev_warn(&adapter->pdev->dev, "MSIX Request IRQ failed - err %d\n",
drivers/net/ethernet/emulex/benet/be_main.c:	netdev->irq = adapter->pdev->irq;
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:	cmd.va = dma_alloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,
drivers/net/ethernet/emulex/benet/be_main.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:			dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,
drivers/net/ethernet/emulex/benet/be_main.c:	dma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va, cmd.dma);
drivers/net/ethernet/emulex/benet/be_main.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/emulex/benet/be_main.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:	flash_cmd.va = dma_alloc_coherent(&adapter->pdev->dev, flash_cmd.size,
drivers/net/ethernet/emulex/benet/be_main.c:	dma_free_coherent(&adapter->pdev->dev, flash_cmd.size, flash_cmd.va,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:	dev_info(&adapter->pdev->dev, "Firmware flashed successfully\n");
drivers/net/ethernet/emulex/benet/be_main.c:	dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:	flash_cmd.va = dma_alloc_coherent(&adapter->pdev->dev, flash_cmd.size,
drivers/net/ethernet/emulex/benet/be_main.c:					dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:	dma_free_coherent(&adapter->pdev->dev, flash_cmd.size, flash_cmd.va,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev, "Firmware load error\n");
drivers/net/ethernet/emulex/benet/be_main.c:	dev_info(&adapter->pdev->dev, "Firmware flashed successfully\n");
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:	status = request_firmware(&fw, fw_file, &adapter->pdev->dev);
drivers/net/ethernet/emulex/benet/be_main.c:	dev_info(&adapter->pdev->dev, "Flashing firmware file %s\n", fw_file);
drivers/net/ethernet/emulex/benet/be_main.c:		dma_free_coherent(&adapter->pdev->dev, mem->size, mem->va,
drivers/net/ethernet/emulex/benet/be_main.c:		dma_free_coherent(&adapter->pdev->dev, mem->size, mem->va,
drivers/net/ethernet/emulex/benet/be_main.c:	mbox_mem_alloc->va = dma_alloc_coherent(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:	rx_filter->va = dma_alloc_coherent(&adapter->pdev->dev, rx_filter->size,
drivers/net/ethernet/emulex/benet/be_main.c:	dma_free_coherent(&adapter->pdev->dev, mbox_mem_alloc->size,
drivers/net/ethernet/emulex/benet/be_main.c:		dma_free_coherent(&adapter->pdev->dev, cmd->size,
drivers/net/ethernet/emulex/benet/be_main.c:	cmd->va = dma_alloc_coherent(&adapter->pdev->dev, cmd->size, &cmd->dma,
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&adapter->pdev->dev, "%s: Memory allocation failure\n",
drivers/net/ethernet/emulex/benet/be_main.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/emulex/benet/be_main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/emulex/benet/be_main.c:	status = dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/net/ethernet/emulex/benet/be_main.c:		status = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/net/ethernet/emulex/benet/be_main.c:			dev_err(&pdev->dev, "dma_set_coherent_mask failed\n");
drivers/net/ethernet/emulex/benet/be_main.c:		status = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/net/ethernet/emulex/benet/be_main.c:			status = dma_set_coherent_mask(&pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:			dev_err(&pdev->dev, "Could not set PCI DMA Mask\n");
drivers/net/ethernet/emulex/benet/be_main.c:		dev_err(&pdev->dev, "Could not use PCIe error reporting\n");
drivers/net/ethernet/emulex/benet/be_main.c:	dev_info(&pdev->dev, "%s: %s %s port %c\n", nic_name(pdev),
drivers/net/ethernet/emulex/benet/be_main.c:	dev_err(&pdev->dev, "%s initialization failed\n", nic_name(pdev));
drivers/net/ethernet/emulex/benet/be_main.c:	dev_err(&adapter->pdev->dev, "EEH error detected\n");
drivers/net/ethernet/emulex/benet/be_main.c:	if (pdev->devfn == 0)
drivers/net/ethernet/emulex/benet/be_main.c:	dev_info(&adapter->pdev->dev, "EEH reset\n");
drivers/net/ethernet/emulex/benet/be_main.c:	dev_info(&adapter->pdev->dev,
drivers/net/ethernet/emulex/benet/be_main.c:	dev_info(&adapter->pdev->dev, "EEH resume\n");
drivers/net/ethernet/emulex/benet/be_main.c:	dev_err(&adapter->pdev->dev, "EEH resume failed\n");
drivers/net/ethernet/emulex/benet/be_roce.c:	if (pdev->device == OC_DEVICE_ID5) {
drivers/net/ethernet/mellanox/mlx4/icm.c:		dma_free_coherent(&dev->pdev->dev, chunk->mem[i].length,
drivers/net/ethernet/mellanox/mlx4/icm.c:			ret = mlx4_alloc_icm_coherent(&dev->pdev->dev,
drivers/net/ethernet/mellanox/mlx4/en_main.c:			   level, DRV_NAME, dev_name(&priv->mdev->pdev->dev),
drivers/net/ethernet/mellanox/mlx4/en_main.c:	mdev->dma_device = &(dev->pdev->dev);
drivers/net/ethernet/mellanox/mlx4/alloc.c:		buf->direct.buf   = dma_alloc_coherent(&dev->pdev->dev,
drivers/net/ethernet/mellanox/mlx4/alloc.c:				dma_alloc_coherent(&dev->pdev->dev, PAGE_SIZE,
drivers/net/ethernet/mellanox/mlx4/alloc.c:		dma_free_coherent(&dev->pdev->dev, size, buf->direct.buf,
drivers/net/ethernet/mellanox/mlx4/alloc.c:				dma_free_coherent(&dev->pdev->dev, PAGE_SIZE,
drivers/net/ethernet/mellanox/mlx4/alloc.c:	pgdir = mlx4_alloc_db_pgdir(&(dev->pdev->dev));
drivers/net/ethernet/mellanox/mlx4/alloc.c:		dma_free_coherent(&(dev->pdev->dev), PAGE_SIZE,
drivers/net/ethernet/mellanox/mlx4/mlx4_en.h:	       dev_name(&mdev->pdev->dev), ##arg)
drivers/net/ethernet/mellanox/mlx4/mlx4_en.h:		dev_name(&mdev->pdev->dev), ##arg)
drivers/net/ethernet/mellanox/mlx4/mlx4_en.h:		   dev_name(&mdev->pdev->dev), ##arg)
drivers/net/ethernet/mellanox/mlx4/eq.c:		eq->page_list[i].buf = dma_alloc_coherent(&dev->pdev->dev,
drivers/net/ethernet/mellanox/mlx4/eq.c:			dma_free_coherent(&dev->pdev->dev, PAGE_SIZE,
drivers/net/ethernet/mellanox/mlx4/eq.c:		dma_free_coherent(&dev->pdev->dev, PAGE_SIZE,
drivers/net/ethernet/mellanox/mlx4/eq.c:		free_irq(dev->pdev->irq, dev);
drivers/net/ethernet/mellanox/mlx4/eq.c:		err = request_irq(dev->pdev->irq, mlx4_interrupt,
drivers/net/ethernet/mellanox/mlx4/mr.c:	dma_sync_single_for_cpu(&dev->pdev->dev, dma_handle,
drivers/net/ethernet/mellanox/mlx4/mr.c:	dma_sync_single_for_device(&dev->pdev->dev, dma_handle,
drivers/net/ethernet/mellanox/mlx4/mr.c:	dma_sync_single_for_cpu(&dev->pdev->dev, fmr->dma_handle,
drivers/net/ethernet/mellanox/mlx4/mr.c:	dma_sync_single_for_device(&dev->pdev->dev, fmr->dma_handle,
drivers/net/ethernet/mellanox/mlx4/mlx4.h:		dev_printk(KERN_DEBUG, &mdev->pdev->dev, format, ##arg); \
drivers/net/ethernet/mellanox/mlx4/mlx4.h:	dev_err(&mdev->pdev->dev, format, ##arg)
drivers/net/ethernet/mellanox/mlx4/mlx4.h:	dev_info(&mdev->pdev->dev, format, ##arg)
drivers/net/ethernet/mellanox/mlx4/mlx4.h:	dev_warn(&mdev->pdev->dev, format, ##arg)
drivers/net/ethernet/mellanox/mlx4/cmd.c:	dma_free_coherent(&(dev->pdev->dev), PAGE_SIZE,
drivers/net/ethernet/mellanox/mlx4/cmd.c:		priv->mfunc.vhcr = dma_alloc_coherent(&(dev->pdev->dev), PAGE_SIZE,
drivers/net/ethernet/mellanox/mlx4/cmd.c:		dma_free_coherent(&(dev->pdev->dev), PAGE_SIZE,
drivers/net/ethernet/mellanox/mlx4/cmd.c:		dma_free_coherent(&(dev->pdev->dev), PAGE_SIZE,
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:	SET_NETDEV_DEV(dev, &mdev->dev->pdev->dev);
drivers/net/ethernet/mellanox/mlx4/en_netdev.c:	priv->ddev = &mdev->pdev->dev;
drivers/net/ethernet/mellanox/mlx4/main.c:		priv->eq_table.eq[i].irq = dev->pdev->irq;
drivers/net/ethernet/mellanox/mlx4/main.c:	err = device_create_file(&dev->pdev->dev, &info->port_attr);
drivers/net/ethernet/mellanox/mlx4/main.c:	err = device_create_file(&dev->pdev->dev, &info->port_mtu_attr);
drivers/net/ethernet/mellanox/mlx4/main.c:		device_remove_file(&info->dev->pdev->dev, &info->port_attr);
drivers/net/ethernet/mellanox/mlx4/main.c:	device_remove_file(&info->dev->pdev->dev, &info->port_attr);
drivers/net/ethernet/mellanox/mlx4/main.c:	device_remove_file(&info->dev->pdev->dev, &info->port_mtu_attr);
drivers/net/ethernet/mellanox/mlx4/main.c:	return PCI_SLOT(pdev->devfn) * 8 + PCI_FUNC(pdev->devfn);
drivers/net/ethernet/mellanox/mlx4/main.c:		dev_err(&pdev->dev, "Cannot enable PCI device, "
drivers/net/ethernet/mellanox/mlx4/main.c:		dev_err(&pdev->dev, "Missing DCS, aborting."
drivers/net/ethernet/mellanox/mlx4/main.c:		dev_err(&pdev->dev, "Missing UAR, aborting.\n");
drivers/net/ethernet/mellanox/mlx4/main.c:		dev_err(&pdev->dev, "Couldn't get PCI resources, aborting\n");
drivers/net/ethernet/mellanox/mlx4/main.c:		dev_warn(&pdev->dev, "Warning: couldn't set 64-bit PCI DMA mask.\n");
drivers/net/ethernet/mellanox/mlx4/main.c:			dev_err(&pdev->dev, "Can't set PCI DMA mask, aborting.\n");
drivers/net/ethernet/mellanox/mlx4/main.c:		dev_warn(&pdev->dev, "Warning: couldn't set 64-bit "
drivers/net/ethernet/mellanox/mlx4/main.c:			dev_err(&pdev->dev, "Can't set consistent PCI DMA mask, "
drivers/net/ethernet/mellanox/mlx4/main.c:	dma_set_max_seg_size(&pdev->dev, 1024 * 1024 * 1024);
drivers/net/ethernet/mellanox/mlx4/main.c:	dev->rev_id = pdev->revision;
drivers/net/ethernet/faraday/ftgmac100.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/faraday/ftgmac100.c:	priv->dev = &pdev->dev;
drivers/net/ethernet/faraday/ftgmac100.c:				       dev_name(&pdev->dev));
drivers/net/ethernet/faraday/ftgmac100.c:		dev_err(&pdev->dev, "Could not reserve memory region\n");
drivers/net/ethernet/faraday/ftgmac100.c:		dev_err(&pdev->dev, "Failed to ioremap ethernet registers\n");
drivers/net/ethernet/faraday/ftgmac100.c:		dev_err(&pdev->dev, "Cannot register MDIO bus!\n");
drivers/net/ethernet/faraday/ftgmac100.c:		dev_err(&pdev->dev, "MII Probe failed!\n");
drivers/net/ethernet/faraday/ftgmac100.c:		dev_err(&pdev->dev, "Failed to register netdev\n");
drivers/net/ethernet/faraday/ftmac100.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/faraday/ftmac100.c:	priv->dev = &pdev->dev;
drivers/net/ethernet/faraday/ftmac100.c:				       dev_name(&pdev->dev));
drivers/net/ethernet/faraday/ftmac100.c:		dev_err(&pdev->dev, "Could not reserve memory region\n");
drivers/net/ethernet/faraday/ftmac100.c:		dev_err(&pdev->dev, "Failed to ioremap ethernet registers\n");
drivers/net/ethernet/faraday/ftmac100.c:		dev_err(&pdev->dev, "Failed to register netdev\n");
drivers/net/ethernet/broadcom/bcm63xx_enet.c:			p = dma_map_single(&priv->pdev->dev, skb->data,
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		dev_warn(&priv->pdev->dev, "unable to refill rx ring\n");
drivers/net/ethernet/broadcom/bcm63xx_enet.c:	kdev = &priv->pdev->dev;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:			dma_unmap_single(&priv->pdev->dev, desc->address,
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		dma_unmap_single(&priv->pdev->dev, desc->address, skb->len,
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		dev_err(&priv->pdev->dev, "xmit called with no tx desc "
drivers/net/ethernet/broadcom/bcm63xx_enet.c:	desc->address = dma_map_single(&priv->pdev->dev, skb->data, skb->len,
drivers/net/ethernet/broadcom/bcm63xx_enet.c:	kdev = &priv->pdev->dev;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:	kdev = &priv->pdev->dev;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:	priv->base = devm_request_and_ioremap(&pdev->dev, res_mem);
drivers/net/ethernet/broadcom/bcm63xx_enet.c:	priv->mac_id = pdev->id;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:	priv->mac_clk = clk_get(&pdev->dev, clk_name);
drivers/net/ethernet/broadcom/bcm63xx_enet.c:	pd = pdev->dev.platform_data;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		priv->phy_clk = clk_get(&pdev->dev, "ephy");
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		bus->parent = &pdev->dev;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		sprintf(bus->id, "%s-%d", pdev->name, priv->mac_id);
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		bus->irq = devm_kzalloc(&pdev->dev, sizeof(int) * PHY_MAX_ADDR,
drivers/net/ethernet/broadcom/bcm63xx_enet.c:			dev_err(&pdev->dev, "unable to register mdio bus\n");
drivers/net/ethernet/broadcom/bcm63xx_enet.c:			dev_err(&pdev->dev, "unable to configure mdio bus\n");
drivers/net/ethernet/broadcom/bcm63xx_enet.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/broadcom/bcm63xx_enet.c:		pd = pdev->dev.platform_data;
drivers/net/ethernet/broadcom/bcm63xx_enet.c:	bcm_enet_shared_base = devm_request_and_ioremap(&pdev->dev, res);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c:	mapping = dma_map_single(&bp->pdev->dev, skb->data,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c:	if (unlikely(dma_mapping_error(&bp->pdev->dev, mapping))) {
drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c:	dma_sync_single_for_cpu(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	dma_unmap_single(&bp->pdev->dev, BD_UNMAP_ADDR(tx_start_bd),
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:		dma_unmap_page(&bp->pdev->dev, BD_UNMAP_ADDR(tx_data_bd),
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	mapping = dma_map_single(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	if (unlikely(dma_mapping_error(&bp->pdev->dev, mapping))) {
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	mapping = dma_map_page(&bp->pdev->dev, page, 0,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	if (unlikely(dma_mapping_error(&bp->pdev->dev, mapping))) {
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:		dma_unmap_page(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	dma_unmap_single(&bp->pdev->dev, dma_unmap_addr(rx_buf, mapping),
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	mapping = dma_map_single(&bp->pdev->dev, data + NET_SKB_PAD,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	if (unlikely(dma_mapping_error(&bp->pdev->dev, mapping))) {
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:		dma_sync_single_for_cpu(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:				dma_unmap_single(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:			dma_unmap_single(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:		dma_unmap_single(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:		irq = bp->pdev->irq;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:			bp->dev->irq = bp->pdev->irq;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:		if (atomic_read(&bp->pdev->enable_cnt) != 1)
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:		dev_err(&bp->pdev->dev, "Can't support state = %d\n", state);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	mapping = dma_map_single(&bp->pdev->dev, skb->data,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:	if (unlikely(dma_mapping_error(&bp->pdev->dev, mapping))) {
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:		mapping = skb_frag_dma_map(&bp->pdev->dev, frag, 0,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:		if (unlikely(dma_mapping_error(&bp->pdev->dev, mapping))) {
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:		dev_err(&pdev->dev, "BAD net device from bnx2x_init_one\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:		dev_err(&pdev->dev, "BAD net device from bnx2x_init_one\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		synchronize_irq(bp->pdev->irq);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	bp->gunzip_buf = dma_alloc_coherent(&bp->pdev->dev, FW_BUF_SIZE,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	dma_free_coherent(&bp->pdev->dev, FW_BUF_SIZE, bp->gunzip_buf,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dma_free_coherent(&bp->pdev->dev, FW_BUF_SIZE, bp->gunzip_buf,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_alert(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		synchronize_irq(bp->pdev->irq);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		if (PCI_SLOT(bp->pdev->devfn) == tmp_list->slot &&
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		    bp->pdev->bus->number == tmp_list->bus &&
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	tmp_list->bus = bp->pdev->bus->number;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	tmp_list->slot = PCI_SLOT(bp->pdev->devfn);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	dev_info(&bp->pdev->dev, "part number %X-%X-%X-%X\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:				dev_err(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:				dev_err(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:				dev_err(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&bp->pdev->dev, "FPGA detected\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&bp->pdev->dev, "MCP disabled, must load devices in order!\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	struct device *dev = &bp->pdev->dev;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&bp->pdev->dev, "Cannot find second PCI device base address, aborting\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	if (atomic_read(&pdev->enable_cnt) == 1) {
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:			dev_err(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:			dev_err(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&bp->pdev->dev, "Not PCI Express, aborting\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	dev->irq = pdev->irq;
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		bp->pf_num = PCI_FUNC(pdev->devfn);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	if (atomic_read(&pdev->enable_cnt) == 1)
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	rc = request_firmware(&bp->firmware, fw_file_name, &bp->pdev->dev);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_info(&pdev->dev, "no msix capability found\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	dev_info(&pdev->dev, "msix capability found\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:			dev_err(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&pdev->dev, "Cannot set interrupts\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&pdev->dev, "Cannot register net device\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		    dev->base_addr, bp->pdev->irq, dev->dev_addr);
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	if (atomic_read(&pdev->enable_cnt) == 1)
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&pdev->dev, "BAD net device from bnx2x_init_one\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:	if (atomic_read(&pdev->enable_cnt) == 1)
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c:	   "pdev->params.dcbx_port_params.pfc.priority_non_pauseable_mask %x\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c:		   "pdev->params.dcbx_port_params.ets.cos_params[%d].pri_bitmask %x\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c:		   "pdev->params.dcbx_port_params.ets.cos_params[%d].bw_tbl %x\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c:		   "pdev->params.dcbx_port_params.ets.cos_params[%d].strict %x\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c:		   "pdev->params.dcbx_port_params.ets.cos_params[%d].pauseable %x\n",
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h:			dma_free_coherent(&bp->pdev->dev, size, (void *)x, y); \
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h:	x = dma_alloc_coherent(&bp->pdev->dev, size, y,		\
drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h:	dma_unmap_page(&bp->pdev->dev, dma_unmap_addr(sw_buf, mapping),
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h:		dev_info(&bp->pdev->dev, fmt, ##__VA_ARGS__);	 \
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h:	x = dma_alloc_coherent(&bp->pdev->dev, size, y,		\
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h:			dma_free_coherent(&bp->pdev->dev, size, x, y); \
drivers/net/ethernet/broadcom/tg3.c:		if (device_may_wakeup(&tp->pdev->dev) &&
drivers/net/ethernet/broadcom/tg3.c:		 (tp->pdev->bus->number << 8) | tp->pdev->devfn);
drivers/net/ethernet/broadcom/tg3.c:	tp->mdio_bus->parent   = &tp->pdev->dev;
drivers/net/ethernet/broadcom/tg3.c:		dev_warn(&tp->pdev->dev, "mdiobus_reg failed (0x%x)\n", i);
drivers/net/ethernet/broadcom/tg3.c:		dev_warn(&tp->pdev->dev, "No PHY devices\n");
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&tp->pdev->dev, "Could not attach to PHY\n");
drivers/net/ethernet/broadcom/tg3.c:	} else if (tp->pdev->device == PCI_DEVICE_ID_TIGON3_5761 ||
drivers/net/ethernet/broadcom/tg3.c:		   tp->pdev->device == TG3PCI_DEVICE_TIGON3_5761S) {
drivers/net/ethernet/broadcom/tg3.c:	device_should_wake = device_may_wakeup(&tp->pdev->dev) &&
drivers/net/ethernet/broadcom/tg3.c:			mapping = skb_frag_dma_map(&tp->pdev->dev, frag, 0,
drivers/net/ethernet/broadcom/tg3.c:			if (dma_mapping_error(&tp->pdev->dev, mapping))
drivers/net/ethernet/broadcom/tg3.c:		dma_free_coherent(&tp->pdev->dev, TG3_RX_STD_RING_BYTES(tp),
drivers/net/ethernet/broadcom/tg3.c:		dma_free_coherent(&tp->pdev->dev, TG3_RX_JMB_RING_BYTES(tp),
drivers/net/ethernet/broadcom/tg3.c:	tpr->rx_std = dma_alloc_coherent(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:		tpr->rx_jmb = dma_alloc_coherent(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:			dma_free_coherent(&tp->pdev->dev, TG3_TX_RING_BYTES,
drivers/net/ethernet/broadcom/tg3.c:		tnapi->tx_ring = dma_alloc_coherent(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:		dma_free_coherent(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:		tnapi->rx_rcb = dma_alloc_coherent(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:			dma_free_coherent(&tp->pdev->dev, TG3_HW_STATUS_SIZE,
drivers/net/ethernet/broadcom/tg3.c:		dma_free_coherent(&tp->pdev->dev, sizeof(struct tg3_hw_stats),
drivers/net/ethernet/broadcom/tg3.c:	tp->hw_stats = dma_alloc_coherent(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:		tnapi->hw_status = dma_alloc_coherent(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:			dev_err(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:		sysfs_remove_group(&tp->pdev->dev.kobj, &tg3_group);
drivers/net/ethernet/broadcom/tg3.c:	err = sysfs_create_group(&pdev->dev.kobj, &tg3_group);
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&pdev->dev, "Cannot create sysfs group, aborting\n");
drivers/net/ethernet/broadcom/tg3.c:	tp->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&pdev->dev, "Cannot register hwmon device, aborting\n");
drivers/net/ethernet/broadcom/tg3.c:		sysfs_remove_group(&pdev->dev.kobj, &tg3_group);
drivers/net/ethernet/broadcom/tg3.c:	tp->napi[0].irq_vec = tp->pdev->irq;
drivers/net/ethernet/broadcom/tg3.c:	if (request_firmware(&tp->fw, tp->fw_needed, &tp->pdev->dev)) {
drivers/net/ethernet/broadcom/tg3.c:		tp->napi[0].irq_vec = tp->pdev->irq;
drivers/net/ethernet/broadcom/tg3.c:						   &tp->pdev->dev);
drivers/net/ethernet/broadcom/tg3.c:	if (tg3_flag(tp, WOL_CAP) && device_can_wakeup(&tp->pdev->dev))
drivers/net/ethernet/broadcom/tg3.c:	if (tg3_flag(tp, WOL_ENABLE) && device_can_wakeup(&tp->pdev->dev))
drivers/net/ethernet/broadcom/tg3.c:	struct device *dp = &tp->pdev->dev;
drivers/net/ethernet/broadcom/tg3.c:		     tp->pdev->subsystem_vendor) &&
drivers/net/ethernet/broadcom/tg3.c:		     tp->pdev->subsystem_device))
drivers/net/ethernet/broadcom/tg3.c:			device_set_wakeup_enable(&tp->pdev->dev, true);
drivers/net/ethernet/broadcom/tg3.c:		    tp->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL)
drivers/net/ethernet/broadcom/tg3.c:			if ((tp->pdev->subsystem_vendor ==
drivers/net/ethernet/broadcom/tg3.c:			    (tp->pdev->subsystem_device == 0x205a ||
drivers/net/ethernet/broadcom/tg3.c:			     tp->pdev->subsystem_device == 0x2063))
drivers/net/ethernet/broadcom/tg3.c:			device_set_wakeup_enable(&tp->pdev->dev, true);
drivers/net/ethernet/broadcom/tg3.c:		device_set_wakeup_enable(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:		device_set_wakeup_capable(&tp->pdev->dev, false);
drivers/net/ethernet/broadcom/tg3.c:		if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||
drivers/net/ethernet/broadcom/tg3.c:		    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718)
drivers/net/ethernet/broadcom/tg3.c:		if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57780)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57760)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57790)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57788)
drivers/net/ethernet/broadcom/tg3.c:		if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795)
drivers/net/ethernet/broadcom/tg3.c:		if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)
drivers/net/ethernet/broadcom/tg3.c:	else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5725)
drivers/net/ethernet/broadcom/tg3.c:	unsigned int func, devnr = tp->pdev->devfn & ~7;
drivers/net/ethernet/broadcom/tg3.c:		peer = pci_get_slot(tp->pdev->bus, devnr | func);
drivers/net/ethernet/broadcom/tg3.c:		if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||
drivers/net/ethernet/broadcom/tg3.c:		    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C ||
drivers/net/ethernet/broadcom/tg3.c:		    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718 ||
drivers/net/ethernet/broadcom/tg3.c:		    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5719 ||
drivers/net/ethernet/broadcom/tg3.c:		    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5720 ||
drivers/net/ethernet/broadcom/tg3.c:		    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5762 ||
drivers/net/ethernet/broadcom/tg3.c:		    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5725 ||
drivers/net/ethernet/broadcom/tg3.c:		    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5727)
drivers/net/ethernet/broadcom/tg3.c:		else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781 ||
drivers/net/ethernet/broadcom/tg3.c:			 tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785 ||
drivers/net/ethernet/broadcom/tg3.c:			 tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761 ||
drivers/net/ethernet/broadcom/tg3.c:			 tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765 ||
drivers/net/ethernet/broadcom/tg3.c:			 tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791 ||
drivers/net/ethernet/broadcom/tg3.c:			 tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795 ||
drivers/net/ethernet/broadcom/tg3.c:			 tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762 ||
drivers/net/ethernet/broadcom/tg3.c:			 tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766 ||
drivers/net/ethernet/broadcom/tg3.c:			 tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782 ||
drivers/net/ethernet/broadcom/tg3.c:			 tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)
drivers/net/ethernet/broadcom/tg3.c:			     tp->pdev->bus->number)) {
drivers/net/ethernet/broadcom/tg3.c:			     tp->pdev->bus->number) &&
drivers/net/ethernet/broadcom/tg3.c:			     tp->pdev->bus->number)) {
drivers/net/ethernet/broadcom/tg3.c:			     tp->pdev->bus->number) &&
drivers/net/ethernet/broadcom/tg3.c:			     tp->pdev->bus->number)) {
drivers/net/ethernet/broadcom/tg3.c:			dev_err(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:	tp->pci_fn = PCI_FUNC(tp->pdev->devfn) & 3;
drivers/net/ethernet/broadcom/tg3.c:	if (tp->pdev->device == PCI_DEVICE_ID_TIGON3_5761 ||
drivers/net/ethernet/broadcom/tg3.c:	    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5761S) {
drivers/net/ethernet/broadcom/tg3.c:			if (tp->pdev->device != PCI_DEVICE_ID_TIGON3_5756 &&
drivers/net/ethernet/broadcom/tg3.c:			    tp->pdev->device != PCI_DEVICE_ID_TIGON3_5722)
drivers/net/ethernet/broadcom/tg3.c:			if (tp->pdev->device == PCI_DEVICE_ID_TIGON3_5755M)
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&tp->pdev->dev, "phy probe failed, err %d\n", err);
drivers/net/ethernet/broadcom/tg3.c:	if (tp->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL &&
drivers/net/ethernet/broadcom/tg3.c:	buf = dma_alloc_coherent(&tp->pdev->dev, TEST_BUFFER_SIZE,
drivers/net/ethernet/broadcom/tg3.c:			dev_err(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:				dev_err(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:			dev_err(&tp->pdev->dev, "%s: Buffer read failed. "
drivers/net/ethernet/broadcom/tg3.c:				dev_err(&tp->pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:	dma_free_coherent(&tp->pdev->dev, TEST_BUFFER_SIZE, buf, buf_dma);
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&pdev->dev, "Cannot enable PCI device, aborting\n");
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&pdev->dev, "Cannot obtain PCI resources, aborting\n");
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&pdev->dev, "Transition to D0 failed, aborting\n");
drivers/net/ethernet/broadcom/tg3.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&pdev->dev, "Cannot map device registers, aborting\n");
drivers/net/ethernet/broadcom/tg3.c:	if (tp->pdev->device == PCI_DEVICE_ID_TIGON3_5761 ||
drivers/net/ethernet/broadcom/tg3.c:	    tp->pdev->device == PCI_DEVICE_ID_TIGON3_5761E ||
drivers/net/ethernet/broadcom/tg3.c:	    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5761S ||
drivers/net/ethernet/broadcom/tg3.c:	    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5761SE ||
drivers/net/ethernet/broadcom/tg3.c:	    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||
drivers/net/ethernet/broadcom/tg3.c:	    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C ||
drivers/net/ethernet/broadcom/tg3.c:	    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718 ||
drivers/net/ethernet/broadcom/tg3.c:	    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5719 ||
drivers/net/ethernet/broadcom/tg3.c:	    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5720 ||
drivers/net/ethernet/broadcom/tg3.c:	    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5762 ||
drivers/net/ethernet/broadcom/tg3.c:	    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5725 ||
drivers/net/ethernet/broadcom/tg3.c:	    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5727) {
drivers/net/ethernet/broadcom/tg3.c:			dev_err(&pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:	dev->irq = pdev->irq;
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:				dev_err(&pdev->dev, "Unable to obtain 64 bit "
drivers/net/ethernet/broadcom/tg3.c:			dev_err(&pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&pdev->dev,
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&pdev->dev, "DMA engine test failed, aborting\n");
drivers/net/ethernet/broadcom/tg3.c:		dev_err(&pdev->dev, "Cannot register net device, aborting\n");
drivers/net/ethernet/broadcom/tg3.c:		    pdev->dma_mask == DMA_BIT_MASK(32) ? 32 :
drivers/net/ethernet/broadcom/tg3.c:		    ((u64)pdev->dma_mask) == DMA_BIT_MASK(40) ? 40 : 64);
drivers/net/ethernet/broadcom/cnic.c:		dma_free_coherent(&udev->pdev->dev, udev->l2_buf_size,
drivers/net/ethernet/broadcom/cnic.c:		dma_free_coherent(&udev->pdev->dev, udev->l2_ring_size,
drivers/net/ethernet/broadcom/cnic.c:	udev->l2_ring = dma_alloc_coherent(&udev->pdev->dev, udev->l2_ring_size,
drivers/net/ethernet/broadcom/cnic.c:	udev->l2_buf = dma_alloc_coherent(&udev->pdev->dev, udev->l2_buf_size,
drivers/net/ethernet/broadcom/cnic.c:			ret = uio_register_device(&udev->pdev->dev, uinfo);
drivers/net/ethernet/broadcom/cnic.c:	if ((pdev->device == PCI_DEVICE_ID_NX2_5709 ||
drivers/net/ethernet/broadcom/cnic.c:	     pdev->device == PCI_DEVICE_ID_NX2_5709S) &&
drivers/net/ethernet/broadcom/cnic.c:	    (pdev->revision < 0x10)) {
drivers/net/ethernet/broadcom/bnx2.c:			dma_free_coherent(&bp->pdev->dev, TXBD_RING_SIZE,
drivers/net/ethernet/broadcom/bnx2.c:				dma_free_coherent(&bp->pdev->dev, RXBD_RING_SIZE,
drivers/net/ethernet/broadcom/bnx2.c:				dma_free_coherent(&bp->pdev->dev, RXBD_RING_SIZE,
drivers/net/ethernet/broadcom/bnx2.c:			dma_alloc_coherent(&bp->pdev->dev, TXBD_RING_SIZE,
drivers/net/ethernet/broadcom/bnx2.c:				dma_alloc_coherent(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:				dma_alloc_coherent(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:			dma_free_coherent(&bp->pdev->dev, BNX2_PAGE_SIZE,
drivers/net/ethernet/broadcom/bnx2.c:		dma_free_coherent(&bp->pdev->dev, bp->status_stats_size,
drivers/net/ethernet/broadcom/bnx2.c:	status_blk = dma_alloc_coherent(&bp->pdev->dev, bp->status_stats_size,
drivers/net/ethernet/broadcom/bnx2.c:			bp->ctx_blk[i] = dma_alloc_coherent(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:	mapping = dma_map_page(&bp->pdev->dev, page, 0, PAGE_SIZE,
drivers/net/ethernet/broadcom/bnx2.c:	if (dma_mapping_error(&bp->pdev->dev, mapping)) {
drivers/net/ethernet/broadcom/bnx2.c:	dma_unmap_page(&bp->pdev->dev, dma_unmap_addr(rx_pg, mapping),
drivers/net/ethernet/broadcom/bnx2.c:	mapping = dma_map_single(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:	if (dma_mapping_error(&bp->pdev->dev, mapping)) {
drivers/net/ethernet/broadcom/bnx2.c:		dma_unmap_single(&bp->pdev->dev, dma_unmap_addr(tx_buf, mapping),
drivers/net/ethernet/broadcom/bnx2.c:			dma_unmap_page(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:	dma_sync_single_for_device(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:	dma_unmap_single(&bp->pdev->dev, dma_addr, bp->rx_buf_use_size,
drivers/net/ethernet/broadcom/bnx2.c:			dma_unmap_page(&bp->pdev->dev, mapping_old,
drivers/net/ethernet/broadcom/bnx2.c:		dma_sync_single_for_cpu(&bp->pdev->dev, dma_addr,
drivers/net/ethernet/broadcom/bnx2.c:	rc = request_firmware(&bp->mips_firmware, mips_fw_file, &bp->pdev->dev);
drivers/net/ethernet/broadcom/bnx2.c:	rc = request_firmware(&bp->rv2p_firmware, rv2p_fw_file, &bp->pdev->dev);
drivers/net/ethernet/broadcom/bnx2.c:			dma_unmap_single(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:				dma_unmap_page(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:			dma_unmap_single(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:	map = dma_map_single(&bp->pdev->dev, skb->data, pkt_size,
drivers/net/ethernet/broadcom/bnx2.c:	if (dma_mapping_error(&bp->pdev->dev, map)) {
drivers/net/ethernet/broadcom/bnx2.c:	dma_unmap_single(&bp->pdev->dev, map, pkt_size, PCI_DMA_TODEVICE);
drivers/net/ethernet/broadcom/bnx2.c:	dma_sync_single_for_cpu(&bp->pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:	bp->irq_tbl[0].vector = bp->pdev->irq;
drivers/net/ethernet/broadcom/bnx2.c:			bp->irq_tbl[0].vector = bp->pdev->irq;
drivers/net/ethernet/broadcom/bnx2.c:	mapping = dma_map_single(&bp->pdev->dev, skb->data, len, PCI_DMA_TODEVICE);
drivers/net/ethernet/broadcom/bnx2.c:	if (dma_mapping_error(&bp->pdev->dev, mapping)) {
drivers/net/ethernet/broadcom/bnx2.c:		mapping = skb_frag_dma_map(&bp->pdev->dev, frag, 0, len,
drivers/net/ethernet/broadcom/bnx2.c:		if (dma_mapping_error(&bp->pdev->dev, mapping))
drivers/net/ethernet/broadcom/bnx2.c:	dma_unmap_single(&bp->pdev->dev, dma_unmap_addr(tx_buf, mapping),
drivers/net/ethernet/broadcom/bnx2.c:		dma_unmap_page(&bp->pdev->dev, dma_unmap_addr(tx_buf, mapping),
drivers/net/ethernet/broadcom/bnx2.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/broadcom/bnx2.c:		dev_err(&pdev->dev, "Cannot enable PCI device, aborting\n");
drivers/net/ethernet/broadcom/bnx2.c:		dev_err(&pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:		dev_err(&pdev->dev, "Cannot obtain PCI resources, aborting\n");
drivers/net/ethernet/broadcom/bnx2.c:		dev_err(&pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:		dev_err(&pdev->dev, "Cannot map register space, aborting\n");
drivers/net/ethernet/broadcom/bnx2.c:			dev_err(&pdev->dev, "Not PCIE, aborting\n");
drivers/net/ethernet/broadcom/bnx2.c:			dev_err(&pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:			dev_err(&pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:		dev_err(&pdev->dev, "System does not support DMA, aborting\n");
drivers/net/ethernet/broadcom/bnx2.c:		dev_err(&pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:		dev_err(&pdev->dev, "Firmware not running, aborting\n");
drivers/net/ethernet/broadcom/bnx2.c:			if (pdev->subsystem_vendor == PCI_VENDOR_ID_HP &&
drivers/net/ethernet/broadcom/bnx2.c:			    pdev->subsystem_device == 0x310c)
drivers/net/ethernet/broadcom/bnx2.c:		dev_err(&pdev->dev, "Cannot register net device\n");
drivers/net/ethernet/broadcom/bnx2.c:		    pdev->irq, dev->dev_addr);
drivers/net/ethernet/broadcom/bnx2.c:		dev_err(&pdev->dev,
drivers/net/ethernet/broadcom/bnx2.c:		dev_err(&pdev->dev,
drivers/net/ethernet/tundra/tsi108_eth.c:	einfo = pdev->dev.platform_data;
drivers/net/ethernet/tundra/tsi108_eth.c:		       pdev->id);
drivers/net/ethernet/tundra/tsi108_eth.c:	printk("tsi108_eth%d: probe...\n", pdev->id);
drivers/net/ethernet/tundra/tsi108_eth.c:			pdev->id, einfo->regs, einfo->phyregs,
drivers/net/ethernet/tundra/tsi108_eth.c:	data->id = pdev->id;
drivers/net/ethernet/dlink/sundance.c:	irq = pdev->irq;
drivers/net/ethernet/dlink/sundance.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/dlink/sundance.c:	ring_space = dma_alloc_coherent(&pdev->dev, TX_TOTAL_SIZE,
drivers/net/ethernet/dlink/sundance.c:	ring_space = dma_alloc_coherent(&pdev->dev, RX_TOTAL_SIZE,
drivers/net/ethernet/dlink/sundance.c:	dma_free_coherent(&pdev->dev, RX_TOTAL_SIZE,
drivers/net/ethernet/dlink/sundance.c:	dma_free_coherent(&pdev->dev, TX_TOTAL_SIZE,
drivers/net/ethernet/dlink/sundance.c:	    dma_free_coherent(&pdev->dev, RX_TOTAL_SIZE,
drivers/net/ethernet/dlink/sundance.c:	    dma_free_coherent(&pdev->dev, TX_TOTAL_SIZE,
drivers/net/ethernet/dlink/dl2k.c:	irq = pdev->irq;
drivers/net/ethernet/dlink/dl2k.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/dlink/dl2k.c:	if (np->pdev->vendor == PCI_VENDOR_ID_DLINK) {	/* D-Link Only */
drivers/net/ethernet/dlink/dl2k.c:	if (np->pdev->vendor != PCI_VENDOR_ID_DLINK) {
drivers/net/ethernet/dlink/dl2k.c:	const int irq = np->pdev->irq;
drivers/net/ethernet/dlink/dl2k.c:			if (np->pdev->pci_rev_id >= 0x0c &&
drivers/net/ethernet/dlink/dl2k.c:	free_irq(pdev->irq, dev);
drivers/net/ethernet/micrel/ks8695net.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/micrel/ks8695net.c:	dev_dbg(&pdev->dev, "ks8695_probe() called\n");
drivers/net/ethernet/micrel/ks8695net.c:	ksp->dev = &pdev->dev;
drivers/net/ethernet/micrel/ks8695net.c:					   pdev->name);
drivers/net/ethernet/micrel/ks8695net.c:	ksp->ring_base = dma_alloc_coherent(&pdev->dev, RING_DMA_SIZE,
drivers/net/ethernet/micrel/ks8695net.c:	dev_dbg(&pdev->dev, "released and freed device\n");
drivers/net/ethernet/micrel/ks8842.c:	struct ks8842_platform_data *pdata = pdev->dev.platform_data;
drivers/net/ethernet/micrel/ks8842.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/micrel/ks8842.c:	adapter->dev = (pdev->dev.parent) ? pdev->dev.parent : &pdev->dev;
drivers/net/ethernet/micrel/ksz884x.c:	if (!pdev->pm_cap)
drivers/net/ethernet/micrel/ksz884x.c:	pci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &data);
drivers/net/ethernet/micrel/ksz884x.c:	if (!pdev->pm_cap)
drivers/net/ethernet/micrel/ksz884x.c:	pci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &data);
drivers/net/ethernet/micrel/ksz884x.c:	pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, data);
drivers/net/ethernet/micrel/ksz884x.c:	if (!pdev->pm_cap)
drivers/net/ethernet/micrel/ksz884x.c:	pci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &data);
drivers/net/ethernet/micrel/ksz884x.c:	pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, data);
drivers/net/ethernet/micrel/ksz884x.c:	dev_info(&hw_priv->pdev->dev, "%s\n", banner);
drivers/net/ethernet/micrel/ksz884x.c:	dev_dbg(&hw_priv->pdev->dev, "Mem = %p; IRQ = %d\n", hw->io, pdev->irq);
drivers/net/ethernet/micrel/ksz884x.c:		dev->irq = pdev->irq;
drivers/net/ethernet/micrel/ks8851_mll.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/micrel/ks8851_mll.c:	pdata = pdev->dev.platform_data;
drivers/net/ethernet/wiznet/w5300.c:	struct wiznet_platform_data *data = pdev->dev.platform_data;
drivers/net/ethernet/wiznet/w5300.c:	if (!devm_request_mem_region(&pdev->dev, mem->start, mem_size, name))
drivers/net/ethernet/wiznet/w5300.c:	priv->base = devm_ioremap(&pdev->dev, mem->start, mem_size);
drivers/net/ethernet/wiznet/w5300.c:		char *link_name = devm_kzalloc(&pdev->dev, 16, GFP_KERNEL);
drivers/net/ethernet/wiznet/w5300.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/wiznet/w5100.c:	struct wiznet_platform_data *data = pdev->dev.platform_data;
drivers/net/ethernet/wiznet/w5100.c:	if (!devm_request_mem_region(&pdev->dev, mem->start, mem_size, name))
drivers/net/ethernet/wiznet/w5100.c:	priv->base = devm_ioremap(&pdev->dev, mem->start, mem_size);
drivers/net/ethernet/wiznet/w5100.c:		char *link_name = devm_kzalloc(&pdev->dev, 16, GFP_KERNEL);
drivers/net/ethernet/wiznet/w5100.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/s6gmac.c:	snprintf(mb->id, MII_BUS_ID_SIZE, "%s-%x", pdev->name, pdev->id);
drivers/net/ethernet/i825xx/lasi_82596.c:	DMA_FREE(&pdev->dev, sizeof(struct i596_private),
drivers/net/ethernet/realtek/8139cp.c:		new_mapping = dma_map_single(&cp->pdev->dev, new_skb->data, buflen,
drivers/net/ethernet/realtek/8139cp.c:		if (dma_mapping_error(&cp->pdev->dev, new_mapping)) {
drivers/net/ethernet/realtek/8139cp.c:		dma_unmap_single(&cp->pdev->dev, mapping,
drivers/net/ethernet/realtek/8139cp.c:	const int irq = cp->pdev->irq;
drivers/net/ethernet/realtek/8139cp.c:		dma_unmap_single(&cp->pdev->dev, le64_to_cpu(txd->addr),
drivers/net/ethernet/realtek/8139cp.c:		dma_unmap_single(&cp->pdev->dev, le64_to_cpu(txd->addr),
drivers/net/ethernet/realtek/8139cp.c:		mapping = dma_map_single(&cp->pdev->dev, skb->data, len, PCI_DMA_TODEVICE);
drivers/net/ethernet/realtek/8139cp.c:		if (dma_mapping_error(&cp->pdev->dev, mapping))
drivers/net/ethernet/realtek/8139cp.c:		first_mapping = dma_map_single(&cp->pdev->dev, skb->data,
drivers/net/ethernet/realtek/8139cp.c:		if (dma_mapping_error(&cp->pdev->dev, first_mapping))
drivers/net/ethernet/realtek/8139cp.c:			mapping = dma_map_single(&cp->pdev->dev,
drivers/net/ethernet/realtek/8139cp.c:			if (dma_mapping_error(&cp->pdev->dev, mapping)) {
drivers/net/ethernet/realtek/8139cp.c:		mapping = dma_map_single(&cp->pdev->dev, skb->data,
drivers/net/ethernet/realtek/8139cp.c:		if (dma_mapping_error(&cp->pdev->dev, mapping)) {
drivers/net/ethernet/realtek/8139cp.c:	struct device *d = &cp->pdev->dev;
drivers/net/ethernet/realtek/8139cp.c:			dma_unmap_single(&cp->pdev->dev,le64_to_cpu(desc->addr),
drivers/net/ethernet/realtek/8139cp.c:			dma_unmap_single(&cp->pdev->dev,le64_to_cpu(desc->addr),
drivers/net/ethernet/realtek/8139cp.c:	dma_free_coherent(&cp->pdev->dev, CP_RING_BYTES, cp->rx_ring,
drivers/net/ethernet/realtek/8139cp.c:	const int irq = cp->pdev->irq;
drivers/net/ethernet/realtek/8139cp.c:	free_irq(cp->pdev->irq, dev);
drivers/net/ethernet/realtek/8139cp.c:	nic_stats = dma_alloc_coherent(&cp->pdev->dev, sizeof(*nic_stats),
drivers/net/ethernet/realtek/8139cp.c:	dma_free_coherent(&cp->pdev->dev, sizeof(*nic_stats), nic_stats, dma);
drivers/net/ethernet/realtek/8139cp.c:	if (pdev->vendor == PCI_VENDOR_ID_REALTEK &&
drivers/net/ethernet/realtek/8139cp.c:	    pdev->device == PCI_DEVICE_ID_REALTEK_8139 && pdev->revision < 0x20) {
drivers/net/ethernet/realtek/8139cp.c:		dev_info(&pdev->dev,
drivers/net/ethernet/realtek/8139cp.c:			 pdev->vendor, pdev->device, pdev->revision);
drivers/net/ethernet/realtek/8139cp.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/realtek/8139cp.c:		dev_err(&pdev->dev, "no MMIO resource\n");
drivers/net/ethernet/realtek/8139cp.c:		dev_err(&pdev->dev, "MMIO resource (%llx) too small\n",
drivers/net/ethernet/realtek/8139cp.c:			dev_err(&pdev->dev,
drivers/net/ethernet/realtek/8139cp.c:			dev_err(&pdev->dev,
drivers/net/ethernet/realtek/8139cp.c:		dev_err(&pdev->dev, "Cannot map PCI MMIO (%Lx@%Lx)\n",
drivers/net/ethernet/realtek/8139cp.c:		    regs, dev->dev_addr, pdev->irq);
drivers/net/ethernet/realtek/8139too.c:	struct device *d = &pdev->dev;
drivers/net/ethernet/realtek/8139too.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/realtek/8139too.c:		dev_err(&pdev->dev, "Chip not responding, ignoring board\n");
drivers/net/ethernet/realtek/8139too.c:	dev_dbg(&pdev->dev, "unknown chip version, assuming RTL-8139\n");
drivers/net/ethernet/realtek/8139too.c:	dev_dbg(&pdev->dev, "TxConfig = 0x%x\n", RTL_R32 (TxConfig));
drivers/net/ethernet/realtek/8139too.c:	if (pdev->vendor == PCI_VENDOR_ID_REALTEK &&
drivers/net/ethernet/realtek/8139too.c:	    pdev->device == PCI_DEVICE_ID_REALTEK_8139 && pdev->revision >= 0x20) {
drivers/net/ethernet/realtek/8139too.c:		dev_info(&pdev->dev,
drivers/net/ethernet/realtek/8139too.c:		       	   pdev->vendor, pdev->device, pdev->revision);
drivers/net/ethernet/realtek/8139too.c:	if (pdev->vendor == PCI_VENDOR_ID_REALTEK &&
drivers/net/ethernet/realtek/8139too.c:	    pdev->device == PCI_DEVICE_ID_REALTEK_8139 &&
drivers/net/ethernet/realtek/8139too.c:	    pdev->subsystem_vendor == PCI_VENDOR_ID_ATHEROS &&
drivers/net/ethernet/realtek/8139too.c:	    pdev->subsystem_device == PCI_DEVICE_ID_REALTEK_8139) {
drivers/net/ethernet/realtek/8139too.c:		    ioaddr, dev->dev_addr, pdev->irq);
drivers/net/ethernet/realtek/r8169.c:	if ((pdev->subsystem_vendor != PCI_VENDOR_ID_GIGABYTE) ||
drivers/net/ethernet/realtek/r8169.c:	    (pdev->subsystem_device != 0xe000))
drivers/net/ethernet/realtek/r8169.c:	if (pdev->broken_parity_status)
drivers/net/ethernet/realtek/r8169.c:	pm_runtime_get_sync(&pdev->dev);
drivers/net/ethernet/realtek/r8169.c:	free_irq(pdev->irq, dev);
drivers/net/ethernet/realtek/r8169.c:	dma_free_coherent(&pdev->dev, R8169_RX_RING_BYTES, tp->RxDescArray,
drivers/net/ethernet/realtek/r8169.c:	dma_free_coherent(&pdev->dev, R8169_TX_RING_BYTES, tp->TxDescArray,
drivers/net/ethernet/realtek/r8169.c:	pm_runtime_put_sync(&pdev->dev);
drivers/net/ethernet/realtek/r8169.c:	pm_runtime_get_sync(&pdev->dev);
drivers/net/ethernet/realtek/r8169.c:	tp->TxDescArray = dma_alloc_coherent(&pdev->dev, R8169_TX_RING_BYTES,
drivers/net/ethernet/realtek/r8169.c:	tp->RxDescArray = dma_alloc_coherent(&pdev->dev, R8169_RX_RING_BYTES,
drivers/net/ethernet/realtek/r8169.c:	retval = request_irq(pdev->irq, rtl8169_interrupt,
drivers/net/ethernet/realtek/r8169.c:	pm_runtime_put_noidle(&pdev->dev);
drivers/net/ethernet/realtek/r8169.c:	dma_free_coherent(&pdev->dev, R8169_RX_RING_BYTES, tp->RxDescArray,
drivers/net/ethernet/realtek/r8169.c:	dma_free_coherent(&pdev->dev, R8169_TX_RING_BYTES, tp->TxDescArray,
drivers/net/ethernet/realtek/r8169.c:	pm_runtime_put_noidle(&pdev->dev);
drivers/net/ethernet/realtek/r8169.c:	struct device *d = &pdev->dev;
drivers/net/ethernet/realtek/r8169.c:		pm_runtime_get_noresume(&pdev->dev);
drivers/net/ethernet/realtek/r8169.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/realtek/r8169.c:		   (u32)(RTL_R32(TxConfig) & 0x9cf0f8ff), pdev->irq);
drivers/net/ethernet/realtek/r8169.c:	device_set_wakeup_enable(&pdev->dev, tp->features & RTL_FEATURE_WOL);
drivers/net/ethernet/realtek/r8169.c:		pm_runtime_put_noidle(&pdev->dev);
drivers/net/ethernet/natsemi/jazzsonic.c:	lp->device = &pdev->dev;
drivers/net/ethernet/natsemi/jazzsonic.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/natsemi/natsemi.c:	irq = pdev->irq;
drivers/net/ethernet/natsemi/natsemi.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/natsemi/natsemi.c:			dev_err(&pdev->dev,
drivers/net/ethernet/natsemi/xtsonic.c:	lp->device = &pdev->dev;
drivers/net/ethernet/natsemi/xtsonic.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/natsemi/macsonic.c:	lp->device = &pdev->dev;
drivers/net/ethernet/natsemi/macsonic.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/alteon/acenic.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/alteon/acenic.c:	switch(pdev->vendor) {
drivers/net/ethernet/alteon/acenic.c:		if (pdev->device == PCI_DEVICE_ID_FARALLON_PN9100T) {
drivers/net/ethernet/alteon/acenic.c:		if (pdev->device == PCI_DEVICE_ID_FARALLON_PN9000SX) {
drivers/net/ethernet/alteon/acenic.c:	printk("irq %d\n", pdev->irq);
drivers/net/ethernet/alteon/acenic.c:	ecode = request_irq(pdev->irq, ace_interrupt, IRQF_SHARED,
drivers/net/ethernet/alteon/acenic.c:		       DRV_NAME, pdev->irq);
drivers/net/ethernet/alteon/acenic.c:		dev->irq = pdev->irq;
drivers/net/ethernet/alteon/acenic.c:			mapping = skb_frag_dma_map(&ap->pdev->dev, frag, 0,
drivers/net/ethernet/alteon/acenic.c:	ret = request_firmware(&fw, fw_name, &ap->pdev->dev);
drivers/net/ethernet/calxeda/xgmac.c:	if (!request_mem_region(res->start, resource_size(res), pdev->name))
drivers/net/ethernet/calxeda/xgmac.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/calxeda/xgmac.c:	priv->device = &pdev->dev;
drivers/net/ethernet/calxeda/xgmac.c:			  dev_name(&pdev->dev), ndev);
drivers/net/ethernet/calxeda/xgmac.c:			  dev_name(&pdev->dev), ndev);
drivers/net/ethernet/calxeda/xgmac.c:	device_set_wakeup_capable(&pdev->dev, 1);
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_warn(&pdev->dev, "%s: Link down.\n", dev->name);
drivers/net/ethernet/nuvoton/w90p910_ether.c:	dev_info(&pdev->dev, "%s: Link now %i-%s\n", dev->name, speed,
drivers/net/ethernet/nuvoton/w90p910_ether.c:	ether->tdesc = dma_alloc_coherent(&pdev->dev, sizeof(struct tran_pdesc),
drivers/net/ethernet/nuvoton/w90p910_ether.c:	ether->rdesc = dma_alloc_coherent(&pdev->dev, sizeof(struct recv_pdesc),
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dma_free_coherent(&pdev->dev, sizeof(struct tran_pdesc),
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_warn(&pdev->dev, "mdio write timed out\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_warn(&pdev->dev, "mdio read timed out\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:	dma_free_coherent(&pdev->dev, sizeof(struct recv_pdesc),
drivers/net/ethernet/nuvoton/w90p910_ether.c:	dma_free_coherent(&pdev->dev, sizeof(struct tran_pdesc),
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "send data %d bytes, check it\n", length);
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "emc defer exceed interrupt\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "emc bus error interrupt\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:				dev_err(&pdev->dev, "rx runt err\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:				dev_err(&pdev->dev, "rx crc err\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:				dev_err(&pdev->dev, "rx aligment err\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:				dev_err(&pdev->dev, "rx longer err\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "emc rx bus error\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:						0x0, pdev->name, dev)) {
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "register irq tx failed\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:						0x0, pdev->name, dev)) {
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "register irq rx failed\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:	dev_info(&pdev->dev, "%s is OPENED\n", dev->name);
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "invalid mac address\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "failed to get I/O memory\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:				resource_size(ether->res), pdev->name)) {
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "failed to request I/O memory\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "failed to remap I/O memory\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "failed to get ether tx irq\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "failed to get ether rx irq\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:	ether->clk = clk_get(&pdev->dev, NULL);
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "failed to get ether clock\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:	ether->rmiiclk = clk_get(&pdev->dev, "RMII");
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "failed to get ether clock\n");
drivers/net/ethernet/nuvoton/w90p910_ether.c:		dev_err(&pdev->dev, "Regiter EMC w90p910 FAILED\n");
drivers/net/ethernet/amd/am79c961a.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to retrieve base register\n");
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to retrieve MAC Enable register\n");
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to retrieve IRQ\n");
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to retrieve MACDMA registers\n");
drivers/net/ethernet/amd/au1000_eth.c:							pdev->name)) {
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to request memory region for base registers\n");
drivers/net/ethernet/amd/au1000_eth.c:							pdev->name)) {
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to request memory region for MAC enable register\n");
drivers/net/ethernet/amd/au1000_eth.c:							pdev->name)) {
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to request MACDMA memory region\n");
drivers/net/ethernet/amd/au1000_eth.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to allocate data buffers\n");
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to ioremap MAC registers\n");
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to ioremap MAC enable register\n");
drivers/net/ethernet/amd/au1000_eth.c:	aup->mac_id = pdev->id;
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to ioremap MACDMA registers\n");
drivers/net/ethernet/amd/au1000_eth.c:	pd = pdev->dev.platform_data;
drivers/net/ethernet/amd/au1000_eth.c:		dev_info(&pdev->dev, "no platform_data passed,"
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "MAC0-associated PHY attached 2nd MACs MII bus not supported yet\n");
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to allocate mdiobus structure\n");
drivers/net/ethernet/amd/au1000_eth.c:		pdev->name, aup->mac_id);
drivers/net/ethernet/amd/au1000_eth.c:		dev_err(&pdev->dev, "failed to register MDIO bus\n");
drivers/net/ethernet/amd/amd8111e.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/amd/amd8111e.c:	dev->irq =pdev->irq;
drivers/net/ethernet/amd/pcnet32.c:		SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/amd/pcnet32.c:		dev->irq = pdev->irq;
drivers/net/ethernet/amd/pcnet32.c:	if (pdev && pdev->subsystem_vendor == PCI_VENDOR_ID_AT &&
drivers/net/ethernet/amd/pcnet32.c:	    (pdev->subsystem_device == PCI_SUBDEVICE_ID_AT_2700FX ||
drivers/net/ethernet/amd/pcnet32.c:	     pdev->subsystem_device == PCI_SUBDEVICE_ID_AT_2701FX)) {
drivers/net/ethernet/xscale/ixp4xx_eth.c:	struct eth_plat_info *plat = pdev->dev.platform_data;
drivers/net/ethernet/xscale/ixp4xx_eth.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/xscale/ixp4xx_eth.c:	port->id = pdev->id;
drivers/net/ethernet/via/via-rhine.c:	const int irq = rp->pdev->irq;
drivers/net/ethernet/via/via-rhine.c:	if (pdev->revision < VTunknown0) {
drivers/net/ethernet/via/via-rhine.c:	else if (pdev->revision >= VT6102) {
drivers/net/ethernet/via/via-rhine.c:		if (pdev->revision < VT6105) {
drivers/net/ethernet/via/via-rhine.c:			if (pdev->revision >= VT6105_B0)
drivers/net/ethernet/via/via-rhine.c:			if (pdev->revision < VT6105M)
drivers/net/ethernet/via/via-rhine.c:		dev_err(&pdev->dev,
drivers/net/ethernet/via/via-rhine.c:		dev_err(&pdev->dev, "Insufficient PCI resources, aborting\n");
drivers/net/ethernet/via/via-rhine.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/via/via-rhine.c:		dev_err(&pdev->dev,
drivers/net/ethernet/via/via-rhine.c:			dev_err(&pdev->dev,
drivers/net/ethernet/via/via-rhine.c:	if (pdev->revision >= VT6105M)
drivers/net/ethernet/via/via-rhine.c:		    dev->dev_addr, pdev->irq);
drivers/net/ethernet/via/via-rhine.c:	if (rp->pdev->revision >= VT6105M)
drivers/net/ethernet/via/via-rhine.c:	rc = request_irq(rp->pdev->irq, rhine_interrupt, IRQF_SHARED, dev->name,
drivers/net/ethernet/via/via-rhine.c:	netif_dbg(rp, ifup, dev, "%s() irq %d\n", __func__, rp->pdev->irq);
drivers/net/ethernet/via/via-rhine.c:		free_irq(rp->pdev->irq, dev);
drivers/net/ethernet/via/via-rhine.c:	} else if (rp->pdev->revision >= VT6105M) {
drivers/net/ethernet/via/via-rhine.c:	if (rp->pdev->revision >= VT6105M) {
drivers/net/ethernet/via/via-rhine.c:	free_irq(rp->pdev->irq, dev);
drivers/net/ethernet/via/via-velocity.c:		dev_err(&pdev->dev, "%s : DMA memory allocation failed.\n",
drivers/net/ethernet/via/via-velocity.c:	ret = request_irq(vptr->pdev->irq, velocity_intr, IRQF_SHARED,
drivers/net/ethernet/via/via-velocity.c:	free_irq(vptr->pdev->irq, dev);
drivers/net/ethernet/via/via-velocity.c:		tdinfo->skb_dma[i + 1] = skb_frag_dma_map(&vptr->pdev->dev,
drivers/net/ethernet/via/via-velocity.c:	vptr->rev_id = pdev->revision;
drivers/net/ethernet/via/via-velocity.c:		dev_err(&pdev->dev,
drivers/net/ethernet/via/via-velocity.c:		dev_err(&pdev->dev,
drivers/net/ethernet/via/via-velocity.c:		dev_err(&pdev->dev, "region #1 is too small.\n");
drivers/net/ethernet/via/via-velocity.c:		dev_notice(&pdev->dev, "already found %d NICs.\n",
drivers/net/ethernet/via/via-velocity.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/via/via-velocity.c:		dev_err(&pdev->dev, "No PCI resources.\n");
drivers/net/ethernet/via/via-velocity.c:	drv_string = dev_driver_string(&pdev->dev);
drivers/net/ethernet/rdc/r6040.c:		dev_err(&lp->pdev->dev, "no PHY found\n");
drivers/net/ethernet/rdc/r6040.c:		dev_err(&lp->pdev->dev, "could not attach to PHY\n");
drivers/net/ethernet/rdc/r6040.c:	dev_info(&lp->pdev->dev, "attached PHY driver [%s] "
drivers/net/ethernet/rdc/r6040.c:		dev_err(&pdev->dev, "32-bit PCI DMA addresses"
drivers/net/ethernet/rdc/r6040.c:		dev_err(&pdev->dev, "32-bit PCI DMA addresses"
drivers/net/ethernet/rdc/r6040.c:		dev_err(&pdev->dev, "Insufficient PCI resources, aborting\n");
drivers/net/ethernet/rdc/r6040.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/rdc/r6040.c:		dev_err(&pdev->dev, "Failed to request PCI regions\n");
drivers/net/ethernet/rdc/r6040.c:		dev_err(&pdev->dev, "ioremap failed for device\n");
drivers/net/ethernet/rdc/r6040.c:	dev->irq = pdev->irq;
drivers/net/ethernet/rdc/r6040.c:		dev_err(&pdev->dev, "mdiobus_alloc() failed\n");
drivers/net/ethernet/rdc/r6040.c:		dev_name(&pdev->dev), card_idx);
drivers/net/ethernet/rdc/r6040.c:		dev_err(&pdev->dev, "failed to register MII bus\n");
drivers/net/ethernet/rdc/r6040.c:		dev_err(&pdev->dev, "failed to probe MII bus\n");
drivers/net/ethernet/rdc/r6040.c:		dev_err(&pdev->dev, "Failed to register net device\n");
drivers/net/ethernet/8390/ne.c:	int err, this_dev = pdev->id;
drivers/net/ethernet/8390/ne.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/8390/mcf8390.c:		dev_err(&pdev->dev, "no IRQ specified?\n");
drivers/net/ethernet/8390/mcf8390.c:		dev_err(&pdev->dev, "no memory address specified?\n");
drivers/net/ethernet/8390/mcf8390.c:	if (!request_mem_region(mem->start, msize, pdev->name))
drivers/net/ethernet/8390/mcf8390.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/8390/ax88796.c:	strlcpy(info->bus_info, pdev->name, sizeof(info->bus_info));
drivers/net/ethernet/8390/ax88796.c:		pdev->name, pdev->id);
drivers/net/ethernet/8390/ax88796.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/8390/ax88796.c:	ax->plat = pdev->dev.platform_data;
drivers/net/ethernet/8390/ax88796.c:		dev_err(&pdev->dev, "no IRQ specified\n");
drivers/net/ethernet/8390/ax88796.c:		dev_err(&pdev->dev, "no MEM specified\n");
drivers/net/ethernet/8390/ax88796.c:	if (!request_mem_region(mem->start, mem_size, pdev->name)) {
drivers/net/ethernet/8390/ax88796.c:		dev_err(&pdev->dev, "cannot reserve registers\n");
drivers/net/ethernet/8390/ax88796.c:		dev_err(&pdev->dev, "Cannot ioremap area %pR\n", mem);
drivers/net/ethernet/8390/ax88796.c:		if (!request_mem_region(mem2->start, mem2_size, pdev->name)) {
drivers/net/ethernet/8390/ax88796.c:			dev_err(&pdev->dev, "cannot reserve registers\n");
drivers/net/ethernet/8390/ax88796.c:			dev_err(&pdev->dev, "cannot map reset register\n");
drivers/net/ethernet/8390/ne2k-pci.c:	irq = pdev->irq;
drivers/net/ethernet/8390/ne2k-pci.c:		dev_err(&pdev->dev, "no I/O resource at PCI BAR #0\n");
drivers/net/ethernet/8390/ne2k-pci.c:		dev_err(&pdev->dev, "I/O resource 0x%x @ 0x%lx busy\n",
drivers/net/ethernet/8390/ne2k-pci.c:		dev_err(&pdev->dev, "cannot allocate ethernet device\n");
drivers/net/ethernet/8390/ne2k-pci.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/8390/ne2k-pci.c:				dev_err(&pdev->dev,
drivers/net/ethernet/netx-eth.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/netx-eth.c:	pdata = (struct netxeth_platform_data *)pdev->dev.platform_data;
drivers/net/ethernet/netx-eth.c:	priv->xc = request_xc(pdata->xcno, &pdev->dev);
drivers/net/ethernet/netx-eth.c:		dev_err(&pdev->dev, "unable to request xc engine\n");
drivers/net/ethernet/netx-eth.c:	priv->id = pdev->id;
drivers/net/ethernet/netx-eth.c:	struct net_device *ndev = dev_get_drvdata(&pdev->dev);
drivers/net/ethernet/netx-eth.c:	dev_err(&pdev->dev, "suspend not implemented\n");
drivers/net/ethernet/netx-eth.c:	dev_err(&pdev->dev, "resume not implemented\n");
drivers/net/ethernet/seeq/sgiseeq.c:	struct sgiseeq_platform_data *pd = pdev->dev.platform_data;
drivers/net/ethernet/seeq/sgiseeq.c:	sr = dma_alloc_noncoherent(&pdev->dev, sizeof(*sp->srings),
drivers/net/ethernet/seeq/sgiseeq.c:	dma_free_noncoherent(&pdev->dev, sizeof(*sp->srings), sp->srings,
drivers/net/ethernet/icplus/ipg.c:	rc = request_irq(pdev->irq, ipg_interrupt_handler, IRQF_SHARED,
drivers/net/ethernet/icplus/ipg.c:	dev->irq = pdev->irq;
drivers/net/ethernet/icplus/ipg.c:	sp->rxd = dma_alloc_coherent(&pdev->dev, IPG_RX_RING_BYTES,
drivers/net/ethernet/icplus/ipg.c:	sp->txd = dma_alloc_coherent(&pdev->dev, IPG_TX_RING_BYTES,
drivers/net/ethernet/icplus/ipg.c:	dma_free_coherent(&pdev->dev, IPG_TX_RING_BYTES, sp->txd, sp->txd_map);
drivers/net/ethernet/icplus/ipg.c:	dma_free_coherent(&pdev->dev, IPG_RX_RING_BYTES, sp->rxd, sp->rxd_map);
drivers/net/ethernet/icplus/ipg.c:	free_irq(pdev->irq, dev);
drivers/net/ethernet/icplus/ipg.c:		synchronize_irq(pdev->irq);
drivers/net/ethernet/icplus/ipg.c:	free_irq(pdev->irq, dev);
drivers/net/ethernet/icplus/ipg.c:		ipg_set_phy_default_param(sp->pdev->revision, dev, phyaddr);
drivers/net/ethernet/icplus/ipg.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/nxp/lpc_eth.c:	if (lpc_phy_interface_mode(&pldat->pdev->dev) == PHY_INTERFACE_MODE_MII)
drivers/net/ethernet/nxp/lpc_eth.c:	if (lpc_phy_interface_mode(&pldat->pdev->dev) == PHY_INTERFACE_MODE_MII)
drivers/net/ethernet/nxp/lpc_eth.c:			     lpc_phy_interface_mode(&pldat->pdev->dev));
drivers/net/ethernet/nxp/lpc_eth.c:	if (lpc_phy_interface_mode(&pldat->pdev->dev) == PHY_INTERFACE_MODE_MII)
drivers/net/ethernet/nxp/lpc_eth.c:		 pldat->pdev->name, pldat->pdev->id);
drivers/net/ethernet/nxp/lpc_eth.c:	pldat->mii_bus->parent = &pldat->pdev->dev;
drivers/net/ethernet/nxp/lpc_eth.c:		dev_dbg(&pldat->pdev->dev, "shutting down %s\n", ndev->name);
drivers/net/ethernet/nxp/lpc_eth.c:		dev_dbg(&pldat->pdev->dev, "enabling %s\n", ndev->name);
drivers/net/ethernet/nxp/lpc_eth.c:	if (lpc_phy_interface_mode(&pdev->dev) == PHY_INTERFACE_MODE_MII)
drivers/net/ethernet/nxp/lpc_eth.c:		dev_err(&pdev->dev, "error getting resources.\n");
drivers/net/ethernet/nxp/lpc_eth.c:		dev_err(&pdev->dev, "could not allocate device.\n");
drivers/net/ethernet/nxp/lpc_eth.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/nxp/lpc_eth.c:	pldat->clk = clk_get(&pdev->dev, NULL);
drivers/net/ethernet/nxp/lpc_eth.c:		dev_err(&pdev->dev, "error getting clock.\n");
drivers/net/ethernet/nxp/lpc_eth.c:		dev_err(&pdev->dev, "failed to map registers\n");
drivers/net/ethernet/nxp/lpc_eth.c:		dev_err(&pdev->dev, "error requesting interrupt.\n");
drivers/net/ethernet/nxp/lpc_eth.c:	if (use_iram_for_net(&pldat->pdev->dev)) {
drivers/net/ethernet/nxp/lpc_eth.c:		pldat->pdev->dev.coherent_dma_mask = 0xFFFFFFFF;
drivers/net/ethernet/nxp/lpc_eth.c:		pldat->pdev->dev.dma_mask = &pldat->pdev->dev.coherent_dma_mask;
drivers/net/ethernet/nxp/lpc_eth.c:			dma_alloc_coherent(&pldat->pdev->dev,
drivers/net/ethernet/nxp/lpc_eth.c:		const char *macaddr = of_get_mac_address(pdev->dev.of_node);
drivers/net/ethernet/nxp/lpc_eth.c:		dev_err(&pdev->dev, "Cannot register net device, aborting.\n");
drivers/net/ethernet/nxp/lpc_eth.c:	device_init_wakeup(&pdev->dev, 1);
drivers/net/ethernet/nxp/lpc_eth.c:	device_set_wakeup_enable(&pdev->dev, 0);
drivers/net/ethernet/nxp/lpc_eth.c:	if (!use_iram_for_net(&pldat->pdev->dev) ||
drivers/net/ethernet/nxp/lpc_eth.c:		dma_free_coherent(&pldat->pdev->dev, pldat->dma_buff_size,
drivers/net/ethernet/nxp/lpc_eth.c:	if (!use_iram_for_net(&pldat->pdev->dev) ||
drivers/net/ethernet/nxp/lpc_eth.c:		dma_free_coherent(&pldat->pdev->dev, pldat->dma_buff_size,
drivers/net/ethernet/nxp/lpc_eth.c:	if (device_may_wakeup(&pdev->dev))
drivers/net/ethernet/nxp/lpc_eth.c:	if (device_may_wakeup(&pdev->dev))
drivers/net/ethernet/adaptec/starfire.c:	struct device *d = &pdev->dev;
drivers/net/ethernet/adaptec/starfire.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/adaptec/starfire.c:	irq = pdev->irq;
drivers/net/ethernet/atheros/atl1e/atl1e_ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	synchronize_irq(adapter->pdev->irq);
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	hw->vendor_id = pdev->vendor;
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	hw->device_id = pdev->device;
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	hw->subsystem_vendor_id = pdev->subsystem_vendor;
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	hw->subsystem_id = pdev->subsystem_device;
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	hw->revision_id  = pdev->revision;
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	disable_irq(adapter->pdev->irq);
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	atl1e_intr(adapter->pdev->irq, netdev);
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	enable_irq(adapter->pdev->irq);
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:		if (dma_mapping_error(&adapter->pdev->dev, tx_buffer->dma))
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:		if (dma_mapping_error(&adapter->pdev->dev, tx_buffer->dma)) {
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:			tx_buffer->dma = skb_frag_dma_map(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:			if (dma_mapping_error(&adapter->pdev->dev, tx_buffer->dma)) {
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:					dma_unmap_page(&adapter->pdev->dev, tx_buffer->dma,
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	free_irq(adapter->pdev->irq, netdev);
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	err = request_irq(pdev->irq, atl1e_intr, IRQF_SHARED, netdev->name,
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:		dev_err(&pdev->dev, "cannot enable PCI device\n");
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:		dev_err(&pdev->dev, "No usable DMA configuration,aborting\n");
drivers/net/ethernet/atheros/atl1e/atl1e_main.c:		dev_err(&pdev->dev, "cannot obtain PCI resources\n");
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_info(&pdev->dev, "%s enabled\n", opt->name);
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_info(&pdev->dev, "%s disabled\n", opt->name);
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_info(&pdev->dev, "%s set to %i\n", opt->name,
drivers/net/ethernet/atheros/atlx/atl1.c:						dev_info(&pdev->dev, "%s\n",
drivers/net/ethernet/atheros/atlx/atl1.c:	dev_info(&pdev->dev, "invalid %s specified (%i) %s\n",
drivers/net/ethernet/atheros/atlx/atl1.c:		dev_notice(&pdev->dev, "no configuration for board#%i\n", bd);
drivers/net/ethernet/atheros/atlx/atl1.c:		dev_notice(&pdev->dev, "using defaults for all values\n");
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_dbg(&pdev->dev, "ICR = 0x%x\n", icr);
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_dbg(&pdev->dev, "pcie phy link down\n");
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_warn(&pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_dbg(&pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_dbg(&pdev->dev, "error resetting phy\n");
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_dbg(&pdev->dev, "error getting speed\n");
drivers/net/ethernet/atheros/atlx/atl1.c:	device_set_wakeup_enable(&adapter->pdev->dev, false);
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_err(&pdev->dev, "kzalloc failed , size = D%d\n",
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_err(&pdev->dev, "pci_alloc_consistent failed\n");
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_info(&adapter->pdev->dev, "link is down\n");
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_info(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_printk(KERN_DEBUG, &pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_printk(KERN_DEBUG, &adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_printk(KERN_DEBUG, &adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_printk(KERN_DEBUG, &adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_printk(KERN_DEBUG, &adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_printk(KERN_DEBUG, &adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_printk(KERN_DEBUG, &adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_printk(KERN_DEBUG, &adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_printk(KERN_DEBUG, &adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_printk(KERN_DEBUG, &adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:			buffer_info->dma = skb_frag_dma_map(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_printk(KERN_DEBUG, &adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_printk(KERN_DEBUG, &adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_printk(KERN_DEBUG, &adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:				&adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:	err = request_irq(adapter->pdev->irq, atl1_intr, irq_flags,
drivers/net/ethernet/atheros/atlx/atl1.c:	free_irq(adapter->pdev->irq, netdev);
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_warn(&adapter->pdev->dev, "invalid MTU setting\n");
drivers/net/ethernet/atheros/atlx/atl1.c:				dev_printk(KERN_DEBUG, &pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:	atl1_suspend(&pdev->dev);
drivers/net/ethernet/atheros/atlx/atl1.c:		dev_err(&pdev->dev, "no usable DMA configuration\n");
drivers/net/ethernet/atheros/atlx/atl1.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/atheros/atlx/atl1.c:		dev_info(&pdev->dev, "version %s\n", ATLX_DRIVER_VERSION);
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_dbg(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:					dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_dbg(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:			dev_dbg(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atlx/atl1.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
drivers/net/ethernet/atheros/atlx/atlx.c:			dev_info(&adapter->pdev->dev, "%s link is down\n",
drivers/net/ethernet/atheros/atlx/atlx.c:	synchronize_irq(adapter->pdev->irq);
drivers/net/ethernet/atheros/atlx/atl2.c:	hw->vendor_id = pdev->vendor;
drivers/net/ethernet/atheros/atlx/atl2.c:	hw->device_id = pdev->device;
drivers/net/ethernet/atheros/atlx/atl2.c:	hw->subsystem_vendor_id = pdev->subsystem_vendor;
drivers/net/ethernet/atheros/atlx/atl2.c:	hw->subsystem_id = pdev->subsystem_device;
drivers/net/ethernet/atheros/atlx/atl2.c:	hw->revision_id  = pdev->revision;
drivers/net/ethernet/atheros/atlx/atl2.c:    synchronize_irq(adapter->pdev->irq);
drivers/net/ethernet/atheros/atlx/atl2.c:	return request_irq(adapter->pdev->irq, atl2_intr, flags, netdev->name,
drivers/net/ethernet/atheros/atlx/atl2.c:	free_irq(adapter->pdev->irq, netdev);
drivers/net/ethernet/atheros/atlx/atl2.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/atheros/alx/hw.h:	return hw->pdev->revision >> ALX_PCI_REVID_SHIFT;
drivers/net/ethernet/atheros/alx/hw.h:	return hw->pdev->revision & 1;
drivers/net/ethernet/atheros/alx/hw.h:	return hw->pdev->device & 1;
drivers/net/ethernet/atheros/alx/hw.c:	dev_err(&pdev->dev, "invalid PHY speed/duplex: 0x%x\n", giga);
drivers/net/ethernet/atheros/alx/ethtool.c:	device_set_wakeup_enable(&alx->hw.pdev->dev, hw->sleep_ctrl);
drivers/net/ethernet/atheros/alx/main.c:		dma_unmap_single(&alx->hw.pdev->dev,
drivers/net/ethernet/atheros/alx/main.c:		dma = dma_map_single(&alx->hw.pdev->dev,
drivers/net/ethernet/atheros/alx/main.c:		if (dma_mapping_error(&alx->hw.pdev->dev, dma)) {
drivers/net/ethernet/atheros/alx/main.c:		dma_unmap_single(&alx->hw.pdev->dev,
drivers/net/ethernet/atheros/alx/main.c:			dma_unmap_single(&alx->hw.pdev->dev,
drivers/net/ethernet/atheros/alx/main.c:	alx->descmem.virt = dma_zalloc_coherent(&alx->hw.pdev->dev,
drivers/net/ethernet/atheros/alx/main.c:	dma_free_coherent(&alx->hw.pdev->dev,
drivers/net/ethernet/atheros/alx/main.c:	synchronize_irq(alx->hw.pdev->irq);
drivers/net/ethernet/atheros/alx/main.c:		err = request_irq(pdev->irq, alx_intr_msi, 0,
drivers/net/ethernet/atheros/alx/main.c:	err = request_irq(pdev->irq, alx_intr_legacy, IRQF_SHARED,
drivers/net/ethernet/atheros/alx/main.c:	free_irq(pdev->irq, alx);
drivers/net/ethernet/atheros/alx/main.c:		dev_err(&pdev->dev, "unrecognized chip, aborting\n");
drivers/net/ethernet/atheros/alx/main.c:		pdev->device == ALX_DEV_ID_AR8161 &&
drivers/net/ethernet/atheros/alx/main.c:		pdev->subsystem_vendor == PCI_VENDOR_ID_ATTANSIC &&
drivers/net/ethernet/atheros/alx/main.c:		pdev->subsystem_device == 0x0091 &&
drivers/net/ethernet/atheros/alx/main.c:		pdev->revision == 0;
drivers/net/ethernet/atheros/alx/main.c:		device_set_wakeup_enable(&pdev->dev, true);
drivers/net/ethernet/atheros/alx/main.c:		dev_err(&pdev->dev, "shutdown fail %d\n", err);
drivers/net/ethernet/atheros/alx/main.c:	dma = dma_map_single(&alx->hw.pdev->dev, skb->data, maplen,
drivers/net/ethernet/atheros/alx/main.c:	if (dma_mapping_error(&alx->hw.pdev->dev, dma))
drivers/net/ethernet/atheros/alx/main.c:		dma = skb_frag_dma_map(&alx->hw.pdev->dev, frag, 0,
drivers/net/ethernet/atheros/alx/main.c:		if (dma_mapping_error(&alx->hw.pdev->dev, dma))
drivers/net/ethernet/atheros/alx/main.c:	if (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(64)) &&
drivers/net/ethernet/atheros/alx/main.c:	    !dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64))) {
drivers/net/ethernet/atheros/alx/main.c:		dev_dbg(&pdev->dev, "DMA to 64-BIT addresses\n");
drivers/net/ethernet/atheros/alx/main.c:		err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/net/ethernet/atheros/alx/main.c:			err = dma_set_coherent_mask(&pdev->dev,
drivers/net/ethernet/atheros/alx/main.c:				dev_err(&pdev->dev,
drivers/net/ethernet/atheros/alx/main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/atheros/alx/main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/atheros/alx/main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/atheros/alx/main.c:		dev_err(&pdev->dev, "cannot map device registers\n");
drivers/net/ethernet/atheros/alx/main.c:	netdev->irq = pdev->irq;
drivers/net/ethernet/atheros/alx/main.c:		pdev->dev_flags |= PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG;
drivers/net/ethernet/atheros/alx/main.c:		dev_err(&pdev->dev, "net device private data init failed\n");
drivers/net/ethernet/atheros/alx/main.c:		dev_err(&pdev->dev, "MAC Reset failed, error = %d\n", err);
drivers/net/ethernet/atheros/alx/main.c:			dev_err(&pdev->dev,
drivers/net/ethernet/atheros/alx/main.c:		dev_warn(&pdev->dev,
drivers/net/ethernet/atheros/alx/main.c:		dev_err(&pdev->dev, "failed to identify PHY\n");
drivers/net/ethernet/atheros/alx/main.c:		dev_err(&pdev->dev, "register netdevice failed\n");
drivers/net/ethernet/atheros/alx/main.c:	device_set_wakeup_enable(&pdev->dev, hw->sleep_ctrl);
drivers/net/ethernet/atheros/alx/main.c:		dev_err(&pdev->dev, "shutdown fail in suspend %d\n", err);
drivers/net/ethernet/atheros/alx/main.c:	dev_info(&pdev->dev, "pci error detected\n");
drivers/net/ethernet/atheros/alx/main.c:	dev_info(&pdev->dev, "pci error slot reset\n");
drivers/net/ethernet/atheros/alx/main.c:		dev_err(&pdev->dev, "Failed to re-enable PCI device after reset\n");
drivers/net/ethernet/atheros/alx/main.c:	dev_info(&pdev->dev, "pci error resume\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	synchronize_irq(adapter->pdev->irq);
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:				dev_warn(&pdev->dev, "reset mac failed\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:				dev_info(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:				dev_info(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_dbg(&pdev->dev, "atl1c_vlan_mode\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_dbg(&pdev->dev, "atl1c_restore_vlan\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:			dev_warn(&adapter->pdev->dev, "invalid MTU setting\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_dbg(&pdev->dev, "<atl1c_mii_ioctl> write %x %x",
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	device_set_wakeup_enable(&pdev->dev, false);
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	hw->vendor_id = pdev->vendor;
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	hw->device_id = pdev->device;
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	hw->subsystem_vendor_id = pdev->subsystem_vendor;
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	hw->subsystem_id = pdev->subsystem_device;
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_err(&pdev->dev, "set mac function pointers failed\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_err(&pdev->dev, "Unable to allocate memory for queues\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_err(&pdev->dev, "pci_alloc_consistend failed\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:				dev_err(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:				dev_warn(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:				dev_warn(&pdev->dev, "alloc rx buffer failed\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:					dev_warn(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:					dev_warn(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:				dev_warn(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	disable_irq(adapter->pdev->irq);
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	atl1c_intr(adapter->pdev->irq, netdev);
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	enable_irq(adapter->pdev->irq);
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:					dev_warn(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:					dev_warn(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:				dev_err(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		buffer_info->dma = skb_frag_dma_map(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		if (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma))
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:			dev_info(&adapter->pdev->dev, "tx locked\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	free_irq(adapter->pdev->irq, netdev);
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:			dev_err(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	err = request_irq(adapter->pdev->irq, atl1c_intr, flags,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:			dev_err(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_dbg(&pdev->dev, "atl1c_request_irq OK\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:			dev_dbg(&pdev->dev, "phy power saving failed");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	atl1c_suspend(&pdev->dev);
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_err(&pdev->dev, "cannot enable PCI device\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_err(&pdev->dev, "No usable DMA configuration,aborting\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_err(&pdev->dev, "cannot obtain PCI resources\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_err(&pdev->dev, "init netdevice failed\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_err(&pdev->dev, "cannot map device registers\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_err(&pdev->dev, "net device private data init failed\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_dbg(&pdev->dev, "mac address : %pM\n",
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_err(&pdev->dev, "register netdevice failed\n");
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:		dev_info(&pdev->dev, "version %s\n", ATL1C_DRV_VERSION);
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:			dev_err(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_main.c:				dev_err(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c:					dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c:				dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c:	eeprom->magic = adapter->pdev->vendor |
drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c:			(adapter->pdev->device << 16);
drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c:	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
drivers/net/ethernet/atheros/atl1c/atl1c_hw.c:			dev_err(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_hw.c:		dev_err(&pdev->dev, "Error get phy ID\n");
drivers/net/ethernet/atheros/atl1c/atl1c_hw.c:				dev_err(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_hw.c:			dev_err(&pdev->dev, "Wrong Media type %d\n",
drivers/net/ethernet/atheros/atl1c/atl1c_hw.c:			dev_dbg(&pdev->dev, "phy autoneg failed\n");
drivers/net/ethernet/atheros/atl1c/atl1c_hw.c:						dev_dbg(&pdev->dev,
drivers/net/ethernet/atheros/atl1c/atl1c_hw.c:			dev_dbg(&pdev->dev, "%s: write phy MII_IER failed.\n",
drivers/net/ethernet/atheros/atl1c/atl1c_hw.c:	dev_dbg(&pdev->dev, "%s: suspend MAC=%x,MASTER=%x,PHY=0x%x,WOL=%x\n",
drivers/net/ethernet/brocade/bna/cna_fwimg.c:	if (request_firmware(&fw, fw_name, &pdev->dev)) {
drivers/net/ethernet/brocade/bna/cna_fwimg.c:	if (pdev->device == BFA_PCI_DEVICE_ID_CT2) {
drivers/net/ethernet/brocade/bna/cna_fwimg.c:	} else if (bfa_asic_id_ct(pdev->device)) {
drivers/net/ethernet/brocade/bna/bnad.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/brocade/bna/bnad.c:		dev_err(&pdev->dev, "ioremap for bar0 failed\n");
drivers/net/ethernet/brocade/bna/bnad.c:	if (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(64)) &&
drivers/net/ethernet/brocade/bna/bnad.c:	    !dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64))) {
drivers/net/ethernet/brocade/bna/bnad.c:		err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/net/ethernet/brocade/bna/bnad.c:			err = dma_set_coherent_mask(&pdev->dev,
drivers/net/ethernet/brocade/bna/bnad.c:	       pdev, pcidev_id, PCI_FUNC(pdev->devfn));
drivers/net/ethernet/smsc/smsc9420.c:	const int irq = pd->pdev->irq;
drivers/net/ethernet/smsc/smsc9420.c:	free_irq(pd->pdev->irq, pd);
drivers/net/ethernet/smsc/smsc9420.c:		(pd->pdev->bus->number << 8) | pd->pdev->devfn);
drivers/net/ethernet/smsc/smsc9420.c:	const int irq = pd->pdev->irq;
drivers/net/ethernet/smsc/smsc9420.c:		free_irq(pd->pdev->irq, pd);
drivers/net/ethernet/smsc/smsc9420.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/smsc/smc91x.c:	struct smc91x_platdata *pd = pdev->dev.platform_data;
drivers/net/ethernet/smsc/smc91x.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/smsc/smc91x.c:		lp->device = &pdev->dev;
drivers/net/ethernet/smsc/epic100.c:	irq = pdev->irq;
drivers/net/ethernet/smsc/epic100.c:		dev_err(&pdev->dev, "no PCI region space\n");
drivers/net/ethernet/smsc/epic100.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/smsc/epic100.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/net/ethernet/smsc/epic100.c:		dev_printk(KERN_DEBUG, &pdev->dev, "EEPROM contents:\n");
drivers/net/ethernet/smsc/epic100.c:				dev_info(&pdev->dev,
drivers/net/ethernet/smsc/epic100.c:			dev_info(&pdev->dev,
drivers/net/ethernet/smsc/epic100.c:			dev_warn(&pdev->dev,
drivers/net/ethernet/smsc/epic100.c:		dev_info(&pdev->dev, "Forced full duplex requested.\n");
drivers/net/ethernet/smsc/epic100.c:	       (long)pci_resource_start(pdev, EPIC_BAR), pdev->irq,
drivers/net/ethernet/smsc/epic100.c:	free_irq(pdev->irq, dev);
drivers/net/ethernet/smsc/smc911x.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/smsc/smc911x.c:		struct smc911x_platdata *pd = pdev->dev.platform_data;
drivers/net/ethernet/smsc/smc911x.c:		lp->dev = &pdev->dev;
drivers/net/ethernet/smsc/smsc911x.c:	ret = regulator_bulk_get(&pdev->dev,
drivers/net/ethernet/smsc/smsc911x.c:	pdata->clk = clk_get(&pdev->dev, NULL);
drivers/net/ethernet/smsc/smsc911x.c:		pdev->name, pdev->id);
drivers/net/ethernet/smsc/smsc911x.c:	pdata->mii_bus->parent = &pdev->dev;
drivers/net/ethernet/smsc/smsc911x.c:	struct device_node *np = pdev->dev.of_node;
drivers/net/ethernet/smsc/smsc911x.c:	struct smsc911x_platform_config *config = pdev->dev.platform_data;
drivers/net/ethernet/smsc/smsc911x.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/qlogic/qlge/qlge_ethtool.c:	unsigned short ssys_dev = qdev->pdev->subsystem_device;
drivers/net/ethernet/qlogic/qlge/qlge_ethtool.c:	unsigned short ssys_dev = qdev->pdev->subsystem_device;
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		map = skb_frag_dma_map(&qdev->pdev->dev, frag, 0, skb_frag_size(frag),
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		err = dma_mapping_error(&qdev->pdev->dev, map);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:				free_irq(qdev->pdev->irq, &qdev->rx_ring[0]);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:				     "%s: irq = %d.\n", __func__, pdev->irq);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:			    request_irq(pdev->irq, qlge_isr,
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	if (qdev->pdev->subsystem_device == 0x0068 ||
drivers/net/ethernet/qlogic/qlge/qlge_main.c:			qdev->pdev->subsystem_device == 0x0180)
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	qdev->device_id = qdev->pdev->device;
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		dev_err(&pdev->dev, "PCI device enable failed.\n");
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		dev_err(&pdev->dev, "Set readrq failed.\n");
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		dev_err(&pdev->dev, "PCI region request failed.\n");
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		dev_err(&pdev->dev, "No usable DMA configuration.\n");
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	pdev->needs_freset = 1;
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		dev_err(&pdev->dev, "Register mapping failed.\n");
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		dev_err(&pdev->dev, "Doorbell register mapping failed.\n");
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		dev_err(&pdev->dev, "Register access failed.\n");
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		dev_err(&pdev->dev, "Invalid FLASH.\n");
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		dev_info(&pdev->dev, "%s\n", DRV_STRING);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		dev_info(&pdev->dev, "Driver name: %s, Version: %s.\n",
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	ndev->irq = pdev->irq;
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		dev_err(&pdev->dev, "net device registration failed.\n");
drivers/net/ethernet/qlogic/qlge/qlge_main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/qlogic/qlge/qlge_main.c:	pdev->error_state = pci_channel_io_normal;
drivers/net/ethernet/qlogic/netxen/netxen_nic_ethtool.c:	if ((data_read & 0xffff) != adapter->pdev->vendor)
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		old_mask = pdev->dma_mask;
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		old_cmask = pdev->dev.coherent_dma_mask;
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_info(&pdev->dev, "using %d-bit dma mask\n", 32+shift);
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_info(&adapter->pdev->dev, "Gen2 strapping detected\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_info(&adapter->pdev->dev, "Gen1 strapping detected\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	pdevfuncsave = pdev->devfn;
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		pdev->devfn++;
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	pdev->devfn = pdevfuncsave;
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_warn(&pdev->dev, "Bad MAC address %pM.\n", netdev->dev_addr);
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:			dev_info(&pdev->dev, "using msi-x interrupts\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_info(&pdev->dev, "using msi interrupts\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		adapter->msix_entries[0].vector = pdev->irq;
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	dev_info(&pdev->dev, "using legacy interrupts\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	adapter->msix_entries[0].vector = pdev->irq;
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:			dev_err(&pdev->dev, "failed to map PCI bar 0\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:			dev_err(&pdev->dev, "failed to map PCI bar 0\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:			dev_err(&pdev->dev, "failed to map PCI bar 0\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	dev_info(&pdev->dev, "%dMB memory map\n", (int)(mem_len>>20));
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:			dev_err(&pdev->dev, "error reading board info\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:				dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_warn(&pdev->dev, "firmware version %d.%d.%d unsupported\n",
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	dev_info(&pdev->dev, "firmware v%d.%d.%d [%s]\n",
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_err(&pdev->dev, "error in init HW init sequence\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_err(&pdev->dev, "%s: failed to setup interrupt\n",
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_warn(&pdev->dev, "failed to read mac addr\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_err(&pdev->dev, "failed to register net device\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	struct pci_dev *root = pdev->bus->self;
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	int pci_func_id = PCI_FUNC(pdev->devfn);
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	if (pdev->revision >= NX_P3_A0 && pdev->revision <= NX_P3_B1) {
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	if (NX_IS_REVISION_P3(pdev->revision))
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	revision_id = pdev->revision;
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_err(&pdev->dev, "Error getting board config info.\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_info(&adapter->pdev->dev, "%s: GbE port initialized\n",
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_info(&adapter->pdev->dev, "%s: XGbE port initialized\n",
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	if (NX_IS_REVISION_P3(pdev->revision)) {
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_err(&pdev->dev, "failed to start firmware\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		map = skb_frag_dma_map(&pdev->dev, frag, 0, skb_frag_size(frag),
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		if (dma_mapping_error(&pdev->dev, map))
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	dev_err(&adapter->pdev->dev, "%s: Device initialization Failed\n",
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	dev_err(&adapter->pdev->dev, "Dumping hw/fw registers\n"
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	dev = &pdev->dev;
drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c:	struct device *dev = &pdev->dev;
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:		dev_err(&adapter->pdev->dev, "Can not capture Minidump "
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:		dev_err(&adapter->pdev->dev, "Unable to allocate dmable memory for template.\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:		dev_err(&adapter->pdev->dev, "Failed to get minidump template, "
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:		dev_err(&adapter->pdev->dev, "Error : Invalid template size "
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:		dev_err(&adapter->pdev->dev, "Minidump template checksum Error\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:		dev_err(&pdev->dev, "failed to allocate hw context\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:		dev_err(&pdev->dev, "%s: failed to allocate tx desc ring\n",
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:			dev_err(&pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_ctx.c:			dev_err(&pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:	dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:	dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:		dev_err(&pdev->dev, "invalid board config, magic=%08x\n",
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:		dev_err(&pdev->dev, "unknown board type %x\n", board_type);
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:						dev_err(&adapter->pdev->dev, "%s : "
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:				dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:		dev_info(&adapter->pdev->dev, "Aborting further dump capture\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:		dev_err(&adapter->pdev->dev, "Capture mask %02x below minimum needed "
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:			dev_info(&adapter->pdev->dev, "%s Successfully "
drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:		dev_err(&adapter->pdev->dev, "Unable to read flash fw"
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:	dev_info(&adapter->pdev->dev, "Flash fw[%d.%d.%d] is < min fw supported"
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:	dev_info(&pdev->dev, "loading firmware from %s\n",
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:		dev_err(&pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:		dev_err(&pdev->dev, "%s: firmware bios is incompatible\n",
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:		dev_err(&pdev->dev, "Unable to read flash fw version\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:		dev_err(&pdev->dev, "Incompatibility detected between driver "
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:			dev_info(&pdev->dev, "%s: firmware is older than flash\n",
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:				fw_name[adapter->fw_type], &pdev->dev);
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:		dev_err(&adapter->pdev->dev, "dma_watchdog_shutdown failed\n");
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:	dev_warn(&adapter->pdev->dev, "firmware init failed\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	if (adapter->pdev->device == PCI_DEVICE_ID_QLOGIC_QLE824X)
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_warn(&pdev->dev, "Bad MAC address %pM.\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_info(&pdev->dev, "using msi-x interrupts\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_info(&pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:				dev_info(&pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_info(&pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_info(&pdev->dev, "using msi interrupts\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		adapter->msix_entries[0].vector = pdev->irq;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	dev_info(&pdev->dev, "using legacy interrupts\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	adapter->msix_entries[0].vector = pdev->irq;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	qlcnic_get_bar_length(pdev->device, &bar0_len);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_err(&pdev->dev, "failed to map PCI bar 0\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	dev_info(&pdev->dev, "%dKB memory map\n", (int)(mem_len >> 10));
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		if (qlcnic_boards[i].vendor == pdev->vendor &&
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			qlcnic_boards[i].device == pdev->device &&
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			qlcnic_boards[i].sub_vendor == pdev->subsystem_vendor &&
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			qlcnic_boards[i].sub_device == pdev->subsystem_device) {
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&pdev->dev, "Error getting board config info.\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:				dev_info(&pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	dev_info(&pdev->dev, "Driver v%s, firmware v%d.%d.%d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	dev_err(&adapter->pdev->dev, "Device state set to failed\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&pdev->dev, "Error in setting sw resources\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&pdev->dev, "Error in setting hw resources\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&pdev->dev, "failed to setup interrupt\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	dev_err(&adapter->pdev->dev, "%s:\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&pdev->dev, "failed to register net device\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&pdev->dev, "Unable to set DMA mask, aborting\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	if (pdev->is_virtfn)
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&pdev->dev, "Failed to create workqueue\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	adapter->ahw->revision_id = pdev->revision;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_err(&pdev->dev, "Loading fw failed.Please Reboot\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_err(&pdev->dev, "%s: failed\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_warn(&pdev->dev, "failed to read mac addr\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_warn(&pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&pdev->dev, "Failed to setup interrupt\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_info(&adapter->pdev->dev, "%s: GbE port initialized\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_info(&adapter->pdev->dev, "%s: XGbE port initialized\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&pdev->dev, "failed to start firmware\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_warn(&adapter->pdev->dev, "IDC Version mismatch, driver's"
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&adapter->pdev->dev, "Device in failed state.\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_info(&adapter->pdev->dev, "Detected state change from "
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_info(&adapter->pdev->dev, "Reset:Failed to get ack %d sec\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	dev_err(&adapter->pdev->dev, "Fwinit work failed state=%u "
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&adapter->pdev->dev, "Detaching the device: temp=%d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	dev_info(&adapter->pdev->dev, "Pause control frames disabled"
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	dev_err(&adapter->pdev->dev, "firmware hang detected\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	dev_err(&adapter->pdev->dev, "Dumping hw/fw registers\n"
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	int val = pdev->devfn;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			(pdev->bus), pdev->bus->number,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			PCI_DEVFN(PCI_SLOT(pdev->devfn), val));
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:		if (oth_pdev->current_state != PCI_D3cold) {
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:	pdev->error_state = pci_channel_io_normal;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:					dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:				dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:				dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:	tmp_addr = dma_alloc_coherent(&adapter->pdev->dev, temp_size,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:	dma_free_coherent(&adapter->pdev->dev, temp_size, tmp_addr, tmp_addr_t);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:		dev_info(&adapter->pdev->dev, "Dump not enabled\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:		if (!qlcnic_valid_dump_entry(&adapter->pdev->dev, entry, dump))
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:		dev_info(&adapter->pdev->dev, "%s: Dump data, %d bytes captured\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:		kobject_uevent_env(&adapter->pdev->dev.kobj, KOBJ_CHANGE, msg);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c:			dev_info(&pdev->dev, "Supports FW dump capability\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c:		dev_err(&adapter->pdev->dev, "Unsupported board model %d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c:	if ((data_read & 0xffff) != adapter->pdev->vendor)
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c:	dev_warn(&adapter->pdev->dev, "%s loopback test in progress\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	dev_info(&pdev->dev, "Driver v%s, firmware version %d.%d.%d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		adapter->msix_entries[0].vector = adapter->pdev->irq;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev, "using legacy interrupt\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev, "Mailbox detached\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	dev_err(&adapter->pdev->dev, "MBX command 0x%x timed out\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	dev_dbg(&adapter->pdev->dev, "Completion AEN:0x%x.\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev, "SFP+ Insert AEN:0x%x.\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev, "SFP Removed AEN:0x%x.\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_dbg(&adapter->pdev->dev, "Unsupported AEN:0x%x.\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	dev_info(&adapter->pdev->dev, "Rx Context[%d] Created, state:0x%x\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:	dev_info(&adapter->pdev->dev, "Tx Context[0x%x] Created, state:0x%x\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:				dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev, "Set Port Config failed.\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev, "Get Port config failed\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev, "LRO config failed\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev, "RSS config failed\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev, "Failed to get mac address%d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev, "Failed to enable eswitch%d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev, "Failed to set nic info%d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_info(&adapter->pdev->dev, "%s:\n"
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev, "Failed to get PCI Info%d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev, "Illegal addr = 0x%x\n", addr);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev, "%s: failed at %d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:				dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:				dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev, "Illegal addr = 0x%x\n", addr);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev, "link state down\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_warn(&adapter->pdev->dev, "Unknown get statistics mode\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev, "%s: Reg test failed\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:		dev_info(&adapter->pdev->dev, "%s: EEPROM test failed.\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_err(&adapter->pdev->dev, "Error waiting for rom done\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_err(&pdev->dev, "ERROR Reading crb_init area: val:%x\n", n);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_err(&pdev->dev, "QLOGIC card flash not initialized.\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:			dev_err(&pdev->dev, "CRB init value out of range %x\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:	dev_err(&adapter->pdev->dev, "Command Peg initialization not "
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_err(&adapter->pdev->dev, "Receive Peg initialization not "
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_info(&adapter->pdev->dev, "Resetting rom_lock\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:	dev_info(&pdev->dev, "loading firmware from %s\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:			dev_info(&pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_err(&pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		dev_err(&pdev->dev, "%s: firmware bios is incompatible\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:				      &pdev->dev);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c:	unsigned short device = adapter->pdev->device;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c:		map = skb_frag_dma_map(&pdev->dev, frag, 0, skb_frag_size(frag),
drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c:		if (dma_mapping_error(&pdev->dev, map))
drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c:	dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:	dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:		dev_err(&adapter->pdev->dev, "Cannot create FLR workqueue\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:		dev_err(&adapter->pdev->dev, "Failed to set ACL, err=%d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c:	dev_info(&adapter->pdev->dev, "%s: op_mode %d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_err(&adapter->pdev->dev, "%s:\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_info(&adapter->pdev->dev, "Device will enter failed state\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_info(&adapter->pdev->dev, "vNIC mode disabled\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_info(&adapter->pdev->dev, "vNIC mode enabled\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_err(&adapter->pdev->dev, "%s: TBD\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_err(&adapter->pdev->dev, "%s: please restart!!\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_info(&adapter->pdev->dev, "%s: TBD\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&adapter->pdev->dev, "MS memory write failed\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_info(&adapter->pdev->dev, "SRE-Shim Ctrl:0x%x\n", val);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_info(&adapter->pdev->dev, "0x%x  ", val);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_info(&adapter->pdev->dev, "\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			 dev_info(&adapter->pdev->dev, "0x%x  ", val);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_info(&adapter->pdev->dev, "\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_info(&adapter->pdev->dev, "0x%x  ", val);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_info(&adapter->pdev->dev, "\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&p_dev->pdev->dev, "firmware hang detected\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_info(&p_dev->pdev->dev, "Dumping HW/FW registers\n"
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_err(&p_dev->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_err(&p_dev->pdev->dev, "%s: failed, state = 0x%x\n", __func__, val);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&p_dev->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&p_dev->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&p_dev->pdev->dev, "%s: failed\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&p_dev->pdev->dev, "%s: flash read failed\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&p_dev->pdev->dev, "%s: flash read failed\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&p_dev->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&p_dev->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_err(&p_dev->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&p_dev->pdev->dev, "%s: failed\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&p_dev->pdev->dev, "%s: failed\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&p_dev->pdev->dev, "%s: failed\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			     QLC_83XX_FW_FILE_NAME, &(adapter->pdev->dev))) {
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:	dev_info(&adapter->pdev->dev, "HAL Version: %d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c:				dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c:				dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_vnic.c:	dev_info(&adapter->pdev->dev, "HAL Version: %d, Management function\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_vnic.c:	dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_vnic.c:	dev_info(&adapter->pdev->dev, "HAL Version: %d, Virtual function\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_err(&adapter->pdev->dev, "Cannot create async workqueue\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:			dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_info(&adapter->pdev->dev, "Mailbox detached\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	dev_err(&adapter->pdev->dev, "MBX command 0x%x timed out\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_err(&adapter->pdev->dev, "Failed to get ACL, err=%d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	dev_info(&adapter->pdev->dev, "HAL Version: %d\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_err(&adapter->pdev->dev, "Failed to setup interrupt\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	dev_info(&adapter->pdev->dev, "%s: XGbE port initialized\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_warn(&adapter->pdev->dev, "failed to read mac addr\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	struct device *dev = &adapter->pdev->dev;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	dev_err(&adapter->pdev->dev, "Device is in failed state\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	dev_info(&adapter->pdev->dev, "Device is in quiescent state\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:	dev_err(&adapter->pdev->dev, "%s: Device in unknown state\n", __func__);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.c:		dev_err(&adapter->pdev->dev, "%sting loopback mode failed\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.c:		dev_err(&adapter->pdev->dev, "Invalid offset 0x%lx\n", off);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.c:			dev_warn(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.c:	dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.c:	dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.c:			dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.c:		dev_err(&pdev->dev, "invalid board config, magic=%08x\n",
drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.c:		dev_err(&pdev->dev, "unknown board type %x\n", board_type);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_hw.c:		dev_err(&adapter->pdev->dev, "LED configuration failed.\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic.h:			 dev_name(&adapter->pdev->dev),	\
drivers/net/ethernet/qlogic/qlcnic/qlcnic.h:	unsigned short device = adapter->pdev->device;
drivers/net/ethernet/qlogic/qlcnic/qlcnic.h:	unsigned short device = adapter->pdev->device;
drivers/net/ethernet/qlogic/qlcnic/qlcnic.h:	unsigned short device = adapter->pdev->device;
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&pdev->dev, "card response timeout.\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&pdev->dev, fmt, cmd->rsp.arg[0]);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev, "Failed to set mtu\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	addr = dma_alloc_coherent(&adapter->pdev->dev, rq_size,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	addr = dma_alloc_coherent(&adapter->pdev->dev, rsp_size,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	dma_free_coherent(&adapter->pdev->dev, rsp_size, prsp,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	dma_free_coherent(&adapter->pdev->dev, rq_size, prq, hostrq_phys_addr);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	rq_addr = dma_alloc_coherent(&adapter->pdev->dev, rq_size,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	rsp_addr = dma_alloc_coherent(&adapter->pdev->dev, rsp_size,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	dma_free_coherent(&adapter->pdev->dev, rsp_size, rsp_addr,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	dma_free_coherent(&adapter->pdev->dev, rq_size, rq_addr, rq_phys_addr);
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		ptr = (__le32 *)dma_alloc_coherent(&pdev->dev, sizeof(u32),
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		addr = dma_alloc_coherent(&pdev->dev, TX_DESC_RINGSIZE(tx_ring),
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		addr = dma_alloc_coherent(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		addr = dma_alloc_coherent(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:			dma_free_coherent(&adapter->pdev->dev, sizeof(u32),
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:			dma_free_coherent(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:			dma_free_coherent(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:			dma_free_coherent(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	nic_info_addr = dma_alloc_coherent(&adapter->pdev->dev, nic_size,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	dma_free_coherent(&adapter->pdev->dev, nic_size, nic_info_addr,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	nic_info_addr = dma_alloc_coherent(&adapter->pdev->dev, nic_size,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	dma_free_coherent(&adapter->pdev->dev, nic_size, nic_info_addr,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	pci_info_addr = dma_alloc_coherent(&adapter->pdev->dev, pci_size,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	dma_free_coherent(&adapter->pdev->dev, pci_size, pci_info_addr,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	stats_addr = dma_alloc_coherent(&adapter->pdev->dev, stats_size,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	dma_free_coherent(&adapter->pdev->dev, stats_size, stats_addr,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	stats_addr = dma_alloc_coherent(&adapter->pdev->dev, stats_size,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	dma_free_coherent(&adapter->pdev->dev, stats_size, stats_addr,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:	dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_err(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qlcnic/qlcnic_ctx.c:		dev_info(&adapter->pdev->dev,
drivers/net/ethernet/qlogic/qla3xxx.c:		map = skb_frag_dma_map(&qdev->pdev->dev, frag, 0, skb_frag_size(frag),
drivers/net/ethernet/qlogic/qla3xxx.c:		err = dma_mapping_error(&qdev->pdev->dev, map);
drivers/net/ethernet/qlogic/qla3xxx.c:	netdev_info(ndev, "Interrupt number = %d\n", pdev->irq);
drivers/net/ethernet/qlogic/qla3xxx.c:	free_irq(qdev->pdev->irq, ndev);
drivers/net/ethernet/qlogic/qla3xxx.c:	err = request_irq(qdev->pdev->irq, ql3xxx_isr,
drivers/net/ethernet/qlogic/qla3xxx.c:			   qdev->pdev->irq);
drivers/net/ethernet/qlogic/qla3xxx.c:	free_irq(qdev->pdev->irq, ndev);
drivers/net/ethernet/qlogic/qla3xxx.c:	qdev->pci_slot = (u8) PCI_SLOT(qdev->pdev->devfn);
drivers/net/ethernet/qlogic/qla3xxx.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/qlogic/qla3xxx.c:	ndev->irq = pdev->irq;
drivers/net/ethernet/ti/cpsw.c:	pm_runtime_get_sync(&priv->pdev->dev);
drivers/net/ethernet/ti/cpsw.c:	pm_runtime_put_sync(&priv->pdev->dev);
drivers/net/ethernet/ti/cpsw.c:	pm_runtime_put_sync(&priv->pdev->dev);
drivers/net/ethernet/ti/cpsw.c:	strlcpy(info->bus_info, priv->pdev->name, sizeof(info->bus_info));
drivers/net/ethernet/ti/cpsw.c:	struct device_node *node = pdev->dev.of_node;
drivers/net/ethernet/ti/cpsw.c:	ret = of_platform_populate(node, NULL, NULL, &pdev->dev);
drivers/net/ethernet/ti/cpsw.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/ti/cpsw.c:	priv->cpts = devm_kzalloc(&pdev->dev, sizeof(struct cpts), GFP_KERNEL);
drivers/net/ethernet/ti/cpsw.c:	pm_runtime_enable(&pdev->dev);
drivers/net/ethernet/ti/cpsw.c:	priv->clk = clk_get(&pdev->dev, "fck");
drivers/net/ethernet/ti/cpsw.c:		dev_err(&pdev->dev, "fck is not found\n");
drivers/net/ethernet/ti/cpsw.c:	dma_params.dev		= &pdev->dev;
drivers/net/ethernet/ti/cpsw.c:					dev_name(&pdev->dev), priv)) {
drivers/net/ethernet/ti/cpsw.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/ti/cpsw.c:	if (cpts_register(&pdev->dev, priv->cpts,
drivers/net/ethernet/ti/cpsw.c:	pm_runtime_disable(&pdev->dev);
drivers/net/ethernet/ti/cpsw.c:	pm_runtime_disable(&pdev->dev);
drivers/net/ethernet/ti/cpsw.c:	pm_runtime_put_sync(&pdev->dev);
drivers/net/ethernet/ti/cpsw.c:	pm_runtime_get_sync(&pdev->dev);
drivers/net/ethernet/ti/cpmac.c:	struct plat_cpmac_data *pdata = priv->pdev->dev.platform_data;
drivers/net/ethernet/ti/cpmac.c:	struct plat_cpmac_data *pdata = priv->pdev->dev.platform_data;
drivers/net/ethernet/ti/cpmac.c:	pdata = pdev->dev.platform_data;
drivers/net/ethernet/ti/cpmac.c:		phy_id = pdev->id;
drivers/net/ethernet/ti/cpmac.c:		dev_err(&pdev->dev, "no PHY present, falling back "
drivers/net/ethernet/ti/cpmac.c:		phy_id = pdev->id;
drivers/net/ethernet/ti/tlan.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/ti/tlan.c:		dev->irq = pdev->irq;
drivers/net/ethernet/ti/tlan.c:		priv->adapter_rev = pdev->revision;
drivers/net/ethernet/ti/davinci_emac.c:	pm_runtime_get(&priv->pdev->dev);
drivers/net/ethernet/ti/davinci_emac.c:	pm_runtime_put(&priv->pdev->dev);
drivers/net/ethernet/ti/davinci_emac.c:	pm_runtime_put(&priv->pdev->dev);
drivers/net/ethernet/ti/davinci_emac.c:	pdata = pdev->dev.platform_data;
drivers/net/ethernet/ti/davinci_emac.c:		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/net/ethernet/ti/davinci_emac.c:	np = pdev->dev.of_node;
drivers/net/ethernet/ti/davinci_emac.c:	pdev->dev.platform_data = pdata;
drivers/net/ethernet/ti/davinci_emac.c:	return  pdev->dev.platform_data;
drivers/net/ethernet/ti/davinci_emac.c:	emac_clk = devm_clk_get(&pdev->dev, NULL);
drivers/net/ethernet/ti/davinci_emac.c:		dev_err(&pdev->dev, "failed to get EMAC clock\n");
drivers/net/ethernet/ti/davinci_emac.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/net/ethernet/ti/davinci_emac.c:		dev_err(&pdev->dev,"error getting res\n");
drivers/net/ethernet/ti/davinci_emac.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
drivers/net/ethernet/ti/davinci_emac.c:		dev_err(&pdev->dev, "failed request_mem_region() for regs\n");
drivers/net/ethernet/ti/davinci_emac.c:	priv->remap_addr = devm_ioremap(&pdev->dev, res->start, size);
drivers/net/ethernet/ti/davinci_emac.c:		dev_err(&pdev->dev, "unable to map IO\n");
drivers/net/ethernet/ti/davinci_emac.c:		dev_err(&pdev->dev, "error initializing DMA\n");
drivers/net/ethernet/ti/davinci_emac.c:		dev_err(&pdev->dev, "error getting irq res\n");
drivers/net/ethernet/ti/davinci_emac.c:		dev_warn(&pdev->dev, "using random MAC addr: %pM\n",
drivers/net/ethernet/ti/davinci_emac.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/ethernet/ti/davinci_emac.c:		dev_err(&pdev->dev, "error in register_netdev\n");
drivers/net/ethernet/ti/davinci_emac.c:	pm_runtime_enable(&pdev->dev);
drivers/net/ethernet/ti/davinci_emac.c:	pm_runtime_resume(&pdev->dev);
drivers/net/ethernet/ti/davinci_mdio.c:	struct device_node *node = pdev->dev.of_node;
drivers/net/ethernet/ti/davinci_mdio.c:	struct mdio_platform_data *pdata = pdev->dev.platform_data;
drivers/net/ethernet/ti/davinci_mdio.c:	struct device *dev = &pdev->dev;
drivers/net/ethernet/ti/davinci_mdio.c:		snprintf(data->bus->id, MII_BUS_ID_SIZE, "%s", pdev->name);
drivers/net/ethernet/ti/davinci_mdio.c:			 pdev->name, pdev->id);
drivers/net/ethernet/ti/davinci_mdio.c:	pm_runtime_enable(&pdev->dev);
drivers/net/ethernet/ti/davinci_mdio.c:	pm_runtime_get_sync(&pdev->dev);
drivers/net/ethernet/ti/davinci_mdio.c:	data->clk = clk_get(&pdev->dev, "fck");
drivers/net/ethernet/ti/davinci_mdio.c:	pm_runtime_put_sync(&pdev->dev);
drivers/net/ethernet/ti/davinci_mdio.c:	pm_runtime_disable(&pdev->dev);
drivers/net/ethernet/ti/davinci_mdio.c:	struct device *dev = &pdev->dev;
drivers/net/ethernet/ti/davinci_mdio.c:	pm_runtime_put_sync(&pdev->dev);
drivers/net/ethernet/ti/davinci_mdio.c:	pm_runtime_disable(&pdev->dev);
drivers/net/ethernet/fealnx.c:		dev_err(&pdev->dev,
drivers/net/ethernet/fealnx.c:	irq = pdev->irq;
drivers/net/ethernet/fealnx.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/fealnx.c:				dev_info(&pdev->dev,
drivers/net/ethernet/fealnx.c:			dev_warn(&pdev->dev,
drivers/net/ethernet/fealnx.c:		dev_info(&pdev->dev, "Media type forced to Full Duplex.\n");
drivers/net/ethernet/octeon/octeon_mgmt.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/octeon/octeon_mgmt.c:	dev_set_drvdata(&pdev->dev, netdev);
drivers/net/ethernet/octeon/octeon_mgmt.c:	p->dev = &pdev->dev;
drivers/net/ethernet/octeon/octeon_mgmt.c:	data = of_get_property(pdev->dev.of_node, "cell-index", &len);
drivers/net/ethernet/octeon/octeon_mgmt.c:		dev_err(&pdev->dev, "no 'cell-index' property\n");
drivers/net/ethernet/octeon/octeon_mgmt.c:		dev_err(&pdev->dev, "no 'reg' resource\n");
drivers/net/ethernet/octeon/octeon_mgmt.c:		dev_err(&pdev->dev, "no 'reg' resource\n");
drivers/net/ethernet/octeon/octeon_mgmt.c:		dev_err(&pdev->dev, "no 'reg' resource\n");
drivers/net/ethernet/octeon/octeon_mgmt.c:	if (!devm_request_mem_region(&pdev->dev, p->mix_phys, p->mix_size,
drivers/net/ethernet/octeon/octeon_mgmt.c:		dev_err(&pdev->dev, "request_mem_region (%s) failed\n",
drivers/net/ethernet/octeon/octeon_mgmt.c:	if (!devm_request_mem_region(&pdev->dev, p->agl_phys, p->agl_size,
drivers/net/ethernet/octeon/octeon_mgmt.c:		dev_err(&pdev->dev, "request_mem_region (%s) failed\n",
drivers/net/ethernet/octeon/octeon_mgmt.c:	if (!devm_request_mem_region(&pdev->dev, p->agl_prt_ctl_phys,
drivers/net/ethernet/octeon/octeon_mgmt.c:		dev_err(&pdev->dev, "request_mem_region (%s) failed\n",
drivers/net/ethernet/octeon/octeon_mgmt.c:	p->mix = (u64)devm_ioremap(&pdev->dev, p->mix_phys, p->mix_size);
drivers/net/ethernet/octeon/octeon_mgmt.c:	p->agl = (u64)devm_ioremap(&pdev->dev, p->agl_phys, p->agl_size);
drivers/net/ethernet/octeon/octeon_mgmt.c:	p->agl_prt_ctl = (u64)devm_ioremap(&pdev->dev, p->agl_prt_ctl_phys,
drivers/net/ethernet/octeon/octeon_mgmt.c:	mac = of_get_mac_address(pdev->dev.of_node);
drivers/net/ethernet/octeon/octeon_mgmt.c:	p->phy_np = of_parse_phandle(pdev->dev.of_node, "phy-handle", 0);
drivers/net/ethernet/octeon/octeon_mgmt.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(64);
drivers/net/ethernet/octeon/octeon_mgmt.c:	pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/net/ethernet/octeon/octeon_mgmt.c:	dev_info(&pdev->dev, "Version " DRV_VERSION "\n");
drivers/net/ethernet/octeon/octeon_mgmt.c:	struct net_device *netdev = dev_get_drvdata(&pdev->dev);
drivers/net/ethernet/jme.c:	if (jme->pdev->device == PCI_DEVICE_ID_JMICRON_JMC250)
drivers/net/ethernet/jme.c:		if (is_buggy250(jme->pdev->device, jme->chiprev)) {
drivers/net/ethernet/jme.c:	txring->alloc = dma_alloc_coherent(&(jme->pdev->dev),
drivers/net/ethernet/jme.c:	dma_free_coherent(&(jme->pdev->dev),
drivers/net/ethernet/jme.c:		dma_free_coherent(&(jme->pdev->dev),
drivers/net/ethernet/jme.c:		dma_free_coherent(&(jme->pdev->dev),
drivers/net/ethernet/jme.c:	rxring->alloc = dma_alloc_coherent(&(jme->pdev->dev),
drivers/net/ethernet/jme.c:	dma_free_coherent(&(jme->pdev->dev),
drivers/net/ethernet/jme.c:	rc = request_irq(jme->pdev->irq, handler, irq_flags, netdev->name,
drivers/net/ethernet/jme.c:		netdev->irq = jme->pdev->irq;
drivers/net/ethernet/jme.c:	free_irq(jme->pdev->irq, jme->dev);
drivers/net/ethernet/jme.c:		jme->dev->irq = jme->pdev->irq;
drivers/net/ethernet/jme.c:	switch (jme->pdev->device) {
drivers/net/ethernet/jme.c:	device_set_wakeup_enable(&jme->pdev->dev, !!(jme->reg_pmcs));
drivers/net/ethernet/jme.c:	if (pdev->device == PCI_DEVICE_ID_JMICRON_JMC250 &&
drivers/net/ethernet/jme.c:	if (pdev->device == PCI_DEVICE_ID_JMICRON_JMC250 &&
drivers/net/ethernet/jme.c:	SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/ethernet/jme.c:	if (pdev->device == PCI_DEVICE_ID_JMICRON_JMC250)
drivers/net/ethernet/jme.c:	device_set_wakeup_enable(&pdev->dev, true);
drivers/net/ethernet/jme.c:	jme->pcirev = pdev->revision;
drivers/net/ethernet/jme.c:		   (jme->pdev->device == PCI_DEVICE_ID_JMICRON_JMC250) ?
drivers/net/ethernet/jme.c:		   (jme->pdev->device == PCI_DEVICE_ID_JMICRON_JMC260) ?
drivers/net/ethernet/dnet.c:		bp->pdev->name, bp->pdev->id);
drivers/net/ethernet/dnet.c:		dev_err(&pdev->dev, "no mmio resource defined\n");
drivers/net/ethernet/dnet.c:		dev_err(&pdev->dev, "no memory region available\n");
drivers/net/ethernet/dnet.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/dnet.c:		dev_err(&pdev->dev, "failed to map registers, aborting.\n");
drivers/net/ethernet/dnet.c:		dev_err(&pdev->dev, "Unable to request IRQ %d (error %d)\n",
drivers/net/ethernet/dnet.c:		dev_err(&pdev->dev, "Cannot register net device, aborting.\n");
drivers/net/ethernet/dnet.c:		dev_warn(&pdev->dev, "Cannot register PHY board fixup.\n");
drivers/net/ethernet/dnet.c:	dev_info(&pdev->dev, "Dave DNET at 0x%p (0x%08x) irq %d %pM\n",
drivers/net/ethernet/dnet.c:	dev_info(&pdev->dev, "has %smdio, %sirq, %sgigabit, %sdma\n",
drivers/net/ethernet/dnet.c:	dev_info(&pdev->dev, "attached PHY driver [%s] "
drivers/net/ethernet/sun/niu.c:		dev_err(&pdev->dev, "Cannot enable PCI device, aborting\n");
drivers/net/ethernet/sun/niu.c:		dev_err(&pdev->dev, "Cannot find proper PCI device base addresses, aborting\n");
drivers/net/ethernet/sun/niu.c:		dev_err(&pdev->dev, "Cannot obtain PCI resources, aborting\n");
drivers/net/ethernet/sun/niu.c:		dev_err(&pdev->dev, "Cannot find PCI Express capability, aborting\n");
drivers/net/ethernet/sun/niu.c:	dev = niu_alloc_and_init(&pdev->dev, pdev, NULL,
drivers/net/ethernet/sun/niu.c:				 &niu_pci_ops, PCI_FUNC(pdev->devfn));
drivers/net/ethernet/sun/niu.c:	parent_id.pci.domain = pci_domain_nr(pdev->bus);
drivers/net/ethernet/sun/niu.c:	parent_id.pci.bus = pdev->bus->number;
drivers/net/ethernet/sun/niu.c:	parent_id.pci.device = PCI_SLOT(pdev->devfn);
drivers/net/ethernet/sun/niu.c:			dev_err(&pdev->dev, "Unable to obtain 44 bit DMA for consistent allocations, aborting\n");
drivers/net/ethernet/sun/niu.c:			dev_err(&pdev->dev, "No usable DMA configuration, aborting\n");
drivers/net/ethernet/sun/niu.c:		dev_err(&pdev->dev, "Cannot map device registers, aborting\n");
drivers/net/ethernet/sun/niu.c:	dev->irq = pdev->irq;
drivers/net/ethernet/sun/niu.c:			dev_err(&pdev->dev, "Problem fetching invariants of chip, aborting\n");
drivers/net/ethernet/sun/niu.c:		dev_err(&pdev->dev, "Cannot register net device, aborting\n");
drivers/net/ethernet/sun/sungem.c:	if (gp->pdev->vendor == PCI_VENDOR_ID_SUN &&
drivers/net/ethernet/sun/sungem.c:	    gp->pdev->device == PCI_DEVICE_ID_SUN_GEM) {
drivers/net/ethernet/sun/sungem.c:	disable_irq(gp->pdev->irq);
drivers/net/ethernet/sun/sungem.c:	gem_interrupt(gp->pdev->irq, dev);
drivers/net/ethernet/sun/sungem.c:	enable_irq(gp->pdev->irq);
drivers/net/ethernet/sun/sungem.c:			mapping = skb_frag_dma_map(&gp->pdev->dev, this_frag,
drivers/net/ethernet/sun/sungem.c:	if (gp->pdev->vendor == PCI_VENDOR_ID_APPLE) {
drivers/net/ethernet/sun/sungem.c:	if (gp->pdev->vendor == PCI_VENDOR_ID_SUN &&
drivers/net/ethernet/sun/sungem.c:	    gp->pdev->device == PCI_DEVICE_ID_SUN_GEM) {
drivers/net/ethernet/sun/sungem.c:       	if (gp->pdev->vendor == PCI_VENDOR_ID_APPLE)
drivers/net/ethernet/sun/sungem.c:	if (pdev->vendor == PCI_VENDOR_ID_APPLE) {
drivers/net/ethernet/sun/sungem.c:		if (gp->pdev->device == PCI_DEVICE_ID_APPLE_K2_GMAC)
drivers/net/ethernet/sun/sungem.c:	if (pdev->vendor == PCI_VENDOR_ID_SUN &&
drivers/net/ethernet/sun/sungem.c:	    pdev->device == PCI_DEVICE_ID_SUN_RIO_GEM) {
drivers/net/ethernet/sun/sungem.c:			if (pdev->device != PCI_DEVICE_ID_SUN_GEM) {
drivers/net/ethernet/sun/sungem.c:	if (pdev->vendor == PCI_VENDOR_ID_SUN) {
drivers/net/ethernet/sun/sungem.c:		if (pdev->device == PCI_DEVICE_ID_SUN_GEM) {
drivers/net/ethernet/sun/sungem.c:	rc = request_irq(gp->pdev->irq, gem_interrupt,
drivers/net/ethernet/sun/sungem.c:	free_irq(gp->pdev->irq, (void *) dev);
drivers/net/ethernet/sun/sungem.c:	if (pdev->vendor == PCI_VENDOR_ID_SUN &&
drivers/net/ethernet/sun/sungem.c:	    pdev->device == PCI_DEVICE_ID_SUN_GEM &&
drivers/net/ethernet/sun/sungem.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/sun/sungem.c:	if (pdev->vendor == PCI_VENDOR_ID_APPLE)
drivers/net/ethernet/sun/sunhme.c:	struct pci_dev *bdev = pdev->bus->self;
drivers/net/ethernet/sun/sunhme.c:	struct pci_dev *busdev = pdev->bus->self;
drivers/net/ethernet/sun/sunhme.c:	list_for_each_entry(this_pdev, &pdev->bus->devices, bus_list) {
drivers/net/ethernet/sun/sunhme.c:		if (this_pdev->vendor == PCI_VENDOR_ID_SUN &&
drivers/net/ethernet/sun/sunhme.c:		    this_pdev->device == PCI_DEVICE_ID_SUN_HAPPYMEAL)
drivers/net/ethernet/sun/sunhme.c:			index = PCI_SLOT(pdev->devfn);
drivers/net/ethernet/sun/sunhme.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/sun/sunhme.c:	hp->dma_dev = &pdev->dev;
drivers/net/ethernet/sun/sunhme.c:		hp->hm_revision = 0xc0 | (pdev->revision & 0x0f);
drivers/net/ethernet/sun/sunhme.c:	hp->happy_block = dma_alloc_coherent(&pdev->dev, PAGE_SIZE,
drivers/net/ethernet/sun/sunhme.c:	hp->irq = pdev->irq;
drivers/net/ethernet/sun/sunhme.c:	dev_set_drvdata(&pdev->dev, hp);
drivers/net/ethernet/sun/sunhme.c:		if (qpdev->vendor == PCI_VENDOR_ID_DEC &&
drivers/net/ethernet/sun/sunhme.c:		    qpdev->device == PCI_DEVICE_ID_DEC_21153)
drivers/net/ethernet/sun/sunhme.c:				qpdev->vendor, qpdev->device);
drivers/net/ethernet/sun/sunhme.c:	struct happy_meal *hp = dev_get_drvdata(&pdev->dev);
drivers/net/ethernet/sun/sunhme.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/net/ethernet/sun/cassini.c:	err = request_firmware(&fw, fw_name, &cp->pdev->dev);
drivers/net/ethernet/sun/cassini.c:	cas_interrupt(cp->pdev->irq, dev);
drivers/net/ethernet/sun/cassini.c:		mapping = skb_frag_dma_map(&cp->pdev->dev, fragp, 0, len,
drivers/net/ethernet/sun/cassini.c:	if ((pdev->vendor == PCI_VENDOR_ID_SUN) &&
drivers/net/ethernet/sun/cassini.c:	    (pdev->device == PCI_DEVICE_ID_SUN_CASSINI)) {
drivers/net/ethernet/sun/cassini.c:		if (pdev->revision >= CAS_ID_REVPLUS)
drivers/net/ethernet/sun/cassini.c:		if (pdev->revision < CAS_ID_REVPLUS02u)
drivers/net/ethernet/sun/cassini.c:		if (pdev->revision < CAS_ID_REV2)
drivers/net/ethernet/sun/cassini.c:		if ((pdev->vendor == PCI_VENDOR_ID_NS) &&
drivers/net/ethernet/sun/cassini.c:		    (pdev->device == PCI_DEVICE_ID_NS_SATURN))
drivers/net/ethernet/sun/cassini.c:					PCI_SLOT(pdev->devfn));
drivers/net/ethernet/sun/cassini.c:	if (request_irq(cp->pdev->irq, cas_interrupt,
drivers/net/ethernet/sun/cassini.c:	free_irq(cp->pdev->irq, (void *) dev);
drivers/net/ethernet/sun/cassini.c:	struct pci_dev *pdev = cas_pdev->bus->self;
drivers/net/ethernet/sun/cassini.c:	if (pdev->vendor != 0x8086 || pdev->device != 0x537c)
drivers/net/ethernet/sun/cassini.c:		dev_err(&pdev->dev, "Cannot enable PCI device, aborting\n");
drivers/net/ethernet/sun/cassini.c:		dev_err(&pdev->dev, "Cannot find proper PCI device "
drivers/net/ethernet/sun/cassini.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/ethernet/sun/cassini.c:		dev_err(&pdev->dev, "Cannot obtain PCI resources, aborting\n");
drivers/net/ethernet/sun/cassini.c:			dev_err(&pdev->dev, "Could not set PCI cache "
drivers/net/ethernet/sun/cassini.c:			dev_err(&pdev->dev, "Unable to obtain 64-bit DMA "
drivers/net/ethernet/sun/cassini.c:			dev_err(&pdev->dev, "No usable DMA configuration, "
drivers/net/ethernet/sun/cassini.c:		dev_err(&pdev->dev, "Cannot map device registers, aborting\n");
drivers/net/ethernet/sun/cassini.c:		dev_err(&pdev->dev, "Cannot allocate init block, aborting\n");
drivers/net/ethernet/sun/cassini.c:	dev->irq = pdev->irq;
drivers/net/ethernet/sun/cassini.c:		dev_err(&pdev->dev, "Cannot register net device, aborting\n");
drivers/net/ethernet/sun/cassini.c:		    (cp->phy_type == CAS_PHY_SERDES) ? "Fi" : "Cu", pdev->irq,
drivers/net/caif/caif_spi.c:	cfspi->dbgfs_dir = debugfs_create_dir(cfspi->pdev->name, dbgfs_root);
drivers/net/caif/caif_spi.c:	dev = (struct cfspi_dev *)pdev->dev.platform_data;
drivers/net/arcnet/com20020-pci.c:	if (pdev->vendor==0x10B5) {
drivers/net/arcnet/com20020-pci.c:	dev->irq = pdev->irq;
drivers/net/can/pch_can.c:		dev_err(&pdev->dev, "%s -> Transmission time out.\n", __func__);
drivers/net/can/pch_can.c:		dev_err(&pdev->dev, "pci_save_state failed.\n");
drivers/net/can/pch_can.c:		dev_err(&pdev->dev, "pci_enable_device failed.\n");
drivers/net/can/pch_can.c:		dev_err(&pdev->dev, "Failed pci_enable_device %d\n", rc);
drivers/net/can/pch_can.c:		dev_err(&pdev->dev, "Failed pci_request_regions %d\n", rc);
drivers/net/can/pch_can.c:		dev_err(&pdev->dev, "Failed pci_iomap\n");
drivers/net/can/pch_can.c:		dev_err(&pdev->dev, "Failed alloc_candev\n");
drivers/net/can/pch_can.c:	ndev->irq = pdev->irq;
drivers/net/can/pch_can.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/can/pch_can.c:		dev_err(&pdev->dev, "Failed register_candev %d\n", rc);
drivers/net/can/at91_can.c:	if (pdev->dev.of_node) {
drivers/net/can/at91_can.c:		match = of_match_node(at91_can_dt_ids, pdev->dev.of_node);
drivers/net/can/at91_can.c:			dev_err(&pdev->dev, "no matching node found in dtb\n");
drivers/net/can/at91_can.c:		dev_err(&pdev->dev, "no driver data\n");
drivers/net/can/at91_can.c:	clk = clk_get(&pdev->dev, "can_clk");
drivers/net/can/at91_can.c:		dev_err(&pdev->dev, "no clock defined\n");
drivers/net/can/at91_can.c:				pdev->name)) {
drivers/net/can/at91_can.c:	priv->pdata = pdev->dev.platform_data;
drivers/net/can/at91_can.c:	dev_set_drvdata(&pdev->dev, dev);
drivers/net/can/at91_can.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/at91_can.c:		dev_err(&pdev->dev, "registering netdev failed\n");
drivers/net/can/at91_can.c:	dev_info(&pdev->dev, "device registered (reg_base=%p, irq=%d)\n",
drivers/net/can/c_can/c_can_pci.c:		dev_err(&pdev->dev, "pci_enable_device FAILED\n");
drivers/net/can/c_can/c_can_pci.c:		dev_err(&pdev->dev, "pci_request_regions FAILED\n");
drivers/net/can/c_can/c_can_pci.c:		dev_err(&pdev->dev,
drivers/net/can/c_can/c_can_pci.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/c_can/c_can_pci.c:	dev->irq = pdev->irq;
drivers/net/can/c_can/c_can_pci.c:		dev_err(&pdev->dev, "no clock frequency defined\n");
drivers/net/can/c_can/c_can_pci.c:		dev_err(&pdev->dev, "registering %s failed (err=%d)\n",
drivers/net/can/c_can/c_can_pci.c:	dev_dbg(&pdev->dev, "%s device registered (regs=%p, irq=%d)\n",
drivers/net/can/c_can/c_can_platform.c:	if (pdev->dev.of_node) {
drivers/net/can/c_can/c_can_platform.c:		match = of_match_device(c_can_of_table, &pdev->dev);
drivers/net/can/c_can/c_can_platform.c:			dev_err(&pdev->dev, "Failed to find matching dt id\n");
drivers/net/can/c_can/c_can_platform.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/net/can/c_can/c_can_platform.c:		dev_warn(&pdev->dev,
drivers/net/can/c_can/c_can_platform.c:	clk = clk_get(&pdev->dev, NULL);
drivers/net/can/c_can/c_can_platform.c:		dev_err(&pdev->dev, "no clock defined\n");
drivers/net/can/c_can/c_can_platform.c:		dev_err(&pdev->dev, "resource unavailable\n");
drivers/net/can/c_can/c_can_platform.c:		dev_err(&pdev->dev, "failed to map can port\n");
drivers/net/can/c_can/c_can_platform.c:		if (pdev->dev.of_node)
drivers/net/can/c_can/c_can_platform.c:			priv->instance = of_alias_get_id(pdev->dev.of_node, "d_can");
drivers/net/can/c_can/c_can_platform.c:			priv->instance = pdev->id;
drivers/net/can/c_can/c_can_platform.c:		priv->raminit_ctrlreg =	devm_request_and_ioremap(&pdev->dev, res);
drivers/net/can/c_can/c_can_platform.c:			dev_info(&pdev->dev, "control memory is not used for raminit\n");
drivers/net/can/c_can/c_can_platform.c:	priv->device = &pdev->dev;
drivers/net/can/c_can/c_can_platform.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/c_can/c_can_platform.c:		dev_err(&pdev->dev, "registering %s failed (err=%d)\n",
drivers/net/can/c_can/c_can_platform.c:	dev_info(&pdev->dev, "%s device registered (regs=%p, irq=%d)\n",
drivers/net/can/c_can/c_can_platform.c:	dev_err(&pdev->dev, "probe failed\n");
drivers/net/can/c_can/c_can_platform.c:		dev_warn(&pdev->dev, "Not supported\n");
drivers/net/can/c_can/c_can_platform.c:		dev_warn(&pdev->dev, "Not supported\n");
drivers/net/can/softing/softing_fw.c:	dev_alert(&card->pdev->dev, "firmware %s failed (%i)\n", msg, ret);
drivers/net/can/softing/softing_fw.c:		dev_alert(&card->pdev->dev, "%s returned %u\n", msg, ret);
drivers/net/can/softing/softing_fw.c:	dev_alert(&card->pdev->dev, "bootloader %s failed (%i)\n", msg, ret);
drivers/net/can/softing/softing_fw.c:	ret = request_firmware(&fw, file, &card->pdev->dev);
drivers/net/can/softing/softing_fw.c:	dev_dbg(&card->pdev->dev, "%s, firmware(%s) got %u bytes"
drivers/net/can/softing/softing_fw.c:			dev_alert(&card->pdev->dev, "DPRAM readback failed\n");
drivers/net/can/softing/softing_fw.c:		dev_info(&card->pdev->dev, "firmware %s failed\n", file);
drivers/net/can/softing/softing_fw.c:	ret = request_firmware(&fw, file, &card->pdev->dev);
drivers/net/can/softing/softing_fw.c:		dev_alert(&card->pdev->dev, "request_firmware(%s) got %i\n",
drivers/net/can/softing/softing_fw.c:	dev_dbg(&card->pdev->dev, "firmware(%s) got %lu bytes\n",
drivers/net/can/softing/softing_fw.c:		dev_alert(&card->pdev->dev, "firmware starts with type 0x%x\n",
drivers/net/can/softing/softing_fw.c:		dev_alert(&card->pdev->dev, "firmware string '%.*s' fault\n",
drivers/net/can/softing/softing_fw.c:			dev_alert(&card->pdev->dev,
drivers/net/can/softing/softing_fw.c:			dev_alert(&card->pdev->dev, "SRAM seems to be damaged"
drivers/net/can/softing/softing_fw.c:		dev_info(&card->pdev->dev, "firmware %s failed\n", file);
drivers/net/can/softing/softing_fw.c:		dev_alert(&card->pdev->dev,
drivers/net/can/softing/softing_main.c:				dev_name(&card->pdev->dev), card);
drivers/net/can/softing/softing_main.c:			dev_alert(&card->pdev->dev,
drivers/net/can/softing/softing_main.c:		dev_alert(&card->pdev->dev, "dpram failed at 0x%04x\n", j);
drivers/net/can/softing/softing_main.c:		dev_alert(&card->pdev->dev, "alloc_candev failed\n");
drivers/net/can/softing/softing_main.c:	SET_NETDEV_DEV(netdev, &card->pdev->dev);
drivers/net/can/softing/softing_main.c:	sysfs_remove_group(&pdev->dev.kobj, &softing_pdev_group);
drivers/net/can/softing/softing_main.c:	const struct softing_platform_data *pdat = pdev->dev.platform_data;
drivers/net/can/softing/softing_main.c:		dev_warn(&pdev->dev, "no platform data\n");
drivers/net/can/softing/softing_main.c:		dev_warn(&pdev->dev, "%u nets??\n", pdat->nbus);
drivers/net/can/softing/softing_main.c:		dev_alert(&card->pdev->dev, "dpram ioremap failed\n");
drivers/net/can/softing/softing_main.c:		dev_alert(&pdev->dev, "failed to boot\n");
drivers/net/can/softing/softing_main.c:	ret = sysfs_create_group(&pdev->dev.kobj, &softing_pdev_group);
drivers/net/can/softing/softing_main.c:		dev_alert(&card->pdev->dev, "sysfs failed\n");
drivers/net/can/softing/softing_main.c:			dev_alert(&pdev->dev, "failed to make can[%i]", j);
drivers/net/can/softing/softing_main.c:			dev_alert(&card->pdev->dev,
drivers/net/can/softing/softing_main.c:	dev_info(&card->pdev->dev, "%s ready.\n", card->pdat->name);
drivers/net/can/softing/softing_main.c:	sysfs_remove_group(&pdev->dev.kobj, &softing_pdev_group);
drivers/net/can/softing/softing_cs.c:	struct pcmcia_device *pcmcia = to_pcmcia_dev(pdev->dev.parent);
drivers/net/can/softing/softing_cs.c:	dev_dbg(&pdev->dev, "pcmcia config [2] %02x\n", v ? 0 : 0x20);
drivers/net/can/softing/softing_cs.c:	struct pcmcia_device *pcmcia = to_pcmcia_dev(pdev->dev.parent);
drivers/net/can/softing/softing_cs.c:	dev_dbg(&pdev->dev, "pcmcia config [0] %02x\n", v ? 0x60 : 0);
drivers/net/can/softing/softing_cs.c: * pdev->resource has 2 entries: io & irq
drivers/net/can/softing/softing_cs.c:	pdev->dev.platform_data = (void *)pdat;
drivers/net/can/softing/softing_cs.c:	pdev->dev.parent = &pcmcia->dev;
drivers/net/can/softing/softing_cs.c:	pdev->resource[0].flags = IORESOURCE_MEM;
drivers/net/can/softing/softing_cs.c:	pdev->resource[0].start = pres->start;
drivers/net/can/softing/softing_cs.c:	pdev->resource[0].end = pres->end;
drivers/net/can/softing/softing_cs.c:	pdev->resource[1].flags = IORESOURCE_IRQ;
drivers/net/can/softing/softing_cs.c:	pdev->resource[1].start = pcmcia->irq;
drivers/net/can/softing/softing_cs.c:	pdev->resource[1].end = pdev->resource[1].start;
drivers/net/can/softing/softing_cs.c:	pdev->id = softingcs_index++;
drivers/net/can/softing/softing_cs.c:	pdev->name = "softing";
drivers/net/can/softing/softing_cs.c:	dev_set_name(&pdev->dev, "softingcs.%i", pdev->id);
drivers/net/can/softing/softing_cs.c:	dev_info(&pcmcia->dev, "created %s\n", dev_name(&pdev->dev));
drivers/net/can/cc770/cc770_isa.c:	int idx = pdev->id;
drivers/net/can/cc770/cc770_isa.c:	dev_dbg(&pdev->dev, "probing idx=%d: port=%#lx, mem=%#lx, irq=%d\n",
drivers/net/can/cc770/cc770_isa.c:	dev_set_drvdata(&pdev->dev, dev);
drivers/net/can/cc770/cc770_isa.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/cc770/cc770_isa.c:		dev_err(&pdev->dev,
drivers/net/can/cc770/cc770_isa.c:	dev_info(&pdev->dev, "device registered (reg_base=0x%p, irq=%d)\n",
drivers/net/can/cc770/cc770_isa.c:	struct net_device *dev = dev_get_drvdata(&pdev->dev);
drivers/net/can/cc770/cc770_isa.c:	int idx = pdev->id;
drivers/net/can/cc770/cc770_isa.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/net/can/cc770/cc770_platform.c:	struct device_node *np = pdev->dev.of_node;
drivers/net/can/cc770/cc770_platform.c:			dev_dbg(&pdev->dev, "invalid clock-out-frequency\n");
drivers/net/can/cc770/cc770_platform.c:	struct cc770_platform_data *pdata = pdev->dev.platform_data;
drivers/net/can/cc770/cc770_platform.c:	if (!request_mem_region(mem->start, mem_size, pdev->name))
drivers/net/can/cc770/cc770_platform.c:	if (pdev->dev.of_node)
drivers/net/can/cc770/cc770_platform.c:	else if (pdev->dev.platform_data)
drivers/net/can/cc770/cc770_platform.c:	dev_dbg(&pdev->dev,
drivers/net/can/cc770/cc770_platform.c:	dev_set_drvdata(&pdev->dev, dev);
drivers/net/can/cc770/cc770_platform.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/cc770/cc770_platform.c:		dev_err(&pdev->dev,
drivers/net/can/cc770/cc770_platform.c:	struct net_device *dev = dev_get_drvdata(&pdev->dev);
drivers/net/can/flexcan.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/net/can/flexcan.c:	if (pdev->dev.of_node)
drivers/net/can/flexcan.c:		of_property_read_u32(pdev->dev.of_node,
drivers/net/can/flexcan.c:		clk_ipg = devm_clk_get(&pdev->dev, "ipg");
drivers/net/can/flexcan.c:			dev_err(&pdev->dev, "no ipg clock defined\n");
drivers/net/can/flexcan.c:		clk_per = devm_clk_get(&pdev->dev, "per");
drivers/net/can/flexcan.c:			dev_err(&pdev->dev, "no per clock defined\n");
drivers/net/can/flexcan.c:	if (!request_mem_region(mem->start, mem_size, pdev->name)) {
drivers/net/can/flexcan.c:	of_id = of_match_device(flexcan_of_match, &pdev->dev);
drivers/net/can/flexcan.c:	} else if (pdev->id_entry->driver_data) {
drivers/net/can/flexcan.c:			pdev->id_entry->driver_data;
drivers/net/can/flexcan.c:	priv->pdata = pdev->dev.platform_data;
drivers/net/can/flexcan.c:	dev_set_drvdata(&pdev->dev, dev);
drivers/net/can/flexcan.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/flexcan.c:		dev_err(&pdev->dev, "registering netdev failed\n");
drivers/net/can/flexcan.c:	dev_info(&pdev->dev, "device registered (reg_base=%p, irq=%d)\n",
drivers/net/can/sja1000/peak_pcmcia.c:		dev_err(&card->pdev->dev,
drivers/net/can/sja1000/peak_pcmcia.c:		dev_err(&card->pdev->dev,
drivers/net/can/sja1000/peak_pcmcia.c:	dev_err(&card->pdev->dev,
drivers/net/can/sja1000/peak_pcmcia.c:		dev_err(&card->pdev->dev,
drivers/net/can/sja1000/peak_pcmcia.c:		dev_info(&card->pdev->dev, "%s removed\n", name);
drivers/net/can/sja1000/peak_pcmcia.c:		SET_NETDEV_DEV(netdev, &pdev->dev);
drivers/net/can/sja1000/peak_pcmcia.c:		netdev->irq = pdev->irq;
drivers/net/can/sja1000/peak_pcmcia.c:			dev_err(&pdev->dev, "channel %d not present\n", i);
drivers/net/can/sja1000/peak_pcmcia.c:		dev_info(&pdev->dev,
drivers/net/can/sja1000/peak_pcmcia.c:			netdev->name, i, priv->reg_base, pdev->irq);
drivers/net/can/sja1000/peak_pcmcia.c:	pdev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;
drivers/net/can/sja1000/peak_pcmcia.c:	pdev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8; /* only */
drivers/net/can/sja1000/peak_pcmcia.c:	pdev->io_lines = 10;
drivers/net/can/sja1000/peak_pcmcia.c:	struct pcan_pccard *card = pdev->priv;
drivers/net/can/sja1000/peak_pcmcia.c:	free_irq(pdev->irq, card);
drivers/net/can/sja1000/peak_pcmcia.c:	pdev->priv = NULL;
drivers/net/can/sja1000/peak_pcmcia.c:	pdev->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;
drivers/net/can/sja1000/peak_pcmcia.c:		dev_err(&pdev->dev, "pcmcia_loop_config() error %d\n", err);
drivers/net/can/sja1000/peak_pcmcia.c:	if (!pdev->irq) {
drivers/net/can/sja1000/peak_pcmcia.c:		dev_err(&pdev->dev, "no irq assigned\n");
drivers/net/can/sja1000/peak_pcmcia.c:		dev_err(&pdev->dev, "pcmcia_enable_device failed err=%d\n",
drivers/net/can/sja1000/peak_pcmcia.c:	pdev->priv = card;
drivers/net/can/sja1000/peak_pcmcia.c:	card->ioport_addr = ioport_map(pdev->resource[0]->start,
drivers/net/can/sja1000/peak_pcmcia.c:					resource_size(pdev->resource[0]));
drivers/net/can/sja1000/peak_pcmcia.c:		dev_err(&pdev->dev, "couldn't map io port into io memory\n");
drivers/net/can/sja1000/peak_pcmcia.c:	dev_info(&pdev->dev, "PEAK-System pcmcia card %s fw %d.%d\n",
drivers/net/can/sja1000/peak_pcmcia.c:		pdev->prod_id[1] ? pdev->prod_id[1] : "PCAN-PC Card",
drivers/net/can/sja1000/peak_pcmcia.c:	err = request_irq(pdev->irq, &pcan_isr, IRQF_SHARED, PCC_NAME, card);
drivers/net/can/sja1000/peak_pcmcia.c:		dev_err(&pdev->dev, "couldn't request irq%d\n", pdev->irq);
drivers/net/can/sja1000/peak_pcmcia.c:	pdev->priv = NULL;
drivers/net/can/sja1000/sja1000_isa.c:	int idx = pdev->id;
drivers/net/can/sja1000/sja1000_isa.c:	dev_dbg(&pdev->dev, "probing idx=%d: port=%#lx, mem=%#lx, irq=%d\n",
drivers/net/can/sja1000/sja1000_isa.c:	dev_set_drvdata(&pdev->dev, dev);
drivers/net/can/sja1000/sja1000_isa.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/sja1000/sja1000_isa.c:		dev_err(&pdev->dev, "registering %s failed (err=%d)\n",
drivers/net/can/sja1000/sja1000_isa.c:	dev_info(&pdev->dev, "%s device registered (reg_base=0x%p, irq=%d)\n",
drivers/net/can/sja1000/sja1000_isa.c:	struct net_device *dev = dev_get_drvdata(&pdev->dev);
drivers/net/can/sja1000/sja1000_isa.c:	int idx = pdev->id;
drivers/net/can/sja1000/sja1000_isa.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/net/can/sja1000/plx_pci.c:			dev_err(&pdev->dev, "Failed to remap reset "
drivers/net/can/sja1000/plx_pci.c:		dev_info(&pdev->dev, "Removing %s\n", dev->name);
drivers/net/can/sja1000/plx_pci.c:	if (pdev->device != PCI_DEVICE_ID_PLX_9056)
drivers/net/can/sja1000/plx_pci.c:		dev_err(&pdev->dev, "Failed to enable PCI device\n");
drivers/net/can/sja1000/plx_pci.c:	dev_info(&pdev->dev, "Detected \"%s\" card at slot #%i\n",
drivers/net/can/sja1000/plx_pci.c:		 ci->name, PCI_SLOT(pdev->devfn));
drivers/net/can/sja1000/plx_pci.c:		dev_err(&pdev->dev, "Failed to remap configuration space "
drivers/net/can/sja1000/plx_pci.c:		dev->irq = pdev->irq;
drivers/net/can/sja1000/plx_pci.c:			dev_err(&pdev->dev, "Failed to remap BAR%d\n", cm->bar);
drivers/net/can/sja1000/plx_pci.c:			SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/sja1000/plx_pci.c:				dev_err(&pdev->dev, "Registering device failed "
drivers/net/can/sja1000/plx_pci.c:			dev_info(&pdev->dev, "Channel #%d at 0x%p, irq %d "
drivers/net/can/sja1000/plx_pci.c:			dev_err(&pdev->dev, "Channel #%d not detected\n",
drivers/net/can/sja1000/plx_pci.c:	if (pdev->device != PCI_DEVICE_ID_PLX_9056) {
drivers/net/can/sja1000/plx_pci.c:		if (pdev->subsystem_vendor == PCI_VENDOR_ID_ESDGMBH)
drivers/net/can/sja1000/plx_pci.c:	dev_err(&pdev->dev, "Error: %d. Cleaning Up.\n", err);
drivers/net/can/sja1000/peak_pci.c:		card->led_chip.dev.parent = &pdev->dev;
drivers/net/can/sja1000/peak_pci.c:			dev_err(&pdev->dev, "i2c init failed\n");
drivers/net/can/sja1000/peak_pci.c:			dev_err(&pdev->dev, "leds hardware init failed\n");
drivers/net/can/sja1000/peak_pci.c:	dev_dbg(&pdev->dev, "probing device %04x:%04x:%04x\n",
drivers/net/can/sja1000/peak_pci.c:		pdev->vendor, pdev->device, sub_sys_id);
drivers/net/can/sja1000/peak_pci.c:		dev_err(&pdev->dev, "failed to map PCI resource #0\n");
drivers/net/can/sja1000/peak_pci.c:		dev_err(&pdev->dev, "failed to map PCI resource #1\n");
drivers/net/can/sja1000/peak_pci.c:		dev->irq = pdev->irq;
drivers/net/can/sja1000/peak_pci.c:		SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/sja1000/peak_pci.c:		if (pdev->device == PEAK_PCIEC_DEVICE_ID) {
drivers/net/can/sja1000/peak_pci.c:				dev_err(&pdev->dev,
drivers/net/can/sja1000/peak_pci.c:			dev_err(&pdev->dev, "failed to register device\n");
drivers/net/can/sja1000/peak_pci.c:		dev_info(&pdev->dev,
drivers/net/can/sja1000/peak_pci.c:		dev_info(&pdev->dev, "removing device %s\n", dev->name);
drivers/net/can/sja1000/sja1000_platform.c:	pdata = pdev->dev.platform_data;
drivers/net/can/sja1000/sja1000_platform.c:		dev_err(&pdev->dev, "No platform data provided!\n");
drivers/net/can/sja1000/sja1000_platform.c:	dev_set_drvdata(&pdev->dev, dev);
drivers/net/can/sja1000/sja1000_platform.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/sja1000/sja1000_platform.c:		dev_err(&pdev->dev, "registering %s failed (err=%d)\n",
drivers/net/can/sja1000/sja1000_platform.c:	dev_info(&pdev->dev, "%s device registered (reg_base=%p, irq=%d)\n",
drivers/net/can/sja1000/sja1000_platform.c:	struct net_device *dev = dev_get_drvdata(&pdev->dev);
drivers/net/can/sja1000/sja1000_platform.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/net/can/sja1000/ems_pci.c:		dev_info(&pdev->dev, "Removing %s.\n", dev->name);
drivers/net/can/sja1000/ems_pci.c:		dev_err(&pdev->dev, "Enabling PCI device failed\n");
drivers/net/can/sja1000/ems_pci.c:	if (pdev->vendor == PCI_VENDOR_ID_PLX) {
drivers/net/can/sja1000/ems_pci.c:			dev_err(&pdev->dev,
drivers/net/can/sja1000/ems_pci.c:		dev->irq = pdev->irq;
drivers/net/can/sja1000/ems_pci.c:			SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/sja1000/ems_pci.c:				dev_err(&pdev->dev, "Registering device failed "
drivers/net/can/sja1000/ems_pci.c:			dev_info(&pdev->dev, "Channel #%d at 0x%p, irq %d\n",
drivers/net/can/sja1000/ems_pci.c:	dev_err(&pdev->dev, "Error: %d. Cleaning Up.\n", err);
drivers/net/can/sja1000/ems_pcmcia.c:	struct ems_pcmcia_card *card = pdev->priv;
drivers/net/can/sja1000/ems_pcmcia.c:	free_irq(pdev->irq, card);
drivers/net/can/sja1000/ems_pcmcia.c:	pdev->priv = NULL;
drivers/net/can/sja1000/ems_pcmcia.c:	pdev->priv = card;
drivers/net/can/sja1000/ems_pcmcia.c:		SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/sja1000/ems_pcmcia.c:		dev->irq = pdev->irq;
drivers/net/can/sja1000/kvaser_pci.c:	dev->irq = pdev->irq;
drivers/net/can/sja1000/kvaser_pci.c:	dev_info(&pdev->dev, "reg_base=%p conf_addr=%p irq=%d\n",
drivers/net/can/sja1000/kvaser_pci.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/sja1000/kvaser_pci.c:		dev_err(&pdev->dev, "Registering device failed (err=%d)\n",
drivers/net/can/sja1000/kvaser_pci.c:	dev_info(&pdev->dev, "initializing device %04x:%04x\n",
drivers/net/can/sja1000/kvaser_pci.c:		 pdev->vendor, pdev->device);
drivers/net/can/sja1000/kvaser_pci.c:	dev_info(&pdev->dev, "xilinx version=%d number of channels=%d\n",
drivers/net/can/bfin_can.c:	pdata = pdev->dev.platform_data;
drivers/net/can/bfin_can.c:		dev_err(&pdev->dev, "No platform data provided!\n");
drivers/net/can/bfin_can.c:				dev_name(&pdev->dev))) {
drivers/net/can/bfin_can.c:	err = peripheral_request_list(pdata, dev_name(&pdev->dev));
drivers/net/can/bfin_can.c:	dev_set_drvdata(&pdev->dev, dev);
drivers/net/can/bfin_can.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/can/bfin_can.c:		dev_err(&pdev->dev, "registering failed (err=%d)\n", err);
drivers/net/can/bfin_can.c:	dev_info(&pdev->dev,
drivers/net/can/bfin_can.c:	struct net_device *dev = dev_get_drvdata(&pdev->dev);
drivers/net/can/bfin_can.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/net/can/bfin_can.c:	struct net_device *dev = dev_get_drvdata(&pdev->dev);
drivers/net/can/bfin_can.c:	struct net_device *dev = dev_get_drvdata(&pdev->dev);
drivers/net/can/usb/peak_usb/pcan_usb.c:	mod_timer(&pdev->restart_timer,
drivers/net/can/usb/peak_usb/pcan_usb.c:	if (timer_pending(&pdev->restart_timer))
drivers/net/can/usb/peak_usb/pcan_usb.c:		peak_usb_update_ts_now(&mc->pdev->time_ref, mc->ts16);
drivers/net/can/usb/peak_usb/pcan_usb.c:		peak_usb_set_ts_now(&mc->pdev->time_ref, mc->ts16);
drivers/net/can/usb/peak_usb/pcan_usb.c:		if (!mc->pdev->time_ref.tick_count)
drivers/net/can/usb/peak_usb/pcan_usb.c:	new_state = mc->pdev->dev.can.state;
drivers/net/can/usb/peak_usb/pcan_usb.c:	switch (mc->pdev->dev.can.state) {
drivers/net/can/usb/peak_usb/pcan_usb.c:			mc->pdev->dev.can.state = CAN_STATE_ERROR_ACTIVE;
drivers/net/can/usb/peak_usb/pcan_usb.c:			mc->pdev->dev.can.state = CAN_STATE_ERROR_ACTIVE;
drivers/net/can/usb/peak_usb/pcan_usb.c:	if (mc->pdev->dev.can.state == new_state)
drivers/net/can/usb/peak_usb/pcan_usb.c:		mc->pdev->dev.can.can_stats.error_passive++;
drivers/net/can/usb/peak_usb/pcan_usb.c:		mc->pdev->dev.can.can_stats.error_warning++;
drivers/net/can/usb/peak_usb/pcan_usb.c:		new_state = mc->pdev->dev.can.state;
drivers/net/can/usb/peak_usb/pcan_usb.c:	mc->pdev->dev.can.state = new_state;
drivers/net/can/usb/peak_usb/pcan_usb.c:		peak_usb_get_ts_tv(&mc->pdev->time_ref, mc->ts16, &tv);
drivers/net/can/usb/peak_usb/pcan_usb.c:	peak_usb_get_ts_tv(&mc->pdev->time_ref, mc->ts16, &tv);
drivers/net/can/usb/peak_usb/pcan_usb.c:	peak_usb_init_time_ref(&pdev->time_ref, &pcan_usb);
drivers/net/can/usb/peak_usb/pcan_usb.c:	init_timer(&pdev->restart_timer);
drivers/net/can/usb/peak_usb/pcan_usb.c:	pdev->restart_timer.function = pcan_usb_restart;
drivers/net/can/usb/peak_usb/pcan_usb.c:	pdev->restart_timer.data = (unsigned long)dev;
drivers/net/can/usb/peak_usb/pcan_usb_pro.c:	pdev->cached_ccbt = ccbt;
drivers/net/can/usb/peak_usb/pcan_usb_pro.c:		pcan_usb_pro_set_bitrate(dev, pdev->cached_ccbt);
drivers/net/can/usb/peak_usb/pcan_usb_pro.c:	return pdev->usb_if;
drivers/net/can/usb/peak_usb/pcan_usb_pro.c:	if (pdev->usb_if->dev_opened_count == 0) {
drivers/net/can/usb/peak_usb/pcan_usb_pro.c:		peak_usb_init_time_ref(&pdev->usb_if->time_ref, &pcan_usb_pro);
drivers/net/can/usb/peak_usb/pcan_usb_pro.c:	pdev->usb_if->dev_opened_count++;
drivers/net/can/usb/peak_usb/pcan_usb_pro.c:	if (pdev->usb_if->dev_opened_count == 1)
drivers/net/can/usb/peak_usb/pcan_usb_pro.c:	pdev->usb_if->dev_opened_count--;
drivers/net/can/usb/peak_usb/pcan_usb_pro.c:	pdev->usb_if = usb_if;
drivers/net/can/usb/peak_usb/pcan_usb_pro.c:		if (pdev->usb_if->dev_opened_count > 0)
drivers/net/can/janz-ican3.c:	pdata = pdev->dev.platform_data;
drivers/net/can/janz-ican3.c:	dev_dbg(&pdev->dev, "probe: module number %d\n", pdata->modno);
drivers/net/can/janz-ican3.c:	dev = &pdev->dev;
drivers/net/can/janz-ican3.c:	mod->dev = &pdev->dev;
drivers/net/can/janz-ican3.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/can/ti_hecc.c:	pdata = pdev->dev.platform_data;
drivers/net/can/ti_hecc.c:		dev_err(&pdev->dev, "No platform data\n");
drivers/net/can/ti_hecc.c:		dev_err(&pdev->dev, "No mem resources\n");
drivers/net/can/ti_hecc.c:		dev_err(&pdev->dev, "No irq resource\n");
drivers/net/can/ti_hecc.c:	if (!request_mem_region(mem->start, resource_size(mem), pdev->name)) {
drivers/net/can/ti_hecc.c:		dev_err(&pdev->dev, "HECC region already claimed\n");
drivers/net/can/ti_hecc.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/net/can/ti_hecc.c:		dev_err(&pdev->dev, "alloc_candev failed\n");
drivers/net/can/ti_hecc.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/can/ti_hecc.c:	priv->clk = clk_get(&pdev->dev, "hecc_ck");
drivers/net/can/ti_hecc.c:		dev_err(&pdev->dev, "No clock available\n");
drivers/net/can/ti_hecc.c:		dev_err(&pdev->dev, "register_candev() failed\n");
drivers/net/can/ti_hecc.c:	dev_info(&pdev->dev, "device registered (reg_base=%p, irq=%u)\n",
drivers/net/fddi/skfp/skfddi.c:	dev->irq = pdev->irq;
drivers/net/fddi/skfp/skfddi.c:	SET_NETDEV_DEV(dev, &pdev->dev);
drivers/net/fddi/skfp/skfddi.c:	if ((pdev->subsystem_device & 0xff00) == 0x5500 ||
drivers/net/fddi/skfp/skfddi.c:	    (pdev->subsystem_device & 0xff00) == 0x5800) 
drivers/net/fddi/skfp/skfddi.c:		       pdev->subsystem_device);
drivers/net/fddi/defxx.c:		dev->irq = pdev->irq;
drivers/net/fddi/defxx.c:	return dfx_register(&pdev->dev);
drivers/net/fddi/defxx.c:	dfx_unregister(&pdev->dev);
drivers/net/wireless/mwl8k.c:					       &priv->pdev->dev, GFP_KERNEL,
drivers/net/wireless/mwl8k.c:		return request_firmware(fw, fname, &priv->pdev->dev);
drivers/net/wireless/mwl8k.c:	rc = request_irq(priv->pdev->irq, mwl8k_interrupt,
drivers/net/wireless/mwl8k.c:	priv->irq = priv->pdev->irq;
drivers/net/wireless/mwl8k.c:		free_irq(priv->pdev->irq, hw);
drivers/net/wireless/mwl8k.c:		free_irq(priv->pdev->irq, hw);
drivers/net/wireless/mwl8k.c:	device_release_driver(&priv->pdev->dev);
drivers/net/wireless/mwl8k.c:	rc = request_irq(priv->pdev->irq, mwl8k_interrupt,
drivers/net/wireless/mwl8k.c:	free_irq(priv->pdev->irq, hw);
drivers/net/wireless/mwl8k.c:	free_irq(priv->pdev->irq, hw);
drivers/net/wireless/mwl8k.c:	SET_IEEE80211_DEV(hw, &pdev->dev);
drivers/net/wireless/iwlwifi/pcie/trans.c:			dev_err(&pdev->dev, "No suitable DMA available\n");
drivers/net/wireless/iwlwifi/pcie/trans.c:		dev_err(&pdev->dev, "pci_request_regions failed\n");
drivers/net/wireless/iwlwifi/pcie/trans.c:		dev_err(&pdev->dev, "pci_ioremap_bar failed\n");
drivers/net/wireless/iwlwifi/pcie/trans.c:		dev_err(&pdev->dev, "pci_enable_msi failed(0X%x)\n", err);
drivers/net/wireless/iwlwifi/pcie/trans.c:	trans->dev = &pdev->dev;
drivers/net/wireless/iwlwifi/pcie/trans.c:	trans->hw_id = (pdev->device << 16) + pdev->subsystem_device;
drivers/net/wireless/iwlwifi/pcie/trans.c:		 "PCI ID: 0x%04X:0x%04X", pdev->device, pdev->subsystem_device);
drivers/net/wireless/iwlwifi/pcie/trans.c:	if (request_threaded_irq(pdev->irq, iwl_pcie_isr_ict,
drivers/net/wireless/iwlwifi/pcie/trans.c:		IWL_ERR(trans, "Error allocating IRQ %d\n", pdev->irq);
drivers/net/wireless/mwifiex/pcie.c:		 pdev->vendor, pdev->device, pdev->revision);
drivers/net/wireless/mwifiex/pcie.c:	ret = request_irq(pdev->irq, mwifiex_pcie_interrupt, IRQF_SHARED,
drivers/net/wireless/mwifiex/pcie.c:	adapter->dev = &pdev->dev;
drivers/net/wireless/iwlegacy/4965-mac.c:	SET_IEEE80211_DEV(hw, &pdev->dev);
drivers/net/wireless/iwlegacy/4965-mac.c:	sysfs_remove_group(&pdev->dev.kobj, &il_attribute_group);
drivers/net/wireless/iwlegacy/3945-mac.c:	SET_IEEE80211_DEV(hw, &pdev->dev);
drivers/net/wireless/iwlegacy/3945-mac.c:	err = sysfs_create_group(&pdev->dev.kobj, &il3945_attribute_group);
drivers/net/wireless/iwlegacy/3945-mac.c:	sysfs_remove_group(&pdev->dev.kobj, &il3945_attribute_group);
drivers/net/wireless/iwlegacy/3945-mac.c:	sysfs_remove_group(&pdev->dev.kobj, &il3945_attribute_group);
drivers/net/wireless/iwlegacy/3945-mac.c:	free_irq(pdev->irq, il);
drivers/net/wireless/orinoco/orinoco_nortel.c:	priv = alloc_orinocodev(sizeof(*card), &pdev->dev,
drivers/net/wireless/orinoco/orinoco_nortel.c:	err = request_irq(pdev->irq, orinoco_interrupt, IRQF_SHARED,
drivers/net/wireless/orinoco/orinoco_nortel.c:		printk(KERN_ERR PFX "Cannot allocate IRQ %d\n", pdev->irq);
drivers/net/wireless/orinoco/orinoco_nortel.c:	free_irq(pdev->irq, priv);
drivers/net/wireless/orinoco/orinoco_nortel.c:	free_irq(pdev->irq, priv);
drivers/net/wireless/orinoco/orinoco_tmd.c:	priv = alloc_orinocodev(sizeof(*card), &pdev->dev,
drivers/net/wireless/orinoco/orinoco_tmd.c:	err = request_irq(pdev->irq, orinoco_interrupt, IRQF_SHARED,
drivers/net/wireless/orinoco/orinoco_tmd.c:		printk(KERN_ERR PFX "Cannot allocate IRQ %d\n", pdev->irq);
drivers/net/wireless/orinoco/orinoco_tmd.c:	free_irq(pdev->irq, priv);
drivers/net/wireless/orinoco/orinoco_tmd.c:	free_irq(pdev->irq, priv);
drivers/net/wireless/orinoco/orinoco_pci.c:	priv = alloc_orinocodev(sizeof(*card), &pdev->dev,
drivers/net/wireless/orinoco/orinoco_pci.c:	err = request_irq(pdev->irq, orinoco_interrupt, IRQF_SHARED,
drivers/net/wireless/orinoco/orinoco_pci.c:		printk(KERN_ERR PFX "Cannot allocate IRQ %d\n", pdev->irq);
drivers/net/wireless/orinoco/orinoco_pci.c:	free_irq(pdev->irq, priv);
drivers/net/wireless/orinoco/orinoco_pci.c:	free_irq(pdev->irq, priv);
drivers/net/wireless/orinoco/orinoco_pci.h:	free_irq(pdev->irq, priv);
drivers/net/wireless/orinoco/orinoco_pci.h:	err = request_irq(pdev->irq, orinoco_interrupt, IRQF_SHARED,
drivers/net/wireless/orinoco/orinoco_plx.c:	priv = alloc_orinocodev(sizeof(*card), &pdev->dev,
drivers/net/wireless/orinoco/orinoco_plx.c:	err = request_irq(pdev->irq, orinoco_interrupt, IRQF_SHARED,
drivers/net/wireless/orinoco/orinoco_plx.c:		printk(KERN_ERR PFX "Cannot allocate IRQ %d\n", pdev->irq);
drivers/net/wireless/orinoco/orinoco_plx.c:	free_irq(pdev->irq, priv);
drivers/net/wireless/orinoco/orinoco_plx.c:	free_irq(pdev->irq, priv);
drivers/net/wireless/rtlwifi/pci.c:	synchronize_irq(rtlpci->pdev->irq);
drivers/net/wireless/rtlwifi/pci.c:	struct pci_dev *bridge_pdev = pdev->bus->self;
drivers/net/wireless/rtlwifi/pci.c:	venderid = pdev->vendor;
drivers/net/wireless/rtlwifi/pci.c:	deviceid = pdev->device;
drivers/net/wireless/rtlwifi/pci.c:	pcipriv->ndis_adapter.busnumber = pdev->bus->number;
drivers/net/wireless/rtlwifi/pci.c:	pcipriv->ndis_adapter.devnumber = PCI_SLOT(pdev->devfn);
drivers/net/wireless/rtlwifi/pci.c:	pcipriv->ndis_adapter.funcnumber = PCI_FUNC(pdev->devfn);
drivers/net/wireless/rtlwifi/pci.c:		pcipriv->ndis_adapter.pcibridge_vendorid = bridge_pdev->vendor;
drivers/net/wireless/rtlwifi/pci.c:			if (bridge_pdev->vendor == pcibridge_vendors[tmp]) {
drivers/net/wireless/rtlwifi/pci.c:		    bridge_pdev->bus->number;
drivers/net/wireless/rtlwifi/pci.c:		    PCI_SLOT(bridge_pdev->devfn);
drivers/net/wireless/rtlwifi/pci.c:		    PCI_FUNC(bridge_pdev->devfn);
drivers/net/wireless/rtlwifi/pci.c:		 pdev->vendor, pcipriv->ndis_adapter.linkctrl_reg);
drivers/net/wireless/rtlwifi/pci.c:	SET_IEEE80211_DEV(hw, &pdev->dev);
drivers/net/wireless/rtlwifi/pci.c:	_rtl_pci_io_handler_init(&pdev->dev, hw);
drivers/net/wireless/rtlwifi/pci.c:	err = sysfs_create_group(&pdev->dev.kobj, &rtl_attribute_group);
drivers/net/wireless/rtlwifi/pci.c:	err = request_irq(rtlpci->pdev->irq, &_rtl_pci_interrupt,
drivers/net/wireless/rtlwifi/pci.c:	sysfs_remove_group(&pdev->dev.kobj, &rtl_attribute_group);
drivers/net/wireless/rtlwifi/pci.c:		synchronize_irq(rtlpci->pdev->irq);
drivers/net/wireless/rtlwifi/pci.c:		free_irq(rtlpci->pdev->irq, hw);
drivers/net/wireless/rtlwifi/rtl8188ee/hw.c:	synchronize_irq(rtlpci->pdev->irq);
drivers/net/wireless/rtlwifi/rtl8192de/hw.c:	synchronize_irq(rtlpci->pdev->irq);
drivers/net/wireless/rtlwifi/rtl8192de/phy.c:			} else if (rtlpci->pdev->current_state != PCI_D0) {
drivers/net/wireless/rtlwifi/rtl8192ce/hw.c:	synchronize_irq(rtlpci->pdev->irq);
drivers/net/wireless/rtlwifi/rtl8192se/hw.c:	synchronize_irq(rtlpci->pdev->irq);
drivers/net/wireless/rtlwifi/rtl8723ae/hw.c:	synchronize_irq(rtlpci->pdev->irq);
drivers/net/wireless/airo.c:	if (pdev->device == 0x5000 || pdev->device == 0xa504)
drivers/net/wireless/airo.c:			dev = _init_airo_card(pdev->irq, pdev->resource[0].start, 0, pdev, &pdev->dev);
drivers/net/wireless/airo.c:			dev = _init_airo_card(pdev->irq, pdev->resource[2].start, 0, pdev, &pdev->dev);
drivers/net/wireless/airo.c:	pci_power_t prev_state = pdev->current_state;
drivers/net/wireless/rt2x00/rt2x00soc.c:	rt2x00dev->dev = &pdev->dev;
drivers/net/wireless/rt2x00/rt2x00soc.c:	rt2x00dev->name = pdev->dev.driver->name;
drivers/net/wireless/p54/p54pci.c:		dev_err(&priv->pdev->dev, "wrong firmware, "
drivers/net/wireless/p54/p54pci.c:				dev_err(&priv->pdev->dev,
drivers/net/wireless/p54/p54pci.c:				dev_err(&priv->pdev->dev, "rx'd frame size "
drivers/net/wireless/p54/p54pci.c:		dev_err(&priv->pdev->dev, "TX DMA mapping error\n");
drivers/net/wireless/p54/p54pci.c:	free_irq(priv->pdev->irq, dev);
drivers/net/wireless/p54/p54pci.c:	err = request_irq(priv->pdev->irq, p54p_interrupt,
drivers/net/wireless/p54/p54pci.c:		dev_err(&priv->pdev->dev, "failed to register IRQ handler\n");
drivers/net/wireless/p54/p54pci.c:		free_irq(priv->pdev->irq, dev);
drivers/net/wireless/p54/p54pci.c:		dev_err(&pdev->dev, "Cannot find firmware (isl3886pci)\n");
drivers/net/wireless/p54/p54pci.c:	err = p54_register_common(dev, &pdev->dev);
drivers/net/wireless/p54/p54pci.c:		struct device *parent = pdev->dev.parent;
drivers/net/wireless/p54/p54pci.c:		device_release_driver(&pdev->dev);
drivers/net/wireless/p54/p54pci.c:		dev_err(&pdev->dev, "Cannot enable new PCI device\n");
drivers/net/wireless/p54/p54pci.c:		dev_err(&pdev->dev, "Too short PCI resources\n");
drivers/net/wireless/p54/p54pci.c:		dev_err(&pdev->dev, "Cannot obtain PCI resources\n");
drivers/net/wireless/p54/p54pci.c:		dev_err(&pdev->dev, "No suitable DMA available\n");
drivers/net/wireless/p54/p54pci.c:		dev_err(&pdev->dev, "ieee80211 alloc failed\n");
drivers/net/wireless/p54/p54pci.c:	SET_IEEE80211_DEV(dev, &pdev->dev);
drivers/net/wireless/p54/p54pci.c:		dev_err(&pdev->dev, "Cannot map device memory\n");
drivers/net/wireless/p54/p54pci.c:		dev_err(&pdev->dev, "Cannot allocate rings\n");
drivers/net/wireless/p54/p54pci.c:				      &priv->pdev->dev, GFP_KERNEL,
drivers/net/wireless/hostap/hostap_plx.c:	tmd7160 = (pdev->vendor == 0x15e8) && (pdev->device == 0x0131);
drivers/net/wireless/hostap/hostap_plx.c:		       plx_ioaddr, pdev->irq, pccard_ioaddr);
drivers/net/wireless/hostap/hostap_plx.c:		       pccard_attr_mem, plx_ioaddr, pdev->irq, pccard_ioaddr);
drivers/net/wireless/hostap/hostap_plx.c:				     &pdev->dev);
drivers/net/wireless/hostap/hostap_plx.c:	dev->irq = pdev->irq;
drivers/net/wireless/hostap/hostap_pci.c:				     &pdev->dev);
drivers/net/wireless/hostap/hostap_pci.c:        dev->irq = pdev->irq;
drivers/net/wireless/adm8211.h:#define ADM8211_SRAM(x) (priv->pdev->revision < ADM8211_REV_BA ? \
drivers/net/wireless/b43/phy_n.c:				if (pdev->device == 0x4328 ||
drivers/net/wireless/b43/phy_n.c:				    pdev->device == 0x432a)
drivers/net/wireless/b43/main.c:	    (pdev->device != 0x4312 &&
drivers/net/wireless/b43/main.c:	     pdev->device != 0x4319 && pdev->device != 0x4324)) {
drivers/net/wireless/b43/main.c:	(pdev->vendor == PCI_VENDOR_ID_##_vendor) &&			\
drivers/net/wireless/b43/main.c:	(pdev->device == _device) &&					\
drivers/net/wireless/b43/main.c:	(pdev->subsystem_vendor == PCI_VENDOR_ID_##_subvendor) &&	\
drivers/net/wireless/b43/main.c:	(pdev->subsystem_device == _subdevice)				)
drivers/net/wireless/adm8211.c:		if (priv->pdev->revision < ADM8211_REV_CA)
drivers/net/wireless/adm8211.c:		if (priv->pdev->revision < ADM8211_REV_CA)
drivers/net/wireless/adm8211.c:		if (priv->pdev->revision < ADM8211_REV_CA)
drivers/net/wireless/adm8211.c:		if (priv->pdev->revision == ADM8211_REV_BA)
drivers/net/wireless/adm8211.c:		else if (priv->pdev->revision == ADM8211_REV_CA)
drivers/net/wireless/adm8211.c:		else if (priv->pdev->revision == ADM8211_REV_AB)
drivers/net/wireless/adm8211.c:			  (priv->pdev->revision < ADM8211_REV_BA ?
drivers/net/wireless/adm8211.c:	if (priv->pdev->revision < ADM8211_REV_BA) {
drivers/net/wireless/adm8211.c:			if (priv->pdev->revision < ADM8211_REV_CA)
drivers/net/wireless/adm8211.c:			(priv->pdev->revision < ADM8211_REV_CA ? tx_power : 0));
drivers/net/wireless/adm8211.c:	adm8211_write_bbp(dev, 0x1c, priv->pdev->revision == ADM8211_REV_BA ?
drivers/net/wireless/adm8211.c:		if (priv->pdev->revision >= ADM8211_REV_BA)
drivers/net/wireless/adm8211.c:		switch (priv->pdev->revision) {
drivers/net/wireless/adm8211.c:			if (priv->pdev->revision == ADM8211_REV_BA)
drivers/net/wireless/adm8211.c:	if (priv->pdev->revision != ADM8211_REV_BA) {
drivers/net/wireless/adm8211.c:	if (priv->pdev->revision < ADM8211_REV_CA)
drivers/net/wireless/adm8211.c:	if (priv->pdev->revision < ADM8211_REV_CA)
drivers/net/wireless/adm8211.c:	if (priv->pdev->revision == ADM8211_REV_BA &&
drivers/net/wireless/adm8211.c:	} else if (priv->pdev->revision == ADM8211_REV_CA) {
drivers/net/wireless/adm8211.c:	retval = request_irq(priv->pdev->irq, adm8211_interrupt,
drivers/net/wireless/adm8211.c:	free_irq(priv->pdev->irq, dev);
drivers/net/wireless/adm8211.c:	SET_IEEE80211_DEV(dev, &pdev->dev);
drivers/net/wireless/adm8211.c:	if (pdev->revision >= ADM8211_REV_BA) {
drivers/net/wireless/adm8211.c:		   dev->wiphy->perm_addr, pdev->revision);
drivers/net/wireless/ti/wlcore/main.c:	struct wlcore_platdev_data *pdev_data = pdev->dev.platform_data;
drivers/net/wireless/ti/wlcore/main.c:				   irqflags, pdev->name, wl);
drivers/net/wireless/ti/wlcore/main.c:	wl->dev = &pdev->dev;
drivers/net/wireless/ti/wlcore/main.c:				      WL12XX_NVS_NAME, &pdev->dev, GFP_KERNEL,
drivers/net/wireless/ti/wl12xx/main.c:	struct wlcore_platdev_data *pdev_data = wl->pdev->dev.platform_data;
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:	struct device *device = &pdev->dev;
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:	if (request_irq(pdev->irq, brcms_isr,
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:	wl->irq = pdev->irq;
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:	dev_info(&pdev->dev, "mfg %x core %x rev %d class %d irq %d\n",
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:		 pdev->id.manuf, pdev->id.id, pdev->id.rev, pdev->id.class,
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:		 pdev->irq);
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:	if ((pdev->id.manuf != BCMA_MANUF_BCM) ||
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:	    (pdev->id.id != BCMA_CORE_80211))
drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c:	SET_IEEE80211_DEV(hw, &pdev->dev);
drivers/net/wireless/brcm80211/brcmfmac/bcmsdh_sdmmc.c:	brcmfmac_sdio_pdata = pdev->dev.platform_data;
drivers/net/wireless/ipw2x00/ipw2200.c:	err = request_irq(pdev->irq, ipw_isr, IRQF_SHARED, DRV_NAME, priv);
drivers/net/wireless/ipw2x00/ipw2200.c:		IPW_ERROR("Error allocating IRQ %d\n", pdev->irq);
drivers/net/wireless/ipw2x00/ipw2200.c:	SET_NETDEV_DEV(net_dev, &pdev->dev);
drivers/net/wireless/ipw2x00/ipw2200.c:	err = sysfs_create_group(&pdev->dev.kobj, &ipw_attribute_group);
drivers/net/wireless/ipw2x00/ipw2200.c:	sysfs_remove_group(&pdev->dev.kobj, &ipw_attribute_group);
drivers/net/wireless/ipw2x00/ipw2200.c:	free_irq(pdev->irq, priv);
drivers/net/wireless/ipw2x00/ipw2200.c:	sysfs_remove_group(&pdev->dev.kobj, &ipw_attribute_group);
drivers/net/wireless/ipw2x00/ipw2200.c:	free_irq(pdev->irq, priv);
drivers/net/wireless/ath/ath6kl/init.c:	{ ATH6KL_FW_CAPABILITY_STA_P2PDEV_DUPLEX, "sta-p2pdev-duplex" },
drivers/net/wireless/ath/ath9k/ahb.c:	pdata = (struct ath9k_platform_data *) pdev->dev.platform_data;
drivers/net/wireless/ath/ath9k/ahb.c:	if (!pdev->dev.platform_data) {
drivers/net/wireless/ath/ath9k/ahb.c:		dev_err(&pdev->dev, "no platform data specified\n");
drivers/net/wireless/ath/ath9k/ahb.c:		dev_err(&pdev->dev, "no memory resource found\n");
drivers/net/wireless/ath/ath9k/ahb.c:	mem = devm_ioremap_nocache(&pdev->dev, res->start, resource_size(res));
drivers/net/wireless/ath/ath9k/ahb.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/net/wireless/ath/ath9k/ahb.c:		dev_err(&pdev->dev, "no IRQ resource found\n");
drivers/net/wireless/ath/ath9k/ahb.c:		dev_err(&pdev->dev, "no memory for ieee80211_hw\n");
drivers/net/wireless/ath/ath9k/ahb.c:	SET_IEEE80211_DEV(hw, &pdev->dev);
drivers/net/wireless/ath/ath9k/ahb.c:	sc->dev = &pdev->dev;
drivers/net/wireless/ath/ath9k/ahb.c:		dev_err(&pdev->dev, "request_irq failed\n");
drivers/net/wireless/ath/ath9k/ahb.c:		dev_err(&pdev->dev, "failed to initialize device\n");
drivers/net/wireless/ath/ath9k/pci.c:	parent = pdev->bus->self;
drivers/net/wireless/ath/ath9k/pci.c:		dev_err(&pdev->dev, "PCI memory region reserve error\n");
drivers/net/wireless/ath/ath9k/pci.c:		dev_err(&pdev->dev, "No memory for ieee80211_hw\n");
drivers/net/wireless/ath/ath9k/pci.c:	SET_IEEE80211_DEV(hw, &pdev->dev);
drivers/net/wireless/ath/ath9k/pci.c:	sc->dev = &pdev->dev;
drivers/net/wireless/ath/ath9k/pci.c:	ret = request_irq(pdev->irq, ath_isr, IRQF_SHARED, "ath9k", sc);
drivers/net/wireless/ath/ath9k/pci.c:		dev_err(&pdev->dev, "request_irq failed\n");
drivers/net/wireless/ath/ath9k/pci.c:	sc->irq = pdev->irq;
drivers/net/wireless/ath/ath9k/pci.c:		dev_err(&pdev->dev, "Failed to initialize device\n");
drivers/net/wireless/ath/ath9k/pci.c:		   hw_name, (unsigned long)sc->mem, pdev->irq);
drivers/net/wireless/ath/ath5k/ahb.c:	struct ar231x_board_config *bcfg = pdev->dev.platform_data;
drivers/net/wireless/ath/ath5k/ahb.c:	bcfg = pdev->dev.platform_data;
drivers/net/wireless/ath/ath5k/ahb.c:	struct ar231x_board_config *bcfg = pdev->dev.platform_data;
drivers/net/wireless/ath/ath5k/ahb.c:	struct ar231x_board_config *bcfg = pdev->dev.platform_data;
drivers/net/wireless/ath/ath5k/ahb.c:	struct ar231x_board_config *bcfg = pdev->dev.platform_data;
drivers/net/wireless/ath/ath5k/ahb.c:	if (!pdev->dev.platform_data) {
drivers/net/wireless/ath/ath5k/ahb.c:		dev_err(&pdev->dev, "no platform data specified\n");
drivers/net/wireless/ath/ath5k/ahb.c:		dev_err(&pdev->dev, "no memory resource found\n");
drivers/net/wireless/ath/ath5k/ahb.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/net/wireless/ath/ath5k/ahb.c:		dev_err(&pdev->dev, "no IRQ resource found\n");
drivers/net/wireless/ath/ath5k/ahb.c:		dev_err(&pdev->dev, "no memory for ieee80211_hw\n");
drivers/net/wireless/ath/ath5k/ahb.c:	ah->dev = &pdev->dev;
drivers/net/wireless/ath/ath5k/ahb.c:		dev_err(&pdev->dev, "failed to attach device, err=%d\n", ret);
drivers/net/wireless/ath/ath5k/ahb.c:	struct ar231x_board_config *bcfg = pdev->dev.platform_data;
drivers/net/wireless/ath/ath5k/pci.c:		dev_err(&pdev->dev, "can't enable device\n");
drivers/net/wireless/ath/ath5k/pci.c:		dev_err(&pdev->dev, "32-bit DMA not available\n");
drivers/net/wireless/ath/ath5k/pci.c:		dev_err(&pdev->dev, "cannot reserve PCI memory region\n");
drivers/net/wireless/ath/ath5k/pci.c:		dev_err(&pdev->dev, "cannot remap PCI memory region\n");
drivers/net/wireless/ath/ath5k/pci.c:		dev_err(&pdev->dev, "cannot allocate ieee80211_hw\n");
drivers/net/wireless/ath/ath5k/pci.c:	dev_info(&pdev->dev, "registered as '%s'\n", wiphy_name(hw->wiphy));
drivers/net/wireless/ath/ath5k/pci.c:	ah->dev = &pdev->dev;
drivers/net/wireless/ath/ath5k/pci.c:	ah->irq = pdev->irq;
drivers/net/wireless/ath/wil6210/pcie_bus.c:	rc = wil6210_init_irq(wil, pdev->irq);
drivers/net/wireless/ath/wil6210/pcie_bus.c:	wil6210_fini_irq(wil, pdev->irq);
drivers/net/wireless/ath/wil6210/pcie_bus.c:	wil6210_fini_irq(wil, pdev->irq);
drivers/net/wireless/ath/wil6210/pcie_bus.c:	struct device *dev = &pdev->dev;
drivers/net/wireless/ath/wil6210/pcie_bus.c:	dev_info(&pdev->dev, WIL_NAME " device found [%04x:%04x] (rev %x)\n",
drivers/net/wireless/ath/wil6210/pcie_bus.c:		 (int)pdev->vendor, (int)pdev->device, (int)pdev->revision);
drivers/net/wireless/ath/wil6210/pcie_bus.c:		dev_err(&pdev->dev, "Not " WIL_NAME "? "
drivers/net/wireless/ath/wil6210/pcie_bus.c:		dev_err(&pdev->dev, "pci_enable_device failed\n");
drivers/net/wireless/ath/wil6210/pcie_bus.c:		dev_err(&pdev->dev, "pci_request_region failed\n");
drivers/net/wireless/ath/wil6210/pcie_bus.c:		dev_err(&pdev->dev, "pci_ioremap_bar failed\n");
drivers/net/wireless/ath/wil6210/pcie_bus.c:	dev_info(&pdev->dev, "CSR at %pR -> %p\n", &pdev->resource[0], csr);
drivers/net/wireless/prism54/prismcompat.h:#define PRISM_FW_PDEV		&priv->pdev->dev
drivers/net/wireless/prism54/islpci_hotplug.c:	rvalue = request_irq(pdev->irq, islpci_interrupt,
drivers/net/wireless/prism54/islpci_hotplug.c:	free_irq(pdev->irq, priv);
drivers/net/wireless/prism54/islpci_dev.c:	synchronize_irq(priv->pdev->irq);
drivers/net/wireless/prism54/islpci_dev.c:	SET_NETDEV_DEV(ndev, &pdev->dev);
drivers/net/wireless/prism54/islpci_dev.c:	ndev->irq = pdev->irq;
drivers/net/wireless/prism54/islpci_dev.c:	switch (pdev->device) {
drivers/net/wireless/atmel_pci.c:	dev = init_atmel_card(pdev->irq, pdev->resource[1].start,
drivers/net/wireless/atmel_pci.c:			      &pdev->dev, NULL, NULL);
drivers/net/wireless/rtl818x/rtl8180/dev.c:	ret = request_irq(priv->pdev->irq, rtl8180_interrupt,
drivers/net/wireless/rtl818x/rtl8180/dev.c:	free_irq(priv->pdev->irq, dev);
drivers/net/wireless/rtl818x/rtl8180/dev.c:	SET_IEEE80211_DEV(dev, &pdev->dev);
drivers/net/wireless/b43legacy/main.c:	    (pdev->device != 0x4312 &&
drivers/net/wireless/b43legacy/main.c:	     pdev->device != 0x4319 &&
drivers/net/wireless/b43legacy/main.c:	     pdev->device != 0x4324)) {
drivers/pps/clients/pps-gpio.c:	const struct pps_gpio_platform_data *pdata = pdev->dev.platform_data;
drivers/pps/clients/pps-gpio.c:	const struct pps_gpio_platform_data *pdata = pdev->dev.platform_data;
drivers/pps/clients/pps-gpio.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct pps_gpio_device_data),
drivers/pps/clients/pps-gpio.c:		 pdev->name, pdev->id);
drivers/ptp/ptp_pch.c:		dev_err(&pdev->dev,
drivers/ptp/ptp_pch.c:			dev_err(&pdev->dev,
drivers/ptp/ptp_pch.c:			dev_err(&pdev->dev,
drivers/ptp/ptp_pch.c:			dev_err(&pdev->dev,
drivers/ptp/ptp_pch.c:		dev_dbg(&pdev->dev, "invoking pch_station_set\n");
drivers/ptp/ptp_pch.c:		dev_err(&pdev->dev, "could not save PCI config state\n");
drivers/ptp/ptp_pch.c:		dev_err(&pdev->dev, "pci_enable_device failed\n");
drivers/ptp/ptp_pch.c:	if (pdev->irq != 0)
drivers/ptp/ptp_pch.c:		free_irq(pdev->irq, chip);
drivers/ptp/ptp_pch.c:	dev_info(&pdev->dev, "complete\n");
drivers/ptp/ptp_pch.c:		dev_err(&pdev->dev, "could not enable the pci device\n");
drivers/ptp/ptp_pch.c:		dev_err(&pdev->dev, "could not locate IO memory address\n");
drivers/ptp/ptp_pch.c:		dev_err(&pdev->dev,
drivers/ptp/ptp_pch.c:		dev_err(&pdev->dev, "Could not get virtual address\n");
drivers/ptp/ptp_pch.c:	chip->ptp_clock = ptp_clock_register(&chip->caps, &pdev->dev);
drivers/ptp/ptp_pch.c:	ret = request_irq(pdev->irq, &isr, IRQF_SHARED, KBUILD_MODNAME, chip);
drivers/ptp/ptp_pch.c:		dev_err(&pdev->dev, "failed to get irq %d\n", pdev->irq);
drivers/ptp/ptp_pch.c:	chip->irq = pdev->irq;
drivers/ptp/ptp_pch.c:			dev_err(&pdev->dev,
drivers/ptp/ptp_pch.c:	dev_err(&pdev->dev, "probe failed(ret=0x%x)\n", ret);
drivers/bluetooth/btwilink.c:	hst = devm_kzalloc(&pdev->dev, sizeof(struct ti_st), GFP_KERNEL);
drivers/bluetooth/btwilink.c:	dev_set_drvdata(&pdev->dev, hst);
drivers/bluetooth/btwilink.c:	struct ti_st *hst = dev_get_drvdata(&pdev->dev);
drivers/bluetooth/btwilink.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/amba/tegra-ahb.c:	ahb = devm_kzalloc(&pdev->dev, bytes, GFP_KERNEL);
drivers/amba/tegra-ahb.c:	ahb->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/amba/tegra-ahb.c:	ahb->dev = &pdev->dev;
drivers/cpufreq/exynos5440-cpufreq.c:	np =  pdev->dev.of_node;
drivers/cpufreq/exynos5440-cpufreq.c:	dvfs_info = devm_kzalloc(&pdev->dev, sizeof(*dvfs_info), GFP_KERNEL);
drivers/cpufreq/exynos5440-cpufreq.c:	dvfs_info->dev = &pdev->dev;
drivers/cpufreq/dbx500-cpufreq.c:	freq_table = dev_get_platdata(&pdev->dev);
drivers/cpufreq/dbx500-cpufreq.c:	armss_clk = clk_get(&pdev->dev, "armss");
drivers/cpufreq/kirkwood-cpufreq.c:	priv.dev = &pdev->dev;
drivers/cpufreq/kirkwood-cpufreq.c:	priv.base = devm_ioremap_resource(&pdev->dev, res);
drivers/cpufreq/imx6q-cpufreq.c:	cpu_dev = &pdev->dev;
drivers/cpufreq/davinci-cpufreq.c:	struct davinci_cpufreq_config *pdata = pdev->dev.platform_data;
drivers/cpufreq/davinci-cpufreq.c:	cpufreq.dev = &pdev->dev;
drivers/cpufreq/cpufreq-cpu0.c:	cpu_dev = &pdev->dev;
drivers/cpuidle/cpuidle-kirkwood.c:	ddr_operation_base = devm_ioremap_resource(&pdev->dev, res);
drivers/ide/pdc202xx_new.c:	switch(pdev->device) {
drivers/ide/pdc202xx_new.c:	if (pdev->revision >= 0x03) {
drivers/ide/alim15x3.c:	if (pdev->subsystem_vendor == 0x10CF &&
drivers/ide/alim15x3.c:	    pdev->subsystem_device == 0x10AF)
drivers/ide/alim15x3.c:	if (pdev->subsystem_vendor == 0x1071 &&
drivers/ide/alim15x3.c:	    pdev->subsystem_device == 0x8317)
drivers/ide/pmac.c:	hw.dev = &mdev->bus->pdev->dev;
drivers/ide/pmac.c:	pmif->irq = pdev->irq;
drivers/ide/pmac.c:	hw.irq = pdev->irq;
drivers/ide/pmac.c:	hw.dev = &pdev->dev;
drivers/ide/pmac.c:	if (mesg.event != pdev->dev.power.power_state.event
drivers/ide/pmac.c:			pdev->dev.power.power_state = mesg;
drivers/ide/pmac.c:	if (pdev->dev.power.power_state.event != PM_EVENT_ON) {
drivers/ide/pmac.c:			pdev->dev.power.power_state = PMSG_ON;
drivers/ide/piix.c:		if (lap->device == pdev->device &&
drivers/ide/piix.c:		    lap->subvendor == pdev->subsystem_vendor &&
drivers/ide/piix.c:		    lap->subdevice == pdev->subsystem_device) {
drivers/ide/piix.c:		if (pdev->revision == 0x00)
drivers/ide/piix.c:		else if (cfg & (1<<14) && pdev->revision < 5)
drivers/ide/sis5513.c:		if (lap->device == pdev->device &&
drivers/ide/sis5513.c:		    lap->subvendor == pdev->subsystem_vendor &&
drivers/ide/sis5513.c:		    lap->subdevice == pdev->subsystem_device)
drivers/ide/tx4939ide.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
drivers/ide/tx4939ide.c:	mapbase = (unsigned long)devm_ioremap(&pdev->dev, res->start,
drivers/ide/tx4939ide.c:	hw.dev = &pdev->dev;
drivers/ide/ide_platform.c:	pdata = pdev->dev.platform_data;
drivers/ide/ide_platform.c:		base = devm_ioremap(&pdev->dev,
drivers/ide/ide_platform.c:		alt_base = devm_ioremap(&pdev->dev,
drivers/ide/ide_platform.c:		base = devm_ioport_map(&pdev->dev,
drivers/ide/ide_platform.c:		alt_base = devm_ioport_map(&pdev->dev,
drivers/ide/ide_platform.c:	hw.dev = &pdev->dev;
drivers/ide/ide_platform.c:	struct ide_host *host = dev_get_drvdata(&pdev->dev);
drivers/ide/gayle.c:	pdata = pdev->dev.platform_data;
drivers/ide/ide-acpi.c:	bus = pdev->bus->number;
drivers/ide/ide-acpi.c:	devnum = PCI_SLOT(pdev->devfn);
drivers/ide/ide-acpi.c:	func = PCI_FUNC(pdev->devfn);
drivers/ide/via82cxxx.c:	if (pdev->subsystem_vendor == 0x161F &&
drivers/ide/via82cxxx.c:	    pdev->subsystem_device == 0x2032)
drivers/ide/palm_bk3710.c:	clk = clk_get(&pdev->dev, NULL);
drivers/ide/palm_bk3710.c:	hw.dev = &pdev->dev;
drivers/ide/siimage.c:	switch (pdev->device) {
drivers/ide/tx4938ide.c:	struct tx4938ide_platform_info *pdata = pdev->dev.platform_data;
drivers/ide/tx4938ide.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
drivers/ide/tx4938ide.c:	mapbase = (unsigned long)devm_ioremap(&pdev->dev, res->start,
drivers/ide/tx4938ide.c:	mapctl = (unsigned long)devm_ioremap(&pdev->dev,
drivers/ide/tx4938ide.c:	hw.dev = &pdev->dev;
drivers/ide/ide-cs.c:	if ((pdev->resource[0]->flags & IO_DATA_PATH_WIDTH)
drivers/ide/ide-cs.c:		pdev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;
drivers/ide/ide-cs.c:		pdev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;
drivers/ide/ide-cs.c:	pdev->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;
drivers/ide/ide-cs.c:	pdev->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;
drivers/ide/ide-cs.c:	if (pdev->resource[1]->end) {
drivers/ide/ide-cs.c:		pdev->resource[0]->end = 8;
drivers/ide/ide-cs.c:		pdev->resource[1]->end = (*is_kme) ? 2 : 1;
drivers/ide/ide-cs.c:		if (pdev->resource[0]->end < 16)
drivers/bcma/driver_pci_host.c:	dev->irq = bcma_core_irq(pc_host->pdev->core);
drivers/bcma/driver_pci_host.c:	return bcma_core_irq(pc_host->pdev->core);
drivers/pci/iov.c:		if (!pdev->is_physfn)
drivers/pci/iov.c:					&pdev->dev.kobj, "dep_link");
drivers/pci/iov.c:		if (pdev->is_physfn)
drivers/pci/pci-acpi.c:	if (pdev->no_d3cold)
drivers/pci/pci-acpi.c:	acpi_state = acpi_pm_device_sleep_state(&pdev->dev, NULL, d_max);
drivers/pci/msi.c:	pdev->msi_kset = kset_create_and_add("msi_irqs", NULL, &pdev->dev.kobj);
drivers/pci/msi.c:	if (!pdev->msi_kset)
drivers/pci/msi.c:	list_for_each_entry(entry, &pdev->msi_list, list) {
drivers/pci/msi.c:		kobj->kset = pdev->msi_kset;
drivers/pci/msi.c:	list_for_each_entry(entry, &pdev->msi_list, list) {
drivers/pci/xen-pcifront.c:	if (test_bit(_XEN_PCIB_active, (unsigned long *)&pdev->sh_info->flags)
drivers/pci/xen-pcifront.c:		&& !test_and_set_bit(_PDEVB_op_active, &pdev->flags)) {
drivers/pci/xen-pcifront.c:		dev_dbg(&pdev->xdev->dev, "schedule aer frontend job\n");
drivers/pci/xen-pcifront.c:		schedule_work(&pdev->op_work);
drivers/pci/xen-pcifront.c:	struct xen_pci_op *active_op = &pdev->sh_info->op;
drivers/pci/xen-pcifront.c:	evtchn_port_t port = pdev->evtchn;
drivers/pci/xen-pcifront.c:	unsigned irq = pdev->irq;
drivers/pci/xen-pcifront.c:	spin_lock_irqsave(&pdev->sh_info_lock, irq_flags);
drivers/pci/xen-pcifront.c:	set_bit(_XEN_PCIF_active, (unsigned long *)&pdev->sh_info->flags);
drivers/pci/xen-pcifront.c:			(unsigned long *)&pdev->sh_info->flags)) {
drivers/pci/xen-pcifront.c:			dev_err(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:				  (unsigned long *)&pdev->sh_info->flags);
drivers/pci/xen-pcifront.c:			(unsigned long *)&pdev->sh_info->flags)) {
drivers/pci/xen-pcifront.c:		dev_err(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:	spin_unlock_irqrestore(&pdev->sh_info_lock, irq_flags);
drivers/pci/xen-pcifront.c:		dev_info(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:			dev_info(&pdev->xdev->dev, "read got back value %x\n",
drivers/pci/xen-pcifront.c:		dev_info(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:			dev_info(&pdev->xdev->dev, "claiming resource %s/%d\n",
drivers/pci/xen-pcifront.c:				dev_err(&pdev->xdev->dev, "Could not claim resource %s/%d! "
drivers/pci/xen-pcifront.c:			dev_info(&pdev->xdev->dev, "New device on "
drivers/pci/xen-pcifront.c:		dev_err(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:		dev_err(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:	dev_info(&pdev->xdev->dev, "Creating PCI Frontend Bus %04x:%02x\n",
drivers/pci/xen-pcifront.c:	b = pci_scan_bus_parented(&pdev->xdev->dev, bus,
drivers/pci/xen-pcifront.c:		dev_err(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:	list_add(&bus_entry->list, &pdev->root_buses);
drivers/pci/xen-pcifront.c:		dev_err(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:		dev_err(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:	dev_info(&pdev->xdev->dev, "Rescanning PCI Frontend Bus %04x:%02x\n",
drivers/pci/xen-pcifront.c:	dev_dbg(&pdev->xdev->dev, "cleaning up root buses\n");
drivers/pci/xen-pcifront.c:	list_for_each_entry_safe(bus_entry, t, &pdev->root_buses, list) {
drivers/pci/xen-pcifront.c:	int bus = pdev->sh_info->aer_op.bus;
drivers/pci/xen-pcifront.c:	int devfn = pdev->sh_info->aer_op.devfn;
drivers/pci/xen-pcifront.c:	dev_dbg(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:		dev_err(&pdev->xdev->dev, "device or AER driver is NULL\n");
drivers/pci/xen-pcifront.c:					dev_err(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:	int cmd = pdev->sh_info->aer_op.cmd;
drivers/pci/xen-pcifront.c:		(pci_channel_state_t)pdev->sh_info->aer_op.err;
drivers/pci/xen-pcifront.c:	dev_dbg(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:		pdev->sh_info->aer_op.bus, pdev->sh_info->aer_op.devfn);
drivers/pci/xen-pcifront.c:	pdev->sh_info->aer_op.err = pcifront_common_process(cmd, pdev, state);
drivers/pci/xen-pcifront.c:	clear_bit(_XEN_PCIB_active, (unsigned long *)&pdev->sh_info->flags);
drivers/pci/xen-pcifront.c:	notify_remote_via_evtchn(pdev->evtchn);
drivers/pci/xen-pcifront.c:	clear_bit(_PDEVB_op_active, &pdev->flags);
drivers/pci/xen-pcifront.c:		dev_info(&pdev->xdev->dev, "Installing PCI frontend\n");
drivers/pci/xen-pcifront.c:			dev_err(&pdev->xdev->dev, "Could not setup SWIOTLB!\n");
drivers/pci/xen-pcifront.c:		dev_info(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:	pdev->sh_info =
drivers/pci/xen-pcifront.c:	if (pdev->sh_info == NULL) {
drivers/pci/xen-pcifront.c:	pdev->sh_info->flags = 0;
drivers/pci/xen-pcifront.c:	set_bit(_XEN_PCIB_AERHANDLER, (void *)&pdev->sh_info->flags);
drivers/pci/xen-pcifront.c:	pdev->xdev = xdev;
drivers/pci/xen-pcifront.c:	INIT_LIST_HEAD(&pdev->root_buses);
drivers/pci/xen-pcifront.c:	spin_lock_init(&pdev->sh_info_lock);
drivers/pci/xen-pcifront.c:	pdev->evtchn = INVALID_EVTCHN;
drivers/pci/xen-pcifront.c:	pdev->gnt_ref = INVALID_GRANT_REF;
drivers/pci/xen-pcifront.c:	pdev->irq = -1;
drivers/pci/xen-pcifront.c:	INIT_WORK(&pdev->op_work, pcifront_do_aer);
drivers/pci/xen-pcifront.c:	dev_dbg(&xdev->dev, "Allocated pdev @ 0x%p pdev->sh_info @ 0x%p\n",
drivers/pci/xen-pcifront.c:		pdev, pdev->sh_info);
drivers/pci/xen-pcifront.c:	dev_dbg(&pdev->xdev->dev, "freeing pdev @ 0x%p\n", pdev);
drivers/pci/xen-pcifront.c:	cancel_work_sync(&pdev->op_work);
drivers/pci/xen-pcifront.c:	if (pdev->irq >= 0)
drivers/pci/xen-pcifront.c:		unbind_from_irqhandler(pdev->irq, pdev);
drivers/pci/xen-pcifront.c:	if (pdev->evtchn != INVALID_EVTCHN)
drivers/pci/xen-pcifront.c:		xenbus_free_evtchn(pdev->xdev, pdev->evtchn);
drivers/pci/xen-pcifront.c:	if (pdev->gnt_ref != INVALID_GRANT_REF)
drivers/pci/xen-pcifront.c:		gnttab_end_foreign_access(pdev->gnt_ref, 0 /* r/w page */,
drivers/pci/xen-pcifront.c:					  (unsigned long)pdev->sh_info);
drivers/pci/xen-pcifront.c:		free_page((unsigned long)pdev->sh_info);
drivers/pci/xen-pcifront.c:	dev_set_drvdata(&pdev->xdev->dev, NULL);
drivers/pci/xen-pcifront.c:	err = xenbus_grant_ring(pdev->xdev, virt_to_mfn(pdev->sh_info));
drivers/pci/xen-pcifront.c:	pdev->gnt_ref = err;
drivers/pci/xen-pcifront.c:	err = xenbus_alloc_evtchn(pdev->xdev, &pdev->evtchn);
drivers/pci/xen-pcifront.c:	err = bind_evtchn_to_irqhandler(pdev->evtchn, pcifront_handler_aer,
drivers/pci/xen-pcifront.c:	pdev->irq = err;
drivers/pci/xen-pcifront.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/pci/xen-pcifront.c:	err = xenbus_printf(trans, pdev->xdev->nodename,
drivers/pci/xen-pcifront.c:			    "pci-op-ref", "%u", pdev->gnt_ref);
drivers/pci/xen-pcifront.c:		err = xenbus_printf(trans, pdev->xdev->nodename,
drivers/pci/xen-pcifront.c:				    "event-channel", "%u", pdev->evtchn);
drivers/pci/xen-pcifront.c:		err = xenbus_printf(trans, pdev->xdev->nodename,
drivers/pci/xen-pcifront.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/pci/xen-pcifront.c:			xenbus_dev_fatal(pdev->xdev, err,
drivers/pci/xen-pcifront.c:	xenbus_switch_state(pdev->xdev, XenbusStateInitialised);
drivers/pci/xen-pcifront.c:	dev_dbg(&pdev->xdev->dev, "publishing successful!\n");
drivers/pci/xen-pcifront.c:	if (xenbus_read_driver_state(pdev->xdev->nodename) !=
drivers/pci/xen-pcifront.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/pci/xen-pcifront.c:	err = xenbus_scanf(XBT_NIL, pdev->xdev->otherend,
drivers/pci/xen-pcifront.c:		xenbus_dev_error(pdev->xdev, err,
drivers/pci/xen-pcifront.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/pci/xen-pcifront.c:		err = xenbus_scanf(XBT_NIL, pdev->xdev->otherend, str,
drivers/pci/xen-pcifront.c:			xenbus_dev_fatal(pdev->xdev, err,
drivers/pci/xen-pcifront.c:			xenbus_dev_fatal(pdev->xdev, err,
drivers/pci/xen-pcifront.c:	err = xenbus_switch_state(pdev->xdev, XenbusStateConnected);
drivers/pci/xen-pcifront.c:	prev_state = xenbus_read_driver_state(pdev->xdev->nodename);
drivers/pci/xen-pcifront.c:	err = xenbus_switch_state(pdev->xdev, XenbusStateClosed);
drivers/pci/xen-pcifront.c:	if (xenbus_read_driver_state(pdev->xdev->nodename) !=
drivers/pci/xen-pcifront.c:	err = xenbus_scanf(XBT_NIL, pdev->xdev->otherend,
drivers/pci/xen-pcifront.c:		xenbus_dev_error(pdev->xdev, err,
drivers/pci/xen-pcifront.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/pci/xen-pcifront.c:		err = xenbus_scanf(XBT_NIL, pdev->xdev->otherend, str,
drivers/pci/xen-pcifront.c:			xenbus_dev_fatal(pdev->xdev, err,
drivers/pci/xen-pcifront.c:			xenbus_dev_fatal(pdev->xdev, err,
drivers/pci/xen-pcifront.c:	xenbus_switch_state(pdev->xdev, XenbusStateConnected);
drivers/pci/xen-pcifront.c:	if (xenbus_read_driver_state(pdev->xdev->nodename) !=
drivers/pci/xen-pcifront.c:	err = xenbus_scanf(XBT_NIL, pdev->xdev->otherend, "num_devs", "%d",
drivers/pci/xen-pcifront.c:		xenbus_dev_fatal(pdev->xdev, err,
drivers/pci/xen-pcifront.c:		err = xenbus_scanf(XBT_NIL, pdev->xdev->otherend, str, "%d",
drivers/pci/xen-pcifront.c:		err = xenbus_scanf(XBT_NIL, pdev->xdev->otherend, str,
drivers/pci/xen-pcifront.c:			xenbus_dev_fatal(pdev->xdev, err,
drivers/pci/xen-pcifront.c:			dev_dbg(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:		dev_dbg(&pdev->xdev->dev,
drivers/pci/xen-pcifront.c:	err = xenbus_switch_state(pdev->xdev, XenbusStateReconfiguring);
drivers/pci/pci.c:		dev_dbg(&pdev->dev, "restoring config space at offset "
drivers/pci/pci.c:					 pdev->saved_config_space[index],
drivers/pci/pci.c:	if (pdev->hdr_type == PCI_HEADER_TYPE_NORMAL) {
drivers/pci/pci.c:	dr = devres_find(&pdev->dev, pcim_release, NULL, NULL);
drivers/pci/pci.c:	return devres_get(&pdev->dev, new_dr, NULL, NULL);
drivers/pci/pci.c:		return devres_find(&pdev->dev, pcim_release, NULL, NULL);
drivers/pci/pci.c:		pdev->is_managed = 1;
drivers/pci/pci.c:	struct device *dev = &pdev->dev;
drivers/pci/pci.c:	 * pdev->current_state is set to PCI_D3cold during suspending,
drivers/pci/pci.c:	if (pdev->current_state == PCI_D3cold)
drivers/pci/pci.c:	struct device *dev = &pdev->dev;
drivers/pci/pci.c:	if (pdev->multifunction)
drivers/pci/pci.c:	    pdev->multifunction) {
drivers/pci/pci.c:		if (pci_is_root_bus(pdev->bus))
drivers/pci/pci.c:		parent = pdev->bus->self;
drivers/pci/pci.c:	dev_warn(&pdev->dev, "BAR %d: can't reserve %pR\n", bar,
drivers/pci/pci.c:		 &pdev->resource[bar]);
drivers/pci/probe.c:	pdev->is_pcie = 1;
drivers/pci/probe.c:	pdev->pcie_cap = pos;
drivers/pci/probe.c:	pdev->pcie_flags_reg = reg16;
drivers/pci/probe.c:	pdev->pcie_mpss = reg16 & PCI_EXP_DEVCAP_PAYLOAD;
drivers/pci/probe.c:		pdev->is_hotplug_bridge = 1;
drivers/pci/ats.c:		mutex_lock(&pdev->sriov->lock);
drivers/pci/ats.c:		if (pdev->ats)
drivers/pci/ats.c:			rc = pdev->ats->stu == ps ? 0 : -EINVAL;
drivers/pci/ats.c:			pdev->ats->ref_cnt++;
drivers/pci/ats.c:		mutex_unlock(&pdev->sriov->lock);
drivers/pci/ats.c:		mutex_lock(&pdev->sriov->lock);
drivers/pci/ats.c:		pdev->ats->ref_cnt--;
drivers/pci/ats.c:		if (!pdev->ats->ref_cnt)
drivers/pci/ats.c:		mutex_unlock(&pdev->sriov->lock);
drivers/pci/rom.c:	struct resource *res = pdev->resource + PCI_ROM_RESOURCE;
drivers/pci/rom.c:	pci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);
drivers/pci/rom.c:	pci_write_config_dword(pdev, pdev->rom_base_reg, rom_addr);
drivers/pci/rom.c:	pci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);
drivers/pci/rom.c:	pci_write_config_dword(pdev, pdev->rom_base_reg, rom_addr);
drivers/pci/rom.c:			dev_err(&pdev->dev, "Invalid ROM contents\n");
drivers/pci/rom.c:	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
drivers/pci/rom.c:	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
drivers/pci/rom.c:	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
drivers/pci/rom.c:	if (pdev->rom && pdev->romlen) {
drivers/pci/rom.c:		*size = pdev->romlen;
drivers/pci/rom.c:		return phys_to_virt((phys_addr_t)pdev->rom);
drivers/pci/irq.c:	struct pci_dev *parent = to_pci_dev(pdev->dev.parent);
drivers/pci/irq.c:	dev_err(&pdev->dev,
drivers/pci/irq.c:	dev_err(&pdev->dev, "%s\n", reason);
drivers/pci/irq.c:	dev_err(&pdev->dev, "Please report to linux-kernel@vger.kernel.org\n");
drivers/pci/irq.c:	if (pdev->msi_enabled || pdev->msix_enabled) {
drivers/pci/irq.c:		if (pdev->msix_enabled) {
drivers/pci/pci-driver.c:	if (add_uevent_var(env, "PCI_CLASS=%04X", pdev->class))
drivers/pci/pci-driver.c:	if (add_uevent_var(env, "PCI_ID=%04X:%04X", pdev->vendor, pdev->device))
drivers/pci/pci-driver.c:	if (add_uevent_var(env, "PCI_SUBSYS_ID=%04X:%04X", pdev->subsystem_vendor,
drivers/pci/pci-driver.c:			   pdev->subsystem_device))
drivers/pci/pci-driver.c:			   pdev->vendor, pdev->device,
drivers/pci/pci-driver.c:			   pdev->subsystem_vendor, pdev->subsystem_device,
drivers/pci/pci-driver.c:			   (u8)(pdev->class >> 16), (u8)(pdev->class >> 8),
drivers/pci/pci-driver.c:			   (u8)(pdev->class)))
drivers/pci/quirks.c:	if (pdev->revision != 0x04)		/* Only C0 requires this */
drivers/pci/quirks.c:		dev_info(&pdev->dev, "C0 revision 450NX. Disabling PCI restreaming\n");
drivers/pci/quirks.c:		pdev->class = PCI_CLASS_STORAGE_SATA_AHCI;
drivers/pci/quirks.c:		dev_info(&pdev->dev, "set SATA to AHCI mode\n");
drivers/pci/quirks.c:		pdev->class &= ~5;
drivers/pci/quirks.c:		dev_info(&pdev->dev, "IDE mode mismatch; forcing legacy mode\n");
drivers/pci/quirks.c:		pdev->class &= ~5;
drivers/pci/quirks.c:	pdev->dev_flags |= PCI_DEV_FLAGS_NO_D3;
drivers/pci/quirks.c:	if (PCI_FUNC(pdev->devfn))
drivers/pci/quirks.c:	switch (pdev->device) {
drivers/pci/quirks.c:	pdev->hdr_type = hdr & 0x7f;
drivers/pci/quirks.c:	pdev->multifunction = !!(hdr & 0x80);
drivers/pci/quirks.c:	pdev->class = class >> 8;
drivers/pci/quirks.c:	if ((pdev->class >> 8) != 0xff00)
drivers/pci/quirks.c:		insert_resource(&iomem_resource, &pdev->resource[0]);
drivers/pci/quirks.c:		memset(&pdev->resource[i], 0, sizeof(pdev->resource[i]));
drivers/pci/quirks.c:	pdev->no_msi = 1;
drivers/pci/hotplug/shpchp_hpc.c:	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
drivers/pci/hotplug/shpchp_hpc.c:	    pdev->device == PCI_DEVICE_ID_AMD_GOLAM_7450) {
drivers/pci/hotplug/shpchp_hpc.c:		  pdev->vendor, pdev->device, pdev->subsystem_vendor,
drivers/pci/hotplug/shpchp_hpc.c:		  pdev->subsystem_device);
drivers/pci/hotplug/shpchp_hpc.c:	ctrl_dbg(ctrl, "HPC at %s irq=%x\n", pci_name(pdev), pdev->irq);
drivers/pci/hotplug/acpi_pcihp.c:	handle = DEVICE_ACPI_HANDLE(&pdev->dev);
drivers/pci/hotplug/acpi_pcihp.c:		for (pbus = pdev->bus; pbus; pbus = pbus->parent) {
drivers/pci/hotplug/pciehp_acpi.c:	handle = DEVICE_ACPI_HANDLE(&pdev->dev);
drivers/pci/hotplug/shpchp_sysfs.c:	bus = pdev->subordinate;
drivers/pci/hotplug/cpqphp_core.c:	bus = pdev->subordinate;
drivers/pci/hotplug/cpqphp_core.c:		dev_notice(&pdev->dev, "the device is not a bridge, "
drivers/pci/hotplug/cpqphp_core.c:	vendor_id = pdev->vendor;
drivers/pci/hotplug/cpqphp_core.c:	dbg("revision: %d\n", pdev->revision);
drivers/pci/hotplug/cpqphp_core.c:	if ((vendor_id == PCI_VENDOR_ID_COMPAQ) && (!pdev->revision)) {
drivers/pci/hotplug/cpqphp_core.c:	if ((pdev->revision <= 2) && (vendor_id != PCI_VENDOR_ID_INTEL)) {
drivers/pci/hotplug/cpqphp_core.c:	subsystem_vid = pdev->subsystem_vendor;
drivers/pci/hotplug/cpqphp_core.c:	subsystem_deviceid = pdev->subsystem_device;
drivers/pci/hotplug/cpqphp_core.c:		if (pdev->revision >= 0x13) { /* CIOBX */
drivers/pci/hotplug/cpqphp_core.c:					pdev->bus->number);
drivers/pci/hotplug/cpqphp_core.c:	ctrl->pci_bus = kmemdup(pdev->bus, sizeof(*ctrl->pci_bus), GFP_KERNEL);
drivers/pci/hotplug/cpqphp_core.c:	ctrl->bus = pdev->bus->number;
drivers/pci/hotplug/cpqphp_core.c:	ctrl->rev = pdev->revision;
drivers/pci/hotplug/cpqphp_core.c:		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn), ctrl->rev);
drivers/pci/hotplug/cpqphp_core.c:	rc = get_slot_mapping(ctrl->pci_bus, pdev->bus->number,
drivers/pci/hotplug/cpqphp_core.c:	ctrl->interrupt = pdev->irq;
drivers/pci/hotplug/shpchp_core.c:		dev_err(&pdev->dev, "%s: Out of memory\n", __func__);
drivers/pci/hotplug/pciehp_hpc.c:		  pci_name(pdev), pdev->irq);
drivers/pci/hotplug/pciehp_hpc.c:	ctrl_info(ctrl, "  Vendor ID            : 0x%04x\n", pdev->vendor);
drivers/pci/hotplug/pciehp_hpc.c:	ctrl_info(ctrl, "  Device ID            : 0x%04x\n", pdev->device);
drivers/pci/hotplug/pciehp_hpc.c:		  pdev->subsystem_device);
drivers/pci/hotplug/pciehp_hpc.c:		  pdev->subsystem_vendor);
drivers/pci/hotplug/pciehp_hpc.c:			  i, &pdev->resource[i]);
drivers/pci/hotplug/pciehp_hpc.c:		  pdev->vendor, pdev->device, pdev->subsystem_vendor,
drivers/pci/hotplug/pciehp_hpc.c:		  pdev->subsystem_device);
drivers/pci/pci-label.c:	bus = pdev->bus->number;
drivers/pci/pci-label.c:	devfn = pdev->devfn;
drivers/pci/pci-label.c:	return sysfs_create_group(&pdev->dev.kobj, &smbios_attr_group);
drivers/pci/pci-label.c:	sysfs_remove_group(&pdev->dev.kobj, &smbios_attr_group);
drivers/pci/pci-label.c:	return sysfs_create_group(&pdev->dev.kobj, &acpi_attr_group);
drivers/pci/pci-label.c:	sysfs_remove_group(&pdev->dev.kobj, &acpi_attr_group);
drivers/pci/pci-label.c:	if (device_has_dsm(&pdev->dev))
drivers/pci/pci-label.c:	if (device_has_dsm(&pdev->dev))
drivers/pci/pci-sysfs.c:	return sprintf (buf, format_string, pdev->field);		\
drivers/pci/pci-sysfs.c:	return sprintf (buf, "%u\n", pdev->broken_parity_status);
drivers/pci/pci-sysfs.c:	pdev->broken_parity_status = !!val;
drivers/pci/pci-sysfs.c:	return sprintf (buf, "%u\n", atomic_read(&pdev->enable_cnt));
drivers/pci/pci-sysfs.c:	return sprintf (buf, "%d\n", fls64(pdev->dma_mask));
drivers/pci/pci-sysfs.c:	if (!pdev->subordinate)
drivers/pci/pci-sysfs.c:			!(pdev->subordinate->bus_flags & PCI_BUS_FLAGS_NO_MSI));
drivers/pci/pci-sysfs.c:	if (!pdev->subordinate)
drivers/pci/pci-sysfs.c:	if (!(pdev->subordinate->bus_flags & PCI_BUS_FLAGS_NO_MSI) ^
drivers/pci/pci-sysfs.c:		pdev->subordinate->bus_flags ^= PCI_BUS_FLAGS_NO_MSI;
drivers/pci/pci-sysfs.c:		dev_warn(&pdev->dev, "forced subordinate bus to%s support MSI,"
drivers/pci/pci-sysfs.c:		pci_rescan_bus(pdev->bus);
drivers/pci/pci-sysfs.c:	pdev->d3cold_allowed = !!val;
drivers/pci/pci-sysfs.c:	return sprintf (buf, "%u\n", pdev->d3cold_allowed);
drivers/pci/pci-sysfs.c:	return sprintf(buf, "%u\n", pdev->sriov->num_VFs);
drivers/pci/pci-sysfs.c:	if (num_vfs == pdev->sriov->num_VFs)
drivers/pci/pci-sysfs.c:	if (!pdev->driver || !pdev->driver->sriov_configure) {
drivers/pci/pci-sysfs.c:		dev_info(&pdev->dev, "Driver doesn't support SRIOV configuration via sysfs\n");
drivers/pci/pci-sysfs.c:		ret = pdev->driver->sriov_configure(pdev, 0);
drivers/pci/pci-sysfs.c:	if (pdev->sriov->num_VFs) {
drivers/pci/pci-sysfs.c:		dev_warn(&pdev->dev, "%d VFs already enabled. Disable before enabling %d VFs\n",
drivers/pci/pci-sysfs.c:			 pdev->sriov->num_VFs, num_vfs);
drivers/pci/pci-sysfs.c:	ret = pdev->driver->sriov_configure(pdev, num_vfs);
drivers/pci/pci-sysfs.c:		dev_warn(&pdev->dev, "%d VFs requested; only %d enabled\n",
drivers/pci/pci-sysfs.c:		!!(pdev->resource[PCI_ROM_RESOURCE].flags &
drivers/pci/pci-sysfs.c:		if (res == &pdev->resource[i])
drivers/pci/pci-sysfs.c:		if (res == &pdev->resource[i])
drivers/pci/pci-sysfs.c:		res_attr = pdev->res_attr[i];
drivers/pci/pci-sysfs.c:			sysfs_remove_bin_file(&pdev->dev.kobj, res_attr);
drivers/pci/pci-sysfs.c:		res_attr = pdev->res_attr_wc[i];
drivers/pci/pci-sysfs.c:			sysfs_remove_bin_file(&pdev->dev.kobj, res_attr);
drivers/pci/pci-sysfs.c:			pdev->res_attr_wc[num] = res_attr;
drivers/pci/pci-sysfs.c:			pdev->res_attr[num] = res_attr;
drivers/pci/pci-sysfs.c:		res_attr->private = &pdev->resource[num];
drivers/pci/pci-sysfs.c:		retval = sysfs_create_bin_file(&pdev->dev.kobj, res_attr);
drivers/pci/pci-sysfs.c:		if (!retval && pdev->resource[i].flags & IORESOURCE_PREFETCH)
drivers/pci/pci-sysfs.c:		pdev->rom_attr_enabled = 0;
drivers/pci/pci-sysfs.c:		pdev->rom_attr_enabled = 1;
drivers/pci/pci-sysfs.c:	if (!pdev->rom_attr_enabled)
drivers/pci/pci-sysfs.c:	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
drivers/pci/pci-sysfs.c:		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pci_config_attr);
drivers/pci/pci-sysfs.c:		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pcie_config_attr);
drivers/pci/pci-sysfs.c:	else if (pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW)
drivers/pci/pci-sysfs.c:		retval = sysfs_create_bin_file(&pdev->dev.kobj, attr);
drivers/pci/pci-sysfs.c:		pdev->rom_attr = attr;
drivers/pci/pci-sysfs.c:		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
drivers/pci/pci-sysfs.c:		kfree(pdev->rom_attr);
drivers/pci/pci-sysfs.c:		pdev->rom_attr = NULL;
drivers/pci/pci-sysfs.c:	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
drivers/pci/pci-sysfs.c:		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
drivers/pci/pci-sysfs.c:		sysfs_remove_bin_file(&pdev->dev.kobj, &pcie_config_attr);
drivers/pci/pci-sysfs.c:	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
drivers/pci/pci-sysfs.c:		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
drivers/pci/pci-sysfs.c:		sysfs_remove_bin_file(&pdev->dev.kobj, &pcie_config_attr);
drivers/pci/pci-sysfs.c:	else if (pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW)
drivers/pci/pci-sysfs.c:	if (rom_size && pdev->rom_attr) {
drivers/pci/pci-sysfs.c:		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
drivers/pci/pci-sysfs.c:		kfree(pdev->rom_attr);
drivers/pci/pci-sysfs.c:		if ((pdev->class >> 8) != PCI_CLASS_DISPLAY_VGA)
drivers/pci/search.c:		if (pci_is_root_bus(pdev->bus))
drivers/pci/search.c:		pdev = pdev->bus->self;
drivers/pci/pcie/aer/aerdrv.c:	pos = pci_find_ext_capability(pdev->port, PCI_EXT_CAP_ID_ERR);
drivers/pci/pcie/aer/aerdrv.c:	pci_read_config_dword(pdev->port, pos + PCI_ERR_ROOT_STATUS, &status);
drivers/pci/pcie/aer/aerdrv.c:	pci_read_config_dword(pdev->port, pos + PCI_ERR_ROOT_ERR_SRC, &id);
drivers/pci/pcie/aer/aerdrv.c:	pci_write_config_dword(pdev->port, pos + PCI_ERR_ROOT_STATUS, status);
drivers/pci/pcie/aer/aer_inject.c:		aer_error_init(rperr, pci_domain_nr(rpdev->bus),
drivers/pci/pcie/aer/aer_inject.c:			       rpdev->bus->number, rpdev->devfn,
drivers/pci/pcie/aer/aer_inject.c:	ret = pci_bus_set_aer_ops(rpdev->bus);
drivers/pci/pcie/portdrv_pci.c:	info->d3cold_delay = max_t(unsigned int, pdev->d3cold_delay,
drivers/pci/pcie/portdrv_pci.c:	if (pdev->no_d3cold)
drivers/pci/pcie/portdrv_pci.c:	pci_walk_bus(pdev->subordinate, pci_dev_d3cold_info, &d3cold_info);
drivers/pci/pcie/portdrv_pci.c:	pdev->no_d3cold = d3cold_info.no_d3cold;
drivers/pci/pcie/portdrv_pci.c:	pdev->d3cold_delay = d3cold_info.d3cold_delay;
drivers/pci/pcie/portdrv_pci.c:	if (pdev->pme_poll)
drivers/pci/pcie/portdrv_pci.c:	pci_walk_bus(pdev->subordinate, pci_dev_pme_poll, &pme_poll);
drivers/pci/pcie/portdrv_core.c:	device->parent = &pdev->dev;
drivers/pci/pcie/aspm.c:	struct pci_bus *linkbus = link->pdev->subordinate;
drivers/pci/pcie/aspm.c:	struct pci_bus *linkbus = link->pdev->subordinate;
drivers/pci/pcie/aspm.c:	link->pdev->link_state = NULL;
drivers/pci/pcie/aspm.c:	list_for_each_entry(child, &pdev->subordinate->devices, bus_list) {
drivers/pci/pcie/aspm.c:		parent = pdev->bus->parent->self->link_state;
drivers/pci/pcie/aspm.c:	pdev->link_state = link;
drivers/pci/pcie/aspm.c:	if (!pci_is_pcie(pdev) || pdev->link_state)
drivers/pci/pcie/aspm.c:	    pdev->bus->self)
drivers/pci/pcie/aspm.c:	if (list_empty(&pdev->subordinate->devices))
drivers/pci/pcie/aspm.c:		struct pci_bus *linkbus = link->pdev->subordinate;
drivers/pci/pcie/aspm.c:	struct pci_dev *parent = pdev->bus->self;
drivers/pci/pcie/aspm.c:	if (!list_is_last(&pdev->bus_list, &parent->subordinate->devices))
drivers/pci/pcie/aspm.c:	struct pcie_link_state *link = pdev->link_state;
drivers/pci/pcie/aspm.c:	struct pcie_link_state *link = pdev->link_state;
drivers/pci/pcie/aspm.c:	struct pci_dev *parent = pdev->bus->self;
drivers/pci/pcie/aspm.c:	struct pcie_link_state *link, *root = pdev->link_state->root;
drivers/pci/pcie/aspm.c:	pcie_set_clkpm_nocheck(pdev->link_state, !!state);
drivers/pci/pcie/aspm.c:	struct pcie_link_state *link_state = pdev->link_state;
drivers/pci/pcie/aspm.c:		sysfs_add_file_to_group(&pdev->dev.kobj,
drivers/pci/pcie/aspm.c:		sysfs_add_file_to_group(&pdev->dev.kobj,
drivers/pci/pcie/aspm.c:	struct pcie_link_state *link_state = pdev->link_state;
drivers/pci/pcie/aspm.c:		sysfs_remove_file_from_group(&pdev->dev.kobj,
drivers/pci/pcie/aspm.c:		sysfs_remove_file_from_group(&pdev->dev.kobj,
drivers/memstick/host/r592.c:	host = memstick_alloc_host(sizeof(struct r592_device), &pdev->dev);
drivers/memstick/host/r592.c:	dev->irq = pdev->irq;
drivers/memstick/host/rtsx_pci_ms.c:	return &(host->pdev->dev);
drivers/memstick/host/rtsx_pci_ms.c:	struct pcr_handle *handle = pdev->dev.platform_data;
drivers/memstick/host/rtsx_pci_ms.c:	dev_dbg(&(pdev->dev),
drivers/memstick/host/rtsx_pci_ms.c:	msh = memstick_alloc_host(sizeof(*host), &pdev->dev);
drivers/memstick/host/rtsx_pci_ms.c:		dev_dbg(&(pdev->dev),
drivers/memstick/host/rtsx_pci_ms.c:	dev_dbg(&(pdev->dev),
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&host->chip->pdev->dev, "irq_status = %08x\n", irq_status);
drivers/memstick/host/jmb38x_ms.c:				dev_dbg(&host->chip->pdev->dev, "TPC_ERR\n");
drivers/memstick/host/jmb38x_ms.c:		dev_dbg(&host->chip->pdev->dev, "media changed\n");
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&host->chip->pdev->dev, "abort\n");
drivers/memstick/host/jmb38x_ms.c:			dev_dbg(&host->chip->pdev->dev, "tasklet req %d\n", rc);
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&host->chip->pdev->dev, "reset_req timeout\n");
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&host->chip->pdev->dev, "reset timeout\n");
drivers/memstick/host/jmb38x_ms.c:			dev_dbg(&host->chip->pdev->dev, "power on\n");
drivers/memstick/host/jmb38x_ms.c:			dev_dbg(&host->chip->pdev->dev, "power off\n");
drivers/memstick/host/jmb38x_ms.c:		dev_dbg(&host->chip->pdev->dev,
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&pdev->dev, "JMB38x: set PMOS0 val 0x%x\n", val);
drivers/memstick/host/jmb38x_ms.c:		dev_dbg(&pdev->dev, "JMB38x: set PMOS1 val 0x%x\n", val);
drivers/memstick/host/jmb38x_ms.c:	dev_dbg(&pdev->dev, "Clock Control by PCI config is disabled!\n");
drivers/memstick/host/jmb38x_ms.c:				  &jm->pdev->dev);
drivers/memstick/host/jmb38x_ms.c:	host->irq = jm->pdev->irq;
drivers/memstick/host/jmb38x_ms.c:		dev_dbg(&jm->pdev->dev, "interrupts off\n");
drivers/memstick/host/jmb38x_ms.c:		dev_dbg(&jm->pdev->dev, "host removed\n");
drivers/pwm/pwm-vt8500.c:	struct device_node *np = pdev->dev.of_node;
drivers/pwm/pwm-vt8500.c:		dev_err(&pdev->dev, "invalid devicetree node\n");
drivers/pwm/pwm-vt8500.c:	chip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);
drivers/pwm/pwm-vt8500.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/pwm/pwm-vt8500.c:	chip->chip.dev = &pdev->dev;
drivers/pwm/pwm-vt8500.c:	chip->clk = devm_clk_get(&pdev->dev, NULL);
drivers/pwm/pwm-vt8500.c:		dev_err(&pdev->dev, "clock source not specified\n");
drivers/pwm/pwm-vt8500.c:	chip->base = devm_ioremap_resource(&pdev->dev, r);
drivers/pwm/pwm-vt8500.c:		dev_err(&pdev->dev, "failed to prepare clock\n");
drivers/pwm/pwm-vt8500.c:		dev_err(&pdev->dev, "failed to add PWM chip\n");
drivers/pwm/pwm-samsung.c:#define pwm_dbg(_pwm, msg...) dev_dbg(&(_pwm)->pdev->dev, msg)
drivers/pwm/pwm-samsung.c:	struct device *dev = &pdev->dev;
drivers/pwm/pwm-samsung.c:	unsigned int id = pdev->id;
drivers/pwm/pwm-samsung.c:	s3c = devm_kzalloc(&pdev->dev, sizeof(*s3c), GFP_KERNEL);
drivers/pwm/pwm-samsung.c:	s3c->chip.dev = &pdev->dev;
drivers/pwm/pwm-spear.c:	struct device_node *np = pdev->dev.of_node;
drivers/pwm/pwm-spear.c:		dev_err(&pdev->dev, "no memory resources defined\n");
drivers/pwm/pwm-spear.c:	pc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);
drivers/pwm/pwm-spear.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/pwm/pwm-spear.c:	pc->mmio_base = devm_ioremap_resource(&pdev->dev, r);
drivers/pwm/pwm-spear.c:	pc->clk = devm_clk_get(&pdev->dev, NULL);
drivers/pwm/pwm-spear.c:	pc->chip.dev = &pdev->dev;
drivers/pwm/pwm-spear.c:		dev_err(&pdev->dev, "pwmchip_add() failed: %d\n", ret);
drivers/pwm/pwm-pxa.c:	pwm = devm_kzalloc(&pdev->dev, sizeof(*pwm), GFP_KERNEL);
drivers/pwm/pwm-pxa.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/pwm/pwm-pxa.c:	pwm->clk = devm_clk_get(&pdev->dev, NULL);
drivers/pwm/pwm-pxa.c:	pwm->chip.dev = &pdev->dev;
drivers/pwm/pwm-pxa.c:	pwm->mmio_base = devm_ioremap_resource(&pdev->dev, r);
drivers/pwm/pwm-pxa.c:		dev_err(&pdev->dev, "pwmchip_add() failed: %d\n", ret);
drivers/pwm/pwm-lpc32xx.c:	lpc32xx = devm_kzalloc(&pdev->dev, sizeof(*lpc32xx), GFP_KERNEL);
drivers/pwm/pwm-lpc32xx.c:	lpc32xx->base = devm_ioremap_resource(&pdev->dev, res);
drivers/pwm/pwm-lpc32xx.c:	lpc32xx->clk = devm_clk_get(&pdev->dev, NULL);
drivers/pwm/pwm-lpc32xx.c:	lpc32xx->chip.dev = &pdev->dev;
drivers/pwm/pwm-lpc32xx.c:		dev_err(&pdev->dev, "failed to add PWM chip, error %d\n", ret);
drivers/pwm/pwm-mxs.c:	struct device_node *np = pdev->dev.of_node;
drivers/pwm/pwm-mxs.c:	mxs = devm_kzalloc(&pdev->dev, sizeof(*mxs), GFP_KERNEL);
drivers/pwm/pwm-mxs.c:	mxs->base = devm_ioremap_resource(&pdev->dev, res);
drivers/pwm/pwm-mxs.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/pwm/pwm-mxs.c:	mxs->clk = devm_clk_get(&pdev->dev, NULL);
drivers/pwm/pwm-mxs.c:	mxs->chip.dev = &pdev->dev;
drivers/pwm/pwm-mxs.c:		dev_err(&pdev->dev, "failed to get pwm number: %d\n", ret);
drivers/pwm/pwm-mxs.c:		dev_err(&pdev->dev, "failed to add pwm chip %d\n", ret);
drivers/pwm/pwm-ab8500.c:	ab8500 = devm_kzalloc(&pdev->dev, sizeof(*ab8500), GFP_KERNEL);
drivers/pwm/pwm-ab8500.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/pwm/pwm-ab8500.c:	ab8500->chip.dev = &pdev->dev;
drivers/pwm/pwm-ab8500.c:	ab8500->chip.base = pdev->id;
drivers/pwm/pwm-ab8500.c:	dev_dbg(&pdev->dev, "pwm probe successful\n");
drivers/pwm/pwm-ab8500.c:	dev_dbg(&pdev->dev, "pwm driver removed\n");
drivers/pwm/pwm-atmel-tcb.c:	struct device_node *np = pdev->dev.of_node;
drivers/pwm/pwm-atmel-tcb.c:		dev_err(&pdev->dev,
drivers/pwm/pwm-atmel-tcb.c:		dev_err(&pdev->dev, "failed to allocate Timer Counter Block\n");
drivers/pwm/pwm-atmel-tcb.c:	tcbpwm = devm_kzalloc(&pdev->dev, sizeof(*tcbpwm), GFP_KERNEL);
drivers/pwm/pwm-atmel-tcb.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/pwm/pwm-atmel-tcb.c:	tcbpwm->chip.dev = &pdev->dev;
drivers/pwm/pwm-bfin.c:	pwm = devm_kzalloc(&pdev->dev, sizeof(*pwm), GFP_KERNEL);
drivers/pwm/pwm-bfin.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/pwm/pwm-bfin.c:	pwm->chip.dev = &pdev->dev;
drivers/pwm/pwm-bfin.c:		dev_err(&pdev->dev, "pwmchip_add() failed: %d\n", ret);
drivers/pwm/pwm-tegra.c:	pwm = devm_kzalloc(&pdev->dev, sizeof(*pwm), GFP_KERNEL);
drivers/pwm/pwm-tegra.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/pwm/pwm-tegra.c:	pwm->dev = &pdev->dev;
drivers/pwm/pwm-tegra.c:	pwm->mmio_base = devm_ioremap_resource(&pdev->dev, r);
drivers/pwm/pwm-tegra.c:	pwm->clk = devm_clk_get(&pdev->dev, NULL);
drivers/pwm/pwm-tegra.c:	pwm->chip.dev = &pdev->dev;
drivers/pwm/pwm-tegra.c:		dev_err(&pdev->dev, "pwmchip_add() failed: %d\n", ret);
drivers/pwm/pwm-tiehrpwm.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/pwm/pwm-tiehrpwm.c:		dev_warn(&pdev->dev, "unable to select pin group\n");
drivers/pwm/pwm-tiehrpwm.c:	pc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);
drivers/pwm/pwm-tiehrpwm.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/pwm/pwm-tiehrpwm.c:	clk = devm_clk_get(&pdev->dev, "fck");
drivers/pwm/pwm-tiehrpwm.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/pwm/pwm-tiehrpwm.c:		dev_err(&pdev->dev, "failed to get clock rate\n");
drivers/pwm/pwm-tiehrpwm.c:	pc->chip.dev = &pdev->dev;
drivers/pwm/pwm-tiehrpwm.c:	pc->mmio_base = devm_ioremap_resource(&pdev->dev, r);
drivers/pwm/pwm-tiehrpwm.c:	pc->tbclk = devm_clk_get(&pdev->dev, "tbclk");
drivers/pwm/pwm-tiehrpwm.c:		dev_err(&pdev->dev, "Failed to get tbclk\n");
drivers/pwm/pwm-tiehrpwm.c:		dev_err(&pdev->dev, "pwmchip_add() failed: %d\n", ret);
drivers/pwm/pwm-tiehrpwm.c:	pm_runtime_enable(&pdev->dev);
drivers/pwm/pwm-tiehrpwm.c:	pm_runtime_get_sync(&pdev->dev);
drivers/pwm/pwm-tiehrpwm.c:	status = pwmss_submodule_state_change(pdev->dev.parent,
drivers/pwm/pwm-tiehrpwm.c:		dev_err(&pdev->dev, "PWMSS config space clock enable failed\n");
drivers/pwm/pwm-tiehrpwm.c:	pm_runtime_put_sync(&pdev->dev);
drivers/pwm/pwm-tiehrpwm.c:	pm_runtime_put_sync(&pdev->dev);
drivers/pwm/pwm-tiehrpwm.c:	pm_runtime_disable(&pdev->dev);
drivers/pwm/pwm-tiehrpwm.c:	pm_runtime_get_sync(&pdev->dev);
drivers/pwm/pwm-tiehrpwm.c:	pwmss_submodule_state_change(pdev->dev.parent, PWMSS_EPWMCLK_STOP_REQ);
drivers/pwm/pwm-tiehrpwm.c:	pm_runtime_put_sync(&pdev->dev);
drivers/pwm/pwm-tiehrpwm.c:	pm_runtime_put_sync(&pdev->dev);
drivers/pwm/pwm-tiehrpwm.c:	pm_runtime_disable(&pdev->dev);
drivers/pwm/pwm-imx.c:			of_match_device(imx_pwm_dt_ids, &pdev->dev);
drivers/pwm/pwm-imx.c:	imx = devm_kzalloc(&pdev->dev, sizeof(*imx), GFP_KERNEL);
drivers/pwm/pwm-imx.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/pwm/pwm-imx.c:	imx->clk_per = devm_clk_get(&pdev->dev, "per");
drivers/pwm/pwm-imx.c:		dev_err(&pdev->dev, "getting per clock failed with %ld\n",
drivers/pwm/pwm-imx.c:	imx->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
drivers/pwm/pwm-imx.c:		dev_err(&pdev->dev, "getting ipg clock failed with %ld\n",
drivers/pwm/pwm-imx.c:	imx->chip.dev = &pdev->dev;
drivers/pwm/pwm-imx.c:	imx->mmio_base = devm_ioremap_resource(&pdev->dev, r);
drivers/pwm/pwm-twl-led.c:	twl = devm_kzalloc(&pdev->dev, sizeof(*twl), GFP_KERNEL);
drivers/pwm/pwm-twl-led.c:	twl->chip.dev = &pdev->dev;
drivers/pwm/pwm-tiecap.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/pwm/pwm-tiecap.c:		dev_warn(&pdev->dev, "unable to select pin group\n");
drivers/pwm/pwm-tiecap.c:	pc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);
drivers/pwm/pwm-tiecap.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/pwm/pwm-tiecap.c:	clk = devm_clk_get(&pdev->dev, "fck");
drivers/pwm/pwm-tiecap.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/pwm/pwm-tiecap.c:		dev_err(&pdev->dev, "failed to get clock rate\n");
drivers/pwm/pwm-tiecap.c:	pc->chip.dev = &pdev->dev;
drivers/pwm/pwm-tiecap.c:	pc->mmio_base = devm_ioremap_resource(&pdev->dev, r);
drivers/pwm/pwm-tiecap.c:		dev_err(&pdev->dev, "pwmchip_add() failed: %d\n", ret);
drivers/pwm/pwm-tiecap.c:	pm_runtime_enable(&pdev->dev);
drivers/pwm/pwm-tiecap.c:	pm_runtime_get_sync(&pdev->dev);
drivers/pwm/pwm-tiecap.c:	status = pwmss_submodule_state_change(pdev->dev.parent,
drivers/pwm/pwm-tiecap.c:		dev_err(&pdev->dev, "PWMSS config space clock enable failed\n");
drivers/pwm/pwm-tiecap.c:	pm_runtime_put_sync(&pdev->dev);
drivers/pwm/pwm-tiecap.c:	pm_runtime_put_sync(&pdev->dev);
drivers/pwm/pwm-tiecap.c:	pm_runtime_disable(&pdev->dev);
drivers/pwm/pwm-tiecap.c:	pm_runtime_get_sync(&pdev->dev);
drivers/pwm/pwm-tiecap.c:	pwmss_submodule_state_change(pdev->dev.parent, PWMSS_ECAPCLK_STOP_REQ);
drivers/pwm/pwm-tiecap.c:	pm_runtime_put_sync(&pdev->dev);
drivers/pwm/pwm-tiecap.c:	pm_runtime_put_sync(&pdev->dev);
drivers/pwm/pwm-tiecap.c:	pm_runtime_disable(&pdev->dev);
drivers/pwm/pwm-jz4740.c:	jz4740 = devm_kzalloc(&pdev->dev, sizeof(*jz4740), GFP_KERNEL);
drivers/pwm/pwm-jz4740.c:	jz4740->chip.dev = &pdev->dev;
drivers/pwm/pwm-twl.c:	twl = devm_kzalloc(&pdev->dev, sizeof(*twl), GFP_KERNEL);
drivers/pwm/pwm-twl.c:	twl->chip.dev = &pdev->dev;
drivers/pwm/pwm-puv3.c:	puv3 = devm_kzalloc(&pdev->dev, sizeof(*puv3), GFP_KERNEL);
drivers/pwm/pwm-puv3.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/pwm/pwm-puv3.c:	puv3->clk = devm_clk_get(&pdev->dev, "OST_CLK");
drivers/pwm/pwm-puv3.c:	puv3->base = devm_ioremap_resource(&pdev->dev, r);
drivers/pwm/pwm-puv3.c:	puv3->chip.dev = &pdev->dev;
drivers/pwm/pwm-puv3.c:		dev_err(&pdev->dev, "pwmchip_add() failed: %d\n", ret);
drivers/pwm/pwm-tipwmss.c:	struct device_node *node = pdev->dev.of_node;
drivers/pwm/pwm-tipwmss.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
drivers/pwm/pwm-tipwmss.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/pwm/pwm-tipwmss.c:	info->mmio_base = devm_ioremap_resource(&pdev->dev, r);
drivers/pwm/pwm-tipwmss.c:	pm_runtime_enable(&pdev->dev);
drivers/pwm/pwm-tipwmss.c:	pm_runtime_get_sync(&pdev->dev);
drivers/pwm/pwm-tipwmss.c:	ret = of_platform_populate(node, NULL, NULL, &pdev->dev);
drivers/pwm/pwm-tipwmss.c:		dev_err(&pdev->dev, "no child node found\n");
drivers/pwm/pwm-tipwmss.c:	pm_runtime_put_sync(&pdev->dev);
drivers/pwm/pwm-tipwmss.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-bcm2835.c:	master = spi_alloc_master(&pdev->dev, sizeof(*bs));
drivers/spi/spi-bcm2835.c:		dev_err(&pdev->dev, "spi_alloc_master() failed\n");
drivers/spi/spi-bcm2835.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-bcm2835.c:		dev_err(&pdev->dev, "could not get memory resource\n");
drivers/spi/spi-bcm2835.c:	bs->regs = devm_request_and_ioremap(&pdev->dev, res);
drivers/spi/spi-bcm2835.c:		dev_err(&pdev->dev, "could not request/map memory region\n");
drivers/spi/spi-bcm2835.c:	bs->clk = devm_clk_get(&pdev->dev, NULL);
drivers/spi/spi-bcm2835.c:		dev_err(&pdev->dev, "could not get clk: %d\n", err);
drivers/spi/spi-bcm2835.c:	bs->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
drivers/spi/spi-bcm2835.c:		dev_err(&pdev->dev, "could not get IRQ: %d\n", bs->irq);
drivers/spi/spi-bcm2835.c:			dev_name(&pdev->dev), master);
drivers/spi/spi-bcm2835.c:		dev_err(&pdev->dev, "could not request IRQ: %d\n", err);
drivers/spi/spi-bcm2835.c:		dev_err(&pdev->dev, "could not register SPI master: %d\n", err);
drivers/spi/spi-coldfire-qspi.c:	master = spi_alloc_master(&pdev->dev, sizeof(*mcfqspi));
drivers/spi/spi-coldfire-qspi.c:		dev_dbg(&pdev->dev, "spi_alloc_master failed\n");
drivers/spi/spi-coldfire-qspi.c:		dev_dbg(&pdev->dev, "platform_get_resource failed\n");
drivers/spi/spi-coldfire-qspi.c:	if (!request_mem_region(res->start, resource_size(res), pdev->name)) {
drivers/spi/spi-coldfire-qspi.c:		dev_dbg(&pdev->dev, "request_mem_region failed\n");
drivers/spi/spi-coldfire-qspi.c:		dev_dbg(&pdev->dev, "ioremap failed\n");
drivers/spi/spi-coldfire-qspi.c:		dev_dbg(&pdev->dev, "platform_get_irq failed\n");
drivers/spi/spi-coldfire-qspi.c:			     pdev->name, mcfqspi);
drivers/spi/spi-coldfire-qspi.c:		dev_dbg(&pdev->dev, "request_irq failed\n");
drivers/spi/spi-coldfire-qspi.c:	mcfqspi->clk = clk_get(&pdev->dev, "qspi_clk");
drivers/spi/spi-coldfire-qspi.c:		dev_dbg(&pdev->dev, "clk_get failed\n");
drivers/spi/spi-coldfire-qspi.c:	pdata = pdev->dev.platform_data;
drivers/spi/spi-coldfire-qspi.c:		dev_dbg(&pdev->dev, "platform data is missing\n");
drivers/spi/spi-coldfire-qspi.c:		dev_dbg(&pdev->dev, "error initializing cs_control\n");
drivers/spi/spi-coldfire-qspi.c:	mcfqspi->dev = &pdev->dev;
drivers/spi/spi-coldfire-qspi.c:		dev_dbg(&pdev->dev, "spi_register_master failed\n");
drivers/spi/spi-coldfire-qspi.c:	dev_info(&pdev->dev, "Coldfire QSPI bus driver\n");
drivers/spi/spi-coldfire-qspi.c:	dev_dbg(&pdev->dev, "Coldfire QSPI probe failed\n");
drivers/spi/spi-clps711x.c:	struct spi_clps711x_pdata *pdata = dev_get_platdata(&pdev->dev);
drivers/spi/spi-clps711x.c:		dev_err(&pdev->dev, "No platform data supplied\n");
drivers/spi/spi-clps711x.c:		dev_err(&pdev->dev, "At least one CS must be defined\n");
drivers/spi/spi-clps711x.c:	master = spi_alloc_master(&pdev->dev,
drivers/spi/spi-clps711x.c:		dev_err(&pdev->dev, "SPI allocating memory error\n");
drivers/spi/spi-clps711x.c:	master->bus_num = pdev->id;
drivers/spi/spi-clps711x.c:			dev_err(&pdev->dev, "Invalid CS GPIO %i\n", i);
drivers/spi/spi-clps711x.c:			dev_err(&pdev->dev, "Can't get CS GPIO %i\n", i);
drivers/spi/spi-clps711x.c:	hw->spi_clk = devm_clk_get(&pdev->dev, "spi");
drivers/spi/spi-clps711x.c:		dev_err(&pdev->dev, "Can't get clocks\n");
drivers/spi/spi-clps711x.c:	ret = devm_request_irq(&pdev->dev, IRQ_SSEOTI, spi_clps711x_isr, 0,
drivers/spi/spi-clps711x.c:			       dev_name(&pdev->dev), hw);
drivers/spi/spi-clps711x.c:		dev_err(&pdev->dev, "Can't request IRQ\n");
drivers/spi/spi-clps711x.c:		dev_info(&pdev->dev,
drivers/spi/spi-clps711x.c:	dev_err(&pdev->dev, "Failed to register master\n");
drivers/spi/spi-clps711x.c:	devm_free_irq(&pdev->dev, IRQ_SSEOTI, hw);
drivers/spi/spi-clps711x.c:	devm_clk_put(&pdev->dev, hw->spi_clk);
drivers/spi/spi-clps711x.c:	devm_free_irq(&pdev->dev, IRQ_SSEOTI, hw);
drivers/spi/spi-clps711x.c:	devm_clk_put(&pdev->dev, hw->spi_clk);
drivers/spi/spi-gpio.c:	struct device_node *np = pdev->dev.of_node;
drivers/spi/spi-gpio.c:			of_match_device(spi_gpio_dt_ids, &pdev->dev);
drivers/spi/spi-gpio.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/spi/spi-gpio.c:		dev_err(&pdev->dev, "gpio-sck property not found\n");
drivers/spi/spi-gpio.c:		dev_info(&pdev->dev, "gpio-miso property not found, switching to no-rx mode\n");
drivers/spi/spi-gpio.c:		dev_info(&pdev->dev, "gpio-mosi property not found, switching to no-tx mode\n");
drivers/spi/spi-gpio.c:		dev_err(&pdev->dev, "num-chipselects property not found\n");
drivers/spi/spi-gpio.c:	pdev->dev.platform_data = pdata;
drivers/spi/spi-gpio.c:	devm_kfree(&pdev->dev, pdata);
drivers/spi/spi-gpio.c:	pdata = pdev->dev.platform_data;
drivers/spi/spi-gpio.c:	status = spi_gpio_request(pdata, dev_name(&pdev->dev), &master_flags);
drivers/spi/spi-gpio.c:	master = spi_alloc_master(&pdev->dev, sizeof(*spi_gpio) +
drivers/spi/spi-gpio.c:	master->bus_num = pdev->id;
drivers/spi/spi-gpio.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-gpio.c:		struct device_node *np = pdev->dev.of_node;
drivers/spi/spi-gpio.c:	pdata = pdev->dev.platform_data;
drivers/spi/spi-ath79.c:	master = spi_alloc_master(&pdev->dev, sizeof(*sp));
drivers/spi/spi-ath79.c:		dev_err(&pdev->dev, "failed to allocate spi master\n");
drivers/spi/spi-ath79.c:	pdata = pdev->dev.platform_data;
drivers/spi/spi-ath79.c:	sp->clk = clk_get(&pdev->dev, "ahb");
drivers/spi/spi-ath79.c:	dev_dbg(&pdev->dev, "register read/write delay is %u nsecs\n",
drivers/spi/spi-davinci.c:	struct device_node *node = pdev->dev.of_node;
drivers/spi/spi-davinci.c:				&pdev->dev);
drivers/spi/spi-davinci.c:	master = spi_alloc_master(&pdev->dev, sizeof(struct davinci_spi));
drivers/spi/spi-davinci.c:	dev_set_drvdata(&pdev->dev, master);
drivers/spi/spi-davinci.c:	if (pdev->dev.platform_data) {
drivers/spi/spi-davinci.c:		pdata = pdev->dev.platform_data;
drivers/spi/spi-davinci.c:	mem = request_mem_region(r->start, resource_size(r), pdev->name);
drivers/spi/spi-davinci.c:				 0, dev_name(&pdev->dev), dspi);
drivers/spi/spi-davinci.c:	dspi->clk = clk_get(&pdev->dev, NULL);
drivers/spi/spi-davinci.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-davinci.c:	master->bus_num = pdev->id;
drivers/spi/spi-davinci.c:		dev_info(&pdev->dev, "DMA: supported\n");
drivers/spi/spi-davinci.c:		dev_info(&pdev->dev, "DMA: RX channel: %d, TX channel: %d, "
drivers/spi/spi-davinci.c:	dev_info(&pdev->dev, "Controller at 0x%p\n", dspi->base);
drivers/spi/spi-davinci.c:	master = dev_get_drvdata(&pdev->dev);
drivers/spi/spi-tegra20-slink.c:	match = of_match_device(tegra_slink_of_match, &pdev->dev);
drivers/spi/spi-tegra20-slink.c:		dev_err(&pdev->dev, "Error: No device match found\n");
drivers/spi/spi-tegra20-slink.c:	master = spi_alloc_master(&pdev->dev, sizeof(*tspi));
drivers/spi/spi-tegra20-slink.c:		dev_err(&pdev->dev, "master allocation failed\n");
drivers/spi/spi-tegra20-slink.c:	dev_set_drvdata(&pdev->dev, master);
drivers/spi/spi-tegra20-slink.c:	tspi->dev = &pdev->dev;
drivers/spi/spi-tegra20-slink.c:		dev_err(&pdev->dev, "No IO memory resource\n");
drivers/spi/spi-tegra20-slink.c:	tspi->base = devm_ioremap_resource(&pdev->dev, r);
drivers/spi/spi-tegra20-slink.c:			dev_name(&pdev->dev), tspi);
drivers/spi/spi-tegra20-slink.c:		dev_err(&pdev->dev, "Failed to register ISR for IRQ %d\n",
drivers/spi/spi-tegra20-slink.c:	tspi->clk = devm_clk_get(&pdev->dev, NULL);
drivers/spi/spi-tegra20-slink.c:		dev_err(&pdev->dev, "can not get clock\n");
drivers/spi/spi-tegra20-slink.c:			dev_err(&pdev->dev, "RxDma Init failed, err %d\n", ret);
drivers/spi/spi-tegra20-slink.c:			dev_err(&pdev->dev, "TxDma Init failed, err %d\n", ret);
drivers/spi/spi-tegra20-slink.c:	pm_runtime_enable(&pdev->dev);
drivers/spi/spi-tegra20-slink.c:	if (!pm_runtime_enabled(&pdev->dev)) {
drivers/spi/spi-tegra20-slink.c:		ret = tegra_slink_runtime_resume(&pdev->dev);
drivers/spi/spi-tegra20-slink.c:	ret = pm_runtime_get_sync(&pdev->dev);
drivers/spi/spi-tegra20-slink.c:		dev_err(&pdev->dev, "pm runtime get failed, e = %d\n", ret);
drivers/spi/spi-tegra20-slink.c:	pm_runtime_put(&pdev->dev);
drivers/spi/spi-tegra20-slink.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-tegra20-slink.c:		dev_err(&pdev->dev, "can not register to master err %d\n", ret);
drivers/spi/spi-tegra20-slink.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-tegra20-slink.c:	if (!pm_runtime_status_suspended(&pdev->dev))
drivers/spi/spi-tegra20-slink.c:		tegra_slink_runtime_suspend(&pdev->dev);
drivers/spi/spi-tegra20-slink.c:	struct spi_master *master = dev_get_drvdata(&pdev->dev);
drivers/spi/spi-tegra20-slink.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-tegra20-slink.c:	if (!pm_runtime_status_suspended(&pdev->dev))
drivers/spi/spi-tegra20-slink.c:		tegra_slink_runtime_suspend(&pdev->dev);
drivers/spi/spi-mxs.c:			of_match_device(mxs_spi_dt_ids, &pdev->dev);
drivers/spi/spi-mxs.c:	struct device_node *np = pdev->dev.of_node;
drivers/spi/spi-mxs.c:	base = devm_ioremap_resource(&pdev->dev, iores);
drivers/spi/spi-mxs.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/spi/spi-mxs.c:	clk = devm_clk_get(&pdev->dev, NULL);
drivers/spi/spi-mxs.c:	master = spi_alloc_master(&pdev->dev, sizeof(*spi));
drivers/spi/spi-mxs.c:	ssp->dev = &pdev->dev;
drivers/spi/spi-mxs.c:	ret = devm_request_irq(&pdev->dev, irq_err, mxs_ssp_irq_handler, 0,
drivers/spi/spi-mxs.c:	ssp->dmach = dma_request_slave_channel(&pdev->dev, "rx-tx");
drivers/spi/spi-mxs.c:		dev_err(&pdev->dev, "Cannot register SPI master, %d\n", ret);
drivers/spi/spi-rspi.c:	struct rspi_plat_data *rspi_pd = pdev->dev.platform_data;
drivers/spi/spi-rspi.c:				dev_info(&pdev->dev, "Use DMA when rx.\n");
drivers/spi/spi-rspi.c:				dev_info(&pdev->dev, "Use DMA when tx\n");
drivers/spi/spi-rspi.c:	struct rspi_data *rspi = dev_get_drvdata(&pdev->dev);
drivers/spi/spi-rspi.c:		dev_err(&pdev->dev, "invalid resource\n");
drivers/spi/spi-rspi.c:		dev_err(&pdev->dev, "platform_get_irq error\n");
drivers/spi/spi-rspi.c:	master = spi_alloc_master(&pdev->dev, sizeof(struct rspi_data));
drivers/spi/spi-rspi.c:		dev_err(&pdev->dev, "spi_alloc_master error.\n");
drivers/spi/spi-rspi.c:	dev_set_drvdata(&pdev->dev, rspi);
drivers/spi/spi-rspi.c:		dev_err(&pdev->dev, "ioremap error.\n");
drivers/spi/spi-rspi.c:	snprintf(clk_name, sizeof(clk_name), "rspi%d", pdev->id);
drivers/spi/spi-rspi.c:	rspi->clk = clk_get(&pdev->dev, clk_name);
drivers/spi/spi-rspi.c:		dev_err(&pdev->dev, "cannot get clock\n");
drivers/spi/spi-rspi.c:	master->bus_num = pdev->id;
drivers/spi/spi-rspi.c:	ret = request_irq(irq, rspi_irq, 0, dev_name(&pdev->dev), rspi);
drivers/spi/spi-rspi.c:		dev_err(&pdev->dev, "request_irq error\n");
drivers/spi/spi-rspi.c:		dev_err(&pdev->dev, "rspi_request_dma failed.\n");
drivers/spi/spi-rspi.c:		dev_err(&pdev->dev, "spi_register_master error.\n");
drivers/spi/spi-rspi.c:	dev_info(&pdev->dev, "probed\n");
drivers/spi/spi-pxa2xx-pxadma.c:	dev_err(&drv_data->pdev->dev, "%s\n", msg);
drivers/spi/spi-pxa2xx-pxadma.c:		dev_err(&drv_data->pdev->dev,
drivers/spi/spi-pxa2xx-pxadma.c:		dev_err(&drv_data->pdev->dev,
drivers/spi/spi-pxa2xx-pxadma.c:			dev_err(&drv_data->pdev->dev,
drivers/spi/spi-pxa2xx-pxadma.c:	struct device *dev = &drv_data->pdev->dev;
drivers/spi/spi-tegra20-sflash.c:	match = of_match_device(tegra_sflash_of_match, &pdev->dev);
drivers/spi/spi-tegra20-sflash.c:		dev_err(&pdev->dev, "Error: No device match found\n");
drivers/spi/spi-tegra20-sflash.c:	master = spi_alloc_master(&pdev->dev, sizeof(*tsd));
drivers/spi/spi-tegra20-sflash.c:		dev_err(&pdev->dev, "master allocation failed\n");
drivers/spi/spi-tegra20-sflash.c:	dev_set_drvdata(&pdev->dev, master);
drivers/spi/spi-tegra20-sflash.c:	tsd->dev = &pdev->dev;
drivers/spi/spi-tegra20-sflash.c:	tsd->base = devm_ioremap_resource(&pdev->dev, r);
drivers/spi/spi-tegra20-sflash.c:			dev_name(&pdev->dev), tsd);
drivers/spi/spi-tegra20-sflash.c:		dev_err(&pdev->dev, "Failed to register ISR for IRQ %d\n",
drivers/spi/spi-tegra20-sflash.c:	tsd->clk = devm_clk_get(&pdev->dev, NULL);
drivers/spi/spi-tegra20-sflash.c:		dev_err(&pdev->dev, "can not get clock\n");
drivers/spi/spi-tegra20-sflash.c:	pm_runtime_enable(&pdev->dev);
drivers/spi/spi-tegra20-sflash.c:	if (!pm_runtime_enabled(&pdev->dev)) {
drivers/spi/spi-tegra20-sflash.c:		ret = tegra_sflash_runtime_resume(&pdev->dev);
drivers/spi/spi-tegra20-sflash.c:	ret = pm_runtime_get_sync(&pdev->dev);
drivers/spi/spi-tegra20-sflash.c:		dev_err(&pdev->dev, "pm runtime get failed, e = %d\n", ret);
drivers/spi/spi-tegra20-sflash.c:	pm_runtime_put(&pdev->dev);
drivers/spi/spi-tegra20-sflash.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-tegra20-sflash.c:		dev_err(&pdev->dev, "can not register to master err %d\n", ret);
drivers/spi/spi-tegra20-sflash.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-tegra20-sflash.c:	if (!pm_runtime_status_suspended(&pdev->dev))
drivers/spi/spi-tegra20-sflash.c:		tegra_sflash_runtime_suspend(&pdev->dev);
drivers/spi/spi-tegra20-sflash.c:	struct spi_master *master = dev_get_drvdata(&pdev->dev);
drivers/spi/spi-tegra20-sflash.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-tegra20-sflash.c:	if (!pm_runtime_status_suspended(&pdev->dev))
drivers/spi/spi-tegra20-sflash.c:		tegra_sflash_runtime_suspend(&pdev->dev);
drivers/spi/spi-falcon.c:		dev_err(&pdev->dev, "invalid bootstrap options\n");
drivers/spi/spi-falcon.c:	master = spi_alloc_master(&pdev->dev, sizeof(*priv));
drivers/spi/spi-falcon.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-pxa2xx-dma.c:		dev_warn(&drv_data->pdev->dev, "DMA slave config failed\n");
drivers/spi/spi-pxa2xx-dma.c:		dev_warn(&drv_data->pdev->dev, "failed to DMA map TX\n");
drivers/spi/spi-pxa2xx-dma.c:		dev_warn(&drv_data->pdev->dev, "failed to DMA map RX\n");
drivers/spi/spi-pxa2xx-dma.c:		dev_err(&drv_data->pdev->dev, "FIFO overrun\n");
drivers/spi/spi-pxa2xx-dma.c:		dev_err(&drv_data->pdev->dev,
drivers/spi/spi-pxa2xx-dma.c:		dev_err(&drv_data->pdev->dev,
drivers/spi/spi-pxa2xx-dma.c:	drv_data->dummy = devm_kzalloc(&drv_data->pdev->dev, SZ_2K, GFP_KERNEL);
drivers/spi/spi-ep93xx.c:		dev_err(&espi->pdev->dev, "invalid bits per word %d\n",
drivers/spi/spi-ep93xx.c:		dev_dbg(&espi->pdev->dev, "initial setup for %s\n",
drivers/spi/spi-ep93xx.c:	dev_dbg(&espi->pdev->dev, "setup: mode %d, cpsr %d, scr %d, dss %d\n",
drivers/spi/spi-ep93xx.c:	dev_dbg(&espi->pdev->dev, "setup: cr0 %#x", cr0);
drivers/spi/spi-ep93xx.c:		dev_warn(&espi->pdev->dev, "len = %d expected 0!", len);
drivers/spi/spi-ep93xx.c:		dev_err(&espi->pdev->dev, "DMA RX failed: %ld\n", PTR_ERR(rxd));
drivers/spi/spi-ep93xx.c:		dev_err(&espi->pdev->dev, "DMA TX failed: %ld\n", PTR_ERR(rxd));
drivers/spi/spi-ep93xx.c:				dev_err(&espi->pdev->dev,
drivers/spi/spi-ep93xx.c:		dev_err(&espi->pdev->dev, "failed to enable SPI controller\n");
drivers/spi/spi-ep93xx.c:			dev_warn(&espi->pdev->dev,
drivers/spi/spi-ep93xx.c:		dev_warn(&espi->pdev->dev,
drivers/spi/spi-ep93xx.c:	info = pdev->dev.platform_data;
drivers/spi/spi-ep93xx.c:	master = spi_alloc_master(&pdev->dev, sizeof(*espi));
drivers/spi/spi-ep93xx.c:		dev_err(&pdev->dev, "failed to allocate spi master\n");
drivers/spi/spi-ep93xx.c:	master->bus_num = pdev->id;
drivers/spi/spi-ep93xx.c:	espi->clk = clk_get(&pdev->dev, NULL);
drivers/spi/spi-ep93xx.c:		dev_err(&pdev->dev, "unable to get spi clock\n");
drivers/spi/spi-ep93xx.c:		dev_err(&pdev->dev, "failed to get irq resources\n");
drivers/spi/spi-ep93xx.c:		dev_err(&pdev->dev, "unable to get iomem resource\n");
drivers/spi/spi-ep93xx.c:	espi->regs_base = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-ep93xx.c:	error = devm_request_irq(&pdev->dev, irq, ep93xx_spi_interrupt,
drivers/spi/spi-ep93xx.c:		dev_err(&pdev->dev, "failed to request irq\n");
drivers/spi/spi-ep93xx.c:		dev_warn(&pdev->dev, "DMA setup failed. Falling back to PIO\n");
drivers/spi/spi-ep93xx.c:		dev_err(&pdev->dev, "unable to create workqueue\n");
drivers/spi/spi-ep93xx.c:		dev_err(&pdev->dev, "failed to register SPI master\n");
drivers/spi/spi-ep93xx.c:	dev_info(&pdev->dev, "EP93xx SPI Controller at 0x%08lx irq %d\n",
drivers/spi/spi-bfin5xx.c:	dev_dbg(&drv_data->pdev->dev, "restoring spi ctl state\n");
drivers/spi/spi-bfin5xx.c:			dev_dbg(&drv_data->pdev->dev, "last read\n");
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev, "duplex: write_TDBR\n");
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev, "read: write_TDBR\n");
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev, "write: write_TDBR\n");
drivers/spi/spi-bfin5xx.c:	dev_dbg(&drv_data->pdev->dev,
drivers/spi/spi-bfin5xx.c:	dev_dbg(&drv_data->pdev->dev,
drivers/spi/spi-bfin5xx.c:			dev_warn(&drv_data->pdev->dev, "timeout waiting for SPIF");
drivers/spi/spi-bfin5xx.c:		dev_err(&drv_data->pdev->dev, "dma receive: fifo/buffer overflow\n");
drivers/spi/spi-bfin5xx.c:	dev_dbg(&drv_data->pdev->dev,
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev, "transfer: we've hit an error\n");
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev, "transfer: all done!\n");
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev, "transfer: still running ...\n");
drivers/spi/spi-bfin5xx.c:		dev_err(&drv_data->pdev->dev, "pump_transfers: flush failed\n");
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev, "tx_buf is %p, tx_end is %p\n",
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev, "rx_buf is %p, rx_end is %p\n",
drivers/spi/spi-bfin5xx.c:		dev_err(&drv_data->pdev->dev, "transfer: unsupported bits_per_word\n");
drivers/spi/spi-bfin5xx.c:	dev_dbg(&drv_data->pdev->dev,
drivers/spi/spi-bfin5xx.c:	dev_dbg(&drv_data->pdev->dev,
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev, "doing dma transfer\n");
drivers/spi/spi-bfin5xx.c:			dev_dbg(&drv_data->pdev->dev,
drivers/spi/spi-bfin5xx.c:			dev_dbg(&drv_data->pdev->dev, "doing DMA in to %p (size %zx)\n",
drivers/spi/spi-bfin5xx.c:			dev_dbg(&drv_data->pdev->dev, "doing DMA out.\n");
drivers/spi/spi-bfin5xx.c:	dev_dbg(&drv_data->pdev->dev, "doing IO transfer\n");
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev,
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev,
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev,
drivers/spi/spi-bfin5xx.c:		dev_dbg(&drv_data->pdev->dev,
drivers/spi/spi-bfin5xx.c:	dev_dbg(&drv_data->pdev->dev, "got a message to pump, "
drivers/spi/spi-bfin5xx.c:	dev_dbg(&drv_data->pdev->dev,
drivers/spi/spi-bfin5xx.c:	struct device *dev = &pdev->dev;
drivers/spi/spi-bfin5xx.c:		dev_err(&pdev->dev, "can not alloc spi_master\n");
drivers/spi/spi-bfin5xx.c:	master->bus_num = pdev->id;
drivers/spi/spi-bfin5xx.c:		dev_err(&pdev->dev, ": Requesting Peripherals failed\n");
drivers/spi/spi-bfin5xx.c:		dev_err(&pdev->dev, "problem starting queue (%d)\n", status);
drivers/spi/spi-au1550.c:	master = spi_alloc_master(&pdev->dev, sizeof(struct au1550_spi));
drivers/spi/spi-au1550.c:		dev_err(&pdev->dev, "No memory for spi_master\n");
drivers/spi/spi-au1550.c:	hw->pdata = pdev->dev.platform_data;
drivers/spi/spi-au1550.c:	hw->dev = &pdev->dev;
drivers/spi/spi-au1550.c:		dev_err(&pdev->dev, "No platform data supplied\n");
drivers/spi/spi-au1550.c:		dev_err(&pdev->dev, "no IRQ\n");
drivers/spi/spi-au1550.c:				if (pdev->dev.dma_mask == NULL)
drivers/spi/spi-au1550.c:					dev_warn(&pdev->dev, "no dma mask\n");
drivers/spi/spi-au1550.c:		dev_err(&pdev->dev, "no mmio resource\n");
drivers/spi/spi-au1550.c:					pdev->name);
drivers/spi/spi-au1550.c:		dev_err(&pdev->dev, "Cannot reserve iomem region\n");
drivers/spi/spi-au1550.c:		dev_err(&pdev->dev, "cannot ioremap\n");
drivers/spi/spi-au1550.c:			dev_err(&pdev->dev,
drivers/spi/spi-au1550.c:			dev_err(&pdev->dev,
drivers/spi/spi-au1550.c:			dev_err(&pdev->dev,
drivers/spi/spi-au1550.c:			dev_err(&pdev->dev,
drivers/spi/spi-au1550.c:			dev_err(&pdev->dev,
drivers/spi/spi-au1550.c:	err = request_irq(hw->irq, au1550_spi_irq, 0, pdev->name, hw);
drivers/spi/spi-au1550.c:		dev_err(&pdev->dev, "Cannot claim IRQ\n");
drivers/spi/spi-au1550.c:	master->bus_num = pdev->id;
drivers/spi/spi-au1550.c:		dev_err(&pdev->dev, "Failed to register SPI master\n");
drivers/spi/spi-au1550.c:	dev_info(&pdev->dev,
drivers/spi/spi-au1550.c:	dev_info(&pdev->dev, "spi master remove: bus_num=%d\n",
drivers/spi/spi-oc-tiny.c:	struct device_node *np = pdev->dev.of_node;
drivers/spi/spi-oc-tiny.c:		hw->gpio_cs = devm_kzalloc(&pdev->dev,
drivers/spi/spi-oc-tiny.c:	hw->bitbang.master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-oc-tiny.c:	val = of_get_property(pdev->dev.of_node,
drivers/spi/spi-oc-tiny.c:	val = of_get_property(pdev->dev.of_node, "baud-width", &len);
drivers/spi/spi-oc-tiny.c:	struct tiny_spi_platform_data *platp = pdev->dev.platform_data;
drivers/spi/spi-oc-tiny.c:	master = spi_alloc_master(&pdev->dev, sizeof(struct tiny_spi));
drivers/spi/spi-oc-tiny.c:	master->bus_num = pdev->id;
drivers/spi/spi-oc-tiny.c:	if (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),
drivers/spi/spi-oc-tiny.c:				     pdev->name))
drivers/spi/spi-oc-tiny.c:	hw->base = devm_ioremap_nocache(&pdev->dev, res->start,
drivers/spi/spi-oc-tiny.c:		err = devm_request_irq(&pdev->dev, hw->irq, tiny_spi_irq, 0,
drivers/spi/spi-oc-tiny.c:				       pdev->name, hw);
drivers/spi/spi-oc-tiny.c:		err = gpio_request(hw->gpio_cs[i], dev_name(&pdev->dev));
drivers/spi/spi-oc-tiny.c:	dev_info(&pdev->dev, "base %p, irq %d\n", hw->base, hw->irq);
drivers/spi/spi-octeon.c:	master = spi_alloc_master(&pdev->dev, sizeof(struct octeon_spi));
drivers/spi/spi-octeon.c:		dev_err(&pdev->dev, "found no memory resource\n");
drivers/spi/spi-octeon.c:	if (!devm_request_mem_region(&pdev->dev, res_mem->start,
drivers/spi/spi-octeon.c:		dev_err(&pdev->dev, "request_mem_region failed\n");
drivers/spi/spi-octeon.c:	p->register_base = (u64)devm_ioremap(&pdev->dev, res_mem->start,
drivers/spi/spi-octeon.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-octeon.c:		dev_err(&pdev->dev, "register master failed: %d\n", err);
drivers/spi/spi-octeon.c:	dev_info(&pdev->dev, "OCTEON SPI bus driver\n");
drivers/spi/spi-atmel.c:		dev_err(&as->pdev->dev,
drivers/spi/spi-atmel.c:		dev_err(&as->pdev->dev,
drivers/spi/spi-atmel.c:		dev_err(&as->pdev->dev,
drivers/spi/spi-atmel.c:	dev_info(&as->pdev->dev,
drivers/spi/spi-atmel.c:		dma_sync_single_for_device(&as->pdev->dev,
drivers/spi/spi-atmel.c:	struct device	*dev = &as->pdev->dev;
drivers/spi/spi-atmel.c:	dev_info(&as->pdev->dev, "version: 0x%x\n", version);
drivers/spi/spi-atmel.c:	clk = clk_get(&pdev->dev, "spi_clk");
drivers/spi/spi-atmel.c:	master = spi_alloc_master(&pdev->dev, sizeof *as);
drivers/spi/spi-atmel.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-atmel.c:	master->bus_num = pdev->id;
drivers/spi/spi-atmel.c:	as->buffer = dma_alloc_coherent(&pdev->dev, BUFFER_SIZE,
drivers/spi/spi-atmel.c:		dev_info(&pdev->dev, "Atmel SPI Controller using PIO only\n");
drivers/spi/spi-atmel.c:					dev_name(&pdev->dev), master);
drivers/spi/spi-atmel.c:					dev_name(&pdev->dev), master);
drivers/spi/spi-atmel.c:	dev_info(&pdev->dev, "Atmel SPI Controller at 0x%08lx (irq %d)\n",
drivers/spi/spi-atmel.c:	dma_free_coherent(&pdev->dev, BUFFER_SIZE, as->buffer,
drivers/spi/spi-atmel.c:	dma_free_coherent(&pdev->dev, BUFFER_SIZE, as->buffer,
drivers/spi/spi-bfin-sport.c:	struct device *dev = &pdev->dev;
drivers/spi/spi-bfin-sport.c:	master->bus_num = pdev->id;
drivers/spi/spi-s3c24xx.c:	master = spi_alloc_master(&pdev->dev, sizeof(struct s3c24xx_spi));
drivers/spi/spi-s3c24xx.c:		dev_err(&pdev->dev, "No memory for spi_master\n");
drivers/spi/spi-s3c24xx.c:	hw->pdata = pdata = pdev->dev.platform_data;
drivers/spi/spi-s3c24xx.c:	hw->dev = &pdev->dev;
drivers/spi/spi-s3c24xx.c:		dev_err(&pdev->dev, "No platform data supplied\n");
drivers/spi/spi-s3c24xx.c:		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
drivers/spi/spi-s3c24xx.c:					pdev->name);
drivers/spi/spi-s3c24xx.c:		dev_err(&pdev->dev, "Cannot reserve region\n");
drivers/spi/spi-s3c24xx.c:		dev_err(&pdev->dev, "Cannot map IO\n");
drivers/spi/spi-s3c24xx.c:		dev_err(&pdev->dev, "No IRQ specified\n");
drivers/spi/spi-s3c24xx.c:	err = request_irq(hw->irq, s3c24xx_spi_irq, 0, pdev->name, hw);
drivers/spi/spi-s3c24xx.c:		dev_err(&pdev->dev, "Cannot claim IRQ\n");
drivers/spi/spi-s3c24xx.c:	hw->clk = clk_get(&pdev->dev, "spi");
drivers/spi/spi-s3c24xx.c:		dev_err(&pdev->dev, "No clock for device\n");
drivers/spi/spi-s3c24xx.c:			dev_err(&pdev->dev, "No chipselect pin\n");
drivers/spi/spi-s3c24xx.c:		err = gpio_request(pdata->pin_cs, dev_name(&pdev->dev));
drivers/spi/spi-s3c24xx.c:			dev_err(&pdev->dev, "Failed to get gpio for cs\n");
drivers/spi/spi-s3c24xx.c:		dev_err(&pdev->dev, "Failed to register SPI master\n");
drivers/spi/spi-omap-uwire.c:	master = spi_alloc_master(&pdev->dev, sizeof *uwire);
drivers/spi/spi-omap-uwire.c:		dev_dbg(&pdev->dev, "can't ioremap UWIRE\n");
drivers/spi/spi-omap-uwire.c:	dev_set_drvdata(&pdev->dev, uwire);
drivers/spi/spi-omap-uwire.c:	uwire->ck = clk_get(&pdev->dev, "fck");
drivers/spi/spi-omap-uwire.c:		dev_dbg(&pdev->dev, "no functional clock?\n");
drivers/spi/spi-omap-uwire.c:	struct uwire_spi	*uwire = dev_get_drvdata(&pdev->dev);
drivers/spi/spi-topcliff-pch.c:		dev_dbg(&board_dat->pdev->dev,
drivers/spi/spi-topcliff-pch.c:		dev_err(&board_dat->pdev->dev, "%s Over run error\n", __func__);
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&board_dat->pdev->dev, "%s EXIT return value=%d\n",
drivers/spi/spi-topcliff-pch.c:	dma_dev = pci_get_bus_and_slot(data->board_dat->pdev->bus->number,
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&board_dat->pdev->dev, "%s ENTRY\n", __func__);
drivers/spi/spi-topcliff-pch.c:		dev_dbg(&board_dat->pdev->dev,
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&board_dat->pdev->dev, "%s ENTRY\n", __func__);
drivers/spi/spi-topcliff-pch.c:		dev_err(&board_dat->pdev->dev,
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&board_dat->pdev->dev,
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&board_dat->pdev->dev, "%s data->irq_reg_sts=true\n", __func__);
drivers/spi/spi-topcliff-pch.c:		dev_err(&board_dat->pdev->dev,
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&board_dat->pdev->dev, "%s Return=%d\n", __func__, retval);
drivers/spi/spi-topcliff-pch.c:		dma_free_coherent(&board_dat->pdev->dev, PCH_BUF_SIZE,
drivers/spi/spi-topcliff-pch.c:		dma_free_coherent(&board_dat->pdev->dev, PCH_BUF_SIZE,
drivers/spi/spi-topcliff-pch.c:	dma->tx_buf_virt = dma_alloc_coherent(&board_dat->pdev->dev,
drivers/spi/spi-topcliff-pch.c:	dma->rx_buf_virt = dma_alloc_coherent(&board_dat->pdev->dev,
drivers/spi/spi-topcliff-pch.c:	master = spi_alloc_master(&board_dat->pdev->dev,
drivers/spi/spi-topcliff-pch.c:	ret = request_irq(board_dat->pdev->irq, pch_spi_handler,
drivers/spi/spi-topcliff-pch.c:	free_irq(board_dat->pdev->irq, data);
drivers/spi/spi-topcliff-pch.c:		__func__, plat_dev->id, board_dat->pdev->irq);
drivers/spi/spi-topcliff-pch.c:		dev_dbg(&board_dat->pdev->dev, "%s :queue not empty\n",
drivers/spi/spi-topcliff-pch.c:		free_irq(board_dat->pdev->irq, data);
drivers/spi/spi-topcliff-pch.c:		free_irq(board_dat->pdev->irq, data);
drivers/spi/spi-topcliff-pch.c:		retval = request_irq(board_dat->pdev->irq, pch_spi_handler,
drivers/spi/spi-topcliff-pch.c:		dev_err(&pdev->dev, "%s Can't allocate pd_dev_sav\n", __func__);
drivers/spi/spi-topcliff-pch.c:		dev_err(&pdev->dev, "%s Can't allocate board_dat\n", __func__);
drivers/spi/spi-topcliff-pch.c:		dev_err(&pdev->dev, "%s request_region failed\n", __func__);
drivers/spi/spi-topcliff-pch.c:		dev_err(&pdev->dev, "%s pci_enable_device failed\n", __func__);
drivers/spi/spi-topcliff-pch.c:			dev_err(&pdev->dev, "platform_device_alloc failed\n");
drivers/spi/spi-topcliff-pch.c:		pd_dev->dev.parent = &pdev->dev;
drivers/spi/spi-topcliff-pch.c:			dev_err(&pdev->dev,
drivers/spi/spi-topcliff-pch.c:			dev_err(&pdev->dev, "platform_device_add failed\n");
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&pdev->dev, "%s ENTRY:pdev=%p\n", __func__, pdev);
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&pdev->dev, "%s ENTRY\n", __func__);
drivers/spi/spi-topcliff-pch.c:		dev_err(&pdev->dev, "%s pci_save_state failed\n", __func__);
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&pdev->dev, "%s ENTRY\n", __func__);
drivers/spi/spi-topcliff-pch.c:		dev_err(&pdev->dev,
drivers/spi/spi-fsl-spi.c:	if (!pdev->dev.platform_data)
drivers/spi/spi-fsl-spi.c:	master = fsl_spi_probe(&pdev->dev, mem, irq);
drivers/spi/spi-fsl-spi.c:	return mpc8xxx_spi_remove(&pdev->dev);
drivers/spi/spi-bcm63xx.c:	pm_runtime_get_sync(&bs->pdev->dev);
drivers/spi/spi-bcm63xx.c:	pm_runtime_put(&bs->pdev->dev);
drivers/spi/spi-bcm63xx.c:	struct device *dev = &pdev->dev;
drivers/spi/spi-bcm63xx.c:	struct bcm63xx_spi_pdata *pdata = pdev->dev.platform_data;
drivers/spi/spi-bcm63xx.c:	bs->regs = devm_ioremap_resource(&pdev->dev, r);
drivers/spi/spi-bcm63xx.c:	ret = devm_request_irq(&pdev->dev, irq, bcm63xx_spi_interrupt, 0,
drivers/spi/spi-bcm63xx.c:							pdev->name, master);
drivers/spi/spi-s3c64xx.c:		dev_warn(&sdd->pdev->dev, "Timed out flushing TX FIFO\n");
drivers/spi/spi-s3c64xx.c:		dev_warn(&sdd->pdev->dev, "Timed out flushing RX FIFO\n");
drivers/spi/spi-s3c64xx.c:	struct device *dev = &sdd->pdev->dev;
drivers/spi/spi-s3c64xx.c:	pm_runtime_get_sync(&sdd->pdev->dev);
drivers/spi/spi-s3c64xx.c:	pm_runtime_put(&sdd->pdev->dev);
drivers/spi/spi-s3c64xx.c:	struct device *dev = &sdd->pdev->dev;
drivers/spi/spi-s3c64xx.c:	ret = pm_runtime_get_sync(&sdd->pdev->dev);
drivers/spi/spi-s3c64xx.c:	pm_runtime_put(&sdd->pdev->dev);
drivers/spi/spi-s3c64xx.c:	struct device *dev = &sdd->pdev->dev;
drivers/spi/spi-s3c64xx.c:	struct device *dev = &sdd->pdev->dev;
drivers/spi/spi-s3c64xx.c:	pm_runtime_get_sync(&sdd->pdev->dev);
drivers/spi/spi-s3c64xx.c:	pm_runtime_put(&sdd->pdev->dev);
drivers/spi/spi-s3c64xx.c:	if (pdev->dev.of_node) {
drivers/spi/spi-s3c64xx.c:		match = of_match_node(s3c64xx_spi_dt_match, pdev->dev.of_node);
drivers/spi/spi-s3c64xx.c:	struct s3c64xx_spi_info *sci = pdev->dev.platform_data;
drivers/spi/spi-s3c64xx.c:	if (!sci && pdev->dev.of_node) {
drivers/spi/spi-s3c64xx.c:		sci = s3c64xx_spi_parse_dt(&pdev->dev);
drivers/spi/spi-s3c64xx.c:		dev_err(&pdev->dev, "platform_data missing!\n");
drivers/spi/spi-s3c64xx.c:		dev_err(&pdev->dev, "Unable to get SPI MEM resource\n");
drivers/spi/spi-s3c64xx.c:		dev_warn(&pdev->dev, "Failed to get IRQ: %d\n", irq);
drivers/spi/spi-s3c64xx.c:	master = spi_alloc_master(&pdev->dev,
drivers/spi/spi-s3c64xx.c:		dev_err(&pdev->dev, "Unable to allocate SPI Master\n");
drivers/spi/spi-s3c64xx.c:	if (pdev->dev.of_node) {
drivers/spi/spi-s3c64xx.c:		ret = of_alias_get_id(pdev->dev.of_node, "spi");
drivers/spi/spi-s3c64xx.c:			dev_err(&pdev->dev, "failed to get alias id, errno %d\n",
drivers/spi/spi-s3c64xx.c:		sdd->port_id = pdev->id;
drivers/spi/spi-s3c64xx.c:	if (!sdd->pdev->dev.of_node) {
drivers/spi/spi-s3c64xx.c:			dev_err(&pdev->dev, "Unable to get SPI tx dma "
drivers/spi/spi-s3c64xx.c:			dev_err(&pdev->dev, "Unable to get SPI rx dma "
drivers/spi/spi-s3c64xx.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-s3c64xx.c:	sdd->regs = devm_ioremap_resource(&pdev->dev, mem_res);
drivers/spi/spi-s3c64xx.c:		dev_err(&pdev->dev, "Unable to config gpio\n");
drivers/spi/spi-s3c64xx.c:	sdd->clk = devm_clk_get(&pdev->dev, "spi");
drivers/spi/spi-s3c64xx.c:		dev_err(&pdev->dev, "Unable to acquire clock 'spi'\n");
drivers/spi/spi-s3c64xx.c:		dev_err(&pdev->dev, "Couldn't enable clock 'spi'\n");
drivers/spi/spi-s3c64xx.c:	sdd->src_clk = devm_clk_get(&pdev->dev, clk_name);
drivers/spi/spi-s3c64xx.c:		dev_err(&pdev->dev,
drivers/spi/spi-s3c64xx.c:		dev_err(&pdev->dev, "Couldn't enable clock '%s'\n", clk_name);
drivers/spi/spi-s3c64xx.c:	ret = devm_request_irq(&pdev->dev, irq, s3c64xx_spi_irq, 0,
drivers/spi/spi-s3c64xx.c:		dev_err(&pdev->dev, "Failed to request IRQ %d: %d\n",
drivers/spi/spi-s3c64xx.c:		dev_err(&pdev->dev, "cannot register SPI master\n");
drivers/spi/spi-s3c64xx.c:	dev_dbg(&pdev->dev, "Samsung SoC SPI Driver loaded for Bus SPI-%d with %d Slaves attached\n",
drivers/spi/spi-s3c64xx.c:	dev_dbg(&pdev->dev, "\tIOmem=[0x%x-0x%x]\tDMA=[Rx-%d, Tx-%d]\n",
drivers/spi/spi-s3c64xx.c:	pm_runtime_enable(&pdev->dev);
drivers/spi/spi-s3c64xx.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-omap-100k.c:	if (!pdev->id)
drivers/spi/spi-omap-100k.c:	master = spi_alloc_master(&pdev->dev, sizeof *spi100k);
drivers/spi/spi-omap-100k.c:		dev_dbg(&pdev->dev, "master allocation failed\n");
drivers/spi/spi-omap-100k.c:	if (pdev->id != -1)
drivers/spi/spi-omap-100k.c:	       master->bus_num = pdev->id;
drivers/spi/spi-omap-100k.c:	dev_set_drvdata(&pdev->dev, master);
drivers/spi/spi-omap-100k.c:	spi100k->base = (void __iomem *) pdev->dev.platform_data;
drivers/spi/spi-omap-100k.c:	spi100k->ick = clk_get(&pdev->dev, "ick");
drivers/spi/spi-omap-100k.c:		dev_dbg(&pdev->dev, "can't get spi100k_ick\n");
drivers/spi/spi-omap-100k.c:	spi100k->fck = clk_get(&pdev->dev, "fck");
drivers/spi/spi-omap-100k.c:		dev_dbg(&pdev->dev, "can't get spi100k_fck\n");
drivers/spi/spi-omap-100k.c:	master = dev_get_drvdata(&pdev->dev);
drivers/spi/spi-orion.c:	master = spi_alloc_master(&pdev->dev, sizeof *spi);
drivers/spi/spi-orion.c:		dev_dbg(&pdev->dev, "master allocation failed\n");
drivers/spi/spi-orion.c:	if (pdev->id != -1)
drivers/spi/spi-orion.c:		master->bus_num = pdev->id;
drivers/spi/spi-orion.c:	if (pdev->dev.of_node) {
drivers/spi/spi-orion.c:		iprop = of_get_property(pdev->dev.of_node, "cell-index",
drivers/spi/spi-orion.c:	dev_set_drvdata(&pdev->dev, master);
drivers/spi/spi-orion.c:	spi->clk = clk_get(&pdev->dev, NULL);
drivers/spi/spi-orion.c:				dev_name(&pdev->dev))) {
drivers/spi/spi-orion.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-orion.c:	master = dev_get_drvdata(&pdev->dev);
drivers/spi/spi-altera.c:	struct altera_spi_platform_data *platp = pdev->dev.platform_data;
drivers/spi/spi-altera.c:	master = spi_alloc_master(&pdev->dev, sizeof(struct altera_spi));
drivers/spi/spi-altera.c:	master->bus_num = pdev->id;
drivers/spi/spi-altera.c:	if (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),
drivers/spi/spi-altera.c:				     pdev->name))
drivers/spi/spi-altera.c:	hw->base = devm_ioremap_nocache(&pdev->dev, res->start,
drivers/spi/spi-altera.c:		err = devm_request_irq(&pdev->dev, hw->irq, altera_spi_irq, 0,
drivers/spi/spi-altera.c:				       pdev->name, hw);
drivers/spi/spi-altera.c:		hw->bitbang.master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-altera.c:	dev_info(&pdev->dev, "base %p, irq %d\n", hw->base, hw->irq);
drivers/spi/spi-nuc900.c:	master = spi_alloc_master(&pdev->dev, sizeof(struct nuc900_spi));
drivers/spi/spi-nuc900.c:		dev_err(&pdev->dev, "No memory for spi_master\n");
drivers/spi/spi-nuc900.c:	hw->pdata  = pdev->dev.platform_data;
drivers/spi/spi-nuc900.c:	hw->dev = &pdev->dev;
drivers/spi/spi-nuc900.c:		dev_err(&pdev->dev, "No platform data supplied\n");
drivers/spi/spi-nuc900.c:		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
drivers/spi/spi-nuc900.c:					resource_size(hw->res), pdev->name);
drivers/spi/spi-nuc900.c:		dev_err(&pdev->dev, "Cannot reserve region\n");
drivers/spi/spi-nuc900.c:		dev_err(&pdev->dev, "Cannot map IO\n");
drivers/spi/spi-nuc900.c:		dev_err(&pdev->dev, "No IRQ specified\n");
drivers/spi/spi-nuc900.c:	err = request_irq(hw->irq, nuc900_spi_irq, 0, pdev->name, hw);
drivers/spi/spi-nuc900.c:		dev_err(&pdev->dev, "Cannot claim IRQ\n");
drivers/spi/spi-nuc900.c:	hw->clk = clk_get(&pdev->dev, "spi");
drivers/spi/spi-nuc900.c:		dev_err(&pdev->dev, "No clock for device\n");
drivers/spi/spi-nuc900.c:	mfp_set_groupg(&pdev->dev, NULL);
drivers/spi/spi-nuc900.c:		dev_err(&pdev->dev, "Failed to register SPI master\n");
drivers/spi/spi-sh.c:	struct spi_sh_data *ss = dev_get_drvdata(&pdev->dev);
drivers/spi/spi-sh.c:		dev_err(&pdev->dev, "invalid resource\n");
drivers/spi/spi-sh.c:		dev_err(&pdev->dev, "platform_get_irq error\n");
drivers/spi/spi-sh.c:	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_sh_data));
drivers/spi/spi-sh.c:		dev_err(&pdev->dev, "spi_alloc_master error.\n");
drivers/spi/spi-sh.c:	dev_set_drvdata(&pdev->dev, ss);
drivers/spi/spi-sh.c:		dev_err(&pdev->dev, "No support width\n");
drivers/spi/spi-sh.c:		dev_err(&pdev->dev, "ioremap error.\n");
drivers/spi/spi-sh.c:		dev_err(&pdev->dev, "create workqueue error\n");
drivers/spi/spi-sh.c:		dev_err(&pdev->dev, "request_irq error\n");
drivers/spi/spi-sh.c:	master->bus_num = pdev->id;
drivers/spi/spi-omap2-mcspi.c:	struct device_node	*node = pdev->dev.of_node;
drivers/spi/spi-omap2-mcspi.c:	master = spi_alloc_master(&pdev->dev, sizeof *mcspi);
drivers/spi/spi-omap2-mcspi.c:		dev_dbg(&pdev->dev, "master allocation failed\n");
drivers/spi/spi-omap2-mcspi.c:	dev_set_drvdata(&pdev->dev, master);
drivers/spi/spi-omap2-mcspi.c:	match = of_match_device(omap_mcspi_of_match, &pdev->dev);
drivers/spi/spi-omap2-mcspi.c:		pdata = pdev->dev.platform_data;
drivers/spi/spi-omap2-mcspi.c:		if (pdev->id != -1)
drivers/spi/spi-omap2-mcspi.c:			master->bus_num = pdev->id;
drivers/spi/spi-omap2-mcspi.c:	mcspi->base = devm_ioremap_resource(&pdev->dev, r);
drivers/spi/spi-omap2-mcspi.c:	mcspi->dev = &pdev->dev;
drivers/spi/spi-omap2-mcspi.c:			dev_dbg(&pdev->dev, "cannot get DMA RX channel\n");
drivers/spi/spi-omap2-mcspi.c:			dev_dbg(&pdev->dev, "cannot get DMA TX channel\n");
drivers/spi/spi-omap2-mcspi.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/spi/spi-omap2-mcspi.c:		dev_warn(&pdev->dev,
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_use_autosuspend(&pdev->dev);
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_set_autosuspend_delay(&pdev->dev, SPI_AUTOSUSPEND_TIMEOUT);
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_enable(&pdev->dev);
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-omap2-mcspi.c:	master = dev_get_drvdata(&pdev->dev);
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-sh-hspi.c:		dev_err(&pdev->dev, "invalid resource\n");
drivers/spi/spi-sh-hspi.c:	master = spi_alloc_master(&pdev->dev, sizeof(*hspi));
drivers/spi/spi-sh-hspi.c:		dev_err(&pdev->dev, "spi_alloc_master error.\n");
drivers/spi/spi-sh-hspi.c:		dev_err(&pdev->dev, "shyway_clk is required\n");
drivers/spi/spi-sh-hspi.c:	dev_set_drvdata(&pdev->dev, hspi);
drivers/spi/spi-sh-hspi.c:	hspi->dev	= &pdev->dev;
drivers/spi/spi-sh-hspi.c:		dev_err(&pdev->dev, "ioremap error.\n");
drivers/spi/spi-sh-hspi.c:	master->bus_num		= pdev->id;
drivers/spi/spi-sh-hspi.c:		dev_err(&pdev->dev, "spi_register_master error.\n");
drivers/spi/spi-sh-hspi.c:	pm_runtime_enable(&pdev->dev);
drivers/spi/spi-sh-hspi.c:	dev_info(&pdev->dev, "probed\n");
drivers/spi/spi-sh-hspi.c:	struct hspi_priv *hspi = dev_get_drvdata(&pdev->dev);
drivers/spi/spi-sh-hspi.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-sh-msiof.c:			pm_runtime_get_sync(&p->pdev->dev);
drivers/spi/spi-sh-msiof.c:			pm_runtime_put(&p->pdev->dev);
drivers/spi/spi-sh-msiof.c:		dev_err(&p->pdev->dev, "failed to start hardware\n");
drivers/spi/spi-sh-msiof.c:		dev_err(&p->pdev->dev, "failed to shut down hardware\n");
drivers/spi/spi-sh-msiof.c:	master = spi_alloc_master(&pdev->dev, sizeof(struct sh_msiof_spi_priv));
drivers/spi/spi-sh-msiof.c:		dev_err(&pdev->dev, "failed to allocate spi master\n");
drivers/spi/spi-sh-msiof.c:	if (pdev->dev.of_node)
drivers/spi/spi-sh-msiof.c:		p->info = sh_msiof_spi_parse_dt(&pdev->dev);
drivers/spi/spi-sh-msiof.c:		p->info = pdev->dev.platform_data;
drivers/spi/spi-sh-msiof.c:		dev_err(&pdev->dev, "failed to obtain device info\n");
drivers/spi/spi-sh-msiof.c:	p->clk = clk_get(&pdev->dev, NULL);
drivers/spi/spi-sh-msiof.c:		dev_err(&pdev->dev, "cannot get clock\n");
drivers/spi/spi-sh-msiof.c:		dev_err(&pdev->dev, "cannot get platform resources\n");
drivers/spi/spi-sh-msiof.c:		dev_err(&pdev->dev, "unable to ioremap\n");
drivers/spi/spi-sh-msiof.c:			  dev_name(&pdev->dev), p);
drivers/spi/spi-sh-msiof.c:		dev_err(&pdev->dev, "unable to request irq\n");
drivers/spi/spi-sh-msiof.c:	pm_runtime_enable(&pdev->dev);
drivers/spi/spi-sh-msiof.c:	master->bus_num = pdev->id;
drivers/spi/spi-sh-msiof.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-sh-msiof.c:		pm_runtime_disable(&pdev->dev);
drivers/spi/spi-dw-pci.c:		pdev->vendor, pdev->device);
drivers/spi/spi-dw-pci.c:	ret = pci_request_region(pdev, pci_bar, dev_name(&pdev->dev));
drivers/spi/spi-dw-pci.c:	dws->parent_dev = &pdev->dev;
drivers/spi/spi-dw-pci.c:	dws->irq = pdev->irq;
drivers/spi/spi-dw-pci.c:	if (pdev->device == 0x0800) {
drivers/spi/spi-tegra114.c:	struct device_node *np = pdev->dev.of_node;
drivers/spi/spi-tegra114.c:	master = spi_alloc_master(&pdev->dev, sizeof(*tspi));
drivers/spi/spi-tegra114.c:		dev_err(&pdev->dev, "master allocation failed\n");
drivers/spi/spi-tegra114.c:	dev_set_drvdata(&pdev->dev, master);
drivers/spi/spi-tegra114.c:	tspi->dev = &pdev->dev;
drivers/spi/spi-tegra114.c:		dev_err(&pdev->dev, "No IO memory resource\n");
drivers/spi/spi-tegra114.c:	tspi->base = devm_ioremap_resource(&pdev->dev, r);
drivers/spi/spi-tegra114.c:		dev_err(&pdev->dev, "ioremap failed: err = %d\n", ret);
drivers/spi/spi-tegra114.c:			dev_name(&pdev->dev), tspi);
drivers/spi/spi-tegra114.c:		dev_err(&pdev->dev, "Failed to register ISR for IRQ %d\n",
drivers/spi/spi-tegra114.c:	tspi->clk = devm_clk_get(&pdev->dev, "spi");
drivers/spi/spi-tegra114.c:		dev_err(&pdev->dev, "can not get clock\n");
drivers/spi/spi-tegra114.c:			dev_err(&pdev->dev, "RxDma Init failed, err %d\n", ret);
drivers/spi/spi-tegra114.c:			dev_err(&pdev->dev, "TxDma Init failed, err %d\n", ret);
drivers/spi/spi-tegra114.c:	pm_runtime_enable(&pdev->dev);
drivers/spi/spi-tegra114.c:	if (!pm_runtime_enabled(&pdev->dev)) {
drivers/spi/spi-tegra114.c:		ret = tegra_spi_runtime_resume(&pdev->dev);
drivers/spi/spi-tegra114.c:	ret = pm_runtime_get_sync(&pdev->dev);
drivers/spi/spi-tegra114.c:		dev_err(&pdev->dev, "pm runtime get failed, e = %d\n", ret);
drivers/spi/spi-tegra114.c:	pm_runtime_put(&pdev->dev);
drivers/spi/spi-tegra114.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-tegra114.c:		dev_err(&pdev->dev, "can not register to master err %d\n", ret);
drivers/spi/spi-tegra114.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-tegra114.c:	if (!pm_runtime_status_suspended(&pdev->dev))
drivers/spi/spi-tegra114.c:		tegra_spi_runtime_suspend(&pdev->dev);
drivers/spi/spi-tegra114.c:	struct spi_master *master = dev_get_drvdata(&pdev->dev);
drivers/spi/spi-tegra114.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-tegra114.c:	if (!pm_runtime_status_suspended(&pdev->dev))
drivers/spi/spi-tegra114.c:		tegra_spi_runtime_suspend(&pdev->dev);
drivers/spi/spi-dw-mmio.c:		dev_err(&pdev->dev, "no mem resource?\n");
drivers/spi/spi-dw-mmio.c:			pdev->name);
drivers/spi/spi-dw-mmio.c:		dev_err(&pdev->dev, "SPI region already claimed\n");
drivers/spi/spi-dw-mmio.c:		dev_err(&pdev->dev, "SPI region already mapped\n");
drivers/spi/spi-dw-mmio.c:		dev_err(&pdev->dev, "no irq resource?\n");
drivers/spi/spi-dw-mmio.c:	dwsmmio->clk = clk_get(&pdev->dev, NULL);
drivers/spi/spi-dw-mmio.c:	dws->parent_dev = &pdev->dev;
drivers/spi/spi-pxa2xx.c:	dev_err(&drv_data->pdev->dev, "%s\n", msg);
drivers/spi/spi-pxa2xx.c:	if (pm_runtime_suspended(&drv_data->pdev->dev))
drivers/spi/spi-pxa2xx.c:		dev_err(&drv_data->pdev->dev, "bad message state "
drivers/spi/spi-pxa2xx.c:			dev_err(&drv_data->pdev->dev,
drivers/spi/spi-pxa2xx.c:		dev_err(&drv_data->pdev->dev, "pump_transfers: flush failed\n");
drivers/spi/spi-pxa2xx.c:	pm_runtime_get_sync(&drv_data->pdev->dev);
drivers/spi/spi-pxa2xx.c:	pm_runtime_mark_last_busy(&drv_data->pdev->dev);
drivers/spi/spi-pxa2xx.c:	pm_runtime_put_autosuspend(&drv_data->pdev->dev);
drivers/spi/spi-pxa2xx.c:	if (!ACPI_HANDLE(&pdev->dev) ||
drivers/spi/spi-pxa2xx.c:	    acpi_bus_get_device(ACPI_HANDLE(&pdev->dev), &adev))
drivers/spi/spi-pxa2xx.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/spi/spi-pxa2xx.c:		dev_err(&pdev->dev,
drivers/spi/spi-pxa2xx.c:	ssp->mmio_base = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-pxa2xx.c:	ssp->clk = devm_clk_get(&pdev->dev, NULL);
drivers/spi/spi-pxa2xx.c:	struct device *dev = &pdev->dev;
drivers/spi/spi-pxa2xx.c:			dev_err(&pdev->dev, "missing platform data\n");
drivers/spi/spi-pxa2xx.c:	ssp = pxa_ssp_request(pdev->id, pdev->name);
drivers/spi/spi-pxa2xx.c:		dev_err(&pdev->dev, "failed to get ssp\n");
drivers/spi/spi-pxa2xx.c:		dev_err(&pdev->dev, "cannot alloc spi_master\n");
drivers/spi/spi-pxa2xx.c:	master->dev.parent = &pdev->dev;
drivers/spi/spi-pxa2xx.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-pxa2xx.c:		dev_err(&pdev->dev, "cannot get IRQ %d\n", ssp->irq);
drivers/spi/spi-pxa2xx.c:		dev_err(&pdev->dev, "problem registering spi master\n");
drivers/spi/spi-pxa2xx.c:	pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
drivers/spi/spi-pxa2xx.c:	pm_runtime_use_autosuspend(&pdev->dev);
drivers/spi/spi-pxa2xx.c:	pm_runtime_set_active(&pdev->dev);
drivers/spi/spi-pxa2xx.c:	pm_runtime_enable(&pdev->dev);
drivers/spi/spi-pxa2xx.c:	pm_runtime_get_sync(&pdev->dev);
drivers/spi/spi-pxa2xx.c:	pm_runtime_put_noidle(&pdev->dev);
drivers/spi/spi-pxa2xx.c:	pm_runtime_disable(&pdev->dev);
drivers/spi/spi-pxa2xx.c:		dev_err(&pdev->dev, "shutdown failed with %d\n", status);
drivers/spi/spi-imx.c:	struct device_node *np = pdev->dev.of_node;
drivers/spi/spi-imx.c:			of_match_device(spi_imx_dt_ids, &pdev->dev);
drivers/spi/spi-imx.c:			dev_get_platdata(&pdev->dev);
drivers/spi/spi-imx.c:		dev_err(&pdev->dev, "can't get the platform data\n");
drivers/spi/spi-imx.c:	master = spi_alloc_master(&pdev->dev,
drivers/spi/spi-imx.c:	master->bus_num = pdev->id;
drivers/spi/spi-imx.c:			dev_err(&pdev->dev, "can't get cs gpios\n");
drivers/spi/spi-imx.c:		(struct spi_imx_devtype_data *) pdev->id_entry->driver_data;
drivers/spi/spi-imx.c:		dev_err(&pdev->dev, "can't get platform resource\n");
drivers/spi/spi-imx.c:	if (!request_mem_region(res->start, resource_size(res), pdev->name)) {
drivers/spi/spi-imx.c:		dev_err(&pdev->dev, "request_mem_region failed\n");
drivers/spi/spi-imx.c:		dev_err(&pdev->dev, "can't get irq%d: %d\n", spi_imx->irq, ret);
drivers/spi/spi-imx.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/spi/spi-imx.c:	spi_imx->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
drivers/spi/spi-imx.c:	spi_imx->clk_per = devm_clk_get(&pdev->dev, "per");
drivers/spi/spi-imx.c:	master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-imx.c:		dev_err(&pdev->dev, "bitbang start failed with %d\n", ret);
drivers/spi/spi-imx.c:	dev_info(&pdev->dev, "probed\n");
drivers/spi/spi-sirf.c:	ret = of_property_read_u32(pdev->dev.of_node,
drivers/spi/spi-sirf.c:		dev_err(&pdev->dev, "Unable to get chip select number\n");
drivers/spi/spi-sirf.c:	master = spi_alloc_master(&pdev->dev, sizeof(*sspi) + sizeof(int) * num_cs);
drivers/spi/spi-sirf.c:		dev_err(&pdev->dev, "Unable to allocate SPI master\n");
drivers/spi/spi-sirf.c:		dev_err(&pdev->dev, "Unable to get IO resource\n");
drivers/spi/spi-sirf.c:		cs_gpio = of_get_named_gpio(pdev->dev.of_node, "cs-gpios", i);
drivers/spi/spi-sirf.c:			dev_err(&pdev->dev, "can't get cs gpio from DT\n");
drivers/spi/spi-sirf.c:			dev_err(&pdev->dev, "fail to request cs gpios\n");
drivers/spi/spi-sirf.c:	sspi->base = devm_ioremap_resource(&pdev->dev, mem_res);
drivers/spi/spi-sirf.c:	ret = devm_request_irq(&pdev->dev, irq, spi_sirfsoc_irq, 0,
drivers/spi/spi-sirf.c:	master->bus_num = pdev->id;
drivers/spi/spi-sirf.c:	sspi->bitbang.master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-sirf.c:	sspi->p = pinctrl_get_select_default(&pdev->dev);
drivers/spi/spi-sirf.c:	sspi->clk = clk_get(&pdev->dev, NULL);
drivers/spi/spi-sirf.c:	dev_info(&pdev->dev, "registerred, bus number = %d\n", master->bus_num);
drivers/spi/spi-ti-ssp.c:	struct device *dev = &pdev->dev;
drivers/spi/spi-ti-ssp.c:	master->bus_num		= pdev->id;
drivers/connector/cn_queue.c:	atomic_dec(&cbq->pdev->refcnt);
drivers/vfio/pci/vfio_pci.c:			 __func__, dev_name(&pdev->dev));
drivers/vfio/pci/vfio_pci.c:	msix_pos = pdev->msix_cap;
drivers/vfio/pci/vfio_pci.c:	if ((pdev->class >> 8) == PCI_CLASS_DISPLAY_VGA)
drivers/vfio/pci/vfio_pci.c:			__func__, dev_name(&pdev->dev));
drivers/vfio/pci/vfio_pci.c:		pos = vdev->pdev->msi_cap;
drivers/vfio/pci/vfio_pci.c:		pos = vdev->pdev->msix_cap;
drivers/vfio/pci/vfio_pci.c:			info.size = pdev->cfg_size;
drivers/vfio/pci/vfio_pci.c:	group = iommu_group_get(&pdev->dev);
drivers/vfio/pci/vfio_pci.c:	ret = vfio_add_group_dev(&pdev->dev, &vfio_pci_ops, vdev);
drivers/vfio/pci/vfio_pci.c:	vdev = vfio_del_group_dev(&pdev->dev);
drivers/vfio/pci/vfio_pci.c:	iommu_group_put(pdev->dev.iommu_group);
drivers/vfio/pci/vfio_pci.c:	device = vfio_device_get_from_dev(&pdev->dev);
drivers/vfio/pci/vfio_pci_config.c:	if (pdev->is_virtfn)
drivers/vfio/pci/vfio_pci_config.c:		__func__, dev_name(&pdev->dev));
drivers/vfio/pci/vfio_pci_config.c:	if (offset == PCI_COMMAND && vdev->pdev->is_virtfn) {
drivers/vfio/pci/vfio_pci_config.c:			dev_name(&pdev->dev), __func__, cap, pos);
drivers/vfio/pci/vfio_pci_config.c:			dev_name(&pdev->dev), __func__, ecap, epos);
drivers/vfio/pci/vfio_pci_config.c:				__func__, dev_name(&pdev->dev), cap);
drivers/vfio/pci/vfio_pci_config.c:				__func__, dev_name(&pdev->dev),
drivers/vfio/pci/vfio_pci_config.c:	loops = (pdev->cfg_size - PCI_CFG_SPACE_SIZE) / PCI_CAP_SIZEOF;
drivers/vfio/pci/vfio_pci_config.c:				__func__, dev_name(&pdev->dev), ecap, epos);
drivers/vfio/pci/vfio_pci_config.c:				__func__, dev_name(&pdev->dev),
drivers/vfio/pci/vfio_pci_config.c:	map = kmalloc(pdev->cfg_size, GFP_KERNEL);
drivers/vfio/pci/vfio_pci_config.c:	vconfig = kmalloc(pdev->cfg_size, GFP_KERNEL);
drivers/vfio/pci/vfio_pci_config.c:	       pdev->cfg_size - PCI_STD_HEADER_SIZEOF);
drivers/vfio/pci/vfio_pci_config.c:	if (pdev->is_virtfn) {
drivers/vfio/pci/vfio_pci_config.c:		*(__le16 *)&vconfig[PCI_VENDOR_ID] = cpu_to_le16(pdev->vendor);
drivers/vfio/pci/vfio_pci_config.c:		*(__le16 *)&vconfig[PCI_DEVICE_ID] = cpu_to_le16(pdev->device);
drivers/vfio/pci/vfio_pci_config.c:	if (*ppos < 0 || *ppos >= pdev->cfg_size ||
drivers/vfio/pci/vfio_pci_config.c:	    *ppos + count > pdev->cfg_size)
drivers/vfio/pci/vfio_pci_intrs.c:			disable_irq_nosync(pdev->irq);
drivers/vfio/pci/vfio_pci_intrs.c:			enable_irq(pdev->irq);
drivers/vfio/pci/vfio_pci_intrs.c:		disable_irq_nosync(vdev->pdev->irq);
drivers/vfio/pci/vfio_pci_intrs.c:	if (!vdev->pdev->irq)
drivers/vfio/pci/vfio_pci_intrs.c:		free_irq(pdev->irq, vdev);
drivers/vfio/pci/vfio_pci_intrs.c:	ret = request_irq(pdev->irq, vfio_intx_handler,
drivers/vfio/pci/vfio_pci_intrs.c:		disable_irq_nosync(pdev->irq);
drivers/vfio/pci/vfio_pci_intrs.c:	int irq = msix ? vdev->msix[vector].vector : pdev->irq + vector;
drivers/vfio/pci/vfio_pci_intrs.c:		device_lock(&pdev->dev);
drivers/vfio/pci/vfio_pci_intrs.c:		device_unlock(&pdev->dev);
drivers/vfio/pci/vfio_pci_intrs.c:		device_lock(&pdev->dev);
drivers/vfio/pci/vfio_pci_intrs.c:		device_unlock(&pdev->dev);
drivers/vfio/pci/vfio_pci_intrs.c:		device_lock(&pdev->dev);
drivers/vfio/pci/vfio_pci_intrs.c:		device_unlock(&pdev->dev);
drivers/vfio/pci/vfio_pci_intrs.c:		device_lock(&pdev->dev);
drivers/vfio/pci/vfio_pci_intrs.c:		device_unlock(&pdev->dev);
drivers/pcmcia/bfin_cf_pcmcia.c:		dev_dbg(&cf->pdev->dev, ": card %s\n",
drivers/pcmcia/bfin_cf_pcmcia.c:	dev_dbg(&cf->pdev->dev, ": Vcc %d, io_irq %d, flags %04x csc %04x\n",
drivers/pcmcia/bfin_cf_pcmcia.c:	dev_info(&pdev->dev, "Blackfin CompactFlash/PCMCIA Socket Driver\n");
drivers/pcmcia/bfin_cf_pcmcia.c:		dev_err(&pdev->dev,
drivers/pcmcia/bfin_cf_pcmcia.c:	dev_err(&pdev->dev, ": on irq %d\n", irq);
drivers/pcmcia/bfin_cf_pcmcia.c:	dev_dbg(&pdev->dev, ": %s\n",
drivers/pcmcia/bfin_cf_pcmcia.c:	cf->socket.dev.parent = &pdev->dev;
drivers/pcmcia/db1xxx_ss.c:	sock->nr = pdev->id;
drivers/pcmcia/db1xxx_ss.c:	sock->socket.dev.parent	= &pdev->dev;
drivers/pcmcia/at91_cf.c:	struct at91_cf_data	*board = pdev->dev.platform_data;
drivers/pcmcia/at91_cf.c:	device_init_wakeup(&pdev->dev, 1);
drivers/pcmcia/at91_cf.c:	cf->socket.dev.parent = &pdev->dev;
drivers/pcmcia/at91_cf.c:	device_init_wakeup(&pdev->dev, 0);
drivers/pcmcia/at91_cf.c:	device_init_wakeup(&pdev->dev, 0);
drivers/pcmcia/at91_cf.c:	if (device_may_wakeup(&pdev->dev)) {
drivers/pcmcia/at91_cf.c:	if (device_may_wakeup(&pdev->dev)) {
drivers/pcmcia/pxa2xx_viper.c:	if (!pdev->dev.platform_data)
drivers/pcmcia/pxa2xx_viper.c:	viper_pcmcia_device->dev.parent = &pdev->dev;
drivers/pcmcia/pxa2xx_sharpsl.c:	reset_scoop(scoopdev->dev);
drivers/pcmcia/pxa2xx_sharpsl.c:		platform_scoop_config->power_ctrl(scoopdev->dev, 0x0000, skt->nr);
drivers/pcmcia/pxa2xx_sharpsl.c:		write_scoop_reg(scoopdev->dev, SCOOP_CPR, 0x0000);
drivers/pcmcia/pxa2xx_sharpsl.c:	scoopdev->keep_vs = NO_KEEP_VS;
drivers/pcmcia/pxa2xx_sharpsl.c:	scoopdev->keep_rd = 0;
drivers/pcmcia/xxs1500_ss.c:		dev_err(&pdev->dev, "missing 'pcmcia-attr' resource!\n");
drivers/pcmcia/xxs1500_ss.c:		dev_err(&pdev->dev, "missing 'pcmcia-mem' resource!\n");
drivers/pcmcia/xxs1500_ss.c:		dev_err(&pdev->dev, "missing 'pcmcia-io' resource!\n");
drivers/pcmcia/xxs1500_ss.c:		dev_err(&pdev->dev, "cannot remap IO area\n");
drivers/pcmcia/xxs1500_ss.c:	sock->socket.dev.parent	= &pdev->dev;
drivers/pcmcia/xxs1500_ss.c:		dev_err(&pdev->dev, "cannot setup cd irq\n");
drivers/pcmcia/xxs1500_ss.c:		dev_err(&pdev->dev, "failed to register\n");
drivers/pcmcia/omap_cf.c:	seg = (int) pdev->dev.platform_data;
drivers/pcmcia/omap_cf.c:	cf->socket.dev.parent = &pdev->dev;
drivers/pcmcia/bcm63xx_pcmcia.c:	skt->pd = pdev->dev.platform_data;
drivers/pcmcia/bcm63xx_pcmcia.c:	sock->dev.parent = &pdev->dev;
drivers/isdn/gigaset/ser-gigaset.c:	kfree(pdev->resource);
drivers/isdn/hisax/hfc4s8s_l1.c:	hw->irq = pdev->irq;
drivers/isdn/hisax/hisax_fcpcipnp.c:	if (pdev->device == PCI_DEVICE_ID_AVM_A1_V2)
drivers/isdn/hisax/hisax_fcpcipnp.c:	adapter->irq = pdev->irq;
drivers/isdn/hardware/eicon/divasmain.c:	return ((byte) pdev->bus->number);
drivers/isdn/hardware/eicon/divasmain.c:	return ((byte) pdev->devfn);
drivers/isdn/hardware/eicon/divasmain.c:		 pdev->bus->number, pdev->devfn))
drivers/isdn/hardware/eicon/divasmain.c:		       pdev->bus->number, pdev->devfn);
drivers/isdn/hardware/eicon/divasmain.c:			 pdev->bus->number,
drivers/isdn/hardware/eicon/divasmain.c:			 pdev->devfn))
drivers/isdn/hardware/eicon/divasmain.c:			       Name, pdev->bus->number,
drivers/isdn/hardware/eicon/divasmain.c:			       pdev->devfn);
drivers/isdn/hardware/eicon/divasmain.c:			 DRIVERLNAME, pdev->bus->number, pdev->devfn))
drivers/isdn/hardware/eicon/divasmain.c:			       DRIVERLNAME, pdev->bus->number, pdev->devfn);
drivers/isdn/hardware/eicon/divasmain.c:			 pdev->bus->number,
drivers/isdn/hardware/eicon/divasmain.c:			 pdev->devfn))
drivers/isdn/hardware/eicon/divasmain.c:			       Name, pdev->bus->number,
drivers/isdn/hardware/eicon/divasmain.c:			       pdev->devfn);
drivers/isdn/hardware/eicon/divasmain.c:		 pdev->bus->number, pdev->devfn))
drivers/isdn/hardware/eicon/divasmain.c:		       DRIVERLNAME, pdev->bus->number, pdev->devfn);
drivers/isdn/hardware/avm/b1isa.c:	card->irq = pdev->irq;
drivers/isdn/hardware/avm/b1pci.c:	param.irq = pdev->irq;
drivers/isdn/hardware/avm/t1isa.c:	card->irq = pdev->irq;
drivers/isdn/hardware/mISDN/hfcmulti.c:		       pdev->vendor, pdev->device,
drivers/isdn/hardware/mISDN/hfcmulti.c:		       pdev->subsystem_vendor, pdev->subsystem_device);
drivers/isdn/hardware/mISDN/hfcmulti.c:		       "subvendor:%04x subdevice:%04x)\n", pdev->vendor,
drivers/isdn/hardware/mISDN/hfcmulti.c:		       pdev->device, pdev->subsystem_vendor,
drivers/isdn/hardware/mISDN/hfcmulti.c:		       pdev->subsystem_device);
drivers/isdn/hardware/mISDN/mISDNinfineon.c:				    &card->pdev->dev, card->name);
drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->irq = pdev->irq;
drivers/isdn/hardware/mISDN/w6692.c:	err = mISDN_register_device(&card->dch.dev, &card->pdev->dev,
drivers/isdn/hardware/mISDN/w6692.c:	card->irq = pdev->irq;
drivers/isdn/hardware/mISDN/speedfax.c:	err = request_firmware(&firmware, "isdn/ISAR.BIN", &card->pdev->dev);
drivers/isdn/hardware/mISDN/speedfax.c:				    &card->pdev->dev, card->name);
drivers/isdn/hardware/mISDN/speedfax.c:	card->irq = pdev->irq;
drivers/isdn/hardware/mISDN/hfcpci.c:		(char __iomem *)(unsigned long)hc->pdev->resource[1].start;
drivers/isdn/hardware/mISDN/hfcpci.c:	err = mISDN_register_device(&card->dch.dev, &card->pdev->dev, name);
drivers/isdn/hardware/mISDN/hfcpci.c:	card->irq = pdev->irq;
drivers/isdn/hardware/mISDN/netjet.c:	card->irq = card->pdev->irq;
drivers/isdn/hardware/mISDN/netjet.c:	err = mISDN_register_device(&card->isac.dch.dev, &card->pdev->dev,
drivers/isdn/hardware/mISDN/netjet.c:	if (pdev->subsystem_vendor == 0x8086 &&
drivers/isdn/hardware/mISDN/netjet.c:	    pdev->subsystem_device == 0x0003) {
drivers/isdn/hardware/mISDN/netjet.c:	if (pdev->subsystem_vendor == 0x55 &&
drivers/isdn/hardware/mISDN/netjet.c:	    pdev->subsystem_device == 0x02) {
drivers/isdn/hardware/mISDN/netjet.c:	if (pdev->subsystem_vendor == 0xb100 &&
drivers/isdn/hardware/mISDN/netjet.c:	    pdev->subsystem_device == 0x0003) {
drivers/isdn/hardware/mISDN/netjet.c:	card->irq = pdev->irq;
drivers/isdn/hardware/mISDN/avmfritz.c:	err = mISDN_register_device(&card->isac.dch.dev, &card->pdev->dev,
drivers/isdn/hardware/mISDN/avmfritz.c:	if (pdev->device == PCI_DEVICE_ID_AVM_A1_V2)
drivers/isdn/hardware/mISDN/avmfritz.c:	card->irq = pdev->irq;
drivers/vlynq/vlynq.c:	dev->id = pdev->id;
drivers/vlynq/vlynq.c:	dev->dev.parent = &pdev->dev;
drivers/vlynq/vlynq.c:	dev->dev.platform_data = pdev->dev.platform_data;
drivers/sn/ioc3.c:		if (!request_irq(pdev->irq, ioc3_intr_eth, IRQF_SHARED,
drivers/sn/ioc3.c:			idd->irq_eth = pdev->irq;
drivers/sn/ioc3.c:			       __func__, pdev->irq);
drivers/sn/ioc3.c:		if (!request_irq(pdev->irq+2, ioc3_intr_io, IRQF_SHARED,
drivers/sn/ioc3.c:			idd->irq_io = pdev->irq+2;
drivers/sn/ioc3.c:			       __func__, pdev->irq+2);
drivers/sn/ioc3.c:		if (!request_irq(pdev->irq, ioc3_intr_io, IRQF_SHARED,
drivers/sn/ioc3.c:			idd->irq_io = pdev->irq;
drivers/sn/ioc3.c:			       __func__, pdev->irq);
drivers/message/fusion/mptctl.c:	karg->pciId = pdev->device;
drivers/message/fusion/mptctl.c:	karg->hwRev = pdev->revision;
drivers/message/fusion/mptctl.c:	karg->subSystemDevice = pdev->subsystem_device;
drivers/message/fusion/mptctl.c:	karg->subSystemVendor = pdev->subsystem_vendor;
drivers/message/fusion/mptctl.c:		karg->pciInfo.u.bits.busNumber = pdev->bus->number;
drivers/message/fusion/mptctl.c:		karg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );
drivers/message/fusion/mptctl.c:		karg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );
drivers/message/fusion/mptctl.c:		karg->pciInfo.u.bits.busNumber = pdev->bus->number;
drivers/message/fusion/mptctl.c:		karg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );
drivers/message/fusion/mptctl.c:		karg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );
drivers/message/fusion/mptctl.c:		karg->pciInfo.segmentID = pci_domain_nr(pdev->bus);
drivers/message/fusion/mptctl.c:	karg.vendor = pdev->vendor;
drivers/message/fusion/mptctl.c:	karg.device = pdev->device;
drivers/message/fusion/mptctl.c:	karg.subsystem_id = pdev->subsystem_device;
drivers/message/fusion/mptctl.c:	karg.subsystem_vendor = pdev->subsystem_vendor;
drivers/message/fusion/mptctl.c:	karg.devfn = pdev->devfn;
drivers/message/fusion/mptctl.c:	karg.bus = pdev->bus->number;
drivers/message/fusion/mptctl.c:	if (pdev->devfn & 1)
drivers/message/fusion/mptbase.c:		    (&pdev->dev);
drivers/message/fusion/mptbase.c:		if (pdev->device == MPI_MANUFACTPAGE_DEVID_SAS1078)
drivers/message/fusion/mptbase.c:	mpt_get_product_name(pdev->vendor, pdev->device, pdev->revision,
drivers/message/fusion/mptbase.c:	switch (pdev->device)
drivers/message/fusion/mptbase.c:		if (pdev->revision < XL_929) {
drivers/message/fusion/mptbase.c:		if (pdev->revision < C0_1030) {
drivers/message/fusion/mptbase.c:	synchronize_irq(pdev->irq);
drivers/message/fusion/mptbase.c:	u32 device_state = pdev->current_state;
drivers/message/fusion/mptbase.c:		if (pdev->device == MPI_MANUFACTPAGE_DEVID_SAS1078)
drivers/message/fusion/mptbase.c:	if (ioc->bus_type == SAS && (pdev->device ==
drivers/message/fusion/mptbase.c:	    MPI_MANUFACTPAGE_DEVID_SAS1068E || pdev->device ==
drivers/message/fusion/mptbase.c:	unsigned int slot = PCI_SLOT(pdev->devfn);
drivers/message/fusion/mptbase.c:	unsigned int func = PCI_FUNC(pdev->devfn);
drivers/message/fusion/mptbase.c:	    ioc->name, pci_name(pdev), pdev->bus->number,
drivers/message/fusion/mptbase.c:	    pdev->devfn, func-1, func+1));
drivers/message/fusion/mptbase.c:	peer = pci_get_slot(pdev->bus, PCI_DEVFN(slot,func-1));
drivers/message/fusion/mptbase.c:		peer = pci_get_slot(pdev->bus, PCI_DEVFN(slot,func+1));
drivers/message/i2o/iop.c:	struct device *dev = &c->pdev->dev;
drivers/message/i2o/iop.c:		res->name = c->pdev->bus->name;
drivers/message/i2o/iop.c:		res->name = c->pdev->bus->name;
drivers/message/i2o/iop.c:	struct device *dev = &c->pdev->dev;
drivers/message/i2o/device.c:	struct device *dev = &c->pdev->dev;
drivers/message/i2o/i2o_block.c:	ireq->dev = &c->pdev->dev;
drivers/message/i2o/i2o_scsi.c:	dev = &c->pdev->dev;
drivers/message/i2o/pci.c:	dev = &c->pdev->dev;
drivers/message/i2o/pci.c:	struct device *dev = &pdev->dev;
drivers/message/i2o/pci.c:				if (pdev->device == 0xa501) {
drivers/message/i2o/pci.c:					if (pdev->subsystem_device >= 0xc032 &&
drivers/message/i2o/pci.c:					    pdev->subsystem_device <= 0xc03b) {
drivers/message/i2o/pci.c:	if (pdev->vendor == PCI_VENDOR_ID_MOTOROLA && pdev->device == 0x18c0) {
drivers/message/i2o/pci.c:	if (pdev->irq) {
drivers/message/i2o/pci.c:		rc = request_irq(pdev->irq, i2o_pci_interrupt, IRQF_SHARED,
drivers/message/i2o/pci.c:			       "\n", c->name, pdev->irq);
drivers/message/i2o/pci.c:	printk(KERN_INFO "%s: Installed at IRQ %d\n", c->name, pdev->irq);
drivers/message/i2o/pci.c:	if (c->pdev->irq > 0)
drivers/message/i2o/pci.c:		free_irq(c->pdev->irq, c);
drivers/message/i2o/pci.c:	if ((pdev->class & 0xff) > 1) {
drivers/message/i2o/pci.c:	c->device.parent = &pdev->dev;
drivers/message/i2o/pci.c:	if (pdev->vendor == PCI_VENDOR_ID_NCR && pdev->device == 0x0630) {
drivers/message/i2o/pci.c:	if (pdev->subsystem_vendor == PCI_VENDOR_ID_PROMISE) {
drivers/message/i2o/pci.c:		i960 = pci_get_slot(c->pdev->bus,
drivers/message/i2o/pci.c:				  PCI_DEVFN(PCI_SLOT(c->pdev->devfn), 0));
drivers/message/i2o/pci.c:	if (pdev->subsystem_vendor == PCI_VENDOR_ID_DPT)
drivers/message/i2o/pci.c:	if (pdev->vendor == PCI_VENDOR_ID_DPT) {
drivers/message/i2o/pci.c:		if (pdev->device == 0xa511)
drivers/message/i2o/pci.c:		if (pdev->subsystem_device == 0xc05a) {
drivers/message/i2o/exec-osm.c:				dev = &c->pdev->dev;
drivers/message/i2o/exec-osm.c:	dev = &c->pdev->dev;
drivers/message/i2o/memory.c:	dma_addr = dma_map_single(&c->pdev->dev, ptr, size, direction);
drivers/message/i2o/memory.c:	if (!dma_mapping_error(&c->pdev->dev, dma_addr)) {
drivers/message/i2o/memory.c:	sg_count = dma_map_sg(&c->pdev->dev, sg, sg_count, direction);
drivers/message/i2o/memory.c:	if ((sizeof(dma_addr_t) > 4) && (pdev->dma_mask == DMA_BIT_MASK(64))) {
drivers/message/i2o/i2o_config.c:	if (i2o_dma_alloc(&c->pdev->dev, &buffer, fragsize)) {
drivers/message/i2o/i2o_config.c:		i2o_dma_free(&c->pdev->dev, &buffer);
drivers/message/i2o/i2o_config.c:		i2o_dma_free(&c->pdev->dev, &buffer);
drivers/message/i2o/i2o_config.c:	if (i2o_dma_alloc(&c->pdev->dev, &buffer, fragsize)) {
drivers/message/i2o/i2o_config.c:			i2o_dma_free(&c->pdev->dev, &buffer);
drivers/message/i2o/i2o_config.c:	i2o_dma_free(&c->pdev->dev, &buffer);
drivers/message/i2o/i2o_config.c:			if (i2o_dma_alloc(&c->pdev->dev, p, sg_size)) {
drivers/message/i2o/i2o_config.c:		i2o_dma_free(&c->pdev->dev, &sg_list[i]);
drivers/message/i2o/i2o_config.c:			if (i2o_dma_alloc(&c->pdev->dev, p, sg_size)) {
drivers/message/i2o/i2o_config.c:		i2o_dma_free(&c->pdev->dev, &sg_list[i]);
drivers/power/goldfish_battery.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/power/goldfish_battery.c:		dev_err(&pdev->dev, "platform_get_resource failed\n");
drivers/power/goldfish_battery.c:	data->reg_base = devm_ioremap(&pdev->dev, r->start, resource_size(r));
drivers/power/goldfish_battery.c:		dev_err(&pdev->dev, "unable to remap MMIO\n");
drivers/power/goldfish_battery.c:		dev_err(&pdev->dev, "platform_get_irq failed\n");
drivers/power/goldfish_battery.c:	ret = devm_request_irq(&pdev->dev, data->irq, goldfish_battery_interrupt,
drivers/power/goldfish_battery.c:						IRQF_SHARED, pdev->name, data);
drivers/power/goldfish_battery.c:	ret = power_supply_register(&pdev->dev, &data->ac);
drivers/power/goldfish_battery.c:	ret = power_supply_register(&pdev->dev, &data->battery);
drivers/power/tps65090-charger.c:	struct device_node *np = pdev->dev.of_node;
drivers/power/tps65090-charger.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/power/tps65090-charger.c:		dev_err(&pdev->dev, "Memory alloc for tps65090_pdata failed\n");
drivers/power/tps65090-charger.c:	pdata = dev_get_platdata(pdev->dev.parent);
drivers/power/tps65090-charger.c:	if (!pdata && pdev->dev.of_node)
drivers/power/tps65090-charger.c:		dev_err(&pdev->dev, "%s():no platform data available\n",
drivers/power/tps65090-charger.c:	cdata = devm_kzalloc(&pdev->dev, sizeof(*cdata), GFP_KERNEL);
drivers/power/tps65090-charger.c:		dev_err(&pdev->dev, "failed to allocate memory status\n");
drivers/power/tps65090-charger.c:	dev_set_drvdata(&pdev->dev, cdata);
drivers/power/tps65090-charger.c:	cdata->dev			= &pdev->dev;
drivers/power/tps65090-charger.c:	ret = power_supply_register(&pdev->dev, &cdata->ac);
drivers/power/tps65090-charger.c:		dev_err(&pdev->dev, "failed: power supply register\n");
drivers/power/tps65090-charger.c:		dev_warn(&pdev->dev, "Unable to get charger irq = %d\n", irq);
drivers/power/tps65090-charger.c:	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
drivers/power/tps65090-charger.c:		dev_err(&pdev->dev, "charger config failed, err %d\n", ret);
drivers/power/tps65090-charger.c:	struct tps65090_charger *cdata = dev_get_drvdata(&pdev->dev);
drivers/power/ab8500_fg.c:	struct device_node *np = pdev->dev.of_node;
drivers/power/ab8500_fg.c:	struct abx500_bm_data *plat = pdev->dev.platform_data;
drivers/power/ab8500_fg.c:	di = devm_kzalloc(&pdev->dev, sizeof(*di), GFP_KERNEL);
drivers/power/ab8500_fg.c:		dev_err(&pdev->dev, "%s no mem for ab8500_fg\n", __func__);
drivers/power/ab8500_fg.c:		dev_err(&pdev->dev, "no battery management data supplied\n");
drivers/power/ab8500_fg.c:		ret = ab8500_bm_of_probe(&pdev->dev, np, di->bm);
drivers/power/ab8500_fg.c:			dev_err(&pdev->dev, "failed to get battery information\n");
drivers/power/ab8500_fg.c:	di->dev = &pdev->dev;
drivers/power/ab8500_fg.c:	di->parent = dev_get_drvdata(pdev->dev.parent);
drivers/power/abx500_chargalg.c:	struct device_node *np = pdev->dev.of_node;
drivers/power/abx500_chargalg.c:	struct abx500_bm_data *plat = pdev->dev.platform_data;
drivers/power/abx500_chargalg.c:	di = devm_kzalloc(&pdev->dev, sizeof(*di), GFP_KERNEL);
drivers/power/abx500_chargalg.c:		dev_err(&pdev->dev, "%s no mem for ab8500_chargalg\n", __func__);
drivers/power/abx500_chargalg.c:		dev_err(&pdev->dev, "no battery management data supplied\n");
drivers/power/abx500_chargalg.c:		ret = ab8500_bm_of_probe(&pdev->dev, np, di->bm);
drivers/power/abx500_chargalg.c:			dev_err(&pdev->dev, "failed to get battery information\n");
drivers/power/abx500_chargalg.c:	di->dev = &pdev->dev;
drivers/power/abx500_chargalg.c:	di->parent = dev_get_drvdata(pdev->dev.parent);
drivers/power/rx51_battery.c:	di = devm_kzalloc(&pdev->dev, sizeof(*di), GFP_KERNEL);
drivers/power/rx51_battery.c:	di->bat.name = dev_name(&pdev->dev);
drivers/power/ab8500_btemp.c:	struct device_node *np = pdev->dev.of_node;
drivers/power/ab8500_btemp.c:	struct abx500_bm_data *plat = pdev->dev.platform_data;
drivers/power/ab8500_btemp.c:	di = devm_kzalloc(&pdev->dev, sizeof(*di), GFP_KERNEL);
drivers/power/ab8500_btemp.c:		dev_err(&pdev->dev, "%s no mem for ab8500_btemp\n", __func__);
drivers/power/ab8500_btemp.c:		dev_err(&pdev->dev, "no battery management data supplied\n");
drivers/power/ab8500_btemp.c:		ret = ab8500_bm_of_probe(&pdev->dev, np, di->bm);
drivers/power/ab8500_btemp.c:			dev_err(&pdev->dev, "failed to get battery information\n");
drivers/power/ab8500_btemp.c:	di->dev = &pdev->dev;
drivers/power/ab8500_btemp.c:	di->parent = dev_get_drvdata(pdev->dev.parent);
drivers/power/88pm860x_battery.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/power/88pm860x_battery.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
drivers/power/88pm860x_battery.c:		dev_err(&pdev->dev, "No IRQ resource!\n");
drivers/power/88pm860x_battery.c:		dev_err(&pdev->dev, "No IRQ resource!\n");
drivers/power/88pm860x_battery.c:	info->dev = &pdev->dev;
drivers/power/88pm860x_battery.c:	pdata = pdev->dev.platform_data;
drivers/power/88pm860x_battery.c:	ret = power_supply_register(&pdev->dev, &info->battery);
drivers/power/88pm860x_battery.c:	info->battery.dev->parent = &pdev->dev;
drivers/power/88pm860x_battery.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/power/88pm860x_battery.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/power/pcf50633-charger.c:	mbc = devm_kzalloc(&pdev->dev, sizeof(*mbc), GFP_KERNEL);
drivers/power/pcf50633-charger.c:	mbc->pcf = dev_to_pcf50633(pdev->dev.parent);
drivers/power/pcf50633-charger.c:	ret = power_supply_register(&pdev->dev, &mbc->adapter);
drivers/power/pcf50633-charger.c:	ret = power_supply_register(&pdev->dev, &mbc->usb);
drivers/power/pcf50633-charger.c:	ret = power_supply_register(&pdev->dev, &mbc->ac);
drivers/power/pcf50633-charger.c:	ret = sysfs_create_group(&pdev->dev.kobj, &mbc_attr_group);
drivers/power/pcf50633-charger.c:	sysfs_remove_group(&pdev->dev.kobj, &mbc_attr_group);
drivers/power/da9030_battery.c:	struct da9030_battery_info *pdata = pdev->dev.platform_data;
drivers/power/da9030_battery.c:	charger = devm_kzalloc(&pdev->dev, sizeof(*charger), GFP_KERNEL);
drivers/power/da9030_battery.c:	charger->master = pdev->dev.parent;
drivers/power/da9030_battery.c:	ret = power_supply_register(&pdev->dev, &charger->psy);
drivers/power/ab8500_charger.c:	struct device_node *np = pdev->dev.of_node;
drivers/power/ab8500_charger.c:	struct abx500_bm_data *plat = pdev->dev.platform_data;
drivers/power/ab8500_charger.c:	di = devm_kzalloc(&pdev->dev, sizeof(*di), GFP_KERNEL);
drivers/power/ab8500_charger.c:		dev_err(&pdev->dev, "%s no mem for ab8500_charger\n", __func__);
drivers/power/ab8500_charger.c:		dev_err(&pdev->dev, "no battery management data supplied\n");
drivers/power/ab8500_charger.c:		ret = ab8500_bm_of_probe(&pdev->dev, np, di->bm);
drivers/power/ab8500_charger.c:			dev_err(&pdev->dev, "failed to get battery information\n");
drivers/power/ab8500_charger.c:	di->dev = &pdev->dev;
drivers/power/ab8500_charger.c:	di->parent = dev_get_drvdata(pdev->dev.parent);
drivers/power/isp1704_charger.c:	isp = devm_kzalloc(&pdev->dev, sizeof(*isp), GFP_KERNEL);
drivers/power/isp1704_charger.c:	isp->dev = &pdev->dev;
drivers/power/isp1704_charger.c:	dev_err(&pdev->dev, "failed to register isp1704 with error %d\n", ret);
drivers/power/wm831x_power.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/power/wm831x_power.c:	ret = power_supply_register(&pdev->dev, wall);
drivers/power/wm831x_power.c:	ret = power_supply_register(&pdev->dev, usb);
drivers/power/wm831x_power.c:		    ret = power_supply_register(&pdev->dev, battery);
drivers/power/wm831x_power.c:		dev_err(&pdev->dev, "Failed to request SYSLO IRQ %d: %d\n",
drivers/power/wm831x_power.c:		dev_err(&pdev->dev, "Failed to request PWR SRC IRQ %d: %d\n",
drivers/power/wm831x_power.c:			dev_err(&pdev->dev,
drivers/power/intel_mid_battery.c:	return probe(pdev->id, &pdev->dev);
drivers/power/intel_mid_battery.c:	struct pmic_power_module_info *pbi = dev_get_drvdata(&pdev->dev);
drivers/power/bq27x00_battery.c:	struct bq27000_platform_data *pdata = pdev->dev.platform_data;
drivers/power/bq27x00_battery.c:		dev_err(&pdev->dev, "no platform_data supplied\n");
drivers/power/bq27x00_battery.c:		dev_err(&pdev->dev, "no hdq read callback supplied\n");
drivers/power/bq27x00_battery.c:		dev_err(&pdev->dev, "failed to allocate device info data\n");
drivers/power/bq27x00_battery.c:	di->dev = &pdev->dev;
drivers/power/bq27x00_battery.c:	di->bat.name = pdata->name ?: dev_name(&pdev->dev);
drivers/power/ds2780_battery.c:	dev_info = devm_kzalloc(&pdev->dev, sizeof(*dev_info), GFP_KERNEL);
drivers/power/ds2780_battery.c:	dev_info->dev			= &pdev->dev;
drivers/power/ds2780_battery.c:	dev_info->w1_dev		= pdev->dev.parent;
drivers/power/ds2780_battery.c:	dev_info->bat.name		= dev_name(&pdev->dev);
drivers/power/ds2780_battery.c:	ret = power_supply_register(&pdev->dev, &dev_info->bat);
drivers/power/charger-manager.c:	struct charger_desc *desc = dev_get_platdata(&pdev->dev);
drivers/power/charger-manager.c:			dev_err(&pdev->dev, "Cannot get RTC %s.\n",
drivers/power/charger-manager.c:		dev_err(&pdev->dev, "No platform data (desc) found.\n");
drivers/power/charger-manager.c:		dev_err(&pdev->dev, "Cannot allocate memory.\n");
drivers/power/charger-manager.c:	cm->dev = &pdev->dev;
drivers/power/charger-manager.c:		dev_err(&pdev->dev, "Cannot allocate memory.\n");
drivers/power/charger-manager.c:		dev_info(&pdev->dev, "Ignoring full-battery voltage threshold"
drivers/power/charger-manager.c:		dev_info(&pdev->dev, "Disabling full-battery voltage drop "
drivers/power/charger-manager.c:		dev_info(&pdev->dev, "Ignoring full-battery soc(state of"
drivers/power/charger-manager.c:		dev_info(&pdev->dev, "Ignoring full-battery full capacity"
drivers/power/charger-manager.c:		dev_err(&pdev->dev, "charger_regulators undefined.\n");
drivers/power/charger-manager.c:		dev_err(&pdev->dev, "No power supply defined.\n");
drivers/power/charger-manager.c:			dev_err(&pdev->dev, "Cannot find power supply "
drivers/power/charger-manager.c:		dev_err(&pdev->dev, "Cannot find power supply \"%s\"\n",
drivers/power/charger-manager.c:		dev_err(&pdev->dev, "polling_interval_ms is too small\n");
drivers/power/charger-manager.c:		dev_err(&pdev->dev, "there is no temperature_out_of_range\n");
drivers/power/charger-manager.c:		dev_info(&pdev->dev, "Cannot limit charging duration "
drivers/power/charger-manager.c:		dev_err(&pdev->dev, "Cannot allocate for psy properties.\n");
drivers/power/charger-manager.c:		dev_err(&pdev->dev, "Cannot register charger-manager with"
drivers/power/charger-manager.c:		dev_err(&pdev->dev, "Cannot initialize extcon device\n");
drivers/power/charger-manager.c:		dev_err(&pdev->dev,
drivers/power/charger-manager.c:	device_init_wakeup(&pdev->dev, true);
drivers/power/charger-manager.c:	device_set_wakeup_capable(&pdev->dev, false);
drivers/power/s3c_adc_battery.c:	struct s3c_adc_bat_pdata *pdata = pdev->dev.platform_data;
drivers/power/s3c_adc_battery.c:		dev_err(&pdev->dev, "cannot register adc\n");
drivers/power/s3c_adc_battery.c:	ret = power_supply_register(&pdev->dev, &main_bat.psy);
drivers/power/s3c_adc_battery.c:		backup_bat.pdata = pdev->dev.platform_data;
drivers/power/s3c_adc_battery.c:		ret = power_supply_register(&pdev->dev, &backup_bat.psy);
drivers/power/s3c_adc_battery.c:	dev_info(&pdev->dev, "successfully loaded\n");
drivers/power/s3c_adc_battery.c:	device_init_wakeup(&pdev->dev, 1);
drivers/power/s3c_adc_battery.c:	struct s3c_adc_bat_pdata *pdata = pdev->dev.platform_data;
drivers/power/s3c_adc_battery.c:	struct s3c_adc_bat_pdata *pdata = pdev->dev.platform_data;
drivers/power/s3c_adc_battery.c:		if (device_may_wakeup(&pdev->dev))
drivers/power/s3c_adc_battery.c:	struct s3c_adc_bat_pdata *pdata = pdev->dev.platform_data;
drivers/power/s3c_adc_battery.c:		if (device_may_wakeup(&pdev->dev))
drivers/power/wm831x_backup.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/power/wm831x_backup.c:	devdata = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_backup),
drivers/power/wm831x_backup.c:	ret = power_supply_register(&pdev->dev, backup);
drivers/power/pda_power.c:	dev = &pdev->dev;
drivers/power/pda_power.c:	if (pdev->id != -1) {
drivers/power/pda_power.c:	pdata = pdev->dev.platform_data;
drivers/power/pda_power.c:		ret = power_supply_register(&pdev->dev, &pda_psy_ac);
drivers/power/pda_power.c:		ret = power_supply_register(&pdev->dev, &pda_psy_usb);
drivers/power/pda_power.c:		device_init_wakeup(&pdev->dev, 1);
drivers/power/pda_power.c:	if (device_may_wakeup(&pdev->dev)) {
drivers/power/pda_power.c:	if (device_may_wakeup(&pdev->dev)) {
drivers/power/pmu_battery.c:	ret = power_supply_register(&bat_pdev->dev, &pmu_ac);
drivers/power/pmu_battery.c:		ret = power_supply_register(&bat_pdev->dev, &pbat->bat);
drivers/power/jz4740-battery.c:	struct jz_battery_platform_data *pdata = pdev->dev.parent->platform_data;
drivers/power/jz4740-battery.c:		dev_err(&pdev->dev, "No platform_data supplied\n");
drivers/power/jz4740-battery.c:	jz_battery = devm_kzalloc(&pdev->dev, sizeof(*jz_battery), GFP_KERNEL);
drivers/power/jz4740-battery.c:		dev_err(&pdev->dev, "Failed to allocate driver structure\n");
drivers/power/jz4740-battery.c:		dev_err(&pdev->dev, "Failed to get platform irq: %d\n", ret);
drivers/power/jz4740-battery.c:	jz_battery->base = devm_ioremap_resource(&pdev->dev, mem);
drivers/power/jz4740-battery.c:	ret = request_irq(jz_battery->irq, jz_battery_irq_handler, 0, pdev->name,
drivers/power/jz4740-battery.c:		dev_err(&pdev->dev, "Failed to request irq %d\n", ret);
drivers/power/jz4740-battery.c:		ret = gpio_request(pdata->gpio_charge, dev_name(&pdev->dev));
drivers/power/jz4740-battery.c:			dev_err(&pdev->dev, "charger state gpio request failed.\n");
drivers/power/jz4740-battery.c:			dev_err(&pdev->dev, "charger state gpio set direction failed.\n");
drivers/power/jz4740-battery.c:				    dev_name(&pdev->dev), jz_battery);
drivers/power/jz4740-battery.c:				dev_err(&pdev->dev, "Failed to request charge irq: %d\n", ret);
drivers/power/jz4740-battery.c:		jz4740_adc_set_config(pdev->dev.parent, JZ_ADC_CONFIG_BAT_MB,
drivers/power/jz4740-battery.c:		jz4740_adc_set_config(pdev->dev.parent, JZ_ADC_CONFIG_BAT_MB, 0);
drivers/power/jz4740-battery.c:	ret = power_supply_register(&pdev->dev, &jz_battery->battery);
drivers/power/jz4740-battery.c:		dev_err(&pdev->dev, "power supply battery register failed.\n");
drivers/power/max8998_charger.c:	struct max8998_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/power/max8998_charger.c:		dev_err(pdev->dev.parent, "No platform init data supplied\n");
drivers/power/max8998_charger.c:	max8998 = devm_kzalloc(&pdev->dev, sizeof(struct max8998_battery_data),
drivers/power/max8998_charger.c:	max8998->dev = &pdev->dev;
drivers/power/max8903_charger.c:	struct device *dev = &pdev->dev;
drivers/power/max8903_charger.c:	struct max8903_pdata *pdata = pdev->dev.platform_data;
drivers/power/max8925_power.c:	struct device_node *nproot = pdev->dev.parent->of_node;
drivers/power/max8925_power.c:		return pdev->dev.platform_data;
drivers/power/max8925_power.c:		dev_err(&pdev->dev, "failed to find charger node\n");
drivers/power/max8925_power.c:	pdata = devm_kzalloc(&pdev->dev,
drivers/power/max8925_power.c:	return pdev->dev.platform_data;
drivers/power/max8925_power.c:	struct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/power/max8925_power.c:		dev_err(&pdev->dev, "platform data isn't assigned to "
drivers/power/max8925_power.c:	info = devm_kzalloc(&pdev->dev, sizeof(struct max8925_power_info),
drivers/power/max8925_power.c:	ret = power_supply_register(&pdev->dev, &info->ac);
drivers/power/max8925_power.c:	info->ac.dev->parent = &pdev->dev;
drivers/power/max8925_power.c:	ret = power_supply_register(&pdev->dev, &info->usb);
drivers/power/max8925_power.c:	info->usb.dev->parent = &pdev->dev;
drivers/power/max8925_power.c:	ret = power_supply_register(&pdev->dev, &info->battery);
drivers/power/max8925_power.c:	info->battery.dev->parent = &pdev->dev;
drivers/power/ds2781_battery.c:	dev_info = devm_kzalloc(&pdev->dev, sizeof(*dev_info), GFP_KERNEL);
drivers/power/ds2781_battery.c:	dev_info->dev			= &pdev->dev;
drivers/power/ds2781_battery.c:	dev_info->w1_dev		= pdev->dev.parent;
drivers/power/ds2781_battery.c:	dev_info->bat.name		= dev_name(&pdev->dev);
drivers/power/ds2781_battery.c:	ret = power_supply_register(&pdev->dev, &dev_info->bat);
drivers/power/gpio-charger.c:	const struct gpio_charger_platform_data *pdata = pdev->dev.platform_data;
drivers/power/gpio-charger.c:		dev_err(&pdev->dev, "No platform data\n");
drivers/power/gpio-charger.c:		dev_err(&pdev->dev, "Invalid gpio pin\n");
drivers/power/gpio-charger.c:	gpio_charger = devm_kzalloc(&pdev->dev, sizeof(*gpio_charger),
drivers/power/gpio-charger.c:		dev_err(&pdev->dev, "Failed to alloc driver structure\n");
drivers/power/gpio-charger.c:	ret = gpio_request(pdata->gpio, dev_name(&pdev->dev));
drivers/power/gpio-charger.c:		dev_err(&pdev->dev, "Failed to request gpio pin: %d\n", ret);
drivers/power/gpio-charger.c:		dev_err(&pdev->dev, "Failed to set gpio to input: %d\n", ret);
drivers/power/gpio-charger.c:	ret = power_supply_register(&pdev->dev, charger);
drivers/power/gpio-charger.c:		dev_err(&pdev->dev, "Failed to register power supply: %d\n",
drivers/power/gpio-charger.c:				dev_name(&pdev->dev), charger);
drivers/power/gpio-charger.c:			dev_warn(&pdev->dev, "Failed to request irq: %d\n", ret);
drivers/power/twl4030_charger.c:	struct twl4030_bci_platform_data *pdata = pdev->dev.platform_data;
drivers/power/twl4030_charger.c:	bci->dev = &pdev->dev;
drivers/power/twl4030_charger.c:	ret = power_supply_register(&pdev->dev, &bci->ac);
drivers/power/twl4030_charger.c:		dev_err(&pdev->dev, "failed to register ac: %d\n", ret);
drivers/power/twl4030_charger.c:	ret = power_supply_register(&pdev->dev, &bci->usb);
drivers/power/twl4030_charger.c:		dev_err(&pdev->dev, "failed to register usb: %d\n", ret);
drivers/power/twl4030_charger.c:			twl4030_charger_interrupt, IRQF_ONESHOT, pdev->name,
drivers/power/twl4030_charger.c:		dev_err(&pdev->dev, "could not request irq %d, status %d\n",
drivers/power/twl4030_charger.c:			twl4030_bci_interrupt, IRQF_ONESHOT, pdev->name, bci);
drivers/power/twl4030_charger.c:		dev_err(&pdev->dev, "could not request irq %d, status %d\n",
drivers/power/twl4030_charger.c:		dev_err(&pdev->dev, "failed to unmask interrupts: %d\n", ret);
drivers/power/twl4030_charger.c:		dev_warn(&pdev->dev, "failed to unmask interrupts: %d\n", ret);
drivers/power/android_battery.c:	struct android_bat_platform_data *pdata = dev_get_platdata(&pdev->dev);
drivers/power/android_battery.c:	dev_info(&pdev->dev, "Android Battery Driver\n");
drivers/power/android_battery.c:	battery->dev = &pdev->dev;
drivers/power/android_battery.c:	ret = power_supply_register(&pdev->dev, &battery->psy_bat);
drivers/power/android_battery.c:		alloc_workqueue(dev_name(&pdev->dev), WQ_FREEZABLE, 1);
drivers/power/lp8788-charger.c:		dev_info(&pdev->dev, "skip updating charger parameters\n");
drivers/power/lp8788-charger.c:	if (power_supply_register(&pdev->dev, &pchg->charger))
drivers/power/lp8788-charger.c:	if (power_supply_register(&pdev->dev, &pchg->battery))
drivers/power/lp8788-charger.c:			dev_warn(&pdev->dev, "irq setup failed: %s\n", name[i]);
drivers/power/lp8788-charger.c:		dev_err(&pdev->dev, "invalid total number of irqs: %d\n",
drivers/power/lp8788-charger.c:	struct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);
drivers/power/lp8788-charger.c:	struct device *dev = &pdev->dev;
drivers/power/lp8788-charger.c:	lp8788_setup_adc_channel(&pdev->dev, pchg);
drivers/power/lp8788-charger.c:	ret = sysfs_create_group(&pdev->dev.kobj, &lp8788_attr_group);
drivers/power/lp8788-charger.c:	sysfs_remove_group(&pdev->dev.kobj, &lp8788_attr_group);
drivers/power/olpc_battery.c:	ret = power_supply_register(&pdev->dev, &olpc_ac);
drivers/power/olpc_battery.c:	ret = power_supply_register(&pdev->dev, &olpc_bat);
drivers/power/wm8350_power.c:	ret = power_supply_register(&pdev->dev, ac);
drivers/power/wm8350_power.c:	ret = power_supply_register(&pdev->dev, battery);
drivers/power/wm8350_power.c:	ret = power_supply_register(&pdev->dev, usb);
drivers/power/wm8350_power.c:	ret = device_create_file(&pdev->dev, &dev_attr_charger_state);
drivers/power/wm8350_power.c:	device_remove_file(&pdev->dev, &dev_attr_charger_state);
drivers/power/da9052-battery.c:	bat = devm_kzalloc(&pdev->dev, sizeof(struct da9052_battery),
drivers/power/da9052-battery.c:	bat->da9052 = dev_get_drvdata(pdev->dev.parent);
drivers/power/da9052-battery.c:	ret = power_supply_register(&pdev->dev, &bat->psy);
drivers/power/max8997_charger.c:	struct max8997_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/power/max8997_charger.c:			dev_err(&pdev->dev, "Cannot use i2c bus.\n");
drivers/power/max8997_charger.c:		dev_err(&pdev->dev, "incorrect timeout value (%d)\n",
drivers/power/max8997_charger.c:		dev_err(&pdev->dev, "Cannot use i2c bus.\n");
drivers/power/max8997_charger.c:	charger = devm_kzalloc(&pdev->dev, sizeof(struct charger_data),
drivers/power/max8997_charger.c:		dev_err(&pdev->dev, "Cannot allocate memory.\n");
drivers/power/max8997_charger.c:	charger->dev = &pdev->dev;
drivers/power/max8997_charger.c:	ret = power_supply_register(&pdev->dev, &charger->battery);
drivers/power/max8997_charger.c:		dev_err(&pdev->dev, "failed: power supply register\n");
drivers/power/avs/smartreflex.c:		dev_err(&sr_info->pdev->dev, "UNKNOWN IP type %d\n",
drivers/power/avs/smartreflex.c:	fck = clk_get(&sr->pdev->dev, "fck");
drivers/power/avs/smartreflex.c:		dev_err(&sr->pdev->dev, "%s: unable to get fck for device %s\n",
drivers/power/avs/smartreflex.c:				__func__, dev_name(&sr->pdev->dev));
drivers/power/avs/smartreflex.c:		dev_err(&sr->pdev->dev, "%s: Invalid fclk rate: %d\n",
drivers/power/avs/smartreflex.c:		dev_warn(&sr->pdev->dev,
drivers/power/avs/smartreflex.c:		dev_warn(&sr->pdev->dev,
drivers/power/avs/smartreflex.c:	struct omap_sr_data *pdata = sr_info->pdev->dev.platform_data;
drivers/power/avs/smartreflex.c:	dev_err(&sr_info->pdev->dev, "%s: ERROR in registering"
drivers/power/avs/smartreflex.c:		dev_warn(&sr->pdev->dev, "%s: Smartreflex disable timedout\n",
drivers/power/avs/smartreflex.c:		dev_warn(&sr->pdev->dev, "%s: Smartreflex disable timedout\n",
drivers/power/avs/smartreflex.c:		dev_warn(&sr->pdev->dev, "%s: Missing ntarget value table\n",
drivers/power/avs/smartreflex.c:		dev_err(&sr->pdev->dev, "%s: Trying to Configure smartreflex"
drivers/power/avs/smartreflex.c:		dev_err(&sr->pdev->dev, "%s: Trying to Configure smartreflex"
drivers/power/avs/smartreflex.c:		dev_err(&sr->pdev->dev, "%s: Trying to Configure smartreflex"
drivers/power/avs/smartreflex.c:		dev_err(&sr->pdev->dev, "%s: Trying to Configure smartreflex"
drivers/power/avs/smartreflex.c:		dev_warn(&sr->pdev->dev, "%s: Unable to get voltage table"
drivers/power/avs/smartreflex.c:		dev_warn(&sr->pdev->dev, "%s: failure getting SR data for this voltage %ld\n",
drivers/power/avs/smartreflex.c:	pm_runtime_get_sync(&sr->pdev->dev);
drivers/power/avs/smartreflex.c:	if (pm_runtime_suspended(&sr->pdev->dev))
drivers/power/avs/smartreflex.c:			dev_err(&sr->pdev->dev, "UNKNOWN IP type %d\n",
drivers/power/avs/smartreflex.c:	pm_runtime_put_sync_suspend(&sr->pdev->dev);
drivers/power/avs/smartreflex.c:		dev_warn(&sr->pdev->dev, "%s: smartreflex class driver not"
drivers/power/avs/smartreflex.c:		dev_warn(&sr->pdev->dev, "%s: smartreflex class driver not"
drivers/power/avs/smartreflex.c:		dev_warn(&sr->pdev->dev, "%s: smartreflex class driver not"
drivers/power/avs/smartreflex.c:	struct omap_sr_data *pdata = pdev->dev.platform_data;
drivers/power/avs/smartreflex.c:		dev_err(&pdev->dev, "%s: unable to allocate sr_info\n",
drivers/power/avs/smartreflex.c:		dev_err(&pdev->dev, "%s: platform data missing\n", __func__);
drivers/power/avs/smartreflex.c:		dev_err(&pdev->dev, "%s: no mem resource\n", __func__);
drivers/power/avs/smartreflex.c:					dev_name(&pdev->dev));
drivers/power/avs/smartreflex.c:		dev_err(&pdev->dev, "%s: no mem region\n", __func__);
drivers/power/avs/smartreflex.c:	pm_runtime_enable(&pdev->dev);
drivers/power/avs/smartreflex.c:	pm_runtime_irq_safe(&pdev->dev);
drivers/power/avs/smartreflex.c:		dev_err(&pdev->dev, "%s: Unable to alloc SR instance name\n",
drivers/power/avs/smartreflex.c:	sr_info->srid = pdev->id;
drivers/power/avs/smartreflex.c:		dev_err(&pdev->dev, "%s: ioremap fail\n", __func__);
drivers/power/avs/smartreflex.c:	dev_info(&pdev->dev, "%s: SmartReflex driver initialized\n", __func__);
drivers/power/avs/smartreflex.c:		dev_err(&pdev->dev, "%s: Unable to create debugfs directory\n",
drivers/power/avs/smartreflex.c:		dev_err(&pdev->dev, "%s: Unable to create debugfs directory"
drivers/power/avs/smartreflex.c:		dev_warn(&pdev->dev, "%s: %s: No Voltage table for the corresponding vdd. Cannot create debugfs entries for n-values\n",
drivers/power/avs/smartreflex.c:	struct omap_sr_data *pdata = pdev->dev.platform_data;
drivers/power/avs/smartreflex.c:		dev_err(&pdev->dev, "%s: platform data missing\n", __func__);
drivers/power/avs/smartreflex.c:		dev_warn(&pdev->dev, "%s: omap_sr struct not found\n",
drivers/power/avs/smartreflex.c:	struct omap_sr_data *pdata = pdev->dev.platform_data;
drivers/power/avs/smartreflex.c:		dev_err(&pdev->dev, "%s: platform data missing\n", __func__);
drivers/power/avs/smartreflex.c:		dev_warn(&pdev->dev, "%s: omap_sr struct not found\n",
drivers/power/reset/qnap-poweroff.c:		dev_err(&pdev->dev, "Missing resource");
drivers/power/reset/qnap-poweroff.c:	base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/power/reset/qnap-poweroff.c:		dev_err(&pdev->dev, "Unable to map resource");
drivers/power/reset/qnap-poweroff.c:	clk = devm_clk_get(&pdev->dev, NULL);
drivers/power/reset/qnap-poweroff.c:		dev_err(&pdev->dev, "Clk missing");
drivers/power/reset/qnap-poweroff.c:		dev_err(&pdev->dev,
drivers/power/reset/gpio-poweroff.c:	gpio_num = of_get_gpio_flags(pdev->dev.of_node, 0, &flags);
drivers/power/reset/gpio-poweroff.c:	input = of_property_read_bool(pdev->dev.of_node, "input");
drivers/power/reset/restart-poweroff.c:		dev_err(&pdev->dev,
drivers/power/reset/vexpress-poweroff.c:			of_match_device(vexpress_reset_of_match, &pdev->dev);
drivers/power/reset/vexpress-poweroff.c:		func = pdev->id_entry->driver_data;
drivers/power/reset/vexpress-poweroff.c:		vexpress_power_off_device = &pdev->dev;
drivers/power/reset/vexpress-poweroff.c:			vexpress_restart_device = &pdev->dev;
drivers/power/reset/vexpress-poweroff.c:		device_create_file(&pdev->dev, &dev_attr_active);
drivers/power/reset/vexpress-poweroff.c:		vexpress_restart_device = &pdev->dev;
drivers/power/reset/vexpress-poweroff.c:		device_create_file(&pdev->dev, &dev_attr_active);
drivers/power/generic-adc-battery.c:	struct gab_platform_data *pdata = pdev->dev.platform_data;
drivers/power/generic-adc-battery.c:	adc_bat = devm_kzalloc(&pdev->dev, sizeof(*adc_bat), GFP_KERNEL);
drivers/power/generic-adc-battery.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/power/generic-adc-battery.c:		adc_bat->channel[chan] = iio_channel_get(&pdev->dev,
drivers/power/generic-adc-battery.c:	ret = power_supply_register(&pdev->dev, psy);
drivers/power/ds2760_battery.c:	di = devm_kzalloc(&pdev->dev, sizeof(*di), GFP_KERNEL);
drivers/power/ds2760_battery.c:	di->dev			= &pdev->dev;
drivers/power/ds2760_battery.c:	di->w1_dev		= pdev->dev.parent;
drivers/power/ds2760_battery.c:	di->bat.name		= dev_name(&pdev->dev);
drivers/power/ds2760_battery.c:	retval = power_supply_register(&pdev->dev, &di->bat);
drivers/power/ds2760_battery.c:	di->monitor_wqueue = create_singlethread_workqueue(dev_name(&pdev->dev));
drivers/power/88pm860x_charger.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/power/88pm860x_charger.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
drivers/power/88pm860x_charger.c:	count = pdev->num_resources;
drivers/power/88pm860x_charger.c:		dev_err(&pdev->dev, "Missed I2C address of 88PM8606!\n");
drivers/power/88pm860x_charger.c:	info->dev = &pdev->dev;
drivers/power/88pm860x_charger.c:	ret = power_supply_register(&pdev->dev, &info->usb);
drivers/scsi/fnic/fnic_isr.c:		free_irq(fnic->pdev->irq, fnic);
drivers/scsi/fnic/fnic_isr.c:		err = request_irq(fnic->pdev->irq, &fnic_isr_legacy,
drivers/scsi/fnic/fnic_isr.c:		err = request_irq(fnic->pdev->irq, &fnic_isr_msi,
drivers/scsi/fnic/fnic_main.c:	err = scsi_add_host(lp->host, &pdev->dev);
drivers/scsi/ufs/ufshcd-pci.c:	disable_irq(pdev->irq);
drivers/scsi/ufs/ufshcd-pci.c:	free_irq(pdev->irq, hba);
drivers/scsi/ufs/ufshcd-pci.c:		dev_err(&pdev->dev, "pci_enable_device failed\n");
drivers/scsi/ufs/ufshcd-pci.c:		dev_err(&pdev->dev, "request regions failed\n");
drivers/scsi/ufs/ufshcd-pci.c:		dev_err(&pdev->dev, "memory map failed\n");
drivers/scsi/ufs/ufshcd-pci.c:		dev_err(&pdev->dev, "set dma mask failed\n");
drivers/scsi/ufs/ufshcd-pci.c:	err = ufshcd_init(&pdev->dev, &hba, mmio_base, pdev->irq);
drivers/scsi/ufs/ufshcd-pci.c:		dev_err(&pdev->dev, "Initialization failed\n");
drivers/scsi/ufs/ufshcd-pltfrm.c:	struct device *dev = &pdev->dev;
drivers/scsi/ufs/ufshcd-pltfrm.c:		dev_err(&pdev->dev,
drivers/scsi/ufs/ufshcd-pltfrm.c:		dev_err(&pdev->dev,
drivers/scsi/ufs/ufshcd-pltfrm.c:		dev_err(&pdev->dev, "memory map failed\n");
drivers/scsi/ufs/ufshcd-pltfrm.c:		dev_err(&pdev->dev, "IRQ resource not available\n");
drivers/scsi/ufs/ufshcd-pltfrm.c:		dev_err(&pdev->dev, "set dma mask failed\n");
drivers/scsi/ufs/ufshcd-pltfrm.c:	err = ufshcd_init(&pdev->dev, &hba, mmio_base, irq_res->start);
drivers/scsi/ufs/ufshcd-pltfrm.c:		dev_err(&pdev->dev, "Intialization failed\n");
drivers/scsi/ufs/ufshcd-pltfrm.c:		dev_err(&pdev->dev, "ufshcd: Memory resource not available\n");
drivers/scsi/lpfc/lpfc_init.c:		pdev->needs_freset = 1;
drivers/scsi/lpfc/lpfc_init.c:		dev_err(&pdev->dev, "failed to allocate hba struct\n");
drivers/scsi/lpfc/lpfc_init.c:		dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/lpfc/lpfc_init.c:		dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/lpfc/lpfc_init.c:	phba->slim2p.virt = dma_alloc_coherent(&pdev->dev,
drivers/scsi/lpfc/lpfc_init.c:	phba->hbqslimp.virt = dma_alloc_coherent(&pdev->dev,
drivers/scsi/lpfc/lpfc_init.c:	dma_free_coherent(&pdev->dev, SLI2_SLIM_SIZE,
drivers/scsi/lpfc/lpfc_init.c:	dma_free_coherent(&pdev->dev, lpfc_sli_hbq_size(),
drivers/scsi/lpfc/lpfc_init.c:	dma_free_coherent(&pdev->dev, SLI2_SLIM_SIZE,
drivers/scsi/lpfc/lpfc_init.c:			dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/lpfc/lpfc_init.c:			dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/lpfc/lpfc_init.c:			dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/lpfc/lpfc_init.c:			dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/lpfc/lpfc_init.c:			dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/lpfc/lpfc_init.c:	dma_free_coherent(&pdev->dev, lpfc_sli_hbq_size(),
drivers/scsi/lpfc/lpfc_init.c:	dma_free_coherent(&pdev->dev, SLI2_SLIM_SIZE,
drivers/scsi/lpfc/lpfc_init.c:	if (pdev->is_busmaster)
drivers/scsi/lpfc/lpfc_init.c:	dev_printk(KERN_INFO, &pdev->dev, "recovering from a slot reset.\n");
drivers/scsi/lpfc/lpfc_init.c:	if (pdev->is_busmaster)
drivers/scsi/lpfc/lpfc_init.c:	if (pdev->is_busmaster)
drivers/scsi/lpfc/lpfc_init.c:	dev_printk(KERN_INFO, &pdev->dev, "recovering from a slot reset.\n");
drivers/scsi/lpfc/lpfc_init.c:	if (pdev->is_busmaster)
drivers/scsi/ipr.h:		dev_err(&(hostrcb)->ioa_cfg->pdev->dev, fmt, __VA_ARGS__); \
drivers/scsi/advansys.c:			if (PCI_FUNC(pdev->devfn) == 0) {
drivers/scsi/advansys.c:			if ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||
drivers/scsi/advansys.c:			    (pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {
drivers/scsi/advansys.c:		if (PCI_FUNC(pdev->devfn) != 0) {
drivers/scsi/advansys.c:		if (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW) {
drivers/scsi/advansys.c:		} else if (pdev->device == PCI_DEVICE_ID_38C0800_REV1) {
drivers/scsi/advansys.c:	if ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||
drivers/scsi/advansys.c:	    (pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {
drivers/scsi/advansys.c:	board->irq = pdev->irq;
drivers/scsi/advansys.c:	board->dev = &pdev->dev;
drivers/scsi/advansys.c:	if (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW ||
drivers/scsi/advansys.c:	    pdev->device == PCI_DEVICE_ID_38C0800_REV1 ||
drivers/scsi/advansys.c:	    pdev->device == PCI_DEVICE_ID_38C1600_REV1) {
drivers/scsi/isci/request.c:		dma_addr = dma_map_single(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_err(&ireq->owning_controller->pdev->dev,
drivers/scsi/isci/request.c:		dev_err(&ireq->owning_controller->pdev->dev,
drivers/scsi/isci/request.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_warn(&ireq->owning_controller->pdev->dev,
drivers/scsi/isci/request.c:		dev_warn(&ihost->pdev->dev, "%s: (%x) in wrong state %s\n",
drivers/scsi/isci/request.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_warn(&ireq->owning_controller->pdev->dev,
drivers/scsi/isci/request.c:		dev_err(&ireq->isci_host->pdev->dev,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:				dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_warn(&ireq->isci_host->pdev->dev,
drivers/scsi/isci/request.c:		dev_warn(&ihost->pdev->dev, "%s: %x in wrong state %s\n",
drivers/scsi/isci/request.c:	dev_dbg(&request->isci_host->pdev->dev,
drivers/scsi/isci/request.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:							 &ihost->pdev->dev);
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dev_dbg(&ihost->pdev->dev, "%s: SCI_IO_SUCCESS\n",
drivers/scsi/isci/request.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dma_unmap_single(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			dma_unmap_sg(&ihost->pdev->dev, task->scatter,
drivers/scsi/isci/request.c:		dma_unmap_sg(&ihost->pdev->dev, sg, 1, DMA_TO_DEVICE);
drivers/scsi/isci/request.c:	dev_dbg(&request->isci_host->pdev->dev,
drivers/scsi/isci/request.c:	dev_dbg(&ireq->isci_host->pdev->dev,
drivers/scsi/isci/request.c:	struct device *dev = &ireq->isci_host->pdev->dev;
drivers/scsi/isci/request.c:		dev_dbg(&ireq->isci_host->pdev->dev,
drivers/scsi/isci/request.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:			&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/request.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/init.c:	sas_phys = devm_kzalloc(&isci_host->pdev->dev,
drivers/scsi/isci/init.c:	sas_ports = devm_kzalloc(&isci_host->pdev->dev,
drivers/scsi/isci/init.c:		dev_err(&pdev->dev,
drivers/scsi/isci/init.c:		err = devm_request_irq(&pdev->dev, msix->vector, isr, 0,
drivers/scsi/isci/init.c:		dev_info(&pdev->dev, "msix setup failed falling back to intx\n");
drivers/scsi/isci/init.c:			devm_free_irq(&pdev->dev, msix->vector, ihost);
drivers/scsi/isci/init.c:		err = devm_request_irq(&pdev->dev, pdev->irq, isci_intx_isr,
drivers/scsi/isci/init.c:	ihost = devm_kzalloc(&pdev->dev, sizeof(*ihost), GFP_KERNEL);
drivers/scsi/isci/init.c:	ihost->sas_ha.dev = &ihost->pdev->dev;
drivers/scsi/isci/init.c:		dev_warn(&pdev->dev,
drivers/scsi/isci/init.c:			dev_warn(&pdev->dev, "parsing firmware oem parameters failed\n");
drivers/scsi/isci/init.c:		dev_warn(&pdev->dev, "oem parameter validation failed\n");
drivers/scsi/isci/init.c:	dev_info(&pdev->dev, "%sSCU controller %d: phy 3-0 cables: "
drivers/scsi/isci/init.c:	err = scsi_add_host(shost, &pdev->dev);
drivers/scsi/isci/init.c:	dev_info(&pdev->dev, "driver configured for rev: %d silicon\n",
drivers/scsi/isci/init.c:		 pdev->revision);
drivers/scsi/isci/init.c:	pci_info = devm_kzalloc(&pdev->dev, sizeof(*pci_info), GFP_KERNEL);
drivers/scsi/isci/init.c:			dev_warn(&pdev->dev,
drivers/scsi/isci/init.c:			dev_warn(&pdev->dev,
drivers/scsi/isci/init.c:			dev_warn(&pdev->dev,
drivers/scsi/isci/init.c:		dev_info(&pdev->dev,
drivers/scsi/isci/init.c:		dev_err(&pdev->dev,
drivers/scsi/isci/host.h:	return &idev->isci_port->isci_host->pdev->dev;
drivers/scsi/isci/host.h:	if (pdev->revision < 4)
drivers/scsi/isci/host.h:	if (pdev->revision == 4)
drivers/scsi/isci/host.h:	if (pdev->revision == 5)
drivers/scsi/isci/host.h:	if (pdev->revision >= 6)
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev, "%s: task = %p, response=%d, status=%d\n",
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev, "%s: num=%d\n", __func__, num);
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_dbg(&ihost->pdev->dev, "%s: No dev\n", __func__);
drivers/scsi/isci/task.c:	dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/task.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev, "%s: idev %p\n", __func__, idev);
drivers/scsi/isci/task.c:	dev_dbg(&ihost->pdev->dev, "%s: idev %p complete, reset_stat=%d.\n",
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:		dev_dbg(&ihost->pdev->dev, "%s: failed isci_get_device(idev=%p)\n",
drivers/scsi/isci/remote_device.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:				dev_warn(&ihost->pdev->dev, "%s host%d timeout single\n",
drivers/scsi/isci/remote_device.c:				dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:				dev_warn(&ihost->pdev->dev, "%s host%d timeout all\n",
drivers/scsi/isci/remote_device.c:				dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:		dev_dbg(&ihost->pdev->dev, "%s: idev=%p, wait done\n",
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev, "%s: starting resume wait: %p\n",
drivers/scsi/isci/remote_device.c:		dev_warn(&ihost->pdev->dev, "%s: #### Timeout waiting for "
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev, "%s: resume wait done: %p\n",
drivers/scsi/isci/remote_device.c:		dev_dbg(&ihost->pdev->dev, "%s: construct failed: %d\n",
drivers/scsi/isci/remote_device.c:		dev_warn(&ihost->pdev->dev, "remote device start failed: %d\n",
drivers/scsi/isci/remote_device.c:		dev_warn(&ihost->pdev->dev, "%s: failed\n", __func__);
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/remote_device.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/remote_device.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/remote_device.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s: %x for io request %p\n",
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s: %x for device %p\n",
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s: unknown completion type %x\n",
drivers/scsi/isci/host.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/host.c:				dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:				dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:			dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_err(&ihost->pdev->dev, "%s: status: %#x\n", __func__,
drivers/scsi/isci/host.c:		dev_info(&ihost->pdev->dev,
drivers/scsi/isci/host.c:			dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
drivers/scsi/isci/host.c:			dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:			dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
drivers/scsi/isci/host.c:			dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:			dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:				dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
drivers/scsi/isci/host.c:	struct device *dev = &ihost->pdev->dev;
drivers/scsi/isci/host.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/host.c:	dev_dbg(&ihost->pdev->dev, "%s[%d]: %#x\n",
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
drivers/scsi/isci/host.c:	dev_dbg(&ihost->pdev->dev, "%s: status=%d; ireq=%p; flags=%lx\n",
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
drivers/scsi/isci/host.c:		dev_warn(&ihost->pdev->dev,
drivers/scsi/isci/task.h:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/task.h:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/probe_roms.c:	rom = devm_kzalloc(&pdev->dev, sizeof(*rom), GFP_KERNEL);
drivers/scsi/isci/probe_roms.c:		dev_warn(&pdev->dev,
drivers/scsi/isci/probe_roms.c:				dev_warn(&pdev->dev,
drivers/scsi/isci/probe_roms.c:			dev_info(&pdev->dev,
drivers/scsi/isci/probe_roms.c:		dev_err(&pdev->dev, "oprom parse error\n");
drivers/scsi/isci/probe_roms.c:	if (request_firmware(&fw, ISCI_FW_NAME, &pdev->dev) != 0)
drivers/scsi/isci/probe_roms.c:	orom = devm_kzalloc(&pdev->dev, fw->size, GFP_KERNEL);
drivers/scsi/isci/probe_roms.c:	efi_data = devm_kzalloc(&pdev->dev, data_len, GFP_KERNEL);
drivers/scsi/isci/probe_roms.c:		dev_warn(&pdev->dev,
drivers/scsi/isci/probe_roms.c:		dev_warn(&pdev->dev,
drivers/scsi/isci/probe_roms.c:		dev_warn(&pdev->dev,
drivers/scsi/isci/probe_roms.c:		dev_warn(&pdev->dev,
drivers/scsi/isci/probe_roms.c:		dev_warn(&pdev->dev,
drivers/scsi/isci/phy.c:	return &phy_to_host(iphy)->pdev->dev;
drivers/scsi/isci/phy.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/phy.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/port.c:	return &ihost->pdev->dev;
drivers/scsi/isci/port.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/port.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/port.c:		dev_err(&isci_host->pdev->dev, "%s: unknown target\n", __func__);
drivers/scsi/isci/port.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/port.c:				dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/port.c:	dev_dbg(&isci_host->pdev->dev,
drivers/scsi/isci/port.c:	dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/port.c:		dev_warn(&ihost->pdev->dev, "Invalid link up!\n");
drivers/scsi/isci/port.c:	dev_dbg(&ihost->pdev->dev, "%s: port%d ready\n",
drivers/scsi/isci/port.c:	dev_dbg(&ihost->pdev->dev, "%s: port%d !ready\n",
drivers/scsi/isci/port.c:		dev_dbg(&ihost->pdev->dev, "%s: port%d !ready\n",
drivers/scsi/isci/port.c:		dev_dbg(&ihost->pdev->dev, "%s: port%d !ready\n",
drivers/scsi/isci/port.c:	dev_dbg(&ihost->pdev->dev, "%s: iport = %p\n",
drivers/scsi/isci/port.c:		dev_dbg(&ihost->pdev->dev,
drivers/scsi/isci/port.c:			dev_err(&ihost->pdev->dev,
drivers/scsi/isci/port.c:		dev_err(&ihost->pdev->dev,
drivers/scsi/isci/port.c:		dev_dbg(&ihost->pdev->dev, "%s: port: %ld\n",
drivers/scsi/tmscsim.c:	shost->irq = pdev->irq;
drivers/scsi/tmscsim.c:	pACB->IRQLevel = pdev->irq;
drivers/scsi/tmscsim.c:	if (request_irq(pdev->irq, do_DC390_Interrupt, IRQF_SHARED,
drivers/scsi/tmscsim.c:	error = scsi_add_host(shost, &pdev->dev);
drivers/scsi/tmscsim.c:	free_irq(pdev->irq, pACB);
drivers/scsi/fdomain.c:	   pdev->bus->number,
drivers/scsi/fdomain.c:	   PCI_SLOT(pdev->devfn),
drivers/scsi/fdomain.c:	   PCI_FUNC(pdev->devfn));
drivers/scsi/fdomain.c:   pci_irq = pdev->irq;
drivers/scsi/nsp32.c:	ret = scsi_add_host(host, &pdev->dev);
drivers/scsi/nsp32.c:	data->IrqNumber   = pdev->irq;
drivers/scsi/nsp32.c:		  pdev->irq,
drivers/scsi/bfa/bfad.c:	bfad->hal_pcidev.pci_slot = PCI_SLOT(pdev->devfn);
drivers/scsi/bfa/bfad.c:	bfad->hal_pcidev.pci_func = PCI_FUNC(pdev->devfn);
drivers/scsi/bfa/bfad.c:	bfad->hal_pcidev.device_id = pdev->device;
drivers/scsi/bfa/bfad.c:	bfad->hal_pcidev.ssid = pdev->subsystem_device;
drivers/scsi/bfa/bfad.c:	bfad->pci_attr.vendor_id = pdev->vendor;
drivers/scsi/bfa/bfad.c:	bfad->pci_attr.device_id = pdev->device;
drivers/scsi/bfa/bfad.c:	bfad->pci_attr.ssid = pdev->subsystem_device;
drivers/scsi/bfa/bfad.c:	bfad->pci_attr.ssvid = pdev->subsystem_vendor;
drivers/scsi/bfa/bfad.c:	bfad->pci_attr.pcifn = PCI_FUNC(pdev->devfn);
drivers/scsi/bfa/bfad.c:	if ((bfa_asic_id_ctc(pdev->device) && !msix_disable_ct) ||
drivers/scsi/bfa/bfad.c:	   (bfa_asic_id_cb(pdev->device) && !msix_disable_cb)) {
drivers/scsi/bfa/bfad.c:			if (bfa_asic_id_ctc(pdev->device)) {
drivers/scsi/bfa/bfad.c:	if ((pdev->device == BFA_PCI_DEVICE_ID_FC_8G1P) &&
drivers/scsi/bfa/bfad.c:		(PCI_FUNC(pdev->devfn) != 0))
drivers/scsi/bfa/bfad.c:	dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/bfa/bfad.c:		dev_printk(KERN_WARNING, &pdev->dev,
drivers/scsi/bfa/bfad.c:		dev_printk(KERN_WARNING, &pdev->dev,
drivers/scsi/bfa/bfad.c:	dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/bfa/bfad.c:		dev_printk(KERN_ERR, &pdev->dev, "Cannot re-enable "
drivers/scsi/bfa/bfad.c:		dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/bfa/bfad.c:	dev_printk(KERN_WARNING, &pdev->dev,
drivers/scsi/bfa/bfad.c:	dev_printk(KERN_INFO, &pdev->dev, "mmio_enabled\n");
drivers/scsi/bfa/bfad.c:	dev_printk(KERN_WARNING, &pdev->dev, "resume\n");
drivers/scsi/bfa/bfad.c:	if (request_firmware(&fw, fw_name, &pdev->dev)) {
drivers/scsi/bfa/bfad.c:	if (bfa_asic_id_ct2(pdev->device)) {
drivers/scsi/bfa/bfad.c:	} else if (bfa_asic_id_ct(pdev->device)) {
drivers/scsi/bfa/bfad.c:	} else if (bfa_asic_id_cb(pdev->device)) {
drivers/scsi/qla2xxx/qla_attr.c:	ha->xgmac_data = dma_alloc_coherent(&ha->pdev->dev, XGMAC_DATA_SIZE,
drivers/scsi/qla2xxx/qla_attr.c:	ha->dcbx_tlv = dma_alloc_coherent(&ha->pdev->dev, DCBX_TLV_DATA_SIZE,
drivers/scsi/qla2xxx/qla_attr.c:	return snprintf(buf, PAGE_SIZE, "ISP%04X\n", vha->hw->pdev->device);
drivers/scsi/qla2xxx/qla_attr.c:				   &ha->pdev->dev)) {
drivers/scsi/qla2xxx/qla_isr.c:		if (unlikely(IS_QLA83XX(ha) && (ha->pdev->revision == 1)))
drivers/scsi/qla2xxx/qla_isr.c:	if (ha->pdev->subsystem_vendor == PCI_VENDOR_ID_HP &&
drivers/scsi/qla2xxx/qla_isr.c:		(ha->pdev->subsystem_device == 0x7040 ||
drivers/scsi/qla2xxx/qla_isr.c:		ha->pdev->subsystem_device == 0x7041 ||
drivers/scsi/qla2xxx/qla_isr.c:		ha->pdev->subsystem_device == 0x1705)) {
drivers/scsi/qla2xxx/qla_isr.c:			ha->pdev->subsystem_vendor,
drivers/scsi/qla2xxx/qla_isr.c:			ha->pdev->subsystem_device);
drivers/scsi/qla2xxx/qla_isr.c:	if (IS_QLA2432(ha) && (ha->pdev->revision < QLA_MSIX_CHIP_REV_24XX)) {
drivers/scsi/qla2xxx/qla_isr.c:		    ha->pdev->revision, QLA_MSIX_CHIP_REV_24XX);
drivers/scsi/qla2xxx/qla_isr.c:	ret = request_irq(ha->pdev->irq, ha->isp_ops->intr_handler,
drivers/scsi/qla2xxx/qla_isr.c:		    ha->pdev->irq);
drivers/scsi/qla2xxx/qla_isr.c:		free_irq(ha->pdev->irq, rsp);
drivers/scsi/qla2xxx/qla_isr.c:		free_irq(ha->pdev->irq, rsp);
drivers/scsi/qla2xxx/qla_os.c:			dma_free_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:		dma_free_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:			dma_free_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:		dma_free_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:		dma_unmap_sg(&ha->pdev->dev, scsi_prot_sglist(cmd),
drivers/scsi/qla2xxx/qla_os.c:	if (!dma_set_mask(&ha->pdev->dev, DMA_BIT_MASK(64))) {
drivers/scsi/qla2xxx/qla_os.c:		if (MSD(dma_get_required_mask(&ha->pdev->dev)) &&
drivers/scsi/qla2xxx/qla_os.c:	dma_set_mask(&ha->pdev->dev, DMA_BIT_MASK(32));
drivers/scsi/qla2xxx/qla_os.c:	switch (ha->pdev->device) {
drivers/scsi/qla2xxx/qla_os.c:		if (ha->pdev->subsystem_vendor == 0x1028 &&
drivers/scsi/qla2xxx/qla_os.c:		    ha->pdev->subsystem_device == 0x0170)
drivers/scsi/qla2xxx/qla_os.c:	if (pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2422 ||
drivers/scsi/qla2xxx/qla_os.c:	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2432 ||
drivers/scsi/qla2xxx/qla_os.c:	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8432 ||
drivers/scsi/qla2xxx/qla_os.c:	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP5422 ||
drivers/scsi/qla2xxx/qla_os.c:	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP5432 ||
drivers/scsi/qla2xxx/qla_os.c:	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2532 ||
drivers/scsi/qla2xxx/qla_os.c:	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8001 ||
drivers/scsi/qla2xxx/qla_os.c:	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8021 ||
drivers/scsi/qla2xxx/qla_os.c:	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2031 ||
drivers/scsi/qla2xxx/qla_os.c:	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8031 ||
drivers/scsi/qla2xxx/qla_os.c:	    pdev->device == PCI_DEVICE_ID_QLOGIC_ISPF001) {
drivers/scsi/qla2xxx/qla_os.c:		pdev->needs_freset = 1;
drivers/scsi/qla2xxx/qla_os.c:		ha->portnum = PCI_FUNC(ha->pdev->devfn);
drivers/scsi/qla2xxx/qla_os.c:	    pdev->device, pdev->irq, ha->iobase);
drivers/scsi/qla2xxx/qla_os.c:	base_vha->host->irq = ha->pdev->irq;
drivers/scsi/qla2xxx/qla_os.c:	ret = scsi_add_host(host, &pdev->dev);
drivers/scsi/qla2xxx/qla_os.c:	    pdev->device, ha->isp_ops->pci_info_str(base_vha, pci_info),
drivers/scsi/qla2xxx/qla_os.c:	if (!atomic_read(&pdev->enable_cnt))
drivers/scsi/qla2xxx/qla_os.c:	if (!atomic_read(&pdev->enable_cnt))
drivers/scsi/qla2xxx/qla_os.c:	ha->init_cb = dma_alloc_coherent(&ha->pdev->dev, ha->init_cb_size,
drivers/scsi/qla2xxx/qla_os.c:	ha->gid_list = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:		ha->pdev->device);
drivers/scsi/qla2xxx/qla_os.c:	ha->s_dma_pool = dma_pool_create(name, &ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:		ha->dl_dma_pool = dma_pool_create(name, &ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:		ha->fcp_cmnd_dma_pool = dma_pool_create(name, &ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:		ha->sns_cmd = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:		ha->ct_sns = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:	(*req)->ring = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:	(*rsp)->ring = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:	dma_free_coherent(&ha->pdev->dev, ((*rsp)->length + 1) *
drivers/scsi/qla2xxx/qla_os.c:	dma_free_coherent(&ha->pdev->dev, ((*req)->length + 1) *
drivers/scsi/qla2xxx/qla_os.c:	dma_free_coherent(&ha->pdev->dev, sizeof(struct ct_sns_pkt),
drivers/scsi/qla2xxx/qla_os.c:	dma_free_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),
drivers/scsi/qla2xxx/qla_os.c:	dma_free_coherent(&ha->pdev->dev, ha->init_cb_size, ha->init_cb,
drivers/scsi/qla2xxx/qla_os.c:		dma_free_coherent(&ha->pdev->dev, FCE_SIZE, ha->fce,
drivers/scsi/qla2xxx/qla_os.c:			dma_free_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_os.c:		dma_free_coherent(&ha->pdev->dev, MCTP_DUMP_SIZE, ha->mctp_dump,
drivers/scsi/qla2xxx/qla_os.c:		dma_free_coherent(&ha->pdev->dev, DCBX_TLV_DATA_SIZE,
drivers/scsi/qla2xxx/qla_os.c:		dma_free_coherent(&ha->pdev->dev, XGMAC_DATA_SIZE,
drivers/scsi/qla2xxx/qla_os.c:		dma_free_coherent(&ha->pdev->dev, sizeof(struct sns_cmd_pkt),
drivers/scsi/qla2xxx/qla_os.c:		dma_free_coherent(&ha->pdev->dev, sizeof(struct ct_sns_pkt),
drivers/scsi/qla2xxx/qla_os.c:		dma_free_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),
drivers/scsi/qla2xxx/qla_os.c:		dma_free_coherent(&ha->pdev->dev, ha->init_cb_size,
drivers/scsi/qla2xxx/qla_os.c:	    dev_name(&(ha->pdev->dev)));
drivers/scsi/qla2xxx/qla_os.c:	kobject_uevent_env(&vha->hw->pdev->dev.kobj, KOBJ_CHANGE, envp);
drivers/scsi/qla2xxx/qla_os.c:	if (request_firmware(&blob->fw, blob->name, &ha->pdev->dev)) {
drivers/scsi/qla2xxx/qla_os.c:	fn = PCI_FUNC(ha->pdev->devfn);
drivers/scsi/qla2xxx/qla_os.c:		    pci_get_domain_bus_and_slot(pci_domain_nr(ha->pdev->bus),
drivers/scsi/qla2xxx/qla_os.c:		    ha->pdev->bus->number, PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),
drivers/scsi/qla2xxx/qla_os.c:		if (atomic_read(&other_pdev->enable_cnt)) {
drivers/scsi/qla2xxx/qla_os.c:		    ha->pdev->devfn);
drivers/scsi/qla2xxx/qla_os.c:		    ha->pdev->devfn);
drivers/scsi/qla2xxx/qla_os.c:	pdev->error_state = pci_channel_io_normal;
drivers/scsi/qla2xxx/qla_sup.c:		optrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,
drivers/scsi/qla2xxx/qla_sup.c:				dma_free_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_sup.c:		dma_free_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_sup.c:	optrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,
drivers/scsi/qla2xxx/qla_sup.c:			dma_free_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,
drivers/scsi/qla2xxx/qla_sup.c:	dma_free_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE, optrom,
drivers/scsi/qla2xxx/qla_mid.c:	dma_free_coherent(&ha->pdev->dev, (req->length + 1) *
drivers/scsi/qla2xxx/qla_mid.c:	dma_free_coherent(&ha->pdev->dev, (rsp->length + 1) *
drivers/scsi/qla2xxx/qla_mid.c:	req->ring = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_mid.c:	rsp->ring = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_dbg.c:	fw_dump->vendor = htonl(ha->pdev->vendor);
drivers/scsi/qla2xxx/qla_dbg.c:	fw_dump->device = htonl(ha->pdev->device);
drivers/scsi/qla2xxx/qla_dbg.c:	fw_dump->subsystem_vendor = htonl(ha->pdev->subsystem_vendor);
drivers/scsi/qla2xxx/qla_dbg.c:	fw_dump->subsystem_device = htonl(ha->pdev->subsystem_device);
drivers/scsi/qla2xxx/qla_dbg.c:			QL_MSGHDR, dev_name(&(pdev->dev)), id + ql_dbg_offset,
drivers/scsi/qla2xxx/qla_dbg.c:		QL_MSGHDR, dev_name(&(pdev->dev)), id + ql_dbg_offset, &vaf);
drivers/scsi/qla2xxx/qla_dbg.c:			QL_MSGHDR, dev_name(&(pdev->dev)), id, vha->host_no);
drivers/scsi/qla2xxx/qla_dbg.c:		 QL_MSGHDR, dev_name(&(pdev->dev)), id);
drivers/scsi/qla2xxx/qla_nx.c:				dev_err(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_nx.c:				dev_err(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_nx.c:	    0xbc000 + (ha->pdev->devfn << 11));
drivers/scsi/qla2xxx/qla_nx.c:		    (ha->pdev->devfn << 12)), 4);
drivers/scsi/qla2xxx/qla_nx.c:		    (ha->pdev->devfn * 8);
drivers/scsi/qla2xxx/qla_nx.c:		ha->nxdb_wr_ptr = (ha->pdev->devfn == 6 ?
drivers/scsi/qla2xxx/qla_nx.c:	ha->chip_revision = ha->pdev->revision;
drivers/scsi/qla2xxx/qla_nx.c:	ha->portnum = PCI_FUNC(ha->pdev->devfn);
drivers/scsi/qla2xxx/qla_nx.c:		optrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,
drivers/scsi/qla2xxx/qla_nx.c:				dma_free_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_nx.c:		dma_free_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_nx.c:		dma_free_coherent(&ha->pdev->dev, ha->md_template_size,
drivers/scsi/qla2xxx/qla_nx.c:				dma_free_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_init.c:	ha->chip_revision = ha->pdev->revision;
drivers/scsi/qla2xxx/qla_init.c:	ha->chip_revision = ha->pdev->revision;
drivers/scsi/qla2xxx/qla_init.c:		tc = dma_alloc_coherent(&ha->pdev->dev, FCE_SIZE, &tc_dma,
drivers/scsi/qla2xxx/qla_init.c:			dma_free_coherent(&ha->pdev->dev, FCE_SIZE, tc,
drivers/scsi/qla2xxx/qla_init.c:		tc = dma_alloc_coherent(&ha->pdev->dev, EFT_SIZE, &tc_dma,
drivers/scsi/qla2xxx/qla_init.c:			dma_free_coherent(&ha->pdev->dev, EFT_SIZE, tc,
drivers/scsi/qla2xxx/qla_init.c:			dma_free_coherent(&ha->pdev->dev, FCE_SIZE, ha->fce,
drivers/scsi/qla2xxx/qla_init.c:			dma_free_coherent(&ha->pdev->dev, eft_size, ha->eft,
drivers/scsi/qla2xxx/qla_init.c:		index = (ha->pdev->subsystem_device & 0xff);
drivers/scsi/qla2xxx/qla_init.c:		    ha->pdev->subsystem_vendor == PCI_VENDOR_ID_QLOGIC &&
drivers/scsi/qla2xxx/qla_init.c:		index = (ha->pdev->subsystem_device & 0xff);
drivers/scsi/qla2xxx/qla_init.c:		    ha->pdev->subsystem_vendor == PCI_VENDOR_ID_QLOGIC &&
drivers/scsi/qla2xxx/qla_init.c:		ha->mctp_dump = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_init.c:		if (cs84xx->bus == ha->pdev->bus) {
drivers/scsi/qla2xxx/qla_init.c:	cs84xx->bus = ha->pdev->bus;
drivers/scsi/qla2xxx/qla_mr.c:	if (ha->pdev->error_state > pci_channel_io_frozen) {
drivers/scsi/qla2xxx/qla_mr.c:	ha->chip_revision = ha->pdev->revision;
drivers/scsi/qla2xxx/qla_mr.c:		fdisc->u.fxiocb.req_addr = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_mr.c:			    ha->pdev->device);
drivers/scsi/qla2xxx/qla_mr.c:		fdisc->u.fxiocb.rsp_addr = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_mr.c:		dma_free_coherent(&ha->pdev->dev, fdisc->u.fxiocb.rsp_len,
drivers/scsi/qla2xxx/qla_mr.c:		dma_free_coherent(&ha->pdev->dev, fdisc->u.fxiocb.req_len,
drivers/scsi/qla2xxx/qla_mr.c:		nseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),
drivers/scsi/qla2xxx/qla_mbx.c:	if (ha->pdev->error_state > pci_channel_io_frozen) {
drivers/scsi/qla2xxx/qla_mbx.c:		pmap = dma_alloc_coherent(&ha->pdev->dev, dma_size,
drivers/scsi/qla2xxx/qla_mbx.c:		dma_free_coherent(&ha->pdev->dev, dma_size, pmap, pmap_dma);
drivers/scsi/qla2xxx/qla_mbx.c:	dma_free_coherent(&ha->pdev->dev, dma_size, pmap, pmap_dma);
drivers/scsi/qla2xxx/qla_mbx.c:	ha->md_tmplt_hdr = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_target.c:	gid_list = dma_alloc_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),
drivers/scsi/qla2xxx/qla_target.c:	dma_free_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),
drivers/scsi/qla2xxx/qla_target.c:	ha->tgt.atio_ring = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_target.c:		dma_free_coherent(&ha->pdev->dev, (ha->tgt.atio_q_length + 1) *
drivers/scsi/qla2xxx/qla_bsg.c:			dma_unmap_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:			dma_unmap_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:		dma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:		dma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:		dma_map_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:	rsp_sg_cnt = dma_map_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:	dma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:	dma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:		dma_map_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:	rsp_sg_cnt = dma_map_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:	dma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:	dma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:	elreq.req_sg_cnt = dma_map_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:	elreq.rsp_sg_cnt = dma_map_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:	req_data = dma_alloc_coherent(&ha->pdev->dev, req_data_len,
drivers/scsi/qla2xxx/qla_bsg.c:	rsp_data = dma_alloc_coherent(&ha->pdev->dev, rsp_data_len,
drivers/scsi/qla2xxx/qla_bsg.c:	dma_free_coherent(&ha->pdev->dev, rsp_data_len,
drivers/scsi/qla2xxx/qla_bsg.c:	dma_free_coherent(&ha->pdev->dev, req_data_len,
drivers/scsi/qla2xxx/qla_bsg.c:	dma_unmap_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:	dma_unmap_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:	sg_cnt = dma_map_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:	fw_buf = dma_alloc_coherent(&ha->pdev->dev, data_len,
drivers/scsi/qla2xxx/qla_bsg.c:	dma_free_coherent(&ha->pdev->dev, data_len, fw_buf, fw_dma);
drivers/scsi/qla2xxx/qla_bsg.c:	dma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:		sg_cnt = dma_map_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:		mgmt_b = dma_alloc_coherent(&ha->pdev->dev, data_len,
drivers/scsi/qla2xxx/qla_bsg.c:		sg_cnt = dma_map_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:		mgmt_b = dma_alloc_coherent(&ha->pdev->dev, data_len,
drivers/scsi/qla2xxx/qla_bsg.c:		dma_free_coherent(&ha->pdev->dev, data_len, mgmt_b, mgmt_dma);
drivers/scsi/qla2xxx/qla_bsg.c:		dma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:		dma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,
drivers/scsi/qla2xxx/qla_bsg.c:	req_sg_cnt = dma_map_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:	rsp_sg_cnt = dma_map_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:	dma_unmap_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:	dma_unmap_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:		req_sg_cnt = dma_map_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:		rsp_sg_cnt = dma_map_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:		dma_unmap_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_bsg.c:		dma_unmap_sg(&ha->pdev->dev,
drivers/scsi/qla2xxx/qla_iocb.c:		nseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),
drivers/scsi/qla2xxx/qla_iocb.c:		nseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),
drivers/scsi/qla2xxx/qla_iocb.c:		nseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),
drivers/scsi/qla2xxx/qla_iocb.c:		nseg = dma_map_sg(&ha->pdev->dev, scsi_prot_sglist(cmd),
drivers/scsi/qla2xxx/qla_iocb.c:		nseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),
drivers/scsi/be2iscsi/be_cmds.c:						PCI_FUNC(ctrl->pdev->devfn));
drivers/scsi/be2iscsi/be_cmds.c:			      PCI_FUNC(ctrl->pdev->devfn));
drivers/scsi/be2iscsi/be_cmds.c:			      pci_func_id, ctxt, PCI_FUNC(ctrl->pdev->devfn));
drivers/scsi/be2iscsi/be_main.c:		       (PCI_FUNC(ctrl->pdev->devfn) * CEV_ISR_SIZE));
drivers/scsi/qla1280.c:          pdev->resource[0].start in detect() for 2.3.x
drivers/scsi/qla1280.c:#define IS_ISP1040(ha) (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP1020)
drivers/scsi/qla1280.c:#define IS_ISP1x40(ha) (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP1020 || \
drivers/scsi/qla1280.c:			ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP1240)
drivers/scsi/qla1280.c:#define IS_ISP1x160(ha)        (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP10160 || \
drivers/scsi/qla1280.c:				ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP12160)
drivers/scsi/qla1280.c:	err = request_firmware(&fw, fwname, &ha->pdev->dev);
drivers/scsi/qla1280.c:	if (pdev->subsystem_vendor == PCI_VENDOR_ID_AMI) {
drivers/scsi/qla1280.c:	       bdp->name, pdev->bus->number, PCI_SLOT(pdev->devfn));
drivers/scsi/qla1280.c:	host->irq = pdev->irq;
drivers/scsi/qla1280.c:	if (request_irq(pdev->irq, qla1280_intr_handler, IRQF_SHARED,
drivers/scsi/qla1280.c:		       "in use\n", pdev->irq);
drivers/scsi/qla1280.c:	error = scsi_add_host(host, &pdev->dev);
drivers/scsi/qla1280.c:	free_irq(pdev->irq, ha);
drivers/scsi/qla1280.c:	free_irq(pdev->irq, ha);
drivers/scsi/qla4xxx/ql4_mbx.c:	init_fw_cb = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_mbx.c:		dma_free_coherent(&ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_mbx.c:	dma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk),
drivers/scsi/qla4xxx/ql4_mbx.c:	init_fw_cb = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_mbx.c:		dma_free_coherent(&ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_mbx.c:	dma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk),
drivers/scsi/qla4xxx/ql4_mbx.c:	crash_record = dma_alloc_coherent(&ha->pdev->dev, crash_record_size,
drivers/scsi/qla4xxx/ql4_mbx.c:		dma_free_coherent(&ha->pdev->dev, crash_record_size,
drivers/scsi/qla4xxx/ql4_mbx.c:	event_log = dma_alloc_coherent(&ha->pdev->dev, event_log_size,
drivers/scsi/qla4xxx/ql4_mbx.c:		dma_free_coherent(&ha->pdev->dev, event_log_size, event_log,
drivers/scsi/qla4xxx/ql4_mbx.c:	about_fw = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_mbx.c:	dma_free_coherent(&ha->pdev->dev, sizeof(struct about_fw_info),
drivers/scsi/qla4xxx/ql4_mbx.c:	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_mbx.c:	dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_nx.c:		dev_info(&ha->pdev->dev, "Resetting rom_lock\n");
drivers/scsi/qla4xxx/ql4_nx.c:	kobject_uevent_env(&(&ha->pdev->dev)->kobj, KOBJ_CHANGE, envp);
drivers/scsi/qla4xxx/ql4_nx.c:	sys_info = dma_alloc_coherent(&ha->pdev->dev, sizeof(*sys_info),
drivers/scsi/qla4xxx/ql4_nx.c:	dma_free_coherent(&ha->pdev->dev, sizeof(*sys_info), sys_info,
drivers/scsi/qla4xxx/ql4_isr.c:		ret = request_irq(ha->pdev->irq, qla4_8xxx_msi_handler,
drivers/scsi/qla4xxx/ql4_isr.c:			    "already in use.\n", ha->pdev->irq);
drivers/scsi/qla4xxx/ql4_isr.c:	ret = request_irq(ha->pdev->irq, ha->isp_ops->intr_handler,
drivers/scsi/qla4xxx/ql4_isr.c:		    " use.\n", ha->pdev->irq);
drivers/scsi/qla4xxx/ql4_isr.c:	ha->host->irq = ha->pdev->irq;
drivers/scsi/qla4xxx/ql4_isr.c:	    __func__, ha->pdev->irq);
drivers/scsi/qla4xxx/ql4_isr.c:			free_irq(ha->pdev->irq, ha);
drivers/scsi/qla4xxx/ql4_isr.c:			free_irq(ha->pdev->irq, ha);
drivers/scsi/qla4xxx/ql4_def.h:	dev_printk(level , &((ha)->pdev->dev) , format , ## arg)
drivers/scsi/qla4xxx/ql4_def.h:	return ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4010;
drivers/scsi/qla4xxx/ql4_def.h:	return ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4022;
drivers/scsi/qla4xxx/ql4_def.h:	return ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4032;
drivers/scsi/qla4xxx/ql4_def.h:	return ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8022;
drivers/scsi/qla4xxx/ql4_def.h:	return ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8324;
drivers/scsi/qla4xxx/ql4_def.h:	return ((ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8022) ||
drivers/scsi/qla4xxx/ql4_def.h:		(ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8324));
drivers/scsi/qla4xxx/ql4_bsg.c:	flash = dma_alloc_coherent(&ha->pdev->dev, length, &flash_dma,
drivers/scsi/qla4xxx/ql4_bsg.c:	dma_free_coherent(&ha->pdev->dev, length, flash, flash_dma);
drivers/scsi/qla4xxx/ql4_bsg.c:	flash = dma_alloc_coherent(&ha->pdev->dev, length, &flash_dma,
drivers/scsi/qla4xxx/ql4_bsg.c:	dma_free_coherent(&ha->pdev->dev, length, flash, flash_dma);
drivers/scsi/qla4xxx/ql4_bsg.c:	nvram = dma_alloc_coherent(&ha->pdev->dev, len, &nvram_dma,
drivers/scsi/qla4xxx/ql4_bsg.c:	dma_free_coherent(&ha->pdev->dev, len, nvram, nvram_dma);
drivers/scsi/qla4xxx/ql4_bsg.c:	nvram = dma_alloc_coherent(&ha->pdev->dev, len, &nvram_dma,
drivers/scsi/qla4xxx/ql4_bsg.c:	dma_free_coherent(&ha->pdev->dev, len, nvram, nvram_dma);
drivers/scsi/qla4xxx/ql4_bsg.c:	acb = dma_alloc_coherent(&ha->pdev->dev, len, &acb_dma, GFP_KERNEL);
drivers/scsi/qla4xxx/ql4_bsg.c:	dma_free_coherent(&ha->pdev->dev, len, acb, acb_dma);
drivers/scsi/qla4xxx/ql4_os.c:	ql_iscsi_stats = dma_alloc_coherent(&ha->pdev->dev, stats_size,
drivers/scsi/qla4xxx/ql4_os.c:	dma_free_coherent(&ha->pdev->dev, stats_size, ql_iscsi_stats,
drivers/scsi/qla4xxx/ql4_os.c:	init_fw_cb = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_os.c:	dma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk),
drivers/scsi/qla4xxx/ql4_os.c:	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:		task_data->data_dma = dma_map_single(&ha->pdev->dev, task->data,
drivers/scsi/qla4xxx/ql4_os.c:	task_data->resp_buffer = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_os.c:	task_data->req_buffer = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, task_data->resp_len,
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, task_data->req_len,
drivers/scsi/qla4xxx/ql4_os.c:		dma_unmap_single(&ha->pdev->dev, task_data->data_dma,
drivers/scsi/qla4xxx/ql4_os.c:	dma_free_coherent(&ha->pdev->dev, task_data->resp_len,
drivers/scsi/qla4xxx/ql4_os.c:	dma_free_coherent(&ha->pdev->dev, task_data->req_len,
drivers/scsi/qla4xxx/ql4_os.c:	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, ha->queues_len, ha->queues,
drivers/scsi/qla4xxx/ql4_os.c:	ha->queues = dma_alloc_coherent(&ha->pdev->dev, ha->queues_len,
drivers/scsi/qla4xxx/ql4_os.c:	ha->chap_dma_pool = dma_pool_create("ql4_chap", &ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_os.c:	ha->fw_ddb_dma_pool = dma_pool_create("ql4_fw_ddb", &ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_os.c:	    __func__, pdev->revision));
drivers/scsi/qla4xxx/ql4_os.c:	ha->revision_id = pdev->revision;
drivers/scsi/qla4xxx/ql4_os.c:				     (ha->pdev->devfn << 11));
drivers/scsi/qla4xxx/ql4_os.c:		ha->nx_db_wr_ptr = (ha->pdev->devfn == 4 ? QLA82XX_CAM_RAM_DB1 :
drivers/scsi/qla4xxx/ql4_os.c:	func_num = PCI_FUNC(ha->pdev->devfn);
drivers/scsi/qla4xxx/ql4_os.c:		   __func__, ha->pdev->device, func_num);
drivers/scsi/qla4xxx/ql4_os.c:		buf = dma_alloc_coherent(&ha->pdev->dev, size,
drivers/scsi/qla4xxx/ql4_os.c:	dma_free_coherent(&ha->pdev->dev, size, buf, buf_dma);
drivers/scsi/qla4xxx/ql4_os.c:	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:	dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:	chap_flash_data = dma_alloc_coherent(&ha->pdev->dev, chap_size,
drivers/scsi/qla4xxx/ql4_os.c:	dma_free_coherent(&ha->pdev->dev, chap_size,
drivers/scsi/qla4xxx/ql4_os.c:	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:	ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, sizeof(*ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:	pddb = dma_alloc_coherent(&ha->pdev->dev, ddb_size,
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, ddb_size, pddb,
drivers/scsi/qla4xxx/ql4_os.c:	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_os.c:	dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry), fw_ddb_entry,
drivers/scsi/qla4xxx/ql4_os.c:	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:		dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
drivers/scsi/qla4xxx/ql4_os.c:	ha->func_num = PCI_FUNC(ha->pdev->devfn);
drivers/scsi/qla4xxx/ql4_os.c:		pdev->needs_freset = 1;
drivers/scsi/qla4xxx/ql4_os.c:		   pdev->device, pdev->irq, ha->reg);
drivers/scsi/qla4xxx/ql4_os.c:	ret = scsi_add_host(host, &pdev->dev);
drivers/scsi/qla4xxx/ql4_os.c:			    "interrupt %d already in use.\n", pdev->irq);
drivers/scsi/qla4xxx/ql4_os.c:	       qla4xxx_version_str, ha->pdev->device, pci_name(ha->pdev),
drivers/scsi/qla4xxx/ql4_os.c:	if (PCI_FUNC(ha->pdev->devfn) & BIT_1)
drivers/scsi/qla4xxx/ql4_os.c:		pci_get_domain_bus_and_slot(pci_domain_nr(ha->pdev->bus),
drivers/scsi/qla4xxx/ql4_os.c:		ha->pdev->bus->number, PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),
drivers/scsi/qla4xxx/ql4_os.c:		if (atomic_read(&other_pdev->enable_cnt)) {
drivers/scsi/qla4xxx/ql4_os.c:				    dev_name(&other_ha->pdev->dev)));
drivers/scsi/qla4xxx/ql4_os.c:			dev_dbg(&ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_os.c:	acb = dma_alloc_coherent(&ha->pdev->dev,
drivers/scsi/qla4xxx/ql4_os.c:	dma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk_def),
drivers/scsi/qla4xxx/ql4_os.c:	fn = PCI_FUNC(ha->pdev->devfn);
drivers/scsi/qla4xxx/ql4_os.c:		    pci_get_domain_bus_and_slot(pci_domain_nr(ha->pdev->bus),
drivers/scsi/qla4xxx/ql4_os.c:		    ha->pdev->bus->number, PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),
drivers/scsi/qla4xxx/ql4_os.c:		if (atomic_read(&other_pdev->enable_cnt)) {
drivers/scsi/qla4xxx/ql4_os.c:		    ha->pdev->devfn);
drivers/scsi/qla4xxx/ql4_os.c:		    ha->pdev->devfn);
drivers/scsi/qla4xxx/ql4_init.c:	sys_info = dma_alloc_coherent(&ha->pdev->dev, sizeof(*sys_info),
drivers/scsi/qla4xxx/ql4_init.c:	dma_free_coherent(&ha->pdev->dev, sizeof(*sys_info), sys_info,
drivers/scsi/qla4xxx/ql4_init.c:	md_tmp = dma_alloc_coherent(&ha->pdev->dev, ha->fw_dump_tmplt_size,
drivers/scsi/qla4xxx/ql4_init.c:	dma_free_coherent(&ha->pdev->dev, ha->fw_dump_tmplt_size,
drivers/scsi/hpsa.h:	dev_dbg(&h->pdev->dev, "Sending %x, tag = %x\n", c->busaddr,
drivers/scsi/hpsa.h:		dev_dbg(&h->pdev->dev, "Read %lx back from board\n",
drivers/scsi/hpsa.h:		dev_dbg(&h->pdev->dev, "FIFO Empty read\n");
drivers/scsi/hpsa.h:	dev_dbg(&h->pdev->dev, "intr_pending %lx\n", register_value);
drivers/scsi/sym53c8xx_2/sym_glue.c:		 pdev->device, pdev->revision);
drivers/scsi/sym53c8xx_2/sym_glue.c:			 pci_name(pdev), pdev->irq);
drivers/scsi/sym53c8xx_2/sym_glue.c:		free_irq(pdev->irq, np->s.host);
drivers/scsi/sym53c8xx_2/sym_glue.c:		unit, dev->chip.name, pdev->revision, pci_name(pdev),
drivers/scsi/sym53c8xx_2/sym_glue.c:		pdev->irq);
drivers/scsi/sym53c8xx_2/sym_glue.c:	np = __sym_calloc_dma(&pdev->dev, sizeof(*np), "HCB");
drivers/scsi/sym53c8xx_2/sym_glue.c:	np->bus_dmat = &pdev->dev; /* Result in 1 DMA pool per HBA */
drivers/scsi/sym53c8xx_2/sym_glue.c:	if (request_irq(pdev->irq, sym53c8xx_intr, IRQF_SHARED, NAME53C8XX,
drivers/scsi/sym53c8xx_2/sym_glue.c:			sym_name(np), pdev->irq);
drivers/scsi/sym53c8xx_2/sym_glue.c:	if (pdev->device == PCI_DEVICE_ID_NCR_53C896 && pdev->revision < 2)
drivers/scsi/sym53c8xx_2/sym_glue.c:	chip = sym_lookup_chip_table(pdev->device, pdev->revision);
drivers/scsi/sym53c8xx_2/sym_glue.c:		dev_info(&pdev->dev, "device not supported\n");
drivers/scsi/sym53c8xx_2/sym_glue.c:	dev_info(&device->pdev->dev,
drivers/scsi/sym53c8xx_2/sym_glue.c:	if (pdev->device == PCI_DEVICE_ID_NCR_53C896 && pdev->revision < 0x4) {
drivers/scsi/sym53c8xx_2/sym_glue.c:	pcibios_resource_to_bus(pdev, &bus_addr, &pdev->resource[1]);
drivers/scsi/sym53c8xx_2/sym_glue.c:		if (!pdev->resource[i].flags)
drivers/scsi/sym53c8xx_2/sym_glue.c:		pcibios_resource_to_bus(pdev, &bus_addr, &pdev->resource[i]);
drivers/scsi/sym53c8xx_2/sym_glue.c:		dev_err(&pdev->dev, "could not map registers; giving up.\n");
drivers/scsi/sym53c8xx_2/sym_glue.c:			dev_warn(&pdev->dev,
drivers/scsi/sym53c8xx_2/sym_glue.c:		struct pci_dev *memc = pci_get_slot(pdev->bus, slot);
drivers/scsi/sym53c8xx_2/sym_glue.c:	if (scsi_add_host(shost, &pdev->dev))
drivers/scsi/sym53c8xx_2/sym_glue.c:	disable_irq(pdev->irq);
drivers/scsi/sym53c8xx_2/sym_glue.c:	chip = sym_lookup_chip_table(pdev->device, pdev->revision);
drivers/scsi/sym53c8xx_2/sym_glue.c:	enable_irq(pdev->irq);
drivers/scsi/sym53c8xx_2/sym_glue.c:	if (PCI_FUNC(pdev->devfn) == 0) {
drivers/scsi/sym53c8xx_2/sym_fw.c:	if (!(pdev->device == PCI_DEVICE_ID_LSI_53C1010_66 &&
drivers/scsi/sym53c8xx_2/sym_fw.c:	      pdev->revision < 0x1 &&
drivers/scsi/sym53c8xx_2/sym_fw.c:	if (!(pdev->device == PCI_DEVICE_ID_LSI_53C1010_33 /* &&
drivers/scsi/sym53c8xx_2/sym_fw.c:	      pdev->revision < 0xff */)) {
drivers/scsi/sym53c8xx_2/sym_hipd.c:	if (pdev->device == PCI_DEVICE_ID_LSI_53C1010_33 &&
drivers/scsi/sym53c8xx_2/sym_hipd.c:	    pdev->revision < 0x1)
drivers/scsi/sym53c8xx_2/sym_hipd.c:	if ((pdev->device == PCI_DEVICE_ID_NCR_53C810 &&
drivers/scsi/sym53c8xx_2/sym_hipd.c:	     pdev->revision >= 0x10 && pdev->revision <= 0x11) ||
drivers/scsi/sym53c8xx_2/sym_hipd.c:	    (pdev->device == PCI_DEVICE_ID_NCR_53C860 &&
drivers/scsi/sym53c8xx_2/sym_hipd.c:	     pdev->revision <= 0x1))
drivers/scsi/sym53c8xx_2/sym_hipd.c:	       pdev->device == PCI_DEVICE_ID_NCR_53C895))) &&
drivers/scsi/sym53c8xx_2/sym_hipd.c:	if (pdev->device == PCI_DEVICE_ID_LSI_53C1010_66)
drivers/scsi/sym53c8xx_2/sym_hipd.c:	if (pdev->device == PCI_DEVICE_ID_LSI_53C1010_33 &&
drivers/scsi/sym53c8xx_2/sym_hipd.c:	    pdev->revision < 1)
drivers/scsi/sym53c8xx_2/sym_hipd.c:	if (pdev->device == PCI_DEVICE_ID_NCR_53C875)
drivers/scsi/sym53c8xx_2/sym_hipd.c:	else if (pdev->device == PCI_DEVICE_ID_NCR_53C896)
drivers/scsi/sym53c8xx_2/sym_nvram.c:	switch (np->pdev->device) {
drivers/scsi/3w-sas.c:	retval = scsi_add_host(host, &pdev->dev);
drivers/scsi/3w-sas.c:	       (u64)pci_resource_start(pdev, 1), pdev->irq);
drivers/scsi/3w-sas.c:	retval = request_irq(pdev->irq, twl_interrupt, IRQF_SHARED, "3w-sas", tw_dev);
drivers/scsi/3w-sas.c:	retval = request_irq(pdev->irq, twl_interrupt, IRQF_SHARED, "3w-sas", tw_dev);
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	karg.hw_rev = ioc->pdev->revision;
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	karg.pci_id = ioc->pdev->device;
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	karg.subsystem_device = ioc->pdev->subsystem_device;
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	karg.subsystem_vendor = ioc->pdev->subsystem_vendor;
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	karg.pci_information.u.bits.bus = ioc->pdev->bus->number;
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	karg.pci_information.u.bits.device = PCI_SLOT(ioc->pdev->devfn);
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	karg.pci_information.u.bits.function = PCI_FUNC(ioc->pdev->devfn);
drivers/scsi/mpt3sas/mpt3sas_ctl.c:	karg.pci_information.segment_id = pci_domain_nr(ioc->pdev->bus);
drivers/scsi/mpt3sas/mpt3sas_scsih.c:	if (ioc->pdev->subsystem_vendor == PCI_VENDOR_ID_IBM)
drivers/scsi/mpt3sas/mpt3sas_scsih.c:	if ((scsi_add_host(shost, &pdev->dev))) {
drivers/scsi/mpt3sas/mpt3sas_scsih.c:	pci_power_t device_state = pdev->current_state;
drivers/scsi/mpt3sas/mpt3sas_config.c:		mem->page = dma_alloc_coherent(&ioc->pdev->dev, mem->sz,
drivers/scsi/mpt3sas/mpt3sas_config.c:		dma_free_coherent(&ioc->pdev->dev, mem->sz, mem->page,
drivers/scsi/mpt3sas/mpt3sas_base.c:		    dma_get_required_mask(&pdev->dev);
drivers/scsi/mpt3sas/mpt3sas_base.c:	r = _base_request_irq(ioc, 0, ioc->pdev->irq);
drivers/scsi/mpt3sas/mpt3sas_base.c:	   ioc->pdev->revision,
drivers/scsi/stex.c:	p->bus = hba->pdev->bus->number;
drivers/scsi/stex.c:	p->slot = hba->pdev->devfn;
drivers/scsi/stex.c:	p->irq_vec = hba->pdev->irq;
drivers/scsi/stex.c:	p->id = hba->pdev->vendor << 16 | hba->pdev->device;
drivers/scsi/stex.c:		hba->pdev->subsystem_vendor << 16 | hba->pdev->subsystem_device;
drivers/scsi/stex.c:			&hba->pdev->saved_config_space[i]);
drivers/scsi/stex.c:	bus = hba->pdev->bus;
drivers/scsi/stex.c:			hba->pdev->saved_config_space[i]);
drivers/scsi/stex.c:	status = request_irq(pdev->irq, hba->cardtype == st_yel ?
drivers/scsi/stex.c:	free_irq(pdev->irq, hba);
drivers/scsi/stex.c:		(hba->cardtype == st_vsc && (pdev->subsystem_device & 1))) {
drivers/scsi/stex.c:	hba->dma_mem = dma_alloc_coherent(&pdev->dev,
drivers/scsi/stex.c:		    (hba->cardtype == st_vsc && (pdev->subsystem_device & 1))) {
drivers/scsi/stex.c:			hba->dma_mem = dma_alloc_coherent(&pdev->dev,
drivers/scsi/stex.c:	err = scsi_add_host(host, &pdev->dev);
drivers/scsi/stex.c:	dma_free_coherent(&pdev->dev, hba->dma_size,
drivers/scsi/stex.c:	dma_free_coherent(&hba->pdev->dev, hba->dma_size,
drivers/scsi/a4000t.c:		dev_err(&pdev->dev, "Failed to allocate host data\n");
drivers/scsi/a4000t.c:			      &pdev->dev);
drivers/scsi/a4000t.c:		dev_err(&pdev->dev,
drivers/scsi/a4000t.c:		dev_err(&pdev->dev, "request_irq failed\n");
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev, "Failed to save PCI-X command register\n");
drivers/scsi/ipr.c:			dev_err(&ioa_cfg->pdev->dev, "Failed to setup PCI-X command register\n");
drivers/scsi/ipr.c:			dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev, "Error notifications lost\n");
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:	dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:	dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:			dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:	strcpy(driver_dump->location_entry.location, dev_name(&ioa_cfg->pdev->dev));
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:	dev_err(&ioa_cfg->pdev->dev, "Dump of IOA initiated\n");
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:	dev_err(&ioa_cfg->pdev->dev, "Dump of IOA completed.\n");
drivers/scsi/ipr.c:		dev_info(&ioa_cfg->pdev->dev, "blk-iopoll not supported on this adapter\n");
drivers/scsi/ipr.c:		dev_info(&ioa_cfg->pdev->dev, "Invalid blk-iopoll weight. It must be less than 256\n");
drivers/scsi/ipr.c:		dev_info(&ioa_cfg->pdev->dev, "Current blk-iopoll weight has the same weight\n");
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:	if (request_firmware(&fw_entry, fname, &ioa_cfg->pdev->dev)) {
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev, "Firmware file %s not found\n", fname);
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev, "Microcode buffer allocation failed\n");
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:				dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:			dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:			dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:	dev_err(&ioa_cfg->pdev->dev, "%s %d\n", msg, number);
drivers/scsi/ipr.c:			dev_err(&ioa_cfg->pdev->dev, "pci_map_sg failed!\n");
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev, "pci_map_sg failed!\n");
drivers/scsi/ipr.c:	if ((ioa_cfg->type == 0x5702) && (ioa_cfg->pdev->revision < 4)) {
drivers/scsi/ipr.c:	dev_info(&ioa_cfg->pdev->dev, "IOA initialized.\n");
drivers/scsi/ipr.c:			dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:			dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:	dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev, "Microcode download required\n");
drivers/scsi/ipr.c:				dev_err(&ioa_cfg->pdev->dev, "Too many devices attached\n");
drivers/scsi/ipr.c:	dev_info(&ioa_cfg->pdev->dev, "Adapter firmware version: %02X%02X%02X%02X\n",
drivers/scsi/ipr.c:	dev_info(&ioa_cfg->pdev->dev, "Starting IOA initialization sequence.\n");
drivers/scsi/ipr.c:	dev_info(&ioa_cfg->pdev->dev, "Initializing IOA.\n");
drivers/scsi/ipr.c:	dev_err(&ioa_cfg->pdev->dev, "IOA unit check with no data\n");
drivers/scsi/ipr.c:	ioa_cfg->pdev->state_saved = true;
drivers/scsi/ipr.c:			dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:	dev_dbg(&ioa_cfg->pdev->dev, "ioa_cfg adx: 0x%p\n", ioa_cfg);
drivers/scsi/ipr.c:		dev_err(&ioa_cfg->pdev->dev,
drivers/scsi/ipr.c:		free_irq(pdev->irq, &ioa_cfg->hrrq[0]);
drivers/scsi/ipr.c:			ioa_cfg->vectors_info[i].vec = ioa_cfg->pdev->irq + i;
drivers/scsi/ipr.c:	dev_info(&ioa_cfg->pdev->dev, "Received IRQ : %d\n", irq);
drivers/scsi/ipr.c:		rc = request_irq(pdev->irq, ipr_test_intr, 0, IPR_NAME, ioa_cfg);
drivers/scsi/ipr.c:		dev_err(&pdev->dev, "Can not assign irq %d\n", pdev->irq);
drivers/scsi/ipr.c:		dev_info(&pdev->dev, "IRQ assigned: %d\n", pdev->irq);
drivers/scsi/ipr.c:		dev_info(&pdev->dev, "MSI test failed.  Falling back to LSI.\n");
drivers/scsi/ipr.c:		dev_info(&pdev->dev, "MSI test succeeded.\n");
drivers/scsi/ipr.c:		free_irq(pdev->irq, ioa_cfg);
drivers/scsi/ipr.c:		dev_err(&pdev->dev, "Cannot enable adapter\n");
drivers/scsi/ipr.c:	dev_info(&pdev->dev, "Found IOA with IRQ: %d\n", pdev->irq);
drivers/scsi/ipr.c:		dev_err(&pdev->dev, "call to scsi_host_alloc failed!\n");
drivers/scsi/ipr.c:	ata_host_init(&ioa_cfg->ata_host, &pdev->dev, &ipr_sata_ops);
drivers/scsi/ipr.c:		dev_err(&pdev->dev, "Unknown adapter chipset 0x%04X 0x%04X\n",
drivers/scsi/ipr.c:	ioa_cfg->revid = pdev->revision;
drivers/scsi/ipr.c:		dev_err(&pdev->dev,
drivers/scsi/ipr.c:		dev_err(&pdev->dev,
drivers/scsi/ipr.c:			dev_dbg(&pdev->dev, "Failed to set 64 bit PCI DMA mask\n");
drivers/scsi/ipr.c:		dev_err(&pdev->dev, "Failed to set PCI DMA mask\n");
drivers/scsi/ipr.c:		dev_err(&pdev->dev, "Write of cache line size failed\n");
drivers/scsi/ipr.c:		dev_err(&pdev->dev, "The max number of MSIX is %d\n",
drivers/scsi/ipr.c:		dev_info(&pdev->dev, "Cannot enable MSI.\n");
drivers/scsi/ipr.c:				dev_info(&pdev->dev,
drivers/scsi/ipr.c:					ioa_cfg->nvectors, pdev->irq);
drivers/scsi/ipr.c:				dev_info(&pdev->dev,
drivers/scsi/ipr.c:		dev_err(&pdev->dev, "Failed to save PCI config space\n");
drivers/scsi/ipr.c:		dev_err(&pdev->dev,
drivers/scsi/ipr.c:		rc = request_irq(pdev->irq, ipr_isr,
drivers/scsi/ipr.c:		dev_err(&pdev->dev, "Couldn't register IRQ %d! rc=%d\n",
drivers/scsi/ipr.c:			pdev->irq, rc);
drivers/scsi/ipr.c:	rc = scsi_add_host(ioa_cfg->host, &pdev->dev);
drivers/scsi/3w-9xxx.c:	if (pdev->device == PCI_DEVICE_ID_3WARE_9000) {
drivers/scsi/3w-9xxx.c:	if ((pdev->device == PCI_DEVICE_ID_3WARE_9650SE) ||
drivers/scsi/3w-9xxx.c:	    (pdev->device == PCI_DEVICE_ID_3WARE_9690SA))
drivers/scsi/3w-9xxx.c:	retval = scsi_add_host(host, &pdev->dev);
drivers/scsi/3w-9xxx.c:	       host->host_no, mem_addr, pdev->irq);
drivers/scsi/3w-9xxx.c:	if (use_msi && (pdev->device != PCI_DEVICE_ID_3WARE_9000) &&
drivers/scsi/3w-9xxx.c:	retval = request_irq(pdev->irq, twa_interrupt, IRQF_SHARED, "3w-9xxx", tw_dev);
drivers/scsi/3w-9xxx.c:	retval = request_irq(pdev->irq, twa_interrupt, IRQF_SHARED, "3w-9xxx", tw_dev);
drivers/scsi/aacraid/rx.c:	if (request_irq(dev->pdev->irq, dev->a_ops.adapter_intr,
drivers/scsi/aacraid/src.c:	if (request_irq(dev->pdev->irq, dev->a_ops.adapter_intr,
drivers/scsi/aacraid/src.c:	if (request_irq(dev->pdev->irq, dev->a_ops.adapter_intr,
drivers/scsi/aacraid/sa.c:	if (request_irq(dev->pdev->irq, dev->a_ops.adapter_intr,
drivers/scsi/aacraid/sa.c:	free_irq(dev->pdev->irq, (void *)dev);
drivers/scsi/aacraid/commsup.c:	free_irq(aac->pdev->irq, aac);
drivers/scsi/aacraid/linit.c:	free_irq(aac->pdev->irq, aac);
drivers/scsi/aacraid/linit.c:	shost->irq = pdev->irq;
drivers/scsi/aacraid/linit.c:	error = scsi_add_host(shost, &pdev->dev);
drivers/scsi/aacraid/commctrl.c:	pci_info.bus = dev->pdev->bus->number;
drivers/scsi/aacraid/commctrl.c:	pci_info.slot = PCI_SLOT(dev->pdev->devfn);
drivers/scsi/aacraid/comminit.c:	aac_max_hostphysmempages = dma_get_required_mask(&dev->pdev->dev) >> 12;
drivers/scsi/aacraid/comminit.c:		if (dev->pdev->device == PMC_DEVICE_S7 ||
drivers/scsi/aacraid/comminit.c:		    dev->pdev->device == PMC_DEVICE_S8 ||
drivers/scsi/aacraid/comminit.c:		    dev->pdev->device == PMC_DEVICE_S9)
drivers/scsi/aacraid/aachba.c:	if (dma_get_required_mask(&dev->pdev->dev) > DMA_BIT_MASK(32))
drivers/scsi/vmw_pvscsi.c:	adapter->rev = pdev->revision;
drivers/scsi/vmw_pvscsi.c:		adapter->irq = pdev->irq;
drivers/scsi/vmw_pvscsi.c:		adapter->irq = pdev->irq;
drivers/scsi/vmw_pvscsi.c:	error = scsi_add_host(host, &pdev->dev);
drivers/scsi/vmw_pvscsi.c:	dev_info(&pdev->dev, "VMware PVSCSI rev %d host #%u\n",
drivers/scsi/pmcraid.c:	dev_info(&pinstance->pdev->dev,
drivers/scsi/pmcraid.c:		dev_info(&pinstance->pdev->dev, "Error notifications lost\n");
drivers/scsi/pmcraid.c:		dev_info(&pinstance->pdev->dev,
drivers/scsi/pmcraid.c:		dev_info(&pinstance->pdev->dev,
drivers/scsi/pmcraid.c:		dev_info(&pinstance->pdev->dev,
drivers/scsi/pmcraid.c:	dev_err(&pinstance->pdev->dev,
drivers/scsi/pmcraid.c:		dev_err(&cmd->drv_inst->pdev->dev,
drivers/scsi/pmcraid.c:	u32 adapter_id = (pinstance->pdev->bus->number << 8) |
drivers/scsi/pmcraid.c:		pinstance->pdev->devfn;
drivers/scsi/pmcraid.c:	pinstance->hrrq_vector[0].vector = pdev->irq;
drivers/scsi/pmcraid.c:	rc = request_irq(pdev->irq, pmcraid_isr, IRQF_SHARED,
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev, "resume: Enable device failed\n");
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev, "resume: Failed to set PCI DMA mask\n");
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev,
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev, "couldn't initialize IOA\n");
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev, "Cannot enable adapter\n");
drivers/scsi/pmcraid.c:	dev_info(&pdev->dev,
drivers/scsi/pmcraid.c:		 pdev->vendor, pdev->device,
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev,
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev, "Couldn't map PCI registers memory\n");
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev, "Failed to set PCI DMA mask\n");
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev, "scsi_host_alloc failed!\n");
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev, "failed to initialize adapter instance\n");
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev, "Failed to save PCI config space\n");
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev, "couldn't register interrupt handler\n");
drivers/scsi/pmcraid.c:		dev_err(&pdev->dev, "couldn't initialize IOA\n");
drivers/scsi/pmcraid.c:	rc = scsi_add_host(pinstance->host, &pdev->dev);
drivers/scsi/csiostor/csio_hw.h:#define CSIO_PCI_BUS(hw)		((hw)->pdev->bus->number)
drivers/scsi/csiostor/csio_hw.h:#define CSIO_PCI_DEV(hw)		(PCI_SLOT((hw)->pdev->devfn))
drivers/scsi/csiostor/csio_hw.h:#define CSIO_PCI_FUNC(hw)		(PCI_FUNC((hw)->pdev->devfn))
drivers/scsi/csiostor/csio_hw.h:			dev_info(&(__hw)->pdev->dev, __fmt, ##__VA_ARGS__)
drivers/scsi/csiostor/csio_hw.h:			dev_crit(&(__hw)->pdev->dev, __fmt, ##__VA_ARGS__)
drivers/scsi/csiostor/csio_hw.h:			dev_err(&(__hw)->pdev->dev, __fmt, ##__VA_ARGS__)
drivers/scsi/csiostor/csio_hw.h:			dev_warn(&(__hw)->pdev->dev, __fmt, ##__VA_ARGS__)
drivers/scsi/csiostor/csio_init.c:		dev_err(&pdev->dev, "No suitable DMA available.\n");
drivers/scsi/csiostor/csio_init.c:	if (dev == &hw->pdev->dev)
drivers/scsi/csiostor/csio_init.c:	if (dev == &hw->pdev->dev)
drivers/scsi/csiostor/csio_init.c:	return csio_shost_init(hw, &hw->pdev->dev, false, NULL);
drivers/scsi/csiostor/csio_init.c:		dev_err(&pdev->dev,
drivers/scsi/csiostor/csio_init.c:		ln = csio_shost_init(hw, &pdev->dev, true, NULL);
drivers/scsi/csiostor/csio_init.c:	dev_err(&pdev->dev, "probe of device failed: %d\n", rv);
drivers/scsi/csiostor/csio_init.c:		dev_err(&pdev->dev, "cannot re-enable device in slot reset\n");
drivers/scsi/csiostor/csio_init.c:		dev_err(&pdev->dev, "Can't initialize HW when in slot reset\n");
drivers/scsi/csiostor/csio_init.c:		ln = csio_shost_init(hw, &pdev->dev, true, NULL);
drivers/scsi/csiostor/csio_init.c:	dev_err(&pdev->dev, "resume of device failed: %d\n", rv);
drivers/scsi/csiostor/csio_isr.c:		rv = request_irq(hw->pdev->irq, csio_fcoe_isr,
drivers/scsi/csiostor/csio_isr.c:			free_irq(hw->pdev->irq, hw);
drivers/scsi/csiostor/csio_isr.c:			free_irq(hw->pdev->irq, hw);
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "unknown resource type %d.\n", type);
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev, "sg count[0x%x] is bigger "
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "failed to create a internal cmd\n");
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "failed to allocate memory for FW"
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev, "failed to allocate memory"
drivers/scsi/mvumi.c:		dev_warn(&mhba->pdev->dev, "command pool is empty!\n");
drivers/scsi/mvumi.c:	dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:		dev_warn(&mhba->pdev->dev, "no free slot to use.\n");
drivers/scsi/mvumi.c:		dev_warn(&mhba->pdev->dev, "firmware io overflow.\n");
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "ob frame data error\n");
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "tag[0x%x] with NO command\n", tag);
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev, "request ID from FW:0x%x,"
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "enable device failed\n");
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "set master failed\n");
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:			dev_warn(&mhba->pdev->dev, "TIMEOUT:release tag [%d]\n",
drivers/scsi/mvumi.c:			dev_warn(&mhba->pdev->dev,
drivers/scsi/mvumi.c:				dev_err(&mhba->pdev->dev, "failed to get memory"
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "cannot build page, code[0x%x]\n",
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:	if (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9580) {
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "checksum error\n");
drivers/scsi/mvumi.c:		dev_dbg(&mhba->pdev->dev, "FW version:%d\n",
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "handshake: page code error\n");
drivers/scsi/mvumi.c:		dev_dbg(&mhba->pdev->dev, "handshake state[0x%x].\n", hs_state);
drivers/scsi/mvumi.c:		if (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9143) {
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "unknown handshake state [0x%x].\n",
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:	dev_dbg(&mhba->pdev->dev, "start firmware handshake...\n");
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:	dev_dbg(&mhba->pdev->dev, "firmware handshake done\n");
drivers/scsi/mvumi.c:	dev_warn(&mhba->pdev->dev,
drivers/scsi/mvumi.c:			dev_dbg(&mhba->pdev->dev, "remove disk %d-%d-%d.\n", 0,
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev, " no disk[%d] to remove\n",
drivers/scsi/mvumi.c:			dev_dbg(&mhba->pdev->dev, " add disk %d-%d-%d.\n", 0,
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev, " don't add disk %d-%d-%d.\n",
drivers/scsi/mvumi.c:		if (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9143)
drivers/scsi/mvumi.c:		dev_dbg(&mhba->pdev->dev,
drivers/scsi/mvumi.c:		dev_dbg(&mhba->pdev->dev, "release device(0:%d:0) wwid(%llx)\n",
drivers/scsi/mvumi.c:		dev_dbg(&mhba->pdev->dev, "release device(0:%d:0) wwid(%llx)\n",
drivers/scsi/mvumi.c:	if (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9580)
drivers/scsi/mvumi.c:				dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:				if (mhba->pdev->device ==
drivers/scsi/mvumi.c:			dev_dbg(&mhba->pdev->dev,
drivers/scsi/mvumi.c:	if (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9143)
drivers/scsi/mvumi.c:					dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:				dev_dbg(&mhba->pdev->dev,
drivers/scsi/mvumi.c:					dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:			dev_err(&mhba->pdev->dev, "event count[0x%x] is bigger"
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "get event failed, status=0x%x.\n",
drivers/scsi/mvumi.c:			dev_warn(&mhba->pdev->dev, "enter handshake again!\n");
drivers/scsi/mvumi.c:		dev_dbg(&mhba->pdev->dev, "firmware not ready.\n");
drivers/scsi/mvumi.c:		dev_dbg(&mhba->pdev->dev, "no free tag.\n");
drivers/scsi/mvumi.c:		if (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9580) {
drivers/scsi/mvumi.c:		dev_warn(&mhba->pdev->dev, "unexpected data direction[%d] "
drivers/scsi/mvumi.c:	switch (mhba->pdev->device) {
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "IO memory region busy!\n");
drivers/scsi/mvumi.c:	switch (mhba->pdev->device) {
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "device 0x%x not supported!\n",
drivers/scsi/mvumi.c:							mhba->pdev->device);
drivers/scsi/mvumi.c:	dev_dbg(&mhba->pdev->dev, "device id : %04X is found.\n",
drivers/scsi/mvumi.c:							mhba->pdev->device);
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:	host->irq = mhba->pdev->irq;
drivers/scsi/mvumi.c:	ret = scsi_add_host(host, &mhba->pdev->dev);
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "scsi_add_host failed\n");
drivers/scsi/mvumi.c:	if (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9580)
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev, "add virtual device failed\n");
drivers/scsi/mvumi.c:		dev_err(&mhba->pdev->dev,
drivers/scsi/mvumi.c:	if (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9580)
drivers/scsi/mvumi.c:	dev_dbg(&pdev->dev, " %#4.04x:%#4.04x:%#4.04x:%#4.04x: ",
drivers/scsi/mvumi.c:			pdev->vendor, pdev->device, pdev->subsystem_vendor,
drivers/scsi/mvumi.c:			pdev->subsystem_device);
drivers/scsi/mvumi.c:		dev_err(&pdev->dev, "scsi_host_alloc failed\n");
drivers/scsi/mvumi.c:	mhba->unique_id = pdev->bus->number << 8 | pdev->devfn;
drivers/scsi/mvumi.c:	ret = request_irq(mhba->pdev->irq, mvumi_isr_handler, IRQF_SHARED,
drivers/scsi/mvumi.c:		dev_err(&pdev->dev, "failed to register IRQ\n");
drivers/scsi/mvumi.c:	dev_dbg(&pdev->dev, "probe mvumi driver successfully.\n");
drivers/scsi/mvumi.c:	free_irq(mhba->pdev->irq, mhba);
drivers/scsi/mvumi.c:	free_irq(mhba->pdev->irq, mhba);
drivers/scsi/mvumi.c:	dev_dbg(&pdev->dev, "driver is removed!\n");
drivers/scsi/mvumi.c:	free_irq(mhba->pdev->irq, mhba);
drivers/scsi/mvumi.c:		dev_err(&pdev->dev, "enable device failed\n");
drivers/scsi/mvumi.c:	ret = request_irq(mhba->pdev->irq, mvumi_isr_handler, IRQF_SHARED,
drivers/scsi/mvumi.c:		dev_err(&pdev->dev, "failed to register IRQ\n");
drivers/scsi/aic7xxx_old.c:          temp_p->irq = pdev->irq;
drivers/scsi/aic7xxx_old.c:          temp_p->pci_bus = pdev->bus->number;
drivers/scsi/aic7xxx_old.c:          temp_p->pci_device_fn = pdev->devfn;
drivers/scsi/aic7xxx_old.c:              PCI_SLOT(pdev->devfn),
drivers/scsi/aic7xxx_old.c:              PCI_FUNC(pdev->devfn));
drivers/scsi/aic7xxx_old.c:              if (PCI_FUNC(pdev->devfn) != 0)
drivers/scsi/mpt2sas/mpt2sas_config.c:		mem->page = dma_alloc_coherent(&ioc->pdev->dev, mem->sz,
drivers/scsi/mpt2sas/mpt2sas_config.c:		dma_free_coherent(&ioc->pdev->dev, mem->sz, mem->page,
drivers/scsi/mpt2sas/mpt2sas_ctl.c:	karg.hw_rev = ioc->pdev->revision;
drivers/scsi/mpt2sas/mpt2sas_ctl.c:	karg.pci_id = ioc->pdev->device;
drivers/scsi/mpt2sas/mpt2sas_ctl.c:	karg.subsystem_device = ioc->pdev->subsystem_device;
drivers/scsi/mpt2sas/mpt2sas_ctl.c:	karg.subsystem_vendor = ioc->pdev->subsystem_vendor;
drivers/scsi/mpt2sas/mpt2sas_ctl.c:	karg.pci_information.u.bits.bus = ioc->pdev->bus->number;
drivers/scsi/mpt2sas/mpt2sas_ctl.c:	karg.pci_information.u.bits.device = PCI_SLOT(ioc->pdev->devfn);
drivers/scsi/mpt2sas/mpt2sas_ctl.c:	karg.pci_information.u.bits.function = PCI_FUNC(ioc->pdev->devfn);
drivers/scsi/mpt2sas/mpt2sas_ctl.c:	karg.pci_information.segment_id = pci_domain_nr(ioc->pdev->bus);
drivers/scsi/mpt2sas/mpt2sas_base.c:		    dma_get_required_mask(&pdev->dev);
drivers/scsi/mpt2sas/mpt2sas_base.c:	if (ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2008 &&
drivers/scsi/mpt2sas/mpt2sas_base.c:	    ioc->pdev->revision == 0x01) {
drivers/scsi/mpt2sas/mpt2sas_base.c:	if (ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2004 ||
drivers/scsi/mpt2sas/mpt2sas_base.c:	    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2008 ||
drivers/scsi/mpt2sas/mpt2sas_base.c:	    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2108_1 ||
drivers/scsi/mpt2sas/mpt2sas_base.c:	    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2108_2 ||
drivers/scsi/mpt2sas/mpt2sas_base.c:	    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2108_3 ||
drivers/scsi/mpt2sas/mpt2sas_base.c:	    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2116_1 ||
drivers/scsi/mpt2sas/mpt2sas_base.c:	    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2116_2)
drivers/scsi/mpt2sas/mpt2sas_base.c:	r = _base_request_irq(ioc, 0, ioc->pdev->irq);
drivers/scsi/mpt2sas/mpt2sas_base.c:	if (ioc->pdev->subsystem_vendor != PCI_VENDOR_ID_DELL)
drivers/scsi/mpt2sas/mpt2sas_base.c:	switch (ioc->pdev->subsystem_device) {
drivers/scsi/mpt2sas/mpt2sas_base.c:		sprintf(dell_branding, "0x%4X", ioc->pdev->subsystem_device);
drivers/scsi/mpt2sas/mpt2sas_base.c:	    ioc->pdev->vendor, ioc->pdev->device, ioc->pdev->subsystem_vendor,
drivers/scsi/mpt2sas/mpt2sas_base.c:	    ioc->pdev->subsystem_device);
drivers/scsi/mpt2sas/mpt2sas_base.c:	if (ioc->pdev->subsystem_vendor != PCI_VENDOR_ID_INTEL)
drivers/scsi/mpt2sas/mpt2sas_base.c:	switch (ioc->pdev->device) {
drivers/scsi/mpt2sas/mpt2sas_base.c:		switch (ioc->pdev->subsystem_device) {
drivers/scsi/mpt2sas/mpt2sas_base.c:		switch (ioc->pdev->subsystem_device) {
drivers/scsi/mpt2sas/mpt2sas_base.c:	if (ioc->pdev->subsystem_vendor != MPT2SAS_HP_3PAR_SSVID)
drivers/scsi/mpt2sas/mpt2sas_base.c:	switch (ioc->pdev->device) {
drivers/scsi/mpt2sas/mpt2sas_base.c:		switch (ioc->pdev->subsystem_device) {
drivers/scsi/mpt2sas/mpt2sas_base.c:		switch (ioc->pdev->subsystem_device) {
drivers/scsi/mpt2sas/mpt2sas_base.c:	   ioc->pdev->revision,
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	if (ioc->pdev->subsystem_vendor == PCI_VENDOR_ID_IBM)
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	if ((scsi_add_host(shost, &pdev->dev))) {
drivers/scsi/mpt2sas/mpt2sas_scsih.c:	pci_power_t device_state = pdev->current_state;
drivers/scsi/cxgbi/libcxgbi.c:		err = iscsi_host_add(shost, &cdev->pdev->dev);
drivers/scsi/cxgbi/libcxgbi.c:		dma_unmap_page(&pdev->dev, gl->phys_addr[i], PAGE_SIZE,
drivers/scsi/cxgbi/libcxgbi.c:		gl->phys_addr[i] = dma_map_page(&pdev->dev, gl->pages[i], 0,
drivers/scsi/cxgbi/libcxgbi.c:		if (unlikely(dma_mapping_error(&pdev->dev, gl->phys_addr[i]))) {
drivers/scsi/aic7xxx/aic79xx_osm_pci.c:		dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/aic7xxx/aic79xx_osm_pci.c:	unsigned int master_devfn = PCI_DEVFN(PCI_SLOT(pdev->devfn), 0);
drivers/scsi/aic7xxx/aic79xx_osm_pci.c:	master_pdev = pci_get_slot(pdev->bus, master_devfn);
drivers/scsi/aic7xxx/aic79xx_osm_pci.c:	struct device	*dev = &pdev->dev;
drivers/scsi/aic7xxx/aic79xx_osm_pci.c:	if ((ahd->features & AHD_MULTI_FUNC) && PCI_FUNC(pdev->devfn) != 0)
drivers/scsi/aic7xxx/aic7xxx_osm_pci.c:		dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/aic7xxx/aic7xxx_osm_pci.c:	unsigned int master_devfn = PCI_DEVFN(PCI_SLOT(pdev->devfn), 0);
drivers/scsi/aic7xxx/aic7xxx_osm_pci.c:	master_pdev = pci_get_slot(pdev->bus, master_devfn);
drivers/scsi/aic7xxx/aic7xxx_osm_pci.c:	struct device	*dev = &pdev->dev;
drivers/scsi/aic7xxx/aic7xxx_osm_pci.c:	if ((ahc->features & AHC_MULTI_FUNC) && PCI_FUNC(pdev->devfn) != 0)
drivers/scsi/a100u2w.c:	shost->irq = pdev->irq;
drivers/scsi/a100u2w.c:	error = request_irq(pdev->irq, inia100_intr, IRQF_SHARED,
drivers/scsi/a100u2w.c:				pdev->irq);
drivers/scsi/a100u2w.c:	error = scsi_add_host(shost, &pdev->dev);
drivers/scsi/dmx3191d.c:	shost->irq = pdev->irq;
drivers/scsi/dmx3191d.c:	if (request_irq(pdev->irq, NCR5380_intr, IRQF_SHARED,
drivers/scsi/dmx3191d.c:				    "switching to polled mode.\n", pdev->irq);
drivers/scsi/dmx3191d.c:	error = scsi_add_host(shost, &pdev->dev);
drivers/scsi/pm8001/pm8001_sas.c:		struct domain_device *pdev_p = pdev->parent;
drivers/scsi/pm8001/pm8001_sas.c:			return pdev->port->id;
drivers/scsi/pm8001/pm8001_sas.c:		pdev = pdev->parent;
drivers/scsi/pm8001/pm8001_init.c:	pm8001_ha->dev = &pdev->dev;
drivers/scsi/pm8001/pm8001_init.c:	pm8001_ha->irq = pdev->irq;
drivers/scsi/pm8001/pm8001_init.c:				dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/pm8001/pm8001_init.c:			dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/pm8001/pm8001_init.c:			dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/pm8001/pm8001_init.c:	rc = request_irq(pdev->irq, pm8001_interrupt_handler_intx, IRQF_SHARED,
drivers/scsi/pm8001/pm8001_init.c:	dev_printk(KERN_INFO, &pdev->dev,
drivers/scsi/pm8001/pm8001_init.c:	rc = scsi_add_host(shost, &pdev->dev);
drivers/scsi/pm8001/pm8001_init.c:	device_state = pdev->current_state;
drivers/scsi/atp870u.c:		atpdev->chip_ver = pdev->revision;
drivers/scsi/atp870u.c:		if (atpdev->chip_ver < 2)
drivers/scsi/atp870u.c:		atpdev->chip_ver = 0x04;
drivers/scsi/atp870u.c:		atpdev->chip_ver = pdev->revision;
drivers/scsi/atp870u.c:			"    IO:%x, IRQ:%d.\n", count, base_io, pdev->irq);
drivers/scsi/atp870u.c:		atpdev->ioport[0] = base_io + 0x40;
drivers/scsi/atp870u.c:		atpdev->pciport[0] = base_io + 0x28;
drivers/scsi/atp870u.c:		atpdev->dev_id = ent->device;
drivers/scsi/atp870u.c:		atpdev->host_id[0] = host_id;
drivers/scsi/atp870u.c:		atpdev->scam_on = inb(tmport);
drivers/scsi/atp870u.c:		atpdev->global_map[0] = inb(tmport);
drivers/scsi/atp870u.c:		atpdev->ultra_map[0] = inw(tmport);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x30);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x31);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x32);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x33);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x30);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x31);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x32);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x33);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x30);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x31);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x32);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x33);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x30);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x31);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x32);
drivers/scsi/atp870u.c:		atpdev->sp[0][m++] = inb(base_io + 0x33);
drivers/scsi/atp870u.c:		atpdev->ultra_map[0] = 0;
drivers/scsi/atp870u.c:		atpdev->async[0] = 0;
drivers/scsi/atp870u.c:			if (atpdev->sp[0][k] > 1) {
drivers/scsi/atp870u.c:				atpdev->ultra_map[0] |= n;
drivers/scsi/atp870u.c:				if (atpdev->sp[0][k] == 0)
drivers/scsi/atp870u.c:					atpdev->async[0] |= n;
drivers/scsi/atp870u.c:		atpdev->async[0] = ~(atpdev->async[0]);
drivers/scsi/atp870u.c:		outb(atpdev->global_map[0], base_io + 0x35);
drivers/scsi/atp870u.c:		atpdev->host = shpnt;
drivers/scsi/atp870u.c:		atpdev->pdev = pdev;
drivers/scsi/atp870u.c:		if (request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp880i", shpnt)) {
drivers/scsi/atp870u.c: 			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", pdev->irq);
drivers/scsi/atp870u.c:		shpnt->irq = pdev->irq;			
drivers/scsi/atp870u.c:			       , base_io, pdev->irq);
drivers/scsi/atp870u.c:		atpdev->pdev = pdev;
drivers/scsi/atp870u.c:		atpdev->dev_id  = ent->device;
drivers/scsi/atp870u.c:		atpdev->baseport = base_io;
drivers/scsi/atp870u.c:		atpdev->ioport[0] = base_io + 0x80;
drivers/scsi/atp870u.c:		atpdev->ioport[1] = base_io + 0xc0;
drivers/scsi/atp870u.c:		atpdev->pciport[0] = base_io + 0x40;
drivers/scsi/atp870u.c:		atpdev->pciport[1] = base_io + 0x50;
drivers/scsi/atp870u.c:		atpdev->host = shpnt;
drivers/scsi/atp870u.c:		atpdev->pdev = pdev;
drivers/scsi/atp870u.c:		if (request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp870u", shpnt)) {
drivers/scsi/atp870u.c:		shpnt->irq = pdev->irq;
drivers/scsi/atp870u.c:			"IO:%x, IRQ:%d.\n", count, base_io, pdev->irq);
drivers/scsi/atp870u.c:		atpdev->ioport[0] = base_io;
drivers/scsi/atp870u.c:		atpdev->pciport[0] = base_io + 0x20;
drivers/scsi/atp870u.c:		atpdev->dev_id = ent->device;
drivers/scsi/atp870u.c:		atpdev->host_id[0] = host_id;
drivers/scsi/atp870u.c:		atpdev->scam_on = inb(tmport);
drivers/scsi/atp870u.c:		atpdev->global_map[0] = inb(tmport++);
drivers/scsi/atp870u.c:		atpdev->ultra_map[0] = inw(tmport);
drivers/scsi/atp870u.c:		if (atpdev->ultra_map[0] == 0) {
drivers/scsi/atp870u.c:			atpdev->scam_on = 0x00;
drivers/scsi/atp870u.c:			atpdev->global_map[0] = 0x20;
drivers/scsi/atp870u.c:			atpdev->ultra_map[0] = 0xffff;
drivers/scsi/atp870u.c:		atpdev->host = shpnt;
drivers/scsi/atp870u.c:		atpdev->pdev = pdev;
drivers/scsi/atp870u.c:		if (request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp870i", shpnt)) {
drivers/scsi/atp870u.c:			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", pdev->irq);
drivers/scsi/atp870u.c:		if (atpdev->chip_ver > 0x07) {	/* check if atp876 chip then enable terminator */
drivers/scsi/atp870u.c:		if (atpdev->chip_ver == 4)
drivers/scsi/atp870u.c:		shpnt->irq = pdev->irq;		
drivers/scsi/atp870u.c:		if (scsi_add_host(shpnt, &pdev->dev))
drivers/scsi/atp870u.c:	free_irq(pdev->irq, shpnt);
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, HPSA "%d: a state change "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, HPSA "%d: LUN failure "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, HPSA "%d: report LUN data "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, HPSA "%d: a power on "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, HPSA "%d: unit attention "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, HPSA "%d: unknown "
drivers/scsi/hpsa.c:	dev_warn(&h->pdev->dev, HPSA "device busy");
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev, "too many devices, some will be "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "physical device with no LUN=0,"
drivers/scsi/hpsa.c:		dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d added.\n",
drivers/scsi/hpsa.c:	dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d updated.\n",
drivers/scsi/hpsa.c:	dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d changed.\n",
drivers/scsi/hpsa.c:	dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d removed.\n",
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "out of memory in "
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev,
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev, "didn't find c%db%dt%dl%d "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "scsi_add_device c%db%dt%dl%d failed, "
drivers/scsi/hpsa.c:	if (dma_mapping_error(&h->pdev->dev, temp64)) {
drivers/scsi/hpsa.c:					dev_warn(&h->pdev->dev, "cp %p "
drivers/scsi/hpsa.c:					dev_warn(&h->pdev->dev, "cp %p "
drivers/scsi/hpsa.c:				dev_warn(&h->pdev->dev, "cp %p "
drivers/scsi/hpsa.c:			dev_dbg(&h->pdev->dev, "cp %p has check condition: "
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev, "cp %p has status 0x%x "
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev, "cp %p SCSI status was 0. "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cp %p has"
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cp %p has "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cp %p had  hardware error\n", cp);
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cp %p had connection lost\n", cp);
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cp %p was aborted with status 0x%x\n",
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cp %p reports abort failed\n", cp);
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cp %p aborted due to an unsolicited "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cp %p timedout\n", cp);
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "Command unabortable\n");
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cp %p returned unknown status %x\n",
drivers/scsi/hpsa.c:	if (dma_mapping_error(&pdev->dev, addr64)) {
drivers/scsi/hpsa.c:	struct device *d = &cp->h->pdev->dev;
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cmd_special_alloc returned NULL!\n");
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cmd_special_alloc returned NULL!\n");
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev, "cmd_special_alloc returned NULL!\n");
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev,
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "Maximum number of external "
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev, "report physical LUNs failed.\n");
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "maximum physical LUNs (%d) exceeded."
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev, "report logical LUNs failed.\n");
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev,
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev,
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev, "out of memory\n");
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev, "maximum devices (%d) exceeded."
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev, "out of memory at %s:%d\n",
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev, "cmd_alloc returned NULL!\n");
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev, "unknown data direction: %d\n",
drivers/scsi/hpsa.c:	error = scsi_add_host(sh, &h->pdev->dev);
drivers/scsi/hpsa.c:	dev_err(&h->pdev->dev, "%s: scsi_add_host"
drivers/scsi/hpsa.c:	dev_err(&h->pdev->dev, "%s: scsi_host_alloc"
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "out of memory in "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "waiting %d secs "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "giving up on device.\n");
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "device is ready.\n");
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev, "hpsa_eh_device_reset_handler: "
drivers/scsi/hpsa.c:	dev_warn(&h->pdev->dev, "resetting device %d:%d:%d:%d\n",
drivers/scsi/hpsa.c:	dev_warn(&h->pdev->dev, "resetting device failed.\n");
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cmd_special_alloc returned NULL!\n");
drivers/scsi/hpsa.c:	dev_dbg(&h->pdev->dev, "%s: Tag:0x%08x:%08x: do_simple_cmd_core completed.\n",
drivers/scsi/hpsa.c:		dev_dbg(&h->pdev->dev, "%s: Tag:0x%08x:%08x: interpreting error.\n",
drivers/scsi/hpsa.c:	dev_dbg(&h->pdev->dev, "%s: Tag:0x%08x:%08x: Finished.\n", __func__,
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "Unexpectedly found byte-swapped tag in completion queue.\n");
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev, "%s FAILED, Device lookup failed.\n",
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev, "%s FAILED, Command to abort is NULL.\n",
drivers/scsi/hpsa.c:	dev_dbg(&h->pdev->dev, "%s\n", msg);
drivers/scsi/hpsa.c:	dev_warn(&h->pdev->dev, "Abort request on C%d:B%d:T%d:L%d\n",
drivers/scsi/hpsa.c:		dev_info(&h->pdev->dev, "%s Request SUCCEEDED (driver queue).\n",
drivers/scsi/hpsa.c:		dev_dbg(&h->pdev->dev, "%s Request SUCCEEDED (not known to driver).\n",
drivers/scsi/hpsa.c:		dev_dbg(&h->pdev->dev, "%s Request FAILED.\n", msg);
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "FAILED abort on device C%d:B%d:T%d:L%d\n",
drivers/scsi/hpsa.c:	dev_info(&h->pdev->dev, "%s REQUEST SUCCEEDED.\n", msg);
drivers/scsi/hpsa.c:	dev_warn(&h->pdev->dev, "%s FAILED. Aborted command has not completed after %d seconds.\n",
drivers/scsi/hpsa.c:	pciinfo.domain = pci_domain_nr(h->pdev->bus);
drivers/scsi/hpsa.c:	pciinfo.bus = h->pdev->bus->number;
drivers/scsi/hpsa.c:	pciinfo.dev_fn = h->pdev->devfn;
drivers/scsi/hpsa.c:		dev_info(&h->pdev->dev, "driver version string '%s' "
drivers/scsi/hpsa.c:		if (dma_mapping_error(&h->pdev->dev, temp64.val)) {
drivers/scsi/hpsa.c:			if (dma_mapping_error(&h->pdev->dev, temp64.val)) {
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev, "unknown command 0x%c\n", cmd);
drivers/scsi/hpsa.c:			dev_dbg(&h->pdev->dev, "Abort Tag:0x%08x:%08x using request Tag:0x%08x:%08x\n",
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev, "unknown message type %d\n",
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "unknown command type %d\n", cmd_type);
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev, "fifo full\n");
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "bad tag 0x%08x ignored.\n", raw_tag);
drivers/scsi/hpsa.c:	dev_info(&h->pdev->dev, "Received interrupt while interrupts disabled "
drivers/scsi/hpsa.c:		dev_err(&pdev->dev, "controller message %02x:%02x timed out\n",
drivers/scsi/hpsa.c:		dev_err(&pdev->dev, "controller message %02x:%02x failed\n",
drivers/scsi/hpsa.c:	dev_info(&pdev->dev, "controller message %02x:%02x succeeded\n",
drivers/scsi/hpsa.c:		dev_info(&pdev->dev, "using doorbell to reset controller\n");
drivers/scsi/hpsa.c:			dev_err(&pdev->dev,
drivers/scsi/hpsa.c:		dev_info(&pdev->dev, "using PCI PM to reset controller\n");
drivers/scsi/hpsa.c:		dev_warn(&pdev->dev, "Not resetting device.\n");
drivers/scsi/hpsa.c:			dev_warn(&pdev->dev, "Soft reset not supported. "
drivers/scsi/hpsa.c:		dev_warn(&pdev->dev, "failed to enable device.\n");
drivers/scsi/hpsa.c:	dev_info(&pdev->dev, "Waiting for board to reset.\n");
drivers/scsi/hpsa.c:		dev_warn(&pdev->dev,
drivers/scsi/hpsa.c:		dev_warn(&pdev->dev,
drivers/scsi/hpsa.c:		dev_warn(&pdev->dev, "Unable to successfully reset "
drivers/scsi/hpsa.c:		dev_info(&pdev->dev, "board ready after hard reset.\n");
drivers/scsi/hpsa.c:				dev_warn(&pdev->dev,
drivers/scsi/hpsa.c:		dev_info(&h->pdev->dev, "MSIX\n");
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev, "only %d MSI-X vectors "
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev, "MSI-X init failed %d\n",
drivers/scsi/hpsa.c:		dev_info(&h->pdev->dev, "MSI\n");
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev, "MSI init failed\n");
drivers/scsi/hpsa.c:	h->intr[h->intr_mode] = h->pdev->irq;
drivers/scsi/hpsa.c:	subsystem_vendor_id = pdev->subsystem_vendor;
drivers/scsi/hpsa.c:	subsystem_device_id = pdev->subsystem_device;
drivers/scsi/hpsa.c:		dev_warn(&pdev->dev, "unrecognized board ID: "
drivers/scsi/hpsa.c:			dev_dbg(&pdev->dev, "memory BAR = %lx\n",
drivers/scsi/hpsa.c:	dev_warn(&pdev->dev, "no memory BAR found\n");
drivers/scsi/hpsa.c:	dev_warn(&pdev->dev, "board not ready, timed out.\n");
drivers/scsi/hpsa.c:		dev_warn(&pdev->dev, "cannot find cfg_base_addr_index\n");
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "Controller reports "
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "not a valid CISS config table\n");
drivers/scsi/hpsa.c:	print_cfg_table(&h->pdev->dev, h->cfgtable);
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev,
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "unable to enable PCI device\n");
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev,
drivers/scsi/hpsa.c:	dev_warn(&pdev->dev, "Waiting for controller to respond to no-op\n");
drivers/scsi/hpsa.c:			dev_warn(&pdev->dev, "no-op failed%s\n",
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev, "out of memory in %s", __func__);
drivers/scsi/hpsa.c:		dev_err(&h->pdev->dev, "unable to get irq %d for %s\n",
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "Resetting array controller failed.\n");
drivers/scsi/hpsa.c:	dev_info(&h->pdev->dev, "Waiting for board to soft reset.\n");
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "Soft reset had no effect.\n");
drivers/scsi/hpsa.c:	dev_info(&h->pdev->dev, "Board reset, awaiting READY status.\n");
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "Board failed to become ready "
drivers/scsi/hpsa.c:		if (h->pdev->msix_enabled)
drivers/scsi/hpsa.c:		if (h->pdev->msi_enabled)
drivers/scsi/hpsa.c:	dev_warn(&h->pdev->dev, "Controller lockup detected: 0x%08x\n",
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev,
drivers/scsi/hpsa.c:			dev_err(&pdev->dev, "no suitable DMA available\n");
drivers/scsi/hpsa.c:	dev_info(&pdev->dev, "%s: <0x%x> at IRQ %d%s using DAC\n",
drivers/scsi/hpsa.c:	       h->devname, pdev->device,
drivers/scsi/hpsa.c:			dev_warn(&h->pdev->dev, "Failed to request_irq after "
drivers/scsi/hpsa.c:		dev_info(&h->pdev->dev, "Board READY.\n");
drivers/scsi/hpsa.c:		dev_info(&h->pdev->dev,
drivers/scsi/hpsa.c:			dev_info(&h->pdev->dev,
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "cmd_special_alloc returned NULL!\n");
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev,
drivers/scsi/hpsa.c:		dev_err(&pdev->dev, "unable to remove device\n");
drivers/scsi/hpsa.c:		dev_warn(&h->pdev->dev, "unable to get board into"
drivers/scsi/mvsas/mv_init.c:	stat = MVS_CHIP_DISP->isr_status(mvi, mvi->pdev->irq);
drivers/scsi/mvsas/mv_init.c:		MVS_CHIP_DISP->isr(mvi, mvi->pdev->irq, stat);
drivers/scsi/mvsas/mv_init.c:	mvi->dev = &pdev->dev;
drivers/scsi/mvsas/mv_init.c:				dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/mvsas/mv_init.c:			dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/mvsas/mv_init.c:			dev_printk(KERN_ERR, &pdev->dev,
drivers/scsi/mvsas/mv_init.c:	dev_printk(KERN_INFO, &pdev->dev,
drivers/scsi/mvsas/mv_init.c:	rc = scsi_add_host(shost, &pdev->dev);
drivers/scsi/mvsas/mv_init.c:	rc = request_irq(pdev->irq, irq_handler, IRQF_SHARED,
drivers/scsi/mvsas/mv_init.c:	free_irq(mvi->pdev->irq, sha);
drivers/scsi/mvsas/mv_94xx.c:	if (mvi->pdev->revision == VANIR_A0_REV)
drivers/scsi/mvsas/mv_94xx.c:	if ((mvi->pdev->revision == VANIR_A0_REV)
drivers/scsi/mvsas/mv_94xx.c:		|| (mvi->pdev->revision == VANIR_B0_REV))
drivers/scsi/mvsas/mv_94xx.c:		switch (mvi->pdev->revision) {
drivers/scsi/mvsas/mv_94xx.c:	revision = mvi->pdev->revision;
drivers/scsi/mvsas/mv_94xx.c:	revision = mvi->pdev->revision;
drivers/scsi/mvsas/mv_94xx.c:	if ((mvi->pdev->revision == VANIR_A0_REV) ||
drivers/scsi/mvsas/mv_94xx.c:			(mvi->pdev->revision == VANIR_B0_REV))
drivers/scsi/mvsas/mv_64xx.c:	if (mvi->pdev && mvi->pdev->revision == 0)
drivers/scsi/eata.c:	if (pdev && (irq != pdev->irq)) {
drivers/scsi/eata.c:		       pdev->irq);
drivers/scsi/eata.c:		irq = pdev->irq;
drivers/scsi/arcmsr/arcmsr_hba.c:		dma_free_coherent(&acb->pdev->dev,
drivers/scsi/arcmsr/arcmsr_hba.c:	dma_coherent = dma_alloc_coherent(&pdev->dev, acb->uncache_size, &dma_coherent_handle, GFP_KERNEL);
drivers/scsi/arcmsr/arcmsr_hba.c:	bus = pdev->bus->number;
drivers/scsi/arcmsr/arcmsr_hba.c:	dev_fun = pdev->devfn;
drivers/scsi/arcmsr/arcmsr_hba.c:	error = scsi_add_host(host, &pdev->dev);
drivers/scsi/arcmsr/arcmsr_hba.c:	error = request_irq(pdev->irq, arcmsr_do_interrupt, IRQF_SHARED, "arcmsr", acb);
drivers/scsi/arcmsr/arcmsr_hba.c:	host->irq = pdev->irq;
drivers/scsi/arcmsr/arcmsr_hba.c:	free_irq(pdev->irq, acb);
drivers/scsi/arcmsr/arcmsr_hba.c:	dma_free_coherent(&acb->pdev->dev, acb->uncache_size, acb->dma_coherent, acb->dma_coherent_handle);
drivers/scsi/arcmsr/arcmsr_hba.c:	dma_coherent = dma_alloc_coherent(&pdev->dev, sizeof(struct MessageUnit_B), &dma_coherent_handle, GFP_KERNEL);
drivers/scsi/arcmsr/arcmsr_hba.c:	switch (acb->pdev->device) {
drivers/scsi/sgiwd93.c:	struct sgiwd93_platform_data *pd = pdev->dev.platform_data;
drivers/scsi/sgiwd93.c:	hdata->dev = &pdev->dev;
drivers/scsi/sgiwd93.c:	hdata->cpu = dma_alloc_noncoherent(&pdev->dev, HPC_DMA_SIZE,
drivers/scsi/sgiwd93.c:	dma_free_noncoherent(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma);
drivers/scsi/sgiwd93.c:	struct sgiwd93_platform_data *pd = pdev->dev.platform_data;
drivers/scsi/sgiwd93.c:	dma_free_noncoherent(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma);
drivers/scsi/megaraid/megaraid_sas_fp.c:		    ((instance->pdev->device != PCI_DEVICE_ID_LSI_INVADER) ||
drivers/scsi/megaraid/megaraid_sas_fp.c:		     (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER &&
drivers/scsi/megaraid/megaraid_sas_fp.c:	if (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER)
drivers/scsi/megaraid/megaraid_mbox.c:		pdev->vendor, pdev->device, pdev->subsystem_vendor,
drivers/scsi/megaraid/megaraid_mbox.c:		pdev->subsystem_device));
drivers/scsi/megaraid/megaraid_mbox.c:	con_log(CL_ANN, ("bus %d:slot %d:func %d\n", pdev->bus->number,
drivers/scsi/megaraid/megaraid_mbox.c:		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn)));
drivers/scsi/megaraid/megaraid_mbox.c:	adapter->unique_id	= pdev->bus->number << 8 | pdev->devfn;
drivers/scsi/megaraid/megaraid_mbox.c:	adapter->irq		= pdev->irq;
drivers/scsi/megaraid/megaraid_mbox.c:			pdev->vendor, pdev->device, pdev->subsystem_vendor,
drivers/scsi/megaraid/megaraid_mbox.c:			pdev->subsystem_device));
drivers/scsi/megaraid/megaraid_mbox.c:			pdev->vendor, pdev->device, pdev->subsystem_vendor,
drivers/scsi/megaraid/megaraid_mbox.c:			pdev->subsystem_device));
drivers/scsi/megaraid/megaraid_mbox.c:	if (scsi_add_host(host, &adapter->pdev->dev)) {
drivers/scsi/megaraid/megaraid_mbox.c:		((adapter->pdev->subsystem_device !=
drivers/scsi/megaraid/megaraid_mbox.c:		(adapter->pdev->subsystem_device !=
drivers/scsi/megaraid/megaraid_mbox.c:		(adapter->pdev->vendor == PCI_VENDOR_ID_LSI_LOGIC &&
drivers/scsi/megaraid/megaraid_mbox.c:		adapter->pdev->device == PCI_DEVICE_ID_VERDE) ||
drivers/scsi/megaraid/megaraid_mbox.c:		(adapter->pdev->vendor == PCI_VENDOR_ID_LSI_LOGIC &&
drivers/scsi/megaraid/megaraid_mbox.c:		adapter->pdev->device == PCI_DEVICE_ID_DOBSON) ||
drivers/scsi/megaraid/megaraid_mbox.c:		(adapter->pdev->vendor == PCI_VENDOR_ID_LSI_LOGIC &&
drivers/scsi/megaraid/megaraid_mbox.c:		adapter->pdev->device == PCI_DEVICE_ID_LINDSAY) ||
drivers/scsi/megaraid/megaraid_mbox.c:		(adapter->pdev->vendor == PCI_VENDOR_ID_DELL &&
drivers/scsi/megaraid/megaraid_mbox.c:		adapter->pdev->device == PCI_DEVICE_ID_PERC4_DI_EVERGLADES) ||
drivers/scsi/megaraid/megaraid_mbox.c:		(adapter->pdev->vendor == PCI_VENDOR_ID_DELL &&
drivers/scsi/megaraid/megaraid_mbox.c:		adapter->pdev->device == PCI_DEVICE_ID_PERC4E_DI_KOBUK)) {
drivers/scsi/megaraid/megaraid_mbox.c:	if (adapter->pdev->vendor == PCI_VENDOR_ID_AMI &&
drivers/scsi/megaraid/megaraid_mbox.c:	    adapter->pdev->device == PCI_DEVICE_ID_AMI_MEGARAID3 &&
drivers/scsi/megaraid/megaraid_mbox.c:	    adapter->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL &&
drivers/scsi/megaraid/megaraid_mbox.c:	    adapter->pdev->subsystem_device == PCI_SUBSYS_ID_CERC_ATA100_4CH &&
drivers/scsi/megaraid/megaraid_mbox.c:	hinfo->pci_vendor_id	= adapter->pdev->vendor;
drivers/scsi/megaraid/megaraid_mbox.c:	hinfo->pci_device_id	= adapter->pdev->device;
drivers/scsi/megaraid/megaraid_mbox.c:	hinfo->subsys_vendor_id	= adapter->pdev->subsystem_vendor;
drivers/scsi/megaraid/megaraid_mbox.c:	hinfo->subsys_device_id	= adapter->pdev->subsystem_device;
drivers/scsi/megaraid/megaraid_mbox.c:	hinfo->pci_bus		= adapter->pdev->bus->number;
drivers/scsi/megaraid/megaraid_mbox.c:	hinfo->pci_dev_fn	= adapter->pdev->devfn;
drivers/scsi/megaraid/megaraid_mbox.c:	hinfo->pci_slot		= PCI_SLOT(adapter->pdev->devfn);
drivers/scsi/megaraid/megaraid_mbox.c:	hinfo->unique_id	= (hinfo->pci_bus << 8) | adapter->pdev->devfn;
drivers/scsi/megaraid/megaraid_sas_base.c:	if ((instance->pdev->device != PCI_DEVICE_ID_LSI_FUSION) &&
drivers/scsi/megaraid/megaraid_sas_base.c:	    (instance->pdev->device != PCI_DEVICE_ID_LSI_INVADER) &&
drivers/scsi/megaraid/megaraid_sas_base.c:	if ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||
drivers/scsi/megaraid/megaraid_sas_base.c:	    (instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||
drivers/scsi/megaraid/megaraid_sas_base.c:	    (instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||
drivers/scsi/megaraid/megaraid_sas_base.c:	    (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER)) {
drivers/scsi/megaraid/megaraid_sas_base.c:		if ((instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:			(instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:	if ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||
drivers/scsi/megaraid/megaraid_sas_base.c:	(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||
drivers/scsi/megaraid/megaraid_sas_base.c:	(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)) {
drivers/scsi/megaraid/megaraid_sas_base.c:		if ((instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:			(instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:	if ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||
drivers/scsi/megaraid/megaraid_sas_base.c:	    (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER))
drivers/scsi/megaraid/megaraid_sas_base.c:		if ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||
drivers/scsi/megaraid/megaraid_sas_base.c:			(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||
drivers/scsi/megaraid/megaraid_sas_base.c:			(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)
drivers/scsi/megaraid/megaraid_sas_base.c:			if ((instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:				(instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:				(instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:			if ((instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:				(instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:				(instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:				(instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:			if ((instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:				(instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:			    (instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:			    (instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:			if ((instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:				(instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:				(instance->pdev->device
drivers/scsi/megaraid/megaraid_sas_base.c:				(instance->pdev->device
drivers/scsi/megaraid/megaraid_sas_base.c:				if ((instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:				    (instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:		if ((instance->pdev->device != PCI_DEVICE_ID_LSI_FUSION) &&
drivers/scsi/megaraid/megaraid_sas_base.c:		    (instance->pdev->device != PCI_DEVICE_ID_LSI_INVADER) &&
drivers/scsi/megaraid/megaraid_sas_base.c:	switch (instance->pdev->device) {
drivers/scsi/megaraid/megaraid_sas_base.c:		dev_info(&instance->pdev->dev,
drivers/scsi/megaraid/megaraid_sas_base.c:		if ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||
drivers/scsi/megaraid/megaraid_sas_base.c:		    (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER)) {
drivers/scsi/megaraid/megaraid_sas_base.c:	if (instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY ||
drivers/scsi/megaraid/megaraid_sas_base.c:	    instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY) {
drivers/scsi/megaraid/megaraid_sas_base.c:	host->irq = instance->pdev->irq;
drivers/scsi/megaraid/megaraid_sas_base.c:	if ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||
drivers/scsi/megaraid/megaraid_sas_base.c:		(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY)) {
drivers/scsi/megaraid/megaraid_sas_base.c:			if (((instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:				(instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_base.c:	if ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||
drivers/scsi/megaraid/megaraid_sas_base.c:	    (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER)) {
drivers/scsi/megaraid/megaraid_sas_base.c:	if (scsi_add_host(host, &instance->pdev->dev)) {
drivers/scsi/megaraid/megaraid_sas_base.c:				dev_info(&pdev->dev, "resetting MSI-X\n");
drivers/scsi/megaraid/megaraid_sas_base.c:	       pdev->vendor, pdev->device, pdev->subsystem_vendor,
drivers/scsi/megaraid/megaraid_sas_base.c:	       pdev->subsystem_device);
drivers/scsi/megaraid/megaraid_sas_base.c:	       pdev->bus->number, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
drivers/scsi/megaraid/megaraid_sas_base.c:	switch (instance->pdev->device) {
drivers/scsi/megaraid/megaraid_sas_base.c:	instance->unique_id = pdev->bus->number << 8 | pdev->devfn;
drivers/scsi/megaraid/megaraid_sas_base.c:	if ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||
drivers/scsi/megaraid/megaraid_sas_base.c:		(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY)) {
drivers/scsi/megaraid/megaraid_sas_base.c:	if ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||
drivers/scsi/megaraid/megaraid_sas_base.c:	    (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER))
drivers/scsi/megaraid/megaraid_sas_base.c:		if (request_irq(pdev->irq, instance->instancet->service_isr,
drivers/scsi/megaraid/megaraid_sas_base.c:		free_irq(instance->pdev->irq, &instance->irq_context[0]);
drivers/scsi/megaraid/megaraid_sas_base.c:	if ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||
drivers/scsi/megaraid/megaraid_sas_base.c:	    (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER))
drivers/scsi/megaraid/megaraid_sas_base.c:		free_irq(instance->pdev->irq, &instance->irq_context[0]);
drivers/scsi/megaraid/megaraid_sas_base.c:	switch (instance->pdev->device) {
drivers/scsi/megaraid/megaraid_sas_base.c:		if (request_irq(pdev->irq, instance->instancet->service_isr,
drivers/scsi/megaraid/megaraid_sas_base.c:		free_irq(instance->pdev->irq, &instance->irq_context[0]);
drivers/scsi/megaraid/megaraid_sas_base.c:	switch (instance->pdev->device) {
drivers/scsi/megaraid/megaraid_sas_base.c:				dma_free_coherent(&instance->pdev->dev,
drivers/scsi/megaraid/megaraid_sas_base.c:		free_irq(instance->pdev->irq, &instance->irq_context[0]);
drivers/scsi/megaraid/megaraid_sas_base.c:		kbuff_arr[i] = dma_alloc_coherent(&instance->pdev->dev,
drivers/scsi/megaraid/megaraid_sas_base.c:		sense = dma_alloc_coherent(&instance->pdev->dev, ioc->sense_len,
drivers/scsi/megaraid/megaraid_sas_base.c:		dma_free_coherent(&instance->pdev->dev, ioc->sense_len,
drivers/scsi/megaraid/megaraid_sas_base.c:			dma_free_coherent(&instance->pdev->dev,
drivers/scsi/megaraid/megaraid_sas_fusion.c:		dma_free_coherent(&instance->pdev->dev, req_sz,
drivers/scsi/megaraid/megaraid_sas_fusion.c:		dma_alloc_coherent(&instance->pdev->dev,
drivers/scsi/megaraid/megaraid_sas_fusion.c:	dma_free_coherent(&instance->pdev->dev, fusion->request_alloc_sz,
drivers/scsi/megaraid/megaraid_sas_fusion.c:	dma_free_coherent(&instance->pdev->dev, fusion->request_alloc_sz,
drivers/scsi/megaraid/megaraid_sas_fusion.c:	  dma_alloc_coherent(&instance->pdev->dev,
drivers/scsi/megaraid/megaraid_sas_fusion.c:		dma_free_coherent(&instance->pdev->dev,
drivers/scsi/megaraid/megaraid_sas_fusion.c:		fusion->ld_map[i] = dma_alloc_coherent(&instance->pdev->dev,
drivers/scsi/megaraid/megaraid_sas_fusion.c:		dma_free_coherent(&instance->pdev->dev, fusion->map_sz,
drivers/scsi/megaraid/megaraid_sas_fusion.c:	if (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) {
drivers/scsi/megaraid/megaraid_sas_fusion.c:		if (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) {
drivers/scsi/megaraid/megaraid_sas_fusion.c:			if (instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_fusion.c:			if (instance->pdev->device ==
drivers/scsi/megaraid/megaraid_sas_fusion.c:		if (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) {
drivers/scsi/megaraid/megaraid_sas_fusion.c:		if (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) {
drivers/scsi/megaraid/megaraid_sas_fusion.c:	if (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) {
drivers/scsi/megaraid.c:	pci_bus = pdev->bus->number;
drivers/scsi/megaraid.c:	pci_dev_func = pdev->devfn;
drivers/scsi/megaraid.c:	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
drivers/scsi/megaraid.c:		if (pdev->subsystem_vendor == PCI_VENDOR_ID_COMPAQ &&
drivers/scsi/megaraid.c:		    pdev->subsystem_device == 0xC000)
drivers/scsi/megaraid.c:	subsysvid = pdev->subsystem_vendor;
drivers/scsi/megaraid.c:	subsysid = pdev->subsystem_device;
drivers/scsi/megaraid.c:	irq = pdev->irq;
drivers/scsi/megaraid.c:	error = scsi_add_host(host, &pdev->dev);
drivers/scsi/3w-xxxx.c:	retval = scsi_add_host(host, &pdev->dev);
drivers/scsi/3w-xxxx.c:	printk(KERN_WARNING "3w-xxxx: scsi%d: Found a 3ware Storage Controller at 0x%x, IRQ: %d.\n", host->host_no, tw_dev->base_addr, pdev->irq);
drivers/scsi/3w-xxxx.c:	retval = request_irq(pdev->irq, tw_interrupt, IRQF_SHARED, "3w-xxxx", tw_dev);
drivers/scsi/gdth.c:	u16 vendor = pdev->vendor;
drivers/scsi/gdth.c:	u16 device = pdev->device;
drivers/scsi/gdth.c:		gdth_pcistr.pdev->bus->number,
drivers/scsi/gdth.c:		PCI_SLOT(gdth_pcistr.pdev->devfn),
drivers/scsi/gdth.c:    if (pdev->vendor == PCI_VENDOR_ID_INTEL)
drivers/scsi/gdth.c:    ha->brd_phys = (pdev->bus->number << 8) | (pdev->devfn & 0xf8);
drivers/scsi/gdth.c:    ha->stype = (u32)pdev->device;
drivers/scsi/gdth.c:    ha->irq = pdev->irq;
drivers/scsi/gdth.c:    if (ha->pdev->device <= PCI_DEVICE_ID_VORTEX_GDT6000B) {  /* GDT6000/B */
drivers/scsi/gdth.c:    } else if (ha->pdev->device <= PCI_DEVICE_ID_VORTEX_GDT6555) { /* GDT6110, ... */
drivers/scsi/gdth.c:        switch (ha->pdev->device) {
drivers/scsi/gdth.c:                    ctrt.ext_type = 0x6000 | ha->pdev->subsystem_device;
drivers/scsi/gdth.c:            ctrt.device_id = ha->pdev->device;
drivers/scsi/gdth.c:            ctrt.sub_device_id = ha->pdev->subsystem_device;
drivers/scsi/gdth.c:		pdev->bus->number,
drivers/scsi/gdth.c:		PCI_SLOT(pdev->devfn),
drivers/scsi/gdth.c:	ha->tid_cnt = pdev->device >= 0x200 ? MAXID : MAX_HDRIVES;
drivers/scsi/gdth.c:	error = scsi_add_host(shp, &pdev->dev);
drivers/scsi/initio.c:	shost->irq = pdev->irq;
drivers/scsi/initio.c:	error = request_irq(pdev->irq, i91u_intr, IRQF_DISABLED|IRQF_SHARED, "i91u", shost);
drivers/scsi/initio.c:		printk(KERN_WARNING "initio: Unable to request IRQ %d\n", pdev->irq);
drivers/scsi/initio.c:	error = scsi_add_host(shost, &pdev->dev);
drivers/scsi/initio.c:	free_irq(pdev->irq, shost);
drivers/scsi/initio.c:	free_irq(pdev->irq, host);
drivers/scsi/bnx2fc/bnx2fc_fcoe.c:	switch (pdev->device) {
drivers/scsi/bnx2fc/bnx2fc_fcoe.c:		pr_err(PFX "Unknown device id 0x%x\n", pdev->device);
drivers/parisc/superio.c:	pdev->irq = sio->usb_pdev->irq;
drivers/parisc/superio.c:	sio->usb_pdev->irq = superio_fixup_irq(sio->usb_pdev);
drivers/parisc/superio.c:	       pci_name(pdev), pdev->irq);
drivers/parisc/superio.c:	if (request_irq(pdev->irq, superio_interrupt, 0,
drivers/parisc/superio.c:	pdev->class |= 0x5;
drivers/parisc/superio.c:	pci_write_config_byte(pdev, PCI_CLASS_PROG, pdev->class);
drivers/regulator/virtual.c:	char *reg_id = pdev->dev.platform_data;
drivers/regulator/virtual.c:	drvdata = devm_kzalloc(&pdev->dev, sizeof(struct virtual_consumer_data),
drivers/regulator/virtual.c:	drvdata->regulator = devm_regulator_get(&pdev->dev, reg_id);
drivers/regulator/virtual.c:		dev_err(&pdev->dev, "Failed to obtain supply '%s': %d\n",
drivers/regulator/virtual.c:	ret = sysfs_create_group(&pdev->dev.kobj,
drivers/regulator/virtual.c:		dev_err(&pdev->dev,
drivers/regulator/virtual.c:	sysfs_remove_group(&pdev->dev.kobj, &regulator_virtual_attr_group);
drivers/regulator/max8998.c:	struct max8998_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/max8998.c:		dev_err(pdev->dev.parent, "No platform init data supplied\n");
drivers/regulator/max8998.c:	max8998 = devm_kzalloc(&pdev->dev, sizeof(struct max8998_data),
drivers/regulator/max8998.c:	max8998->rdev = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
drivers/regulator/max8998.c:	max8998->dev = &pdev->dev;
drivers/regulator/max8998.c:			dev_err(&pdev->dev,
drivers/regulator/max8998.c:			dev_err(&pdev->dev,
drivers/regulator/max8998.c:			dev_err(&pdev->dev,
drivers/regulator/wm8350-regulator.c:	struct wm8350 *wm8350 = dev_get_drvdata(&pdev->dev);
drivers/regulator/wm8350-regulator.c:	if (pdev->id < WM8350_DCDC_1 || pdev->id > WM8350_ISINK_B)
drivers/regulator/wm8350-regulator.c:	switch (pdev->id) {
drivers/regulator/wm8350-regulator.c:	config.dev = &pdev->dev;
drivers/regulator/wm8350-regulator.c:	config.init_data = pdev->dev.platform_data;
drivers/regulator/wm8350-regulator.c:	config.driver_data = dev_get_drvdata(&pdev->dev);
drivers/regulator/wm8350-regulator.c:	rdev = regulator_register(&wm8350_reg[pdev->id], &config);
drivers/regulator/wm8350-regulator.c:		dev_err(&pdev->dev, "failed to register %s\n",
drivers/regulator/wm8350-regulator.c:			wm8350_reg[pdev->id].name);
drivers/regulator/wm8350-regulator.c:	ret = wm8350_register_irq(wm8350, wm8350_reg[pdev->id].irq,
drivers/regulator/wm8350-regulator.c:		dev_err(&pdev->dev, "failed to register regulator %s IRQ\n",
drivers/regulator/wm8350-regulator.c:			wm8350_reg[pdev->id].name);
drivers/regulator/wm8350-regulator.c:	wm8350_free_irq(wm8350, wm8350_reg[pdev->id].irq, rdev);
drivers/regulator/wm8350-regulator.c:	pdev->dev.platform_data = initdata;
drivers/regulator/wm8350-regulator.c:	pdev->dev.parent = wm8350->dev;
drivers/regulator/wm8350-regulator.c:	led->isink_consumer.dev_name = dev_name(&pdev->dev);
drivers/regulator/wm8350-regulator.c:	led->dcdc_consumer.dev_name = dev_name(&pdev->dev);
drivers/regulator/wm8350-regulator.c:	pdev->dev.platform_data = pdata;
drivers/regulator/wm8350-regulator.c:	pdev->dev.parent = wm8350->dev;
drivers/regulator/ab8500-ext.c:	struct ab8500 *ab8500 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/ab8500-ext.c:		dev_err(&pdev->dev, "null mfd parent\n");
drivers/regulator/ab8500-ext.c:		dev_err(&pdev->dev, "null parent pdata\n");
drivers/regulator/ab8500-ext.c:		dev_err(&pdev->dev, "null pdata\n");
drivers/regulator/ab8500-ext.c:		dev_err(&pdev->dev, "Configuration error: size mismatch.\n");
drivers/regulator/ab8500-ext.c:		info->dev = &pdev->dev;
drivers/regulator/ab8500-ext.c:		config.dev = &pdev->dev;
drivers/regulator/ab8500-ext.c:			dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/regulator/wm8994-regulator.c:	struct wm8994 *wm8994 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/wm8994-regulator.c:	int id = pdev->id % ARRAY_SIZE(pdata->ldo);
drivers/regulator/wm8994-regulator.c:	dev_dbg(&pdev->dev, "Probing LDO%d\n", id + 1);
drivers/regulator/wm8994-regulator.c:	ldo = devm_kzalloc(&pdev->dev, sizeof(struct wm8994_ldo), GFP_KERNEL);
drivers/regulator/wm8994-regulator.c:		dev_err(&pdev->dev, "Unable to allocate private data\n");
drivers/regulator/rc5t583-regulator.c:	struct rc5t583 *rc5t583 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/rc5t583-regulator.c:		dev_err(&pdev->dev, "No platform data, exiting...\n");
drivers/regulator/rc5t583-regulator.c:	regs = devm_kzalloc(&pdev->dev, RC5T583_REGULATOR_MAX *
drivers/regulator/rc5t583-regulator.c:		dev_err(&pdev->dev, "Memory allocation failed exiting..\n");
drivers/regulator/rc5t583-regulator.c:			dev_warn(&pdev->dev,
drivers/regulator/rc5t583-regulator.c:		config.dev = &pdev->dev;
drivers/regulator/rc5t583-regulator.c:			dev_err(&pdev->dev, "Failed to register regulator %s\n",
drivers/regulator/tps65912-regulator.c:	struct tps65912 *tps65912 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/tps65912-regulator.c:	pmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);
drivers/regulator/tps65912-regulator.c:				pdev->name);
drivers/regulator/s5m8767.c:	struct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/s5m8767.c:	rdata = devm_kzalloc(&pdev->dev, sizeof(*rdata) *
drivers/regulator/s5m8767.c:	rmode = devm_kzalloc(&pdev->dev, sizeof(*rmode) *
drivers/regulator/s5m8767.c:						&pdev->dev, reg_np);
drivers/regulator/s5m8767.c:	struct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/s5m8767.c:		dev_err(pdev->dev.parent, "Platform data not supplied\n");
drivers/regulator/s5m8767.c:			dev_err(&pdev->dev, "S5M8767 GPIO DVS NOT VALID\n");
drivers/regulator/s5m8767.c:			dev_err(&pdev->dev, "S5M8767 GPIO DVS NOT VALID\n");
drivers/regulator/s5m8767.c:			dev_err(&pdev->dev, "S5M8767 GPIO DVS NOT VALID\n");
drivers/regulator/s5m8767.c:	s5m8767 = devm_kzalloc(&pdev->dev, sizeof(struct s5m8767_info),
drivers/regulator/s5m8767.c:	s5m8767->rdev = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
drivers/regulator/s5m8767.c:	s5m8767->dev = &pdev->dev;
drivers/regulator/s5m8767.c:			dev_err(&pdev->dev, "GPIO NOT VALID\n");
drivers/regulator/s5m8767.c:		ret = devm_gpio_request(&pdev->dev, pdata->buck_gpios[0],
drivers/regulator/s5m8767.c:		ret = devm_gpio_request(&pdev->dev, pdata->buck_gpios[1],
drivers/regulator/s5m8767.c:		ret = devm_gpio_request(&pdev->dev, pdata->buck_gpios[2],
drivers/regulator/s5m8767.c:	ret = devm_gpio_request(&pdev->dev, pdata->buck_ds[0], "S5M8767 DS2");
drivers/regulator/s5m8767.c:	ret = devm_gpio_request(&pdev->dev, pdata->buck_ds[1], "S5M8767 DS3");
drivers/regulator/s5m8767.c:	ret = devm_gpio_request(&pdev->dev, pdata->buck_ds[2], "S5M8767 DS4");
drivers/regulator/max8907-regulator.c:	np = of_node_get(pdev->dev.parent->of_node);
drivers/regulator/max8907-regulator.c:		dev_err(&pdev->dev, "regulators node not found\n");
drivers/regulator/max8907-regulator.c:	ret = of_regulator_match(&pdev->dev, regulators, max8907_matches,
drivers/regulator/max8907-regulator.c:		dev_err(&pdev->dev, "Error parsing regulator init data: %d\n",
drivers/regulator/max8907-regulator.c:	struct max8907 *max8907 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/max8907-regulator.c:	pmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);
drivers/regulator/max8907-regulator.c:		dev_err(&pdev->dev, "Failed to alloc pmic\n");
drivers/regulator/max8907-regulator.c:		config.dev = pdev->dev.parent;
drivers/regulator/max8907-regulator.c:			dev_err(&pdev->dev,
drivers/regulator/wm831x-ldo.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/wm831x-ldo.c:	id = pdev->id - id;
drivers/regulator/wm831x-ldo.c:	dev_dbg(&pdev->dev, "Probing LDO%d\n", id + 1);
drivers/regulator/wm831x-ldo.c:	ldo = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_ldo), GFP_KERNEL);
drivers/regulator/wm831x-ldo.c:		dev_err(&pdev->dev, "Unable to allocate private data\n");
drivers/regulator/wm831x-ldo.c:		dev_err(&pdev->dev, "No REG resource\n");
drivers/regulator/wm831x-ldo.c:	config.dev = pdev->dev.parent;
drivers/regulator/wm831x-ldo.c:		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
drivers/regulator/wm831x-ldo.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/wm831x-ldo.c:	id = pdev->id - id;
drivers/regulator/wm831x-ldo.c:	dev_dbg(&pdev->dev, "Probing LDO%d\n", id + 1);
drivers/regulator/wm831x-ldo.c:	ldo = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_ldo), GFP_KERNEL);
drivers/regulator/wm831x-ldo.c:		dev_err(&pdev->dev, "Unable to allocate private data\n");
drivers/regulator/wm831x-ldo.c:		dev_err(&pdev->dev, "No REG resource\n");
drivers/regulator/wm831x-ldo.c:	config.dev = pdev->dev.parent;
drivers/regulator/wm831x-ldo.c:		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
drivers/regulator/wm831x-ldo.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/wm831x-ldo.c:	id = pdev->id - id;
drivers/regulator/wm831x-ldo.c:	dev_dbg(&pdev->dev, "Probing LDO%d\n", id + 1);
drivers/regulator/wm831x-ldo.c:	ldo = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_ldo), GFP_KERNEL);
drivers/regulator/wm831x-ldo.c:		dev_err(&pdev->dev, "Unable to allocate private data\n");
drivers/regulator/wm831x-ldo.c:		dev_err(&pdev->dev, "No REG resource\n");
drivers/regulator/wm831x-ldo.c:	config.dev = pdev->dev.parent;
drivers/regulator/mc13xxx-regulator-core.c:	of_node_get(pdev->dev.parent->of_node);
drivers/regulator/mc13xxx-regulator-core.c:	parent = of_find_node_by_name(pdev->dev.parent->of_node, "regulators");
drivers/regulator/mc13xxx-regulator-core.c:	of_node_get(pdev->dev.parent->of_node);
drivers/regulator/mc13xxx-regulator-core.c:	parent = of_find_node_by_name(pdev->dev.parent->of_node, "regulators");
drivers/regulator/mc13xxx-regulator-core.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data) * priv->num_regulators,
drivers/regulator/mc13xxx-regulator-core.c:							&pdev->dev, child);
drivers/regulator/mc13xxx-regulator-core.c:			dev_warn(&pdev->dev,
drivers/regulator/max77686.c:	struct max77686_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/max77686.c:		dev_err(&pdev->dev, "could not find regulators sub-node\n");
drivers/regulator/max77686.c:	rdata = devm_kzalloc(&pdev->dev, sizeof(*rdata) *
drivers/regulator/max77686.c:		dev_err(&pdev->dev,
drivers/regulator/max77686.c:		of_regulator_match(&pdev->dev, regulators_np, &rmatch, 1);
drivers/regulator/max77686.c:	struct max77686_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/max77686.c:	dev_dbg(&pdev->dev, "%s\n", __func__);
drivers/regulator/max77686.c:		dev_err(&pdev->dev, "no platform data found for regulator\n");
drivers/regulator/max77686.c:		dev_err(&pdev->dev,
drivers/regulator/max77686.c:	max77686 = devm_kzalloc(&pdev->dev, sizeof(struct max77686_data),
drivers/regulator/max77686.c:	config.dev = &pdev->dev;
drivers/regulator/max77686.c:			dev_err(&pdev->dev,
drivers/regulator/ab3100.c:	reg->dev = &pdev->dev;
drivers/regulator/ab3100.c:	config.dev = &pdev->dev;
drivers/regulator/ab3100.c:		dev_err(&pdev->dev,
drivers/regulator/ab3100.c:		err = abx500_set_register_interruptible(&pdev->dev, 0,
drivers/regulator/ab3100.c:			dev_err(&pdev->dev, "regulator initialization failed with error %d\n",
drivers/regulator/ab3100.c:	struct ab3100_platform_data *plfdata = pdev->dev.platform_data;
drivers/regulator/ab3100.c:	struct device_node *np = pdev->dev.of_node;
drivers/regulator/ab3100.c:	err = abx500_get_register_interruptible(&pdev->dev, 0,
drivers/regulator/ab3100.c:		dev_err(&pdev->dev, "could not read initial status of LDO_D\n");
drivers/regulator/ab3100.c:		dev_notice(&pdev->dev,
drivers/regulator/ab3100.c:		dev_notice(&pdev->dev,
drivers/regulator/ab3100.c:		err = of_regulator_match(&pdev->dev, np,
drivers/regulator/ab3100.c:			dev_err(&pdev->dev,
drivers/regulator/ab3100.c:		err = abx500_set_register_interruptible(&pdev->dev, 0,
drivers/regulator/ab3100.c:			dev_err(&pdev->dev, "regulator initialization failed with error %d\n",
drivers/regulator/wm8400-regulator.c:	struct wm8400 *wm8400 = container_of(pdev, struct wm8400, regulators[pdev->id]);
drivers/regulator/wm8400-regulator.c:	config.dev = &pdev->dev;
drivers/regulator/wm8400-regulator.c:	config.init_data = pdev->dev.platform_data;
drivers/regulator/wm8400-regulator.c:	rdev = regulator_register(&regulators[pdev->id], &config);
drivers/regulator/tps6507x-regulator.c:	struct device_node *np = pdev->dev.parent->of_node;
drivers/regulator/tps6507x-regulator.c:	tps_board = devm_kzalloc(&pdev->dev, sizeof(*tps_board),
drivers/regulator/tps6507x-regulator.c:		dev_err(&pdev->dev, "Failure to alloc pdata for regulators.\n");
drivers/regulator/tps6507x-regulator.c:		dev_err(&pdev->dev, "regulator node not found\n");
drivers/regulator/tps6507x-regulator.c:	ret = of_regulator_match(&pdev->dev, regulators, matches, count);
drivers/regulator/tps6507x-regulator.c:		dev_err(&pdev->dev, "Error parsing regulator init data: %d\n",
drivers/regulator/tps6507x-regulator.c:	reg_data = devm_kzalloc(&pdev->dev, (sizeof(struct regulator_init_data)
drivers/regulator/tps6507x-regulator.c:		dev_err(&pdev->dev, "Failure to alloc init data for regulators.\n");
drivers/regulator/tps6507x-regulator.c:	struct tps6507x_dev *tps6507x_dev = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/tps6507x-regulator.c:	tps = devm_kzalloc(&pdev->dev, sizeof(*tps), GFP_KERNEL);
drivers/regulator/tps6507x-regulator.c:				pdev->name);
drivers/regulator/userspace-consumer.c:	pdata = pdev->dev.platform_data;
drivers/regulator/userspace-consumer.c:	drvdata = devm_kzalloc(&pdev->dev,
drivers/regulator/userspace-consumer.c:	ret = devm_regulator_bulk_get(&pdev->dev, drvdata->num_supplies,
drivers/regulator/userspace-consumer.c:		dev_err(&pdev->dev, "Failed to get supplies: %d\n", ret);
drivers/regulator/userspace-consumer.c:	ret = sysfs_create_group(&pdev->dev.kobj, &attr_group);
drivers/regulator/userspace-consumer.c:			dev_err(&pdev->dev,
drivers/regulator/userspace-consumer.c:	sysfs_remove_group(&pdev->dev.kobj, &attr_group);
drivers/regulator/userspace-consumer.c:	sysfs_remove_group(&pdev->dev.kobj, &attr_group);
drivers/regulator/dummy.c:	config.dev = &pdev->dev;
drivers/regulator/arizona-micsupp.c:	struct arizona *arizona = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/arizona-micsupp.c:	micsupp = devm_kzalloc(&pdev->dev, sizeof(*micsupp), GFP_KERNEL);
drivers/regulator/arizona-micsupp.c:		dev_err(&pdev->dev, "Unable to allocate private data\n");
drivers/regulator/tps65090-regulator.c:	struct device_node *np = pdev->dev.parent->of_node;
drivers/regulator/tps65090-regulator.c:	tps65090_pdata = devm_kzalloc(&pdev->dev, sizeof(*tps65090_pdata),
drivers/regulator/tps65090-regulator.c:		dev_err(&pdev->dev, "Memory alloc for tps65090_pdata failed\n");
drivers/regulator/tps65090-regulator.c:	reg_pdata = devm_kzalloc(&pdev->dev, TPS65090_REGULATOR_MAX *
drivers/regulator/tps65090-regulator.c:		dev_err(&pdev->dev, "Memory alloc for reg_pdata failed\n");
drivers/regulator/tps65090-regulator.c:		dev_err(&pdev->dev, "regulator node not found\n");
drivers/regulator/tps65090-regulator.c:	ret = of_regulator_match(&pdev->dev, regulators, tps65090_matches,
drivers/regulator/tps65090-regulator.c:		dev_err(&pdev->dev,
drivers/regulator/tps65090-regulator.c:	struct tps65090 *tps65090_mfd = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/tps65090-regulator.c:	dev_dbg(&pdev->dev, "Probing regulator\n");
drivers/regulator/tps65090-regulator.c:	tps65090_pdata = dev_get_platdata(pdev->dev.parent);
drivers/regulator/tps65090-regulator.c:		dev_err(&pdev->dev, "Platform data missing\n");
drivers/regulator/tps65090-regulator.c:	pmic = devm_kzalloc(&pdev->dev, TPS65090_REGULATOR_MAX * sizeof(*pmic),
drivers/regulator/tps65090-regulator.c:		dev_err(&pdev->dev, "mem alloc for pmic failed\n");
drivers/regulator/tps65090-regulator.c:		ri->dev = &pdev->dev;
drivers/regulator/tps65090-regulator.c:					dev_err(&pdev->dev,
drivers/regulator/tps65090-regulator.c:		config.dev = pdev->dev.parent;
drivers/regulator/tps65090-regulator.c:			dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/regulator/max8925-regulator.c:	nproot = of_node_get(pdev->dev.parent->of_node);
drivers/regulator/max8925-regulator.c:		dev_err(&pdev->dev, "failed to find regulators node\n");
drivers/regulator/max8925-regulator.c:	rcount = of_regulator_match(&pdev->dev, np,
drivers/regulator/max8925-regulator.c:	struct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/max8925-regulator.c:	struct regulator_init_data *pdata = pdev->dev.platform_data;
drivers/regulator/max8925-regulator.c:		dev_err(&pdev->dev, "No REG resource!\n");
drivers/regulator/max8925-regulator.c:		dev_err(&pdev->dev, "Failed to find regulator %llu\n",
drivers/regulator/max8925-regulator.c:	config.dev = &pdev->dev;
drivers/regulator/max8925-regulator.c:		dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/regulator/ab8500.c:		&pdev->dev,
drivers/regulator/ab8500.c:		dev_err(&pdev->dev,
drivers/regulator/ab8500.c:	dev_vdbg(&pdev->dev,
drivers/regulator/ab8500.c:	struct ab8500 *ab8500 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/ab8500.c:	info->dev = &pdev->dev;
drivers/regulator/ab8500.c:	config.dev = &pdev->dev;
drivers/regulator/ab8500.c:		dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/regulator/ab8500.c:	struct ab8500 *ab8500 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/ab8500.c:	struct device_node *np = pdev->dev.of_node;
drivers/regulator/ab8500.c:		dev_err(&pdev->dev, "null mfd parent\n");
drivers/regulator/ab8500.c:		err = of_regulator_match(&pdev->dev, np,
drivers/regulator/ab8500.c:			dev_err(&pdev->dev,
drivers/regulator/ab8500.c:		dev_err(&pdev->dev, "null parent pdata\n");
drivers/regulator/ab8500.c:		dev_err(&pdev->dev, "null pdata\n");
drivers/regulator/ab8500.c:		dev_err(&pdev->dev, "Configuration error: size mismatch.\n");
drivers/regulator/ab8500.c:	struct ab8500 *ab8500 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/dbx500-prcmu.c:		S_IRUGO, rdebug.dir, &pdev->dev,
drivers/regulator/dbx500-prcmu.c:		S_IRUGO, rdebug.dir, &pdev->dev,
drivers/regulator/dbx500-prcmu.c:		dev_err(&pdev->dev,
drivers/regulator/dbx500-prcmu.c:		dev_err(&pdev->dev,
drivers/regulator/dbx500-prcmu.c:	dev_err(&pdev->dev, "failed to create debugfs entries.\n");
drivers/regulator/palmas-regulator.c:	struct palmas *palmas = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/palmas-regulator.c:	struct palmas_pmic_platform_data *pdata = pdev->dev.platform_data;
drivers/regulator/palmas-regulator.c:	struct device_node *node = pdev->dev.of_node;
drivers/regulator/palmas-regulator.c:		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/regulator/palmas-regulator.c:		palmas_dt_to_pdata(&pdev->dev, node, pdata);
drivers/regulator/palmas-regulator.c:	pmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);
drivers/regulator/palmas-regulator.c:	pmic->dev = &pdev->dev;
drivers/regulator/palmas-regulator.c:	config.dev = &pdev->dev;
drivers/regulator/palmas-regulator.c:				dev_err(&pdev->dev,
drivers/regulator/palmas-regulator.c:			dev_err(&pdev->dev,
drivers/regulator/palmas-regulator.c:				pdev->name);
drivers/regulator/palmas-regulator.c:			dev_err(&pdev->dev,
drivers/regulator/palmas-regulator.c:				pdev->name);
drivers/regulator/vexpress.c:	reg = devm_kzalloc(&pdev->dev, sizeof(*reg), GFP_KERNEL);
drivers/regulator/vexpress.c:	reg->func = vexpress_config_func_get_by_dev(&pdev->dev);
drivers/regulator/vexpress.c:	reg->desc.name = dev_name(&pdev->dev);
drivers/regulator/vexpress.c:	init_data = of_get_regulator_init_data(&pdev->dev, pdev->dev.of_node);
drivers/regulator/vexpress.c:	config.dev = &pdev->dev;
drivers/regulator/vexpress.c:	config.of_node = pdev->dev.of_node;
drivers/regulator/gpio-regulator.c:	struct gpio_regulator_config *config = pdev->dev.platform_data;
drivers/regulator/gpio-regulator.c:	struct device_node *np = pdev->dev.of_node;
drivers/regulator/gpio-regulator.c:		config = of_get_gpio_regulator_config(&pdev->dev, np);
drivers/regulator/gpio-regulator.c:	drvdata = devm_kzalloc(&pdev->dev, sizeof(struct gpio_regulator_data),
drivers/regulator/gpio-regulator.c:		dev_err(&pdev->dev, "Failed to allocate device data\n");
drivers/regulator/gpio-regulator.c:		dev_err(&pdev->dev, "Failed to allocate supply name\n");
drivers/regulator/gpio-regulator.c:		dev_err(&pdev->dev, "Failed to allocate gpio data\n");
drivers/regulator/gpio-regulator.c:		dev_err(&pdev->dev, "Failed to allocate state data\n");
drivers/regulator/gpio-regulator.c:		dev_err(&pdev->dev, "No regulator type set\n");
drivers/regulator/gpio-regulator.c:		dev_err(&pdev->dev,
drivers/regulator/gpio-regulator.c:	cfg.dev = &pdev->dev;
drivers/regulator/gpio-regulator.c:		dev_err(&pdev->dev, "Failed to register regulator: %d\n", ret);
drivers/regulator/anatop-regulator.c:	struct device *dev = &pdev->dev;
drivers/regulator/anatop-regulator.c:	config.dev = &pdev->dev;
drivers/regulator/anatop-regulator.c:	config.of_node = pdev->dev.of_node;
drivers/regulator/tps65910-regulator.c:	struct tps65910 *tps65910 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/tps65910-regulator.c:	pmic_plat_data = devm_kzalloc(&pdev->dev, sizeof(*pmic_plat_data),
drivers/regulator/tps65910-regulator.c:		dev_err(&pdev->dev, "Failure to alloc pdata for regulators.\n");
drivers/regulator/tps65910-regulator.c:	np = of_node_get(pdev->dev.parent->of_node);
drivers/regulator/tps65910-regulator.c:		dev_err(&pdev->dev, "regulator node not found\n");
drivers/regulator/tps65910-regulator.c:		dev_err(&pdev->dev, "Invalid tps chip version\n");
drivers/regulator/tps65910-regulator.c:	ret = of_regulator_match(&pdev->dev, regulators, matches, count);
drivers/regulator/tps65910-regulator.c:		dev_err(&pdev->dev, "Error parsing regulator init data: %d\n",
drivers/regulator/tps65910-regulator.c:	struct tps65910 *tps65910 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/tps65910-regulator.c:		dev_err(&pdev->dev, "Platform data not found\n");
drivers/regulator/tps65910-regulator.c:	pmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);
drivers/regulator/tps65910-regulator.c:		dev_err(&pdev->dev, "Memory allocation failed for pmic\n");
drivers/regulator/tps65910-regulator.c:		dev_err(&pdev->dev, "Invalid tps chip version\n");
drivers/regulator/tps65910-regulator.c:	pmic->desc = devm_kzalloc(&pdev->dev, pmic->num_regulators *
drivers/regulator/tps65910-regulator.c:		dev_err(&pdev->dev, "Memory alloc fails for desc\n");
drivers/regulator/tps65910-regulator.c:	pmic->info = devm_kzalloc(&pdev->dev, pmic->num_regulators *
drivers/regulator/tps65910-regulator.c:		dev_err(&pdev->dev, "Memory alloc fails for info\n");
drivers/regulator/tps65910-regulator.c:	pmic->rdev = devm_kzalloc(&pdev->dev, pmic->num_regulators *
drivers/regulator/tps65910-regulator.c:		dev_err(&pdev->dev, "Memory alloc fails for rdev\n");
drivers/regulator/tps65910-regulator.c:				pdev->name);
drivers/regulator/tps65910-regulator.c:			dev_err(&pdev->dev,
drivers/regulator/max8997.c:			dev_err(&pdev->dev, "invalid gpio[%d]: %d\n", i, gpio);
drivers/regulator/max8997.c:	struct max8997_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/max8997.c:		dev_err(&pdev->dev, "could not find pmic sub-node\n");
drivers/regulator/max8997.c:		dev_err(&pdev->dev, "could not find regulators sub-node\n");
drivers/regulator/max8997.c:	rdata = devm_kzalloc(&pdev->dev, sizeof(*rdata) *
drivers/regulator/max8997.c:		dev_err(&pdev->dev, "could not allocate memory for regulator data\n");
drivers/regulator/max8997.c:			dev_warn(&pdev->dev, "don't know how to configure regulator %s\n",
drivers/regulator/max8997.c:		rdata->initdata = of_get_regulator_init_data(&pdev->dev,
drivers/regulator/max8997.c:				dev_info(&pdev->dev, "invalid value for default dvs index, using 0 instead\n");
drivers/regulator/max8997.c:		dev_err(&pdev->dev, "buck1 voltages not specified\n");
drivers/regulator/max8997.c:		dev_err(&pdev->dev, "buck2 voltages not specified\n");
drivers/regulator/max8997.c:		dev_err(&pdev->dev, "buck5 voltages not specified\n");
drivers/regulator/max8997.c:	struct max8997_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/max8997.c:		dev_err(&pdev->dev, "No platform init data supplied.\n");
drivers/regulator/max8997.c:	max8997 = devm_kzalloc(&pdev->dev, sizeof(struct max8997_data),
drivers/regulator/max8997.c:	max8997->rdev = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
drivers/regulator/max8997.c:	max8997->dev = &pdev->dev;
drivers/regulator/max8997.c:			dev_err(&pdev->dev, "GPIO NOT VALID\n");
drivers/regulator/max8997.c:		ret = devm_gpio_request(&pdev->dev, pdata->buck125_gpios[0],
drivers/regulator/max8997.c:		ret = devm_gpio_request(&pdev->dev, pdata->buck125_gpios[1],
drivers/regulator/max8997.c:		ret = devm_gpio_request(&pdev->dev, pdata->buck125_gpios[2],
drivers/regulator/wm831x-isink.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/wm831x-isink.c:	int id = pdev->id % ARRAY_SIZE(pdata->isink);
drivers/regulator/wm831x-isink.c:	dev_dbg(&pdev->dev, "Probing ISINK%d\n", id + 1);
drivers/regulator/wm831x-isink.c:	isink = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_isink),
drivers/regulator/wm831x-isink.c:		dev_err(&pdev->dev, "Unable to allocate private data\n");
drivers/regulator/wm831x-isink.c:		dev_err(&pdev->dev, "No REG resource\n");
drivers/regulator/wm831x-isink.c:	config.dev = pdev->dev.parent;
drivers/regulator/wm831x-isink.c:		dev_err(&pdev->dev, "Failed to request ISINK IRQ %d: %d\n",
drivers/regulator/fixed.c:	if (pdev->dev.of_node) {
drivers/regulator/fixed.c:		config = of_get_fixed_voltage_config(&pdev->dev);
drivers/regulator/fixed.c:		config = pdev->dev.platform_data;
drivers/regulator/fixed.c:	drvdata = devm_kzalloc(&pdev->dev, sizeof(struct fixed_voltage_data),
drivers/regulator/fixed.c:		dev_err(&pdev->dev, "Failed to allocate device data\n");
drivers/regulator/fixed.c:		dev_err(&pdev->dev, "Failed to allocate supply name\n");
drivers/regulator/fixed.c:			dev_err(&pdev->dev,
drivers/regulator/fixed.c:	cfg.dev = &pdev->dev;
drivers/regulator/fixed.c:	cfg.of_node = pdev->dev.of_node;
drivers/regulator/fixed.c:		dev_err(&pdev->dev, "Failed to register regulator: %d\n", ret);
drivers/regulator/fixed.c:	dev_dbg(&pdev->dev, "%s supplying %duV\n", drvdata->desc.name,
drivers/regulator/tps80031-regulator.c:	struct tps80031 *tps80031_mfd = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/tps80031-regulator.c:	pdata = dev_get_platdata(pdev->dev.parent);
drivers/regulator/tps80031-regulator.c:		dev_err(&pdev->dev, "No platform data\n");
drivers/regulator/tps80031-regulator.c:	pmic = devm_kzalloc(&pdev->dev,
drivers/regulator/tps80031-regulator.c:		dev_err(&pdev->dev, "mem alloc for pmic failed\n");
drivers/regulator/tps80031-regulator.c:		ri->dev = &pdev->dev;
drivers/regulator/tps80031-regulator.c:		check_smps_mode_mult(pdev->dev.parent, ri);
drivers/regulator/tps80031-regulator.c:		config.dev = &pdev->dev;
drivers/regulator/tps80031-regulator.c:			ret = tps80031_regulator_config(pdev->dev.parent,
drivers/regulator/tps80031-regulator.c:				dev_err(&pdev->dev,
drivers/regulator/tps80031-regulator.c:			ret = tps80031_power_req_config(pdev->dev.parent,
drivers/regulator/tps80031-regulator.c:				dev_err(&pdev->dev,
drivers/regulator/tps80031-regulator.c:			dev_err(&pdev->dev,
drivers/regulator/mc13783-regulator.c:	struct mc13xxx *mc13783 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/mc13783-regulator.c:		dev_get_platdata(&pdev->dev);
drivers/regulator/mc13783-regulator.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv) +
drivers/regulator/mc13783-regulator.c:		config.dev = &pdev->dev;
drivers/regulator/mc13783-regulator.c:			dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/regulator/da9052-regulator.c:	regulator = devm_kzalloc(&pdev->dev, sizeof(struct da9052_regulator),
drivers/regulator/da9052-regulator.c:	da9052 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/da9052-regulator.c:					      pdev->id);
drivers/regulator/da9052-regulator.c:		dev_err(&pdev->dev, "invalid regulator ID specified\n");
drivers/regulator/da9052-regulator.c:	config.dev = &pdev->dev;
drivers/regulator/da9052-regulator.c:		config.init_data = pdata->regulators[pdev->id];
drivers/regulator/da9052-regulator.c:					&pdev->dev, np);
drivers/regulator/da9052-regulator.c:		dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/regulator/da903x.c:	ri = find_regulator_info(pdev->id);
drivers/regulator/da903x.c:		dev_err(&pdev->dev, "invalid regulator ID specified\n");
drivers/regulator/da903x.c:	config.dev = &pdev->dev;
drivers/regulator/da903x.c:	config.init_data = pdev->dev.platform_data;
drivers/regulator/da903x.c:		dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/regulator/s2mps11.c:	struct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/s2mps11.c:		dev_err(pdev->dev.parent, "Platform data not supplied\n");
drivers/regulator/s2mps11.c:	s2mps11 = devm_kzalloc(&pdev->dev, sizeof(struct s2mps11_info),
drivers/regulator/s2mps11.c:		config.dev = &pdev->dev;
drivers/regulator/s2mps11.c:			dev_err(&pdev->dev, "regulator init failed for %d\n",
drivers/regulator/arizona-ldo1.c:	struct arizona *arizona = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/arizona-ldo1.c:	ldo1 = devm_kzalloc(&pdev->dev, sizeof(*ldo1), GFP_KERNEL);
drivers/regulator/arizona-ldo1.c:		dev_err(&pdev->dev, "Unable to allocate private data\n");
drivers/regulator/da9055-regulator.c:	struct da9055 *da9055 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/da9055-regulator.c:	if (pdata == NULL || pdata->regulators[pdev->id] == NULL)
drivers/regulator/da9055-regulator.c:	regulator = devm_kzalloc(&pdev->dev, sizeof(struct da9055_regulator),
drivers/regulator/da9055-regulator.c:	regulator->info = find_regulator_info(pdev->id);
drivers/regulator/da9055-regulator.c:		dev_err(&pdev->dev, "invalid regulator ID specified\n");
drivers/regulator/da9055-regulator.c:	config.dev = &pdev->dev;
drivers/regulator/da9055-regulator.c:		config.init_data = pdata->regulators[pdev->id];
drivers/regulator/da9055-regulator.c:	ret = da9055_gpio_init(regulator, &config, pdata, pdev->id);
drivers/regulator/da9055-regulator.c:		dev_err(&pdev->dev, "Failed to register regulator %s\n",
drivers/regulator/da9055-regulator.c:	if (pdev->id == DA9055_ID_LDO5 || pdev->id ==  DA9055_ID_LDO6) {
drivers/regulator/da9055-regulator.c:		ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
drivers/regulator/da9055-regulator.c:						pdev->name, regulator);
drivers/regulator/da9055-regulator.c:				dev_err(&pdev->dev,
drivers/regulator/88pm8607.c:	nproot = of_node_get(pdev->dev.parent->of_node);
drivers/regulator/88pm8607.c:		dev_err(&pdev->dev, "failed to find regulators node\n");
drivers/regulator/88pm8607.c:				of_get_regulator_init_data(&pdev->dev, np);
drivers/regulator/88pm8607.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/88pm8607.c:	struct regulator_init_data *pdata = pdev->dev.platform_data;
drivers/regulator/88pm8607.c:			dev_err(&pdev->dev, "Failed to find regulator %llu\n",
drivers/regulator/88pm8607.c:	config.dev = &pdev->dev;
drivers/regulator/88pm8607.c:		dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/regulator/lp8788-buck.c:		ret = devm_gpio_request_one(&pdev->dev, gpio, DVS_LOW,
drivers/regulator/lp8788-buck.c:			ret = devm_gpio_request_one(&pdev->dev, gpio,
drivers/regulator/lp8788-buck.c:	struct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/lp8788-buck.c:	int id = pdev->id;
drivers/regulator/lp8788-buck.c:	buck = devm_kzalloc(&pdev->dev, sizeof(struct lp8788_buck), GFP_KERNEL);
drivers/regulator/lp8788-buck.c:	cfg.dev = pdev->dev.parent;
drivers/regulator/lp8788-buck.c:		dev_err(&pdev->dev, "BUCK%d regulator register err = %d\n",
drivers/regulator/mc13892-regulator.c:	struct mc13xxx *mc13892 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/mc13892-regulator.c:		dev_get_platdata(&pdev->dev);
drivers/regulator/mc13892-regulator.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv) +
drivers/regulator/mc13892-regulator.c:		config.dev = &pdev->dev;
drivers/regulator/mc13892-regulator.c:			dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/regulator/as3711-regulator.c:	struct as3711_regulator_pdata *pdata = dev_get_platdata(&pdev->dev);
drivers/regulator/as3711-regulator.c:	struct as3711 *as3711 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/as3711-regulator.c:	struct regulator_config config = {.dev = &pdev->dev,};
drivers/regulator/as3711-regulator.c:		dev_err(&pdev->dev, "No platform data...\n");
drivers/regulator/as3711-regulator.c:	if (pdev->dev.parent->of_node) {
drivers/regulator/as3711-regulator.c:		ret = as3711_regulator_parse_dt(&pdev->dev, of_node, AS3711_REGULATOR_NUM);
drivers/regulator/as3711-regulator.c:			dev_err(&pdev->dev, "DT parsing failed: %d\n", ret);
drivers/regulator/as3711-regulator.c:	regs = devm_kzalloc(&pdev->dev, AS3711_REGULATOR_NUM *
drivers/regulator/as3711-regulator.c:		dev_err(&pdev->dev, "Memory allocation failed exiting..\n");
drivers/regulator/as3711-regulator.c:			dev_err(&pdev->dev, "Failed to register regulator %s\n",
drivers/regulator/db8500-prcmu.c:	info->dev = &pdev->dev;
drivers/regulator/db8500-prcmu.c:	config.dev = &pdev->dev;
drivers/regulator/db8500-prcmu.c:		dev_err(&pdev->dev, "failed to register %s: err %i\n",
drivers/regulator/db8500-prcmu.c:					dev_get_platdata(&pdev->dev);
drivers/regulator/db8500-prcmu.c:	struct device_node *np = pdev->dev.of_node;
drivers/regulator/db8500-prcmu.c:		err = of_regulator_match(&pdev->dev, np,
drivers/regulator/db8500-prcmu.c:			dev_err(&pdev->dev,
drivers/regulator/tps6586x-regulator.c:	struct device *parent = pdev->dev.parent;
drivers/regulator/tps6586x-regulator.c:		dev_err(&pdev->dev, "Only SM0/SM1 can set slew rate\n");
drivers/regulator/tps6586x-regulator.c:	struct device_node *np = pdev->dev.parent->of_node;
drivers/regulator/tps6586x-regulator.c:		dev_err(&pdev->dev, "regulator node not found\n");
drivers/regulator/tps6586x-regulator.c:	err = of_regulator_match(&pdev->dev, regs, tps6586x_matches, num);
drivers/regulator/tps6586x-regulator.c:		dev_err(&pdev->dev, "Regulator match failed, e %d\n", err);
drivers/regulator/tps6586x-regulator.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/regulator/tps6586x-regulator.c:		dev_err(&pdev->dev, "Memory alloction failed\n");
drivers/regulator/tps6586x-regulator.c:	dev_dbg(&pdev->dev, "Probing regulator\n");
drivers/regulator/tps6586x-regulator.c:	pdata = dev_get_platdata(pdev->dev.parent);
drivers/regulator/tps6586x-regulator.c:	if ((!pdata) && (pdev->dev.parent->of_node))
drivers/regulator/tps6586x-regulator.c:		dev_err(&pdev->dev, "Platform data not available, exiting\n");
drivers/regulator/tps6586x-regulator.c:	rdev = devm_kzalloc(&pdev->dev, TPS6586X_ID_MAX_REGULATOR *
drivers/regulator/tps6586x-regulator.c:		dev_err(&pdev->dev, "Mmemory alloc failed\n");
drivers/regulator/tps6586x-regulator.c:			dev_err(&pdev->dev, "invalid regulator ID specified\n");
drivers/regulator/tps6586x-regulator.c:		err = tps6586x_regulator_preinit(pdev->dev.parent, ri);
drivers/regulator/tps6586x-regulator.c:			dev_err(&pdev->dev,
drivers/regulator/tps6586x-regulator.c:		config.dev = pdev->dev.parent;
drivers/regulator/tps6586x-regulator.c:			dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/regulator/tps6586x-regulator.c:				dev_err(&pdev->dev,
drivers/regulator/aat2870-regulator.c:	ri = aat2870_get_regulator(pdev->id);
drivers/regulator/aat2870-regulator.c:		dev_err(&pdev->dev, "Invalid device ID, %d\n", pdev->id);
drivers/regulator/aat2870-regulator.c:	ri->aat2870 = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/aat2870-regulator.c:	config.dev = &pdev->dev;
drivers/regulator/aat2870-regulator.c:	config.init_data = pdev->dev.platform_data;
drivers/regulator/aat2870-regulator.c:		dev_err(&pdev->dev, "Failed to register regulator %s\n",
drivers/regulator/pcap-regulator.c:	void *pcap = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/pcap-regulator.c:	config.dev = &pdev->dev;
drivers/regulator/pcap-regulator.c:	config.init_data = pdev->dev.platform_data;
drivers/regulator/pcap-regulator.c:	rdev = regulator_register(&pcap_regulators[pdev->id], &config);
drivers/regulator/wm831x-dcdc.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/wm831x-dcdc.c:	id = pdev->id - id;
drivers/regulator/wm831x-dcdc.c:	dev_dbg(&pdev->dev, "Probing DCDC%d\n", id + 1);
drivers/regulator/wm831x-dcdc.c:	dcdc = devm_kzalloc(&pdev->dev,  sizeof(struct wm831x_dcdc),
drivers/regulator/wm831x-dcdc.c:		dev_err(&pdev->dev, "Unable to allocate private data\n");
drivers/regulator/wm831x-dcdc.c:		dev_err(&pdev->dev, "No REG resource\n");
drivers/regulator/wm831x-dcdc.c:	config.dev = pdev->dev.parent;
drivers/regulator/wm831x-dcdc.c:		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
drivers/regulator/wm831x-dcdc.c:		dev_err(&pdev->dev, "Failed to request HC IRQ %d: %d\n",
drivers/regulator/wm831x-dcdc.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/wm831x-dcdc.c:	id = pdev->id - id;
drivers/regulator/wm831x-dcdc.c:	dev_dbg(&pdev->dev, "Probing DCDC%d\n", id + 1);
drivers/regulator/wm831x-dcdc.c:	dcdc = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_dcdc),
drivers/regulator/wm831x-dcdc.c:		dev_err(&pdev->dev, "Unable to allocate private data\n");
drivers/regulator/wm831x-dcdc.c:		dev_err(&pdev->dev, "No REG resource\n");
drivers/regulator/wm831x-dcdc.c:	config.dev = pdev->dev.parent;
drivers/regulator/wm831x-dcdc.c:		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
drivers/regulator/wm831x-dcdc.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/wm831x-dcdc.c:	int id = pdev->id % ARRAY_SIZE(pdata->dcdc);
drivers/regulator/wm831x-dcdc.c:	dev_dbg(&pdev->dev, "Probing DCDC%d\n", id + 1);
drivers/regulator/wm831x-dcdc.c:	dcdc = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_dcdc), GFP_KERNEL);
drivers/regulator/wm831x-dcdc.c:		dev_err(&pdev->dev, "Unable to allocate private data\n");
drivers/regulator/wm831x-dcdc.c:		dev_err(&pdev->dev, "No REG resource\n");
drivers/regulator/wm831x-dcdc.c:	config.dev = pdev->dev.parent;
drivers/regulator/wm831x-dcdc.c:		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
drivers/regulator/wm831x-dcdc.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/wm831x-dcdc.c:	int id = pdev->id % ARRAY_SIZE(pdata->epe);
drivers/regulator/wm831x-dcdc.c:	dev_dbg(&pdev->dev, "Probing EPE%d\n", id + 1);
drivers/regulator/wm831x-dcdc.c:	dcdc = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_dcdc), GFP_KERNEL);
drivers/regulator/wm831x-dcdc.c:		dev_err(&pdev->dev, "Unable to allocate private data\n");
drivers/regulator/wm831x-dcdc.c:	config.dev = pdev->dev.parent;
drivers/regulator/twl-regulator.c:	match = of_match_device(twl_of_match, &pdev->dev);
drivers/regulator/twl-regulator.c:		initdata = of_get_regulator_init_data(&pdev->dev,
drivers/regulator/twl-regulator.c:						      pdev->dev.of_node);
drivers/regulator/twl-regulator.c:		id = pdev->id;
drivers/regulator/twl-regulator.c:		initdata = pdev->dev.platform_data;
drivers/regulator/twl-regulator.c:	config.dev = &pdev->dev;
drivers/regulator/twl-regulator.c:	config.of_node = pdev->dev.of_node;
drivers/regulator/twl-regulator.c:		dev_err(&pdev->dev, "can't register %s, %ld\n",
drivers/regulator/tps6105x-regulator.c:	struct tps6105x *tps6105x = dev_get_platdata(&pdev->dev);
drivers/regulator/tps6105x-regulator.c:		dev_info(&pdev->dev,
drivers/regulator/tps6105x-regulator.c:	struct tps6105x *tps6105x = dev_get_platdata(&pdev->dev);
drivers/regulator/lp8788-ldo.c:	struct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/lp8788-ldo.c:	int id = pdev->id;
drivers/regulator/lp8788-ldo.c:	ldo = devm_kzalloc(&pdev->dev, sizeof(struct lp8788_ldo), GFP_KERNEL);
drivers/regulator/lp8788-ldo.c:	cfg.dev = pdev->dev.parent;
drivers/regulator/lp8788-ldo.c:		dev_err(&pdev->dev, "DLDO%d regulator register err = %d\n",
drivers/regulator/lp8788-ldo.c:	struct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/lp8788-ldo.c:	int id = pdev->id;
drivers/regulator/lp8788-ldo.c:	ldo = devm_kzalloc(&pdev->dev, sizeof(struct lp8788_ldo), GFP_KERNEL);
drivers/regulator/lp8788-ldo.c:	cfg.dev = pdev->dev.parent;
drivers/regulator/lp8788-ldo.c:		dev_err(&pdev->dev, "ALDO%d regulator register err = %d\n",
drivers/regulator/pcf50633-regulator.c:	pcf = dev_to_pcf50633(pdev->dev.parent);
drivers/regulator/pcf50633-regulator.c:	config.dev = &pdev->dev;
drivers/regulator/pcf50633-regulator.c:	config.init_data = pdev->dev.platform_data;
drivers/regulator/pcf50633-regulator.c:	rdev = regulator_register(&regulators[pdev->id], &config);
drivers/regulator/pcf50633-regulator.c:		pcf->pdata->regulator_registered(pcf, pdev->id);
drivers/regulator/tps65217-regulator.c:	struct tps65217 *tps = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/tps65217-regulator.c:	count = of_regulator_match(&pdev->dev, regs, reg_matches,
drivers/regulator/tps65217-regulator.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/regulator/tps65217-regulator.c:	struct tps65217 *tps = dev_get_drvdata(pdev->dev.parent);
drivers/regulator/tps65217-regulator.c:		dev_err(&pdev->dev, "Platform data not found\n");
drivers/regulator/tps65217-regulator.c:		dev_err(&pdev->dev, "Invalid tps chip version\n");
drivers/regulator/tps65217-regulator.c:				pdev->name);
drivers/ipack/carriers/tpci200.c:	free_irq(tpci200->info->pdev->irq, (void *) tpci200);
drivers/ipack/carriers/tpci200.c:			dev_info(&tpci200->info->pdev->dev,
drivers/ipack/carriers/tpci200.c:		dev_err(&tpci200->info->pdev->dev,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->bus->number,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->devfn);
drivers/ipack/carriers/tpci200.c:		dev_err(&tpci200->info->pdev->dev,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->bus->number,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->devfn);
drivers/ipack/carriers/tpci200.c:		dev_err(&tpci200->info->pdev->dev,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->bus->number,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->devfn);
drivers/ipack/carriers/tpci200.c:		dev_err(&tpci200->info->pdev->dev,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->bus->number,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->devfn);
drivers/ipack/carriers/tpci200.c:	res = request_irq(tpci200->info->pdev->irq,
drivers/ipack/carriers/tpci200.c:		dev_err(&tpci200->info->pdev->dev,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->bus->number,
drivers/ipack/carriers/tpci200.c:			tpci200->info->pdev->devfn);
drivers/ipack/carriers/tpci200.c:		dev_err(&pdev->dev, "Failed to allocate PCI Configuration Memory");
drivers/ipack/carriers/tpci200.c:		dev_err(&pdev->dev, "Failed to map PCI Configuration Memory");
drivers/ipack/carriers/tpci200.c:		dev_err(&pdev->dev, "error during tpci200 install\n");
drivers/ipack/carriers/tpci200.c:	tpci200->info->ipack_bus = ipack_bus_register(&pdev->dev,
drivers/ipack/carriers/tpci200.c:		dev_err(&pdev->dev,
drivers/ipack/carriers/tpci200.c:	dev_set_drvdata(&pdev->dev, tpci200);
drivers/base/platform.c:		put_device(&pdev->dev);
drivers/base/platform.c:	kfree(pdev->resource);
drivers/base/platform.c:	pdev->resource = r;
drivers/base/platform.c:	pdev->num_resources = num;
drivers/base/platform.c:	kfree(pdev->dev.platform_data);
drivers/base/platform.c:	pdev->dev.platform_data = d;
drivers/base/platform.c:	if (!pdev->dev.parent)
drivers/base/platform.c:		pdev->dev.parent = &platform_bus;
drivers/base/platform.c:	pdev->dev.bus = &platform_bus_type;
drivers/base/platform.c:	switch (pdev->id) {
drivers/base/platform.c:		dev_set_name(&pdev->dev, "%s.%d", pdev->name,  pdev->id);
drivers/base/platform.c:		dev_set_name(&pdev->dev, "%s", pdev->name);
drivers/base/platform.c:		pdev->id = ret;
drivers/base/platform.c:		pdev->id_auto = true;
drivers/base/platform.c:		dev_set_name(&pdev->dev, "%s.%d.auto", pdev->name, pdev->id);
drivers/base/platform.c:	for (i = 0; i < pdev->num_resources; i++) {
drivers/base/platform.c:		struct resource *p, *r = &pdev->resource[i];
drivers/base/platform.c:			r->name = dev_name(&pdev->dev);
drivers/base/platform.c:			dev_err(&pdev->dev, "failed to claim resource %d\n", i);
drivers/base/platform.c:		 dev_name(&pdev->dev), dev_name(pdev->dev.parent));
drivers/base/platform.c:	ret = device_add(&pdev->dev);
drivers/base/platform.c:	if (pdev->id_auto) {
drivers/base/platform.c:		ida_simple_remove(&platform_devid_ida, pdev->id);
drivers/base/platform.c:		pdev->id = PLATFORM_DEVID_AUTO;
drivers/base/platform.c:		struct resource *r = &pdev->resource[i];
drivers/base/platform.c:		device_del(&pdev->dev);
drivers/base/platform.c:		if (pdev->id_auto) {
drivers/base/platform.c:			ida_simple_remove(&platform_devid_ida, pdev->id);
drivers/base/platform.c:			pdev->id = PLATFORM_DEVID_AUTO;
drivers/base/platform.c:		for (i = 0; i < pdev->num_resources; i++) {
drivers/base/platform.c:			struct resource *r = &pdev->resource[i];
drivers/base/platform.c:	device_initialize(&pdev->dev);
drivers/base/platform.c:	pdev->dev.parent = pdevinfo->parent;
drivers/base/platform.c:	ACPI_HANDLE_SET(&pdev->dev, pdevinfo->acpi_node.handle);
drivers/base/platform.c:		pdev->dev.dma_mask =
drivers/base/platform.c:			kmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);
drivers/base/platform.c:		if (!pdev->dev.dma_mask)
drivers/base/platform.c:		*pdev->dev.dma_mask = pdevinfo->dma_mask;
drivers/base/platform.c:		pdev->dev.coherent_dma_mask = pdevinfo->dma_mask;
drivers/base/platform.c:		ACPI_HANDLE_SET(&pdev->dev, NULL);
drivers/base/platform.c:		kfree(pdev->dev.dma_mask);
drivers/base/platform.c:	int len = snprintf(buf, PAGE_SIZE, "platform:%s\n", pdev->name);
drivers/base/platform.c:			pdev->name);
drivers/base/platform.c:		if (strcmp(pdev->name, id->name) == 0) {
drivers/base/platform.c:			pdev->id_entry = id;
drivers/base/platform.c:	return (strcmp(pdev->name, drv->name) == 0);
drivers/platform/x86/intel_mid_powerbtn.c:		dev_err(&pdev->dev, "Input device allocation error\n");
drivers/platform/x86/intel_mid_powerbtn.c:	input->name = pdev->name;
drivers/platform/x86/intel_mid_powerbtn.c:	input->dev.parent = &pdev->dev;
drivers/platform/x86/intel_mid_powerbtn.c:		dev_err(&pdev->dev, "Unable to request irq %d for mfld power"
drivers/platform/x86/intel_mid_powerbtn.c:		dev_err(&pdev->dev, "Unable to register input dev, error "
drivers/platform/x86/intel_mid_powerbtn.c:		dev_err(&pdev->dev, "Unable to clear power button interrupt, "
drivers/platform/x86/samsung-q10.c:	bd = backlight_device_register("samsung", &pdev->dev, NULL,
drivers/platform/x86/thinkpad_acpi.c:						&tpacpi_pdev->dev,
drivers/platform/x86/thinkpad_acpi.c:		sysfs_notify(&tpacpi_pdev->dev.kobj, NULL,
drivers/platform/x86/thinkpad_acpi.c:		sysfs_notify(&tpacpi_pdev->dev.kobj, NULL,
drivers/platform/x86/thinkpad_acpi.c:	sysfs_notify(&tpacpi_pdev->dev.kobj, NULL,
drivers/platform/x86/thinkpad_acpi.c:	sysfs_notify(&tpacpi_pdev->dev.kobj, NULL,
drivers/platform/x86/thinkpad_acpi.c:		delete_attr_set(hotkey_dev_attributes, &tpacpi_pdev->dev.kobj);
drivers/platform/x86/thinkpad_acpi.c:				&tpacpi_pdev->dev.kobj);
drivers/platform/x86/thinkpad_acpi.c:	delete_attr_set(hotkey_dev_attributes, &tpacpi_pdev->dev.kobj);
drivers/platform/x86/thinkpad_acpi.c:	sysfs_remove_group(&tpacpi_pdev->dev.kobj,
drivers/platform/x86/thinkpad_acpi.c:	res = sysfs_create_group(&tpacpi_pdev->dev.kobj,
drivers/platform/x86/thinkpad_acpi.c:	sysfs_remove_group(&tpacpi_pdev->dev.kobj,
drivers/platform/x86/thinkpad_acpi.c:	res = sysfs_create_group(&tpacpi_pdev->dev.kobj,
drivers/platform/x86/thinkpad_acpi.c:	rc = led_classdev_register(&tpacpi_pdev->dev,
drivers/platform/x86/thinkpad_acpi.c:	res = device_create_file(&tpacpi_pdev->dev, &dev_attr_cmos_command);
drivers/platform/x86/thinkpad_acpi.c:	device_remove_file(&tpacpi_pdev->dev, &dev_attr_cmos_command);
drivers/platform/x86/thinkpad_acpi.c:	rc = led_classdev_register(&tpacpi_pdev->dev,
drivers/platform/x86/thinkpad_acpi.c:		res = sysfs_create_group(&tpacpi_sensors_pdev->dev.kobj,
drivers/platform/x86/thinkpad_acpi.c:		res = sysfs_create_group(&tpacpi_sensors_pdev->dev.kobj,
drivers/platform/x86/thinkpad_acpi.c:		sysfs_remove_group(&tpacpi_sensors_pdev->dev.kobj,
drivers/platform/x86/thinkpad_acpi.c:		sysfs_remove_group(&tpacpi_sensors_pdev->dev.kobj,
drivers/platform/x86/thinkpad_acpi.c:	snd_card_set_dev(card, &tpacpi_pdev->dev);
drivers/platform/x86/thinkpad_acpi.c:		rc = sysfs_create_group(&tpacpi_sensors_pdev->dev.kobj,
drivers/platform/x86/thinkpad_acpi.c:			sysfs_remove_group(&tpacpi_sensors_pdev->dev.kobj,
drivers/platform/x86/thinkpad_acpi.c:	sysfs_remove_group(&tpacpi_sensors_pdev->dev.kobj, &fan_attr_group);
drivers/platform/x86/thinkpad_acpi.c:		device_remove_file(&tpacpi_sensors_pdev->dev,
drivers/platform/x86/thinkpad_acpi.c:	ret = device_create_file(&tpacpi_sensors_pdev->dev,
drivers/platform/x86/thinkpad_acpi.c:	tpacpi_hwmon = hwmon_device_register(&tpacpi_sensors_pdev->dev);
drivers/platform/x86/thinkpad_acpi.c:		tpacpi_inputdev->dev.parent = &tpacpi_pdev->dev;
drivers/platform/x86/hdaps.c:	ret = sysfs_create_group(&pdev->dev.kobj, &hdaps_attribute_group);
drivers/platform/x86/hdaps.c:	idev->dev.parent = &pdev->dev;
drivers/platform/x86/hdaps.c:	sysfs_remove_group(&pdev->dev.kobj, &hdaps_attribute_group);
drivers/platform/x86/hdaps.c:	sysfs_remove_group(&pdev->dev.kobj, &hdaps_attribute_group);
drivers/platform/x86/xo1-rfkill.c:	rfk = rfkill_alloc(pdev->name, &pdev->dev, RFKILL_TYPE_WLAN,
drivers/platform/x86/apple-gmux.c:	if (pdev->vendor == PCI_VENDOR_ID_INTEL)
drivers/platform/x86/apple-gmux.c:	else if (pdev->vendor == PCI_VENDOR_ID_NVIDIA &&
drivers/platform/x86/apple-gmux.c:		 pdev->device == 0x0863)
drivers/platform/x86/intel_mid_thermal.c:	ret = mid_initialize_adc(&pdev->dev);
drivers/platform/x86/intel_mid_thermal.c:		dev_err(&pdev->dev, "ADC init failed");
drivers/platform/x86/intel_pmic_gpio.c:	struct device *dev = &pdev->dev;
drivers/platform/x86/compal-laptop.c:	err = sysfs_create_group(&pdev->dev.kobj, &compal_attribute_group);
drivers/platform/x86/compal-laptop.c:	data->hwmon_dev = hwmon_device_register(&pdev->dev);
drivers/platform/x86/compal-laptop.c:		sysfs_remove_group(&pdev->dev.kobj,
drivers/platform/x86/compal-laptop.c:	sysfs_remove_group(&pdev->dev.kobj, &compal_attribute_group);
drivers/platform/x86/asus-wmi.c:	struct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);
drivers/platform/x86/asus-wmi.c:	struct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);
drivers/platform/x86/intel_scu_ipc.c:			dev_err(&ipcdev.pdev->dev, "IPC timed out");
drivers/platform/x86/intel_scu_ipc.c:		dev_err(&ipcdev.pdev->dev,
drivers/platform/x86/intel_scu_ipc.c:	free_irq(pdev->irq, &ipcdev);
drivers/platform/goldfish/pdev_bus.c:		dev_err(&pdev->dev, "unable to reserve Goldfish MMIO.\n");
drivers/platform/goldfish/pdev_bus.c:		dev_err(&pdev->dev, "unable to map Goldfish MMIO.\n");
drivers/platform/goldfish/pdev_bus.c:		dev_err(&pdev->dev, "unable to request Goldfish IRQ\n");
drivers/platform/goldfish/goldfish_pipe.c:	aps = devm_kzalloc(&pdev->dev, sizeof(struct access_params), GFP_KERNEL);
drivers/platform/goldfish/goldfish_pipe.c:		dev_err(&pdev->dev, "can't allocate i/o page\n");
drivers/platform/goldfish/goldfish_pipe.c:	dev->base = devm_ioremap(&pdev->dev, r->start, PAGE_SIZE);
drivers/platform/goldfish/goldfish_pipe.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/platform/goldfish/goldfish_pipe.c:	err = devm_request_irq(&pdev->dev, dev->irq, goldfish_pipe_interrupt,
drivers/platform/goldfish/goldfish_pipe.c:		dev_err(&pdev->dev, "unable to allocate IRQ\n");
drivers/platform/goldfish/goldfish_pipe.c:		dev_err(&pdev->dev, "unable to register device\n");
drivers/iio/light/lm3533-als.c:		dev_err(&als->pdev->dev, "failed to set input mode %d\n",
drivers/iio/light/lm3533-als.c:		dev_err(&als->pdev->dev, "failed to set resistor\n");
drivers/iio/light/lm3533-als.c:		dev_err(&als->pdev->dev, "failed to disable interrupts\n");
drivers/iio/light/lm3533-als.c:					dev_name(&als->pdev->dev), dev);
drivers/iio/light/lm3533-als.c:		dev_err(&als->pdev->dev, "failed to request irq %d\n",
drivers/iio/light/lm3533-als.c:		dev_err(&als->pdev->dev, "failed to enable ALS\n");
drivers/iio/light/lm3533-als.c:		dev_err(&als->pdev->dev, "failed to disable ALS\n");
drivers/iio/light/lm3533-als.c:	lm3533 = dev_get_drvdata(pdev->dev.parent);
drivers/iio/light/lm3533-als.c:	pdata = pdev->dev.platform_data;
drivers/iio/light/lm3533-als.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/iio/light/lm3533-als.c:	indio_dev->name = dev_name(&pdev->dev);
drivers/iio/light/lm3533-als.c:	indio_dev->dev.parent = pdev->dev.parent;
drivers/iio/light/lm3533-als.c:		dev_err(&pdev->dev, "failed to register ALS\n");
drivers/iio/light/hid-sensor-als.c:	dev_dbg(&pdev->dev, "als %x:%x\n", st->als_illum.index,
drivers/iio/light/hid-sensor-als.c:	struct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;
drivers/iio/light/hid-sensor-als.c:		dev_err(&pdev->dev, "failed to setup common attributes\n");
drivers/iio/light/hid-sensor-als.c:		dev_err(&pdev->dev, "failed to duplicate channels\n");
drivers/iio/light/hid-sensor-als.c:		dev_err(&pdev->dev, "failed to setup attributes\n");
drivers/iio/light/hid-sensor-als.c:	indio_dev->dev.parent = &pdev->dev;
drivers/iio/light/hid-sensor-als.c:		dev_err(&pdev->dev, "failed to initialize trigger buffer\n");
drivers/iio/light/hid-sensor-als.c:		dev_err(&pdev->dev, "trigger setup failed\n");
drivers/iio/light/hid-sensor-als.c:		dev_err(&pdev->dev, "device register failed\n");
drivers/iio/light/hid-sensor-als.c:		dev_err(&pdev->dev, "callback reg failed\n");
drivers/iio/light/hid-sensor-als.c:	struct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;
drivers/iio/adc/viperboard_adc.c:	struct vprbrd *vb = dev_get_drvdata(pdev->dev.parent);
drivers/iio/adc/viperboard_adc.c:		dev_err(&pdev->dev, "failed allocating iio device\n");
drivers/iio/adc/viperboard_adc.c:	indio_dev->dev.parent = &pdev->dev;
drivers/iio/adc/viperboard_adc.c:		dev_err(&pdev->dev, "could not register iio (adc)");
drivers/iio/adc/ti_am335x_adc.c:	struct ti_tscadc_dev	*tscadc_dev = pdev->dev.platform_data;
drivers/iio/adc/ti_am335x_adc.c:		dev_err(&pdev->dev, "Could not find platform data\n");
drivers/iio/adc/ti_am335x_adc.c:		dev_err(&pdev->dev, "failed to allocate iio device\n");
drivers/iio/adc/ti_am335x_adc.c:	indio_dev->dev.parent = &pdev->dev;
drivers/iio/adc/ti_am335x_adc.c:	indio_dev->name = dev_name(&pdev->dev);
drivers/iio/adc/exynos_adc.c:	match = of_match_node(exynos_adc_match, pdev->dev.of_node);
drivers/iio/adc/exynos_adc.c:	struct device_node *np = pdev->dev.of_node;
drivers/iio/adc/exynos_adc.c:		dev_err(&pdev->dev, "failed allocating iio device\n");
drivers/iio/adc/exynos_adc.c:	info->regs = devm_request_and_ioremap(&pdev->dev, mem);
drivers/iio/adc/exynos_adc.c:	info->enable_reg = devm_request_and_ioremap(&pdev->dev, mem);
drivers/iio/adc/exynos_adc.c:		dev_err(&pdev->dev, "no irq resource?\n");
drivers/iio/adc/exynos_adc.c:					0, dev_name(&pdev->dev), info);
drivers/iio/adc/exynos_adc.c:		dev_err(&pdev->dev, "failed requesting irq, irq = %d\n",
drivers/iio/adc/exynos_adc.c:	info->clk = devm_clk_get(&pdev->dev, "adc");
drivers/iio/adc/exynos_adc.c:		dev_err(&pdev->dev, "failed getting clock, err = %ld\n",
drivers/iio/adc/exynos_adc.c:	info->vdd = devm_regulator_get(&pdev->dev, "vdd");
drivers/iio/adc/exynos_adc.c:		dev_err(&pdev->dev, "failed getting regulator, err = %ld\n",
drivers/iio/adc/exynos_adc.c:	indio_dev->name = dev_name(&pdev->dev);
drivers/iio/adc/exynos_adc.c:	indio_dev->dev.parent = &pdev->dev;
drivers/iio/adc/exynos_adc.c:	indio_dev->dev.of_node = pdev->dev.of_node;
drivers/iio/adc/exynos_adc.c:	ret = of_platform_populate(np, exynos_adc_match, NULL, &pdev->dev);
drivers/iio/adc/exynos_adc.c:		dev_err(&pdev->dev, "failed adding child nodes\n");
drivers/iio/adc/exynos_adc.c:	device_for_each_child(&pdev->dev, NULL,
drivers/iio/adc/exynos_adc.c:	device_for_each_child(&pdev->dev, NULL,
drivers/iio/adc/lp8788_adc.c:	struct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);
drivers/iio/adc/lp8788_adc.c:	indio_dev->dev.of_node = pdev->dev.of_node;
drivers/iio/adc/lp8788_adc.c:	indio_dev->dev.parent = &pdev->dev;
drivers/iio/adc/lp8788_adc.c:	indio_dev->name = pdev->name;
drivers/iio/adc/lp8788_adc.c:		dev_err(&pdev->dev, "iio dev register err: %d\n", ret);
drivers/iio/adc/at91_adc.c:	struct device_node *np = pdev->dev.of_node;
drivers/iio/adc/at91_adc.c:	struct device_node *node = pdev->dev.of_node;
drivers/iio/adc/at91_adc.c:	struct at91_adc_data *pdata = pdev->dev.platform_data;
drivers/iio/adc/at91_adc.c:	if (pdev->dev.of_node)
drivers/iio/adc/at91_adc.c:		dev_err(&pdev->dev, "No platform data available.\n");
drivers/iio/adc/at91_adc.c:	idev->dev.parent = &pdev->dev;
drivers/iio/adc/at91_adc.c:	idev->name = dev_name(&pdev->dev);
drivers/iio/adc/at91_adc.c:		dev_err(&pdev->dev, "No IRQ ID is designated\n");
drivers/iio/adc/at91_adc.c:	st->reg_base = devm_ioremap_resource(&pdev->dev, res);
drivers/iio/adc/at91_adc.c:			  pdev->dev.driver->name,
drivers/iio/adc/at91_adc.c:		dev_err(&pdev->dev, "Failed to allocate IRQ.\n");
drivers/iio/adc/at91_adc.c:	st->clk = devm_clk_get(&pdev->dev, "adc_clk");
drivers/iio/adc/at91_adc.c:		dev_err(&pdev->dev, "Failed to get the clock.\n");
drivers/iio/adc/at91_adc.c:		dev_err(&pdev->dev,
drivers/iio/adc/at91_adc.c:	st->adc_clk = devm_clk_get(&pdev->dev, "adc_op_clk");
drivers/iio/adc/at91_adc.c:		dev_err(&pdev->dev, "Failed to get the ADC clock.\n");
drivers/iio/adc/at91_adc.c:		dev_err(&pdev->dev,
drivers/iio/adc/at91_adc.c:		dev_err(&pdev->dev, "No startup time available.\n");
drivers/iio/adc/at91_adc.c:		dev_err(&pdev->dev, "Couldn't initialize the channels.\n");
drivers/iio/adc/at91_adc.c:		dev_err(&pdev->dev, "Couldn't initialize the buffer.\n");
drivers/iio/adc/at91_adc.c:		dev_err(&pdev->dev, "Couldn't setup the triggers.\n");
drivers/iio/adc/at91_adc.c:		dev_err(&pdev->dev, "Couldn't register the device.\n");
drivers/iio/gyro/hid-sensor-gyro-3d.c:	dev_dbg(&pdev->dev, "gyro_3d %x:%x, %x:%x, %x:%x\n",
drivers/iio/gyro/hid-sensor-gyro-3d.c:	struct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;
drivers/iio/gyro/hid-sensor-gyro-3d.c:		dev_err(&pdev->dev, "failed to setup common attributes\n");
drivers/iio/gyro/hid-sensor-gyro-3d.c:		dev_err(&pdev->dev, "failed to duplicate channels\n");
drivers/iio/gyro/hid-sensor-gyro-3d.c:		dev_err(&pdev->dev, "failed to setup attributes\n");
drivers/iio/gyro/hid-sensor-gyro-3d.c:	indio_dev->dev.parent = &pdev->dev;
drivers/iio/gyro/hid-sensor-gyro-3d.c:		dev_err(&pdev->dev, "failed to initialize trigger buffer\n");
drivers/iio/gyro/hid-sensor-gyro-3d.c:		dev_err(&pdev->dev, "trigger setup failed\n");
drivers/iio/gyro/hid-sensor-gyro-3d.c:		dev_err(&pdev->dev, "device register failed\n");
drivers/iio/gyro/hid-sensor-gyro-3d.c:		dev_err(&pdev->dev, "callback reg failed\n");
drivers/iio/gyro/hid-sensor-gyro-3d.c:	struct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;
drivers/iio/accel/hid-sensor-accel-3d.c:	dev_dbg(&pdev->dev, "accel_3d %x:%x, %x:%x, %x:%x\n",
drivers/iio/accel/hid-sensor-accel-3d.c:	struct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;
drivers/iio/accel/hid-sensor-accel-3d.c:		dev_err(&pdev->dev, "failed to setup common attributes\n");
drivers/iio/accel/hid-sensor-accel-3d.c:		dev_err(&pdev->dev, "failed to duplicate channels\n");
drivers/iio/accel/hid-sensor-accel-3d.c:		dev_err(&pdev->dev, "failed to setup attributes\n");
drivers/iio/accel/hid-sensor-accel-3d.c:	indio_dev->dev.parent = &pdev->dev;
drivers/iio/accel/hid-sensor-accel-3d.c:		dev_err(&pdev->dev, "failed to initialize trigger buffer\n");
drivers/iio/accel/hid-sensor-accel-3d.c:		dev_err(&pdev->dev, "trigger setup failed\n");
drivers/iio/accel/hid-sensor-accel-3d.c:		dev_err(&pdev->dev, "device register failed\n");
drivers/iio/accel/hid-sensor-accel-3d.c:		dev_err(&pdev->dev, "callback reg failed\n");
drivers/iio/accel/hid-sensor-accel-3d.c:	struct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;
drivers/iio/magnetometer/hid-sensor-magn-3d.c:	dev_dbg(&pdev->dev, "magn_3d %x:%x, %x:%x, %x:%x\n",
drivers/iio/magnetometer/hid-sensor-magn-3d.c:	struct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;
drivers/iio/magnetometer/hid-sensor-magn-3d.c:		dev_err(&pdev->dev, "failed to setup common attributes\n");
drivers/iio/magnetometer/hid-sensor-magn-3d.c:		dev_err(&pdev->dev, "failed to duplicate channels\n");
drivers/iio/magnetometer/hid-sensor-magn-3d.c:		dev_err(&pdev->dev, "failed to setup attributes\n");
drivers/iio/magnetometer/hid-sensor-magn-3d.c:	indio_dev->dev.parent = &pdev->dev;
drivers/iio/magnetometer/hid-sensor-magn-3d.c:		dev_err(&pdev->dev, "failed to initialize trigger buffer\n");
drivers/iio/magnetometer/hid-sensor-magn-3d.c:		dev_err(&pdev->dev, "trigger setup failed\n");
drivers/iio/magnetometer/hid-sensor-magn-3d.c:		dev_err(&pdev->dev, "device register failed\n");
drivers/iio/magnetometer/hid-sensor-magn-3d.c:		dev_err(&pdev->dev, "callback reg failed\n");
drivers/iio/magnetometer/hid-sensor-magn-3d.c:	struct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;
drivers/ntb/ntb_transport.c:	dma_free_coherent(&pdev->dev, mw->size, mw->virt_addr, mw->dma_addr);
drivers/ntb/ntb_transport.c:	mw->virt_addr = dma_alloc_coherent(&pdev->dev, mw->size, &mw->dma_addr,
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "Unable to allocate MW buffer of size %d\n",
drivers/ntb/ntb_transport.c:	dev_info(&pdev->dev, "qp %d: Link Down\n", qp->qp_num);
drivers/ntb/ntb_transport.c:			dev_err(&pdev->dev, "Error writing %u to remote spad %d\n",
drivers/ntb/ntb_transport.c:			dev_err(&pdev->dev, "Error writing %u to remote spad %d\n",
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "Error writing %x to remote spad %d\n",
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "Error writing %x to remote spad %d\n",
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "Error writing %x to remote spad %d\n",
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "Error reading remote spad %d\n", VERSION);
drivers/ntb/ntb_transport.c:	dev_dbg(&pdev->dev, "Remote version = %d\n", val);
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "Error reading remote spad %d\n", NUM_QPS);
drivers/ntb/ntb_transport.c:	dev_dbg(&pdev->dev, "Remote max number of qps = %d\n", val);
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "Error reading remote spad %d\n", NUM_MWS);
drivers/ntb/ntb_transport.c:	dev_dbg(&pdev->dev, "Remote number of mws = %d\n", val);
drivers/ntb/ntb_transport.c:			dev_err(&pdev->dev, "Error reading remote spad %d\n",
drivers/ntb/ntb_transport.c:			dev_err(&pdev->dev, "Error reading remote spad %d\n",
drivers/ntb/ntb_transport.c:		dev_dbg(&pdev->dev, "Remote MW%d size = %llu\n", i, val64);
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "Error reading spad %d\n", QP_LINKS);
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "Error writing %x to remote spad %d\n",
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "Error reading remote spad %d\n", QP_LINKS);
drivers/ntb/ntb_transport.c:	dev_dbg(&pdev->dev, "Remote QP link status = %x\n", val);
drivers/ntb/ntb_transport.c:		dev_info(&pdev->dev, "qp %d: Link Up\n", qp->qp_num);
drivers/ntb/ntb_transport.c:	dev_info(&pdev->dev, "qp %d: Link Down\n", qp->qp_num);
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "ntb: QP%d unable to send linkdown msg\n",
drivers/ntb/ntb_transport.c:	dev_info(&pdev->dev, "NTB Transport QP %d created\n", qp->qp_num);
drivers/ntb/ntb_transport.c:		dev_warn(&pdev->dev, "Freeing item from a non-empty queue\n");
drivers/ntb/ntb_transport.c:	dev_info(&pdev->dev, "NTB Transport QP %d freed\n", qp->qp_num);
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "Error reading spad %d\n", QP_LINKS);
drivers/ntb/ntb_transport.c:		dev_err(&pdev->dev, "Error writing %x to remote spad %d\n",
drivers/ntb/ntb_hw.c:		dev_warn(&ndev->pdev->dev, "Invalid Index.\n");
drivers/ntb/ntb_hw.c:	dev_dbg(&ndev->pdev->dev, "Writing %x to local scratch pad index %d\n",
drivers/ntb/ntb_hw.c:	dev_dbg(&ndev->pdev->dev,
drivers/ntb/ntb_hw.c:	dev_dbg(&ndev->pdev->dev, "Writing %x to remote scratch pad index %d\n",
drivers/ntb/ntb_hw.c:	dev_dbg(&ndev->pdev->dev,
drivers/ntb/ntb_hw.c:	dev_dbg(&ndev->pdev->dev, "Writing addr %Lx to BAR %d\n", addr,
drivers/ntb/ntb_hw.c:	dev_dbg(&ndev->pdev->dev, "%s: ringing doorbell %d\n", __func__, db);
drivers/ntb/ntb_hw.c:		dev_info(&ndev->pdev->dev, "Link Up\n");
drivers/ntb/ntb_hw.c:		dev_info(&ndev->pdev->dev, "Link Width %d, Link Speed %d\n",
drivers/ntb/ntb_hw.c:		dev_info(&ndev->pdev->dev, "Link Down\n");
drivers/ntb/ntb_hw.c:			dev_err(&ndev->pdev->dev,
drivers/ntb/ntb_hw.c:		dev_err(&ndev->pdev->dev, "Only B2B supported at this time\n");
drivers/ntb/ntb_hw.c:		dev_err(&ndev->pdev->dev, "Only B2B supported at this time\n");
drivers/ntb/ntb_hw.c:	switch (ndev->pdev->device) {
drivers/ntb/ntb_hw.c:	dev_info(&ndev->pdev->dev, "Device Type = %s\n",
drivers/ntb/ntb_hw.c:	dev_dbg(&ndev->pdev->dev, "MSI-X irq %d received for DB %d\n", irq,
drivers/ntb/ntb_hw.c:	dev_dbg(&ndev->pdev->dev, "MSI-X irq %d received for DB %d\n", irq,
drivers/ntb/ntb_hw.c:	dev_dbg(&ndev->pdev->dev, "MSI-X irq %d received for Events\n", irq);
drivers/ntb/ntb_hw.c:		dev_err(&ndev->pdev->dev, "Error determining link status\n");
drivers/ntb/ntb_hw.c:		dev_dbg(&ndev->pdev->dev, "irq %d - pdb = %Lx\n", irq, pdb);
drivers/ntb/ntb_hw.c:		dev_dbg(&ndev->pdev->dev, "irq %d - pdb = %x sdb %x\n", irq,
drivers/ntb/ntb_hw.c:		dev_warn(&pdev->dev,
drivers/ntb/ntb_hw.c:	dev_err(&pdev->dev, "Error allocating MSI-X interrupt\n");
drivers/ntb/ntb_hw.c:	rc = request_irq(pdev->irq, ntb_interrupt, 0, "ntb-msi", ndev);
drivers/ntb/ntb_hw.c:		dev_err(&pdev->dev, "Error allocating MSI interrupt\n");
drivers/ntb/ntb_hw.c:	rc = request_irq(pdev->irq, ntb_interrupt, IRQF_SHARED, "ntb-intx",
drivers/ntb/ntb_hw.c:		dev_err(&ndev->pdev->dev, "no usable interrupts\n");
drivers/ntb/ntb_hw.c:		free_irq(pdev->irq, ndev);
drivers/ntb/ntb_hw.c:		dev_warn(&pdev->dev, "Cannot remap BAR 0\n");
drivers/ntb/ntb_hw.c:		dev_info(&pdev->dev, "MW %d size %llu\n", i,
drivers/ntb/ntb_hw.c:			dev_warn(&pdev->dev, "Cannot remap BAR %d\n",
drivers/ntb/ntb_hw.c:		dev_warn(&pdev->dev, "Cannot DMA highmem\n");
drivers/ntb/ntb_hw.c:		dev_warn(&pdev->dev, "Cannot DMA consistent highmem\n");
drivers/ntb/ntb_hw.c:	dev_err(&pdev->dev, "Error loading %s module\n", KBUILD_MODNAME);
drivers/usb/chipidea/ci13xxx_imx.c:	if (of_find_property(pdev->dev.of_node, "fsl,usbmisc", NULL)
drivers/usb/chipidea/ci13xxx_imx.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/usb/chipidea/ci13xxx_imx.c:		dev_err(&pdev->dev, "Failed to allocate CI13xxx-IMX data!\n");
drivers/usb/chipidea/ci13xxx_imx.c:		dev_err(&pdev->dev, "Can't get device resources!\n");
drivers/usb/chipidea/ci13xxx_imx.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/usb/chipidea/ci13xxx_imx.c:		dev_warn(&pdev->dev, "pinctrl get/select failed, err=%ld\n",
drivers/usb/chipidea/ci13xxx_imx.c:	data->clk = devm_clk_get(&pdev->dev, NULL);
drivers/usb/chipidea/ci13xxx_imx.c:		dev_err(&pdev->dev,
drivers/usb/chipidea/ci13xxx_imx.c:		dev_err(&pdev->dev,
drivers/usb/chipidea/ci13xxx_imx.c:	phy_np = of_parse_phandle(pdev->dev.of_node, "fsl,usbphy", 0);
drivers/usb/chipidea/ci13xxx_imx.c:			    try_module_get(phy_pdev->dev.driver->owner)) {
drivers/usb/chipidea/ci13xxx_imx.c:	reg_vbus = devm_regulator_get(&pdev->dev, "vbus");
drivers/usb/chipidea/ci13xxx_imx.c:			dev_err(&pdev->dev,
drivers/usb/chipidea/ci13xxx_imx.c:	if (!pdev->dev.dma_mask)
drivers/usb/chipidea/ci13xxx_imx.c:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/chipidea/ci13xxx_imx.c:	if (!pdev->dev.coherent_dma_mask)
drivers/usb/chipidea/ci13xxx_imx.c:		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/chipidea/ci13xxx_imx.c:		ret = usbmisc_ops->init(&pdev->dev);
drivers/usb/chipidea/ci13xxx_imx.c:			dev_err(&pdev->dev,
drivers/usb/chipidea/ci13xxx_imx.c:	plat_ci = ci13xxx_add_device(&pdev->dev,
drivers/usb/chipidea/ci13xxx_imx.c:				pdev->resource, pdev->num_resources,
drivers/usb/chipidea/ci13xxx_imx.c:		dev_err(&pdev->dev,
drivers/usb/chipidea/ci13xxx_imx.c:		ret = usbmisc_ops->post(&pdev->dev);
drivers/usb/chipidea/ci13xxx_imx.c:			dev_err(&pdev->dev,
drivers/usb/chipidea/ci13xxx_imx.c:	pm_runtime_no_callbacks(&pdev->dev);
drivers/usb/chipidea/ci13xxx_imx.c:	pm_runtime_enable(&pdev->dev);
drivers/usb/chipidea/ci13xxx_imx.c:	pm_runtime_disable(&pdev->dev);
drivers/usb/chipidea/usbmisc_imx.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/usb/chipidea/usbmisc_imx.c:	data->base = devm_ioremap_resource(&pdev->dev, res);
drivers/usb/chipidea/usbmisc_imx.c:	data->clk = devm_clk_get(&pdev->dev, NULL);
drivers/usb/chipidea/usbmisc_imx.c:		dev_err(&pdev->dev,
drivers/usb/chipidea/usbmisc_imx.c:		dev_err(&pdev->dev,
drivers/usb/chipidea/usbmisc_imx.c:		of_match_device(usbmisc_imx_dt_ids, &pdev->dev);
drivers/usb/chipidea/core.c:	pdev->dev.parent = dev;
drivers/usb/chipidea/core.c:	pdev->dev.dma_mask = dev->dma_mask;
drivers/usb/chipidea/core.c:	pdev->dev.dma_parms = dev->dma_parms;
drivers/usb/chipidea/core.c:	dma_set_coherent_mask(&pdev->dev, dev->coherent_dma_mask);
drivers/usb/chipidea/core.c:	int id = pdev->id;
drivers/usb/chipidea/core.c:	struct device	*dev = &pdev->dev;
drivers/usb/chipidea/ci13xxx_msm.c:	dev_dbg(&pdev->dev, "ci13xxx_msm_probe\n");
drivers/usb/chipidea/ci13xxx_msm.c:	plat_ci = ci13xxx_add_device(&pdev->dev,
drivers/usb/chipidea/ci13xxx_msm.c:				pdev->resource, pdev->num_resources,
drivers/usb/chipidea/ci13xxx_msm.c:		dev_err(&pdev->dev, "ci13xxx_add_device failed!\n");
drivers/usb/chipidea/ci13xxx_msm.c:	pm_runtime_no_callbacks(&pdev->dev);
drivers/usb/chipidea/ci13xxx_msm.c:	pm_runtime_enable(&pdev->dev);
drivers/usb/chipidea/ci13xxx_msm.c:	pm_runtime_disable(&pdev->dev);
drivers/usb/chipidea/ci13xxx_pci.c:		dev_err(&pdev->dev, "device doesn't provide driver data\n");
drivers/usb/chipidea/ci13xxx_pci.c:	if (!pdev->irq) {
drivers/usb/chipidea/ci13xxx_pci.c:		dev_err(&pdev->dev, "No IRQ, check BIOS/PCI setup!");
drivers/usb/chipidea/ci13xxx_pci.c:	res[1].start	= pdev->irq;
drivers/usb/chipidea/ci13xxx_pci.c:	plat_ci = ci13xxx_add_device(&pdev->dev, res, nres, platdata);
drivers/usb/chipidea/ci13xxx_pci.c:		dev_err(&pdev->dev, "ci13xxx_add_device failed!\n");
drivers/usb/phy/phy-mv-u3d-usb.c:	struct device *dev = &pdev->dev;
drivers/usb/phy/phy-mv-u3d-usb.c:	pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-mv-u3d-usb.c:		dev_err(&pdev->dev, "%s: no platform data defined\n", __func__);
drivers/usb/phy/phy-mv-u3d-usb.c:	mv_u3d_phy->dev			= &pdev->dev;
drivers/usb/phy/phy-mv-u3d-usb.c:	dev_info(&pdev->dev, "Initialized Marvell USB 3.0 PHY\n");
drivers/usb/phy/phy-omap-control.c:	struct device_node *np = pdev->dev.of_node;
drivers/usb/phy/phy-omap-control.c:	struct omap_control_usb_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-omap-control.c:	control_usb = devm_kzalloc(&pdev->dev, sizeof(*control_usb),
drivers/usb/phy/phy-omap-control.c:		dev_err(&pdev->dev, "unable to alloc memory for control usb\n");
drivers/usb/phy/phy-omap-control.c:		dev_err(&pdev->dev, "no pdata present\n");
drivers/usb/phy/phy-omap-control.c:	control_usb->dev	= &pdev->dev;
drivers/usb/phy/phy-omap-control.c:	control_usb->dev_conf = devm_ioremap_resource(&pdev->dev, res);
drivers/usb/phy/phy-omap-control.c:			&pdev->dev, res);
drivers/usb/phy/phy-omap-control.c:			&pdev->dev, res);
drivers/usb/phy/phy-nop.c:	struct device *dev = &pdev->dev;
drivers/usb/phy/phy-nop.c:	struct nop_usb_xceiv_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-nop.c:	nop = devm_kzalloc(&pdev->dev, sizeof(*nop), GFP_KERNEL);
drivers/usb/phy/phy-nop.c:	nop->phy.otg = devm_kzalloc(&pdev->dev, sizeof(*nop->phy.otg),
drivers/usb/phy/phy-nop.c:	nop->clk = devm_clk_get(&pdev->dev, "main_clk");
drivers/usb/phy/phy-nop.c:		dev_dbg(&pdev->dev, "Can't get phy clock: %ld\n",
drivers/usb/phy/phy-nop.c:			dev_err(&pdev->dev, "Error setting clock rate\n");
drivers/usb/phy/phy-nop.c:			dev_err(&pdev->dev, "Error preparing clock\n");
drivers/usb/phy/phy-nop.c:	nop->vcc = devm_regulator_get(&pdev->dev, "vcc");
drivers/usb/phy/phy-nop.c:		dev_dbg(&pdev->dev, "Error getting vcc regulator: %ld\n",
drivers/usb/phy/phy-nop.c:	nop->reset = devm_regulator_get(&pdev->dev, "reset");
drivers/usb/phy/phy-nop.c:		dev_dbg(&pdev->dev, "Error getting reset regulator: %ld\n",
drivers/usb/phy/phy-nop.c:	nop->dev		= &pdev->dev;
drivers/usb/phy/phy-nop.c:		dev_err(&pdev->dev, "can't register transceiver, err: %d\n",
drivers/usb/phy/phy-aml-usb3.c:	struct device *dev = &pdev->dev;
drivers/usb/phy/phy-aml-usb3.c:		dev_err(&pdev->dev, "This phy has no usb port\n");
drivers/usb/phy/phy-aml-usb3.c:	phy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);
drivers/usb/phy/phy-aml-usb3.c:		dev_err(&pdev->dev, "unable to allocate memory for USB3 PHY\n");
drivers/usb/phy/phy-aml-usb3.c:	if (!pm_runtime_suspended(&pdev->dev))
drivers/usb/phy/phy-aml-usb3.c:		pm_runtime_put(&pdev->dev);
drivers/usb/phy/phy-aml-usb3.c:	pm_runtime_disable(&pdev->dev);
drivers/usb/phy/phy-samsung-usb.h:	if (pdev->dev.of_node) {
drivers/usb/phy/phy-samsung-usb.h:							pdev->dev.of_node);
drivers/usb/phy/phy-twl6030-usb.c:	struct device_node	*np = pdev->dev.of_node;
drivers/usb/phy/phy-twl6030-usb.c:	struct device		*dev = &pdev->dev;
drivers/usb/phy/phy-twl6030-usb.c:	twl->dev		= &pdev->dev;
drivers/usb/phy/phy-twl6030-usb.c:		dev_info(&pdev->dev, "phy not ready, deferring probe");
drivers/usb/phy/phy-twl6030-usb.c:		dev_err(&pdev->dev, "twl6030 initialized without pdata\n");
drivers/usb/phy/phy-twl6030-usb.c:		dev_err(&pdev->dev, "ldo init failed\n");
drivers/usb/phy/phy-twl6030-usb.c:	if (device_create_file(&pdev->dev, &dev_attr_vbus))
drivers/usb/phy/phy-twl6030-usb.c:		dev_warn(&pdev->dev, "could not create sysfs file\n");
drivers/usb/phy/phy-twl6030-usb.c:		dev_err(&pdev->dev, "can't get IRQ %d, err %d\n",
drivers/usb/phy/phy-twl6030-usb.c:		dev_err(&pdev->dev, "can't get IRQ %d, err %d\n",
drivers/usb/phy/phy-twl6030-usb.c:	dev_info(&pdev->dev, "Initialized TWL6030 USB module\n");
drivers/usb/phy/phy-samsung-usb3.c:	struct samsung_usbphy_data *pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-samsung-usb3.c:	struct device *dev = &pdev->dev;
drivers/usb/phy/phy-gpio-vbus-usb.c:	struct gpio_vbus_mach_info *pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-gpio-vbus-usb.c:	dev_dbg(&pdev->dev, "VBUS %s (gadget: %s)\n",
drivers/usb/phy/phy-gpio-vbus-usb.c:		dev_dbg(&pdev->dev, "unregistering gadget '%s'\n",
drivers/usb/phy/phy-gpio-vbus-usb.c:	dev_dbg(&pdev->dev, "registered gadget '%s'\n", gadget->name);
drivers/usb/phy/phy-gpio-vbus-usb.c:	struct gpio_vbus_mach_info *pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->dev = &pdev->dev;
drivers/usb/phy/phy-gpio-vbus-usb.c:		dev_err(&pdev->dev, "can't request vbus gpio %d, err: %d\n",
drivers/usb/phy/phy-gpio-vbus-usb.c:			dev_err(&pdev->dev,
drivers/usb/phy/phy-gpio-vbus-usb.c:		dev_err(&pdev->dev, "can't request irq %i, err: %d\n",
drivers/usb/phy/phy-gpio-vbus-usb.c:	gpio_vbus->vbus_draw = regulator_get(&pdev->dev, "vbus_draw");
drivers/usb/phy/phy-gpio-vbus-usb.c:		dev_dbg(&pdev->dev, "can't get vbus_draw regulator, err: %ld\n",
drivers/usb/phy/phy-gpio-vbus-usb.c:		dev_err(&pdev->dev, "can't register transceiver, err: %d\n",
drivers/usb/phy/phy-gpio-vbus-usb.c:	device_init_wakeup(&pdev->dev, pdata->wakeup);
drivers/usb/phy/phy-gpio-vbus-usb.c:	struct gpio_vbus_mach_info *pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-gpio-vbus-usb.c:	device_init_wakeup(&pdev->dev, 0);
drivers/usb/phy/phy-omap-usb3.c:	phy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);
drivers/usb/phy/phy-omap-usb3.c:		dev_err(&pdev->dev, "unable to alloc mem for OMAP USB3 PHY\n");
drivers/usb/phy/phy-omap-usb3.c:	phy->pll_ctrl_base = devm_ioremap_resource(&pdev->dev, res);
drivers/usb/phy/phy-omap-usb3.c:	phy->dev		= &pdev->dev;
drivers/usb/phy/phy-omap-usb3.c:		dev_err(&pdev->dev, "unable to get usb_phy_cm_clk32k\n");
drivers/usb/phy/phy-omap-usb3.c:		dev_err(&pdev->dev, "unable to get usb_otg_ss_refclk960m\n");
drivers/usb/phy/phy-omap-usb3.c:		dev_dbg(&pdev->dev, "Failed to get control device\n");
drivers/usb/phy/phy-omap-usb3.c:	pm_runtime_get(&pdev->dev);
drivers/usb/phy/phy-omap-usb3.c:	if (!pm_runtime_suspended(&pdev->dev))
drivers/usb/phy/phy-omap-usb3.c:		pm_runtime_put(&pdev->dev);
drivers/usb/phy/phy-omap-usb3.c:	pm_runtime_disable(&pdev->dev);
drivers/usb/phy/phy-mxs-usb.c:	base = devm_ioremap_resource(&pdev->dev, res);
drivers/usb/phy/phy-mxs-usb.c:	clk = devm_clk_get(&pdev->dev, NULL);
drivers/usb/phy/phy-mxs-usb.c:		dev_err(&pdev->dev,
drivers/usb/phy/phy-mxs-usb.c:	mxs_phy = devm_kzalloc(&pdev->dev, sizeof(*mxs_phy), GFP_KERNEL);
drivers/usb/phy/phy-mxs-usb.c:		dev_err(&pdev->dev, "Failed to allocate USB PHY structure!\n");
drivers/usb/phy/phy-mxs-usb.c:	mxs_phy->phy.dev		= &pdev->dev;
drivers/usb/phy/phy-twl4030-usb.c:	struct twl4030_usb_data *pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-twl4030-usb.c:	struct device_node	*np = pdev->dev.of_node;
drivers/usb/phy/phy-twl4030-usb.c:	twl = devm_kzalloc(&pdev->dev, sizeof *twl, GFP_KERNEL);
drivers/usb/phy/phy-twl4030-usb.c:		dev_err(&pdev->dev, "twl4030 initialized without pdata\n");
drivers/usb/phy/phy-twl4030-usb.c:	otg = devm_kzalloc(&pdev->dev, sizeof *otg, GFP_KERNEL);
drivers/usb/phy/phy-twl4030-usb.c:	twl->dev		= &pdev->dev;
drivers/usb/phy/phy-twl4030-usb.c:		dev_err(&pdev->dev, "ldo init failed\n");
drivers/usb/phy/phy-twl4030-usb.c:	if (device_create_file(&pdev->dev, &dev_attr_vbus))
drivers/usb/phy/phy-twl4030-usb.c:		dev_warn(&pdev->dev, "could not create sysfs file\n");
drivers/usb/phy/phy-twl4030-usb.c:		dev_dbg(&pdev->dev, "can't get IRQ %d, err %d\n",
drivers/usb/phy/phy-twl4030-usb.c:	dev_info(&pdev->dev, "Initialized TWL4030 USB module\n");
drivers/usb/phy/phy-msm-usb.c:	dev_info(&pdev->dev, "msm_otg probe\n");
drivers/usb/phy/phy-msm-usb.c:	if (!pdev->dev.platform_data) {
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "No platform data given. Bailing out\n");
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "unable to allocate msm_otg\n");
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "unable to allocate msm_otg\n");
drivers/usb/phy/phy-msm-usb.c:	motg->pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-msm-usb.c:	phy->dev = &pdev->dev;
drivers/usb/phy/phy-msm-usb.c:	motg->phy_reset_clk = clk_get(&pdev->dev, "usb_phy_clk");
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "failed to get usb_phy_clk\n");
drivers/usb/phy/phy-msm-usb.c:	motg->clk = clk_get(&pdev->dev, "usb_hs_clk");
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "failed to get usb_hs_clk\n");
drivers/usb/phy/phy-msm-usb.c:		motg->pclk_src = clk_get(&pdev->dev,
drivers/usb/phy/phy-msm-usb.c:	motg->pclk = clk_get(&pdev->dev, "usb_hs_pclk");
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "failed to get usb_hs_pclk\n");
drivers/usb/phy/phy-msm-usb.c:	motg->core_clk = clk_get(&pdev->dev, "usb_hs_core_clk");
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "failed to get platform resource mem\n");
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/usb/phy/phy-msm-usb.c:	dev_info(&pdev->dev, "OTG regs = %p\n", motg->regs);
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "platform_get_irq failed\n");
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "hsusb vddcx configuration failed\n");
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "hsusb vreg configuration failed\n");
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "hsusb vreg enable failed\n");
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "request irq failed\n");
drivers/usb/phy/phy-msm-usb.c:		dev_err(&pdev->dev, "usb_add_phy failed\n");
drivers/usb/phy/phy-msm-usb.c:	device_init_wakeup(&pdev->dev, 1);
drivers/usb/phy/phy-msm-usb.c:			dev_dbg(&pdev->dev, "mode debugfs file is"
drivers/usb/phy/phy-msm-usb.c:	pm_runtime_set_active(&pdev->dev);
drivers/usb/phy/phy-msm-usb.c:	pm_runtime_enable(&pdev->dev);
drivers/usb/phy/phy-msm-usb.c:	pm_runtime_resume(&pdev->dev);
drivers/usb/phy/phy-msm-usb.c:	device_init_wakeup(&pdev->dev, 0);
drivers/usb/phy/phy-msm-usb.c:	pm_runtime_disable(&pdev->dev);
drivers/usb/phy/phy-msm-usb.c:	pm_runtime_set_suspended(&pdev->dev);
drivers/usb/phy/phy-rcar-usb.c:	struct device *dev = &pdev->dev;
drivers/usb/phy/phy-omap-usb2.c:	phy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);
drivers/usb/phy/phy-omap-usb2.c:		dev_err(&pdev->dev, "unable to allocate memory for USB2 PHY\n");
drivers/usb/phy/phy-omap-usb2.c:	otg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);
drivers/usb/phy/phy-omap-usb2.c:		dev_err(&pdev->dev, "unable to allocate memory for USB OTG\n");
drivers/usb/phy/phy-omap-usb2.c:	phy->dev		= &pdev->dev;
drivers/usb/phy/phy-omap-usb2.c:		dev_dbg(&pdev->dev, "Failed to get control device\n");
drivers/usb/phy/phy-omap-usb2.c:		dev_err(&pdev->dev, "unable to get usb_phy_cm_clk32k\n");
drivers/usb/phy/phy-omap-usb2.c:		dev_vdbg(&pdev->dev, "unable to get refclk960m\n");
drivers/usb/phy/phy-samsung-usb2.c:	struct samsung_usbphy_data *pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-samsung-usb2.c:	struct device *dev = &pdev->dev;
drivers/usb/phy/phy-mv-usb.c:	dev_dbg(&mvotg->pdev->dev, "transceiver is updated\n");
drivers/usb/phy/phy-mv-usb.c:	dev_info(&mvotg->pdev->dev, "B Device No Response!\n");
drivers/usb/phy/phy-mv-usb.c:		dev_err(&mvotg->pdev->dev, "Timer%d is already running\n", id);
drivers/usb/phy/phy-mv-usb.c:			dev_err(&mvotg->pdev->dev,
drivers/usb/phy/phy-mv-usb.c:	dev_info(&mvotg->pdev->dev, "%s host\n", on ? "start" : "stop");
drivers/usb/phy/phy-mv-usb.c:	dev_dbg(&mvotg->pdev->dev, "otg enabled\n");
drivers/usb/phy/phy-mv-usb.c:			dev_err(&mvotg->pdev->dev,
drivers/usb/phy/phy-mv-usb.c:		dev_dbg(&mvotg->pdev->dev, "otg disabled\n");
drivers/usb/phy/phy-mv-usb.c:	dev_dbg(&mvotg->pdev->dev, "%s: ", __func__);
drivers/usb/phy/phy-mv-usb.c:	dev_dbg(&mvotg->pdev->dev, "id %d\n", otg_ctrl->id);
drivers/usb/phy/phy-mv-usb.c:	dev_dbg(&mvotg->pdev->dev, "b_sess_vld %d\n", otg_ctrl->b_sess_vld);
drivers/usb/phy/phy-mv-usb.c:	dev_dbg(&mvotg->pdev->dev, "b_sess_end %d\n", otg_ctrl->b_sess_end);
drivers/usb/phy/phy-mv-usb.c:	dev_dbg(&mvotg->pdev->dev, "a_vbus_vld %d\n", otg_ctrl->a_vbus_vld);
drivers/usb/phy/phy-mv-usb.c:	dev_dbg(&mvotg->pdev->dev, "a_sess_vld %d\n", otg_ctrl->a_sess_vld);
drivers/usb/phy/phy-mv-usb.c:		dev_info(&mvotg->pdev->dev, "change from state %s to %s\n",
drivers/usb/phy/phy-mv-usb.c:		dev_dbg(&mvotg->pdev->dev,
drivers/usb/phy/phy-mv-usb.c:		dev_dbg(&mvotg->pdev->dev,
drivers/usb/phy/phy-mv-usb.c:		dev_dbg(&mvotg->pdev->dev,
drivers/usb/phy/phy-mv-usb.c:		dev_dbg(&mvotg->pdev->dev,
drivers/usb/phy/phy-mv-usb.c:		dev_dbg(&mvotg->pdev->dev,
drivers/usb/phy/phy-mv-usb.c:	sysfs_remove_group(&mvotg->pdev->dev.kobj, &inputs_attr_group);
drivers/usb/phy/phy-mv-usb.c:	struct mv_usb_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-mv-usb.c:		dev_err(&pdev->dev, "failed to get platform data\n");
drivers/usb/phy/phy-mv-usb.c:	mvotg = devm_kzalloc(&pdev->dev, sizeof(*mvotg), GFP_KERNEL);
drivers/usb/phy/phy-mv-usb.c:		dev_err(&pdev->dev, "failed to allocate memory!\n");
drivers/usb/phy/phy-mv-usb.c:	otg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);
drivers/usb/phy/phy-mv-usb.c:	mvotg->clk = devm_clk_get(&pdev->dev, NULL);
drivers/usb/phy/phy-mv-usb.c:		dev_dbg(&pdev->dev, "cannot create workqueue for OTG\n");
drivers/usb/phy/phy-mv-usb.c:	mvotg->phy.dev = &pdev->dev;
drivers/usb/phy/phy-mv-usb.c:		dev_err(&pdev->dev, "no phy I/O memory resource defined\n");
drivers/usb/phy/phy-mv-usb.c:	mvotg->phy_regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));
drivers/usb/phy/phy-mv-usb.c:		dev_err(&pdev->dev, "failed to map phy I/O memory\n");
drivers/usb/phy/phy-mv-usb.c:		dev_err(&pdev->dev, "no I/O memory resource defined\n");
drivers/usb/phy/phy-mv-usb.c:	mvotg->cap_regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));
drivers/usb/phy/phy-mv-usb.c:		dev_err(&pdev->dev, "failed to map I/O memory\n");
drivers/usb/phy/phy-mv-usb.c:		dev_err(&pdev->dev, "mv otg enable error %d\n", retval);
drivers/usb/phy/phy-mv-usb.c:		retval = devm_request_threaded_irq(&pdev->dev, pdata->id->irq,
drivers/usb/phy/phy-mv-usb.c:			dev_info(&pdev->dev,
drivers/usb/phy/phy-mv-usb.c:		retval = devm_request_threaded_irq(&pdev->dev, pdata->vbus->irq,
drivers/usb/phy/phy-mv-usb.c:			dev_info(&pdev->dev,
drivers/usb/phy/phy-mv-usb.c:		dev_err(&pdev->dev, "no IRQ resource defined\n");
drivers/usb/phy/phy-mv-usb.c:	if (devm_request_irq(&pdev->dev, mvotg->irq, mv_otg_irq, IRQF_SHARED,
drivers/usb/phy/phy-mv-usb.c:		dev_err(&pdev->dev, "Request irq %d for OTG failed\n",
drivers/usb/phy/phy-mv-usb.c:		dev_err(&pdev->dev, "can't register transceiver, %d\n",
drivers/usb/phy/phy-mv-usb.c:	retval = sysfs_create_group(&pdev->dev.kobj, &inputs_attr_group);
drivers/usb/phy/phy-mv-usb.c:		dev_dbg(&pdev->dev,
drivers/usb/phy/phy-mv-usb.c:	dev_info(&pdev->dev,
drivers/usb/phy/phy-mv-usb.c:		dev_info(&pdev->dev,
drivers/usb/phy/phy-fsl-usb.c:	fsl_otg_tc->phy.dev = &pdev->dev;
drivers/usb/phy/phy-fsl-usb.c:	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-fsl-usb.c:	if (!pdev->dev.platform_data)
drivers/usb/phy/phy-fsl-usb.c:		dev_err(&pdev->dev, "Couldn't configure OTG module\n");
drivers/usb/phy/phy-fsl-usb.c:		dev_err(&pdev->dev, "Can't init FSL OTG device\n");
drivers/usb/phy/phy-fsl-usb.c:		dev_err(&pdev->dev, "unable to register FSL OTG device\n");
drivers/usb/phy/phy-fsl-usb.c:	ret = device_create_file(&pdev->dev, &dev_attr_fsl_usb2_otg_state);
drivers/usb/phy/phy-fsl-usb.c:		dev_warn(&pdev->dev, "Can't register sysfs attribute\n");
drivers/usb/phy/phy-fsl-usb.c:	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/phy/phy-fsl-usb.c:	device_remove_file(&pdev->dev, &dev_attr_fsl_usb2_otg_state);
drivers/usb/phy/phy-ab8500-usb.c:		dev_err(&pdev->dev, "Link status irq not found\n");
drivers/usb/phy/phy-ab8500-usb.c:	err = devm_request_threaded_irq(&pdev->dev, irq, NULL,
drivers/usb/phy/phy-ab8500-usb.c:		dev_err(&pdev->dev, "ID fall irq not found\n");
drivers/usb/phy/phy-ab8500-usb.c:	err = devm_request_threaded_irq(&pdev->dev, irq, NULL,
drivers/usb/phy/phy-ab8500-usb.c:		dev_err(&pdev->dev, "VBUS fall irq not found\n");
drivers/usb/phy/phy-ab8500-usb.c:	err = devm_request_threaded_irq(&pdev->dev, irq, NULL,
drivers/usb/phy/phy-ab8500-usb.c:	ab8500 = dev_get_drvdata(pdev->dev.parent);
drivers/usb/phy/phy-ab8500-usb.c:	rev = abx500_get_chip_id(&pdev->dev);
drivers/usb/phy/phy-ab8500-usb.c:		dev_err(&pdev->dev, "Unsupported AB8500 chip rev=%d\n", rev);
drivers/usb/phy/phy-ab8500-usb.c:	ab = devm_kzalloc(&pdev->dev, sizeof(*ab), GFP_KERNEL);
drivers/usb/phy/phy-ab8500-usb.c:	otg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);
drivers/usb/phy/phy-ab8500-usb.c:	ab->dev			= &pdev->dev;
drivers/usb/phy/phy-ab8500-usb.c:		dev_err(&pdev->dev, "Can't register transceiver\n");
drivers/usb/phy/phy-ab8500-usb.c:	dev_info(&pdev->dev, "revision 0x%2x driver initialized\n", rev);
drivers/usb/phy/phy-aml-usb2.c:	struct device *dev = &pdev->dev;
drivers/usb/phy/phy-aml-usb2.c:		dev_err(&pdev->dev, "This phy has no usb port\n");
drivers/usb/phy/phy-aml-usb2.c:	phy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);
drivers/usb/phy/phy-aml-usb2.c:		dev_err(&pdev->dev, "unable to allocate memory for USB2 PHY\n");
drivers/usb/phy/phy-aml-usb2.c://	otg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);
drivers/usb/phy/phy-aml-usb2.c://		dev_err(&pdev->dev, "unable to allocate memory for USB OTG\n");
drivers/usb/core/hcd-pci.c:	return pdev->class == CL_OHCI || pdev->class == CL_UHCI;
drivers/usb/core/hcd-pci.c:	unsigned int		slot = PCI_SLOT(pdev->devfn);
drivers/usb/core/hcd-pci.c:		if (companion->bus != pdev->bus ||
drivers/usb/core/hcd-pci.c:		if (dev_get_drvdata(&pdev->dev)) {	/* Succeeded */
drivers/usb/core/hcd-pci.c:			dev_dbg(&pdev->dev, "HS companion for %s\n",
drivers/usb/core/hcd-pci.c:		dev_dbg(&pdev->dev, "FS/LS companion for %s\n",
drivers/usb/core/hcd-pci.c:		device_pm_wait_for_dev(&pdev->dev, &companion->dev);
drivers/usb/host/ehci-tilegx.c:	struct tilegx_usb_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/host/ehci-tilegx.c:	hcd = usb_create_hcd(&ehci_tilegx_hc_driver, &pdev->dev,
drivers/usb/host/ehci-tilegx.c:			     dev_name(&pdev->dev));
drivers/usb/host/ehci-tilegx.c:	struct tilegx_usb_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/host/ehci-pci.c:	switch (pdev->vendor) {
drivers/usb/host/ehci-pci.c:		if (pdev->device == 0x01b5) {
drivers/usb/host/ehci-pci.c:		switch (pdev->device) {
drivers/usb/host/ehci-pci.c:			if (pdev->revision < 0xa4)
drivers/usb/host/ehci-pci.c:		if (pdev->device == PCI_DEVICE_ID_INTEL_CE4100_USB)
drivers/usb/host/ehci-pci.c:		if (pdev->device == PCI_DEVICE_ID_TDI_EHCI)
drivers/usb/host/ehci-pci.c:		if (pdev->device == 0x7463) {
drivers/usb/host/ehci-pci.c:		if (pdev->device == 0x7808) {
drivers/usb/host/ehci-pci.c:		if (pdev->device == 0x3104 && (pdev->revision & 0xf0) == 0x60) {
drivers/usb/host/ehci-pci.c:		if (pdev->device == 0x4396) {
drivers/usb/host/ehci-pci.c:		if ((pdev->device == 0x4386) || (pdev->device == 0x4396)) {
drivers/usb/host/ehci-pci.c:			if ((pdev->device == 0x4386) || (rev == 0x3a)
drivers/usb/host/ehci-pci.c:	switch (pdev->vendor) {
drivers/usb/host/ehci-pci.c:		switch (pdev->device) {
drivers/usb/host/ehci-pci.c:		switch (pdev->vendor) {
drivers/usb/host/ehci-pci.c:	if (pdev->vendor == PCI_VENDOR_ID_STMICRO
drivers/usb/host/ehci-pci.c:	    && pdev->device == PCI_DEVICE_ID_STMICRO_USB_HOST)
drivers/usb/host/ehci-pci.c:	if (!device_can_wakeup(&pdev->dev)) {
drivers/usb/host/ehci-pci.c:			dev_warn(&pdev->dev, "Enabling legacy PCI PM\n");
drivers/usb/host/ehci-pci.c:			device_set_wakeup_capable(&pdev->dev, 1);
drivers/usb/host/ehci-pci.c:	if (ehci->no_selective_suspend && device_can_wakeup(&pdev->dev))
drivers/usb/host/ehci-pci.c:	return pdev->class == PCI_CLASS_SERIAL_USB_EHCI &&
drivers/usb/host/ehci-pci.c:		pdev->vendor == PCI_VENDOR_ID_INTEL &&
drivers/usb/host/ehci-pci.c:		(pdev->device == 0x1E26 ||
drivers/usb/host/ehci-pci.c:		 pdev->device == 0x8C2D ||
drivers/usb/host/ehci-pci.c:		 pdev->device == 0x8C26 ||
drivers/usb/host/ehci-pci.c:		 pdev->device == 0x9C26);
drivers/usb/host/imx21-hcd.c:		&pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/imx21-hcd.c:		dev_err(&pdev->dev, "Cannot create hcd (%s)\n",
drivers/usb/host/imx21-hcd.c:		    dev_name(&pdev->dev));
drivers/usb/host/imx21-hcd.c:	imx21->dev = &pdev->dev;
drivers/usb/host/imx21-hcd.c:	imx21->pdata = pdev->dev.platform_data;
drivers/usb/host/ohci-sm501.c:	struct device *dev = &pdev->dev;
drivers/usb/host/ohci-sm501.c:	if (!request_mem_region(mem->start, resource_size(mem), pdev->name)) {
drivers/usb/host/ohci-sm501.c:	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/ohci-sm501.c:	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,	pdev->name)) {
drivers/usb/host/ohci-sm501.c:	dma_release_declared_memory(&pdev->dev);
drivers/usb/host/ohci-sm501.c:	sm501_modify_reg(pdev->dev.parent, SM501_IRQ_MASK, 0, 1 << 6);
drivers/usb/host/ohci-sm501.c:	sm501_unit_power(pdev->dev.parent, SM501_GATE_USB_HOST, 0);
drivers/usb/host/ohci-sm501.c:	struct device *dev = &pdev->dev;
drivers/usb/host/ohci-sm501.c:	struct device *dev = &pdev->dev;
drivers/usb/host/ehci-pmcmsp.c:	dev_err(&pdev->dev, "Failed to map non-EHCI regs.\n");
drivers/usb/host/ehci-pmcmsp.c:	if (int_src & (1 << pdev->id))
drivers/usb/host/ehci-orion.c:	struct orion_ehci_data *pd = pdev->dev.platform_data;
drivers/usb/host/ehci-orion.c:	if (pdev->dev.of_node)
drivers/usb/host/ehci-orion.c:		irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
drivers/usb/host/ehci-orion.c:		dev_err(&pdev->dev,
drivers/usb/host/ehci-orion.c:			dev_name(&pdev->dev));
drivers/usb/host/ehci-orion.c:		dev_err(&pdev->dev,
drivers/usb/host/ehci-orion.c:			dev_name(&pdev->dev));
drivers/usb/host/ehci-orion.c:	if (!pdev->dev.dma_mask)
drivers/usb/host/ehci-orion.c:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/host/ehci-orion.c:	if (!pdev->dev.coherent_dma_mask)
drivers/usb/host/ehci-orion.c:		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/ehci-orion.c:		dev_dbg(&pdev->dev, "controller already in use\n");
drivers/usb/host/ehci-orion.c:		dev_dbg(&pdev->dev, "error mapping memory\n");
drivers/usb/host/ehci-orion.c:	clk = clk_get(&pdev->dev, NULL);
drivers/usb/host/ehci-orion.c:			&pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/ehci-orion.c:	if (pdev->dev.of_node)
drivers/usb/host/ehci-orion.c:	dev_err(&pdev->dev, "init %s fail, %d\n",
drivers/usb/host/ehci-orion.c:		dev_name(&pdev->dev), err);
drivers/usb/host/ehci-orion.c:	clk = clk_get(&pdev->dev, NULL);
drivers/usb/host/xhci-plat.c:	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/xhci-plat.c:		dev_dbg(&pdev->dev, "controller already in use\n");
drivers/usb/host/xhci-plat.c:		dev_dbg(&pdev->dev, "error mapping memory\n");
drivers/usb/host/xhci-plat.c:	hcd = dev_get_drvdata(&pdev->dev);
drivers/usb/host/xhci-plat.c:	xhci->shared_hcd = usb_create_shared_hcd(driver, &pdev->dev,
drivers/usb/host/xhci-plat.c:			dev_name(&pdev->dev), hcd);
drivers/usb/host/ohci-pci.c:	b  = pci_get_slot (pdev->bus, PCI_DEVFN (PCI_SLOT (pdev->devfn), 1));
drivers/usb/host/ohci-pci.c:		if (device_can_wakeup(&pdev->dev))
drivers/usb/host/ehci-atmel.c:	dev_dbg(&pdev->dev, "start\n");
drivers/usb/host/ehci-atmel.c:	dev_dbg(&pdev->dev, "stop\n");
drivers/usb/host/ehci-atmel.c:		dev_err(&pdev->dev,
drivers/usb/host/ehci-atmel.c:			dev_name(&pdev->dev));
drivers/usb/host/ehci-atmel.c:	if (!pdev->dev.dma_mask)
drivers/usb/host/ehci-atmel.c:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/host/ehci-atmel.c:	if (!pdev->dev.coherent_dma_mask)
drivers/usb/host/ehci-atmel.c:		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/ehci-atmel.c:	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/ehci-atmel.c:		dev_err(&pdev->dev,
drivers/usb/host/ehci-atmel.c:			dev_name(&pdev->dev));
drivers/usb/host/ehci-atmel.c:	hcd->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/usb/host/ehci-atmel.c:	iclk = devm_clk_get(&pdev->dev, "ehci_clk");
drivers/usb/host/ehci-atmel.c:		dev_err(&pdev->dev, "Error getting interface clock\n");
drivers/usb/host/ehci-atmel.c:	fclk = devm_clk_get(&pdev->dev, "uhpck");
drivers/usb/host/ehci-atmel.c:		dev_err(&pdev->dev, "Error getting function clock\n");
drivers/usb/host/ehci-atmel.c:	dev_err(&pdev->dev, "init %s fail, %d\n",
drivers/usb/host/ehci-atmel.c:		dev_name(&pdev->dev), retval);
drivers/usb/host/ehci-fsl.c:	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
drivers/usb/host/ehci-fsl.c:		dev_err(&pdev->dev,
drivers/usb/host/ehci-fsl.c:			"No platform data for %s.\n", dev_name(&pdev->dev));
drivers/usb/host/ehci-fsl.c:		dev_err(&pdev->dev,
drivers/usb/host/ehci-fsl.c:			dev_name(&pdev->dev));
drivers/usb/host/ehci-fsl.c:		dev_err(&pdev->dev,
drivers/usb/host/ehci-fsl.c:			dev_name(&pdev->dev));
drivers/usb/host/ehci-fsl.c:	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/ehci-fsl.c:		dev_err(&pdev->dev,
drivers/usb/host/ehci-fsl.c:			dev_name(&pdev->dev));
drivers/usb/host/ehci-fsl.c:		dev_dbg(&pdev->dev, "controller already in use\n");
drivers/usb/host/ehci-fsl.c:		dev_dbg(&pdev->dev, "error mapping memory\n");
drivers/usb/host/ehci-fsl.c:		dev_dbg(&pdev->dev, "hcd=0x%p  ehci=0x%p, phy=0x%p\n",
drivers/usb/host/ehci-fsl.c:			dev_err(&pdev->dev, "can't find phy\n");
drivers/usb/host/ehci-fsl.c:	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);
drivers/usb/host/ehci-fsl.c:	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/host/ehci-s5p.c:	struct device *dev = &pdev->dev;
drivers/usb/host/ehci-s5p.c:	struct s5p_ehci_platdata *pdata = pdev->dev.platform_data;
drivers/usb/host/ehci-s5p.c:	if (!pdev->dev.dma_mask)
drivers/usb/host/ehci-s5p.c:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/host/ehci-s5p.c:	if (!pdev->dev.coherent_dma_mask)
drivers/usb/host/ehci-s5p.c:		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/ehci-s5p.c:			     &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/ehci-s5p.c:		dev_err(&pdev->dev, "Unable to create HCD\n");
drivers/usb/host/ehci-s5p.c:	phy = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);
drivers/usb/host/ehci-s5p.c:			dev_warn(&pdev->dev, "no platform data or transceiver defined\n");
drivers/usb/host/ehci-s5p.c:	s5p_ehci->clk = devm_clk_get(&pdev->dev, "usbhost");
drivers/usb/host/ehci-s5p.c:		dev_err(&pdev->dev, "Failed to get usbhost clock\n");
drivers/usb/host/ehci-s5p.c:		dev_err(&pdev->dev, "Failed to get I/O memory\n");
drivers/usb/host/ehci-s5p.c:	hcd->regs = devm_ioremap(&pdev->dev, res->start, hcd->rsrc_len);
drivers/usb/host/ehci-s5p.c:		dev_err(&pdev->dev, "Failed to remap I/O memory\n");
drivers/usb/host/ehci-s5p.c:		dev_err(&pdev->dev, "Failed to get IRQ\n");
drivers/usb/host/ehci-s5p.c:		dev_err(&pdev->dev, "Failed to add USB HCD\n");
drivers/usb/host/fsl-mph-dr-of.c:	pdev->dev.parent = &ofdev->dev;
drivers/usb/host/fsl-mph-dr-of.c:	pdev->dev.coherent_dma_mask = ofdev->dev.coherent_dma_mask;
drivers/usb/host/fsl-mph-dr-of.c:	*pdev->dev.dma_mask = *ofdev->dev.dma_mask;
drivers/usb/host/fsl-mph-dr-of.c:	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/host/fsl-mph-dr-of.c:	base = pdev->resource->start & 0xf000;
drivers/usb/host/fsl-mph-dr-of.c:	clk = clk_get(&pdev->dev, clk_name);
drivers/usb/host/fsl-mph-dr-of.c:		dev_err(&pdev->dev, "failed to get clk\n");
drivers/usb/host/fsl-mph-dr-of.c:	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/host/ehci-mxc.c:	struct mxc_usbh_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/host/ehci-mxc.c:	struct device *dev = &pdev->dev;
drivers/usb/host/ehci-mxc.c:	hcd->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/usb/host/ehci-mxc.c:	priv->usbclk = devm_clk_get(&pdev->dev, "ipg");
drivers/usb/host/ehci-mxc.c:	priv->ahbclk = devm_clk_get(&pdev->dev, "ahb");
drivers/usb/host/ehci-mxc.c:	priv->phyclk = devm_clk_get(&pdev->dev, "phy");
drivers/usb/host/ehci-mxc.c:	struct mxc_usbh_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/host/ehci-msm.c:	dev_dbg(&pdev->dev, "ehci_msm proble\n");
drivers/usb/host/ehci-msm.c:	hcd = usb_create_hcd(&msm_hc_driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/ehci-msm.c:		dev_err(&pdev->dev, "Unable to create HCD\n");
drivers/usb/host/ehci-msm.c:		dev_err(&pdev->dev, "Unable to get IRQ resource\n");
drivers/usb/host/ehci-msm.c:		dev_err(&pdev->dev, "Unable to get memory resource\n");
drivers/usb/host/ehci-msm.c:	hcd->regs = devm_ioremap(&pdev->dev, hcd->rsrc_start, hcd->rsrc_len);
drivers/usb/host/ehci-msm.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/usb/host/ehci-msm.c:	phy = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);
drivers/usb/host/ehci-msm.c:		dev_err(&pdev->dev, "unable to find transceiver\n");
drivers/usb/host/ehci-msm.c:		dev_err(&pdev->dev, "unable to register with transceiver\n");
drivers/usb/host/ehci-msm.c:	device_init_wakeup(&pdev->dev, 1);
drivers/usb/host/ehci-msm.c:	pm_runtime_no_callbacks(&pdev->dev);
drivers/usb/host/ehci-msm.c:	pm_runtime_enable(&pdev->dev);
drivers/usb/host/ehci-msm.c:	device_init_wakeup(&pdev->dev, 0);
drivers/usb/host/ehci-msm.c:	pm_runtime_disable(&pdev->dev);
drivers/usb/host/ehci-msm.c:	pm_runtime_set_suspended(&pdev->dev);
drivers/usb/host/xhci.c:	ret = request_irq(pdev->irq, (irq_handler_t)xhci_msi_irq,
drivers/usb/host/xhci.c:	if (pdev->irq > 0)
drivers/usb/host/xhci.c:		free_irq(pdev->irq, xhci_to_hcd(xhci));
drivers/usb/host/xhci.c:	if (!pdev->irq) {
drivers/usb/host/xhci.c:	ret = request_irq(pdev->irq, &usb_hcd_irq, IRQF_SHARED,
drivers/usb/host/xhci.c:				pdev->irq);
drivers/usb/host/xhci.c:	hcd->irq = pdev->irq;
drivers/usb/host/oxu210hp-hcd.c:	dev_info(&pdev->dev, "device ID %x\n", id);
drivers/usb/host/oxu210hp-hcd.c:	dev_info(&pdev->dev, "found device %x %s (%04x:%04x)\n",
drivers/usb/host/oxu210hp-hcd.c:	struct device *dev = &pdev->dev;
drivers/usb/host/oxu210hp-hcd.c:		dev_err(&pdev->dev, "no devices found!\n");
drivers/usb/host/oxu210hp-hcd.c:		dev_err(&pdev->dev, "cannot create OTG controller!\n");
drivers/usb/host/oxu210hp-hcd.c:		dev_err(&pdev->dev, "cannot create SPH controller!\n");
drivers/usb/host/oxu210hp-hcd.c:		dev_err(&pdev->dev,
drivers/usb/host/oxu210hp-hcd.c:			"no IRQ! Check %s setup!\n", dev_name(&pdev->dev));
drivers/usb/host/oxu210hp-hcd.c:	dev_dbg(&pdev->dev, "IRQ resource %d\n", irq);
drivers/usb/host/oxu210hp-hcd.c:		dev_err(&pdev->dev, "no registers address! Check %s setup!\n",
drivers/usb/host/oxu210hp-hcd.c:			dev_name(&pdev->dev));
drivers/usb/host/oxu210hp-hcd.c:	dev_dbg(&pdev->dev, "MEM resource %lx-%lx\n", memstart, memlen);
drivers/usb/host/oxu210hp-hcd.c:		dev_dbg(&pdev->dev, "memory area already in use\n");
drivers/usb/host/oxu210hp-hcd.c:		dev_err(&pdev->dev, "error setting irq type\n");
drivers/usb/host/oxu210hp-hcd.c:		dev_dbg(&pdev->dev, "error mapping memory\n");
drivers/usb/host/oxu210hp-hcd.c:		dev_dbg(&pdev->dev, "error allocating memory\n");
drivers/usb/host/oxu210hp-hcd.c:		dev_dbg(&pdev->dev, "cannot init USB devices\n");
drivers/usb/host/oxu210hp-hcd.c:	dev_info(&pdev->dev, "devices enabled and running\n");
drivers/usb/host/oxu210hp-hcd.c:	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), ret);
drivers/usb/host/ehci-w90x900.c:	hcd = usb_create_hcd(driver, &pdev->dev, "w90x900 EHCI");
drivers/usb/host/ehci-platform.c:	struct usb_ehci_pdata *pdata = pdev->dev.platform_data;
drivers/usb/host/ohci-da8xx.c:	struct da8xx_ohci_root_hub *hub	= pdev->dev.platform_data;
drivers/usb/host/ohci-da8xx.c:	usb11_clk = clk_get(&pdev->dev, "usb11");
drivers/usb/host/ohci-da8xx.c:	usb20_clk = clk_get(&pdev->dev, "usb20");
drivers/usb/host/ohci-da8xx.c:	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/ohci-da8xx.c:		dev_dbg(&pdev->dev, "request_mem_region failed\n");
drivers/usb/host/ohci-da8xx.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/usb/host/ohci-da8xx.c:	struct da8xx_ohci_root_hub *hub	= pdev->dev.platform_data;
drivers/usb/host/ohci-omap.c:	if (pdev->num_resources != 2) {
drivers/usb/host/ohci-omap.c:		       pdev->num_resources);
drivers/usb/host/ohci-omap.c:	if (pdev->resource[0].flags != IORESOURCE_MEM
drivers/usb/host/ohci-omap.c:			|| pdev->resource[1].flags != IORESOURCE_IRQ) {
drivers/usb/host/ohci-omap.c:	usb_host_ck = clk_get(&pdev->dev, "usb_hhc_ck");
drivers/usb/host/ohci-omap.c:		usb_dc_ck = clk_get(&pdev->dev, "usb_dc_ck");
drivers/usb/host/ohci-omap.c:		usb_dc_ck = clk_get(&pdev->dev, "lb_ck");
drivers/usb/host/ohci-omap.c:	hcd = usb_create_hcd (driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/ohci-omap.c:	hcd->rsrc_start = pdev->resource[0].start;
drivers/usb/host/ohci-omap.c:	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
drivers/usb/host/ohci-omap.c:		dev_dbg(&pdev->dev, "request_mem_region failed\n");
drivers/usb/host/ohci-omap.c:		dev_err(&pdev->dev, "can't ioremap OHCI HCD\n");
drivers/usb/host/ehci-spear.c:	if (!pdev->dev.dma_mask)
drivers/usb/host/ehci-spear.c:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/host/ehci-spear.c:	if (!pdev->dev.coherent_dma_mask)
drivers/usb/host/ehci-spear.c:		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/ehci-spear.c:	usbh_clk = devm_clk_get(&pdev->dev, NULL);
drivers/usb/host/ehci-spear.c:		dev_err(&pdev->dev, "Error getting interface clock\n");
drivers/usb/host/ehci-spear.c:	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/ehci-spear.c:	if (!devm_request_mem_region(&pdev->dev, hcd->rsrc_start, hcd->rsrc_len,
drivers/usb/host/ehci-spear.c:	hcd->regs = devm_ioremap(&pdev->dev, hcd->rsrc_start, hcd->rsrc_len);
drivers/usb/host/ehci-spear.c:		dev_dbg(&pdev->dev, "error mapping memory\n");
drivers/usb/host/ehci-spear.c:	dev_err(&pdev->dev, "init fail, %d\n", retval);
drivers/usb/host/ehci-tegra.c:		gpio = of_get_named_gpio(pdev->dev.of_node,
drivers/usb/host/ehci-tegra.c:		dev_err(&pdev->dev, "can't request vbus gpio %d", gpio);
drivers/usb/host/ehci-tegra.c:		dev_err(&pdev->dev, "can't enable vbus\n");
drivers/usb/host/ehci-tegra.c:	int instance = pdev->id;
drivers/usb/host/ehci-tegra.c:	pdata = pdev->dev.platform_data;
drivers/usb/host/ehci-tegra.c:		dev_err(&pdev->dev, "Platform data missing\n");
drivers/usb/host/ehci-tegra.c:	if (!pdev->dev.dma_mask)
drivers/usb/host/ehci-tegra.c:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/host/ehci-tegra.c:	if (!pdev->dev.coherent_dma_mask)
drivers/usb/host/ehci-tegra.c:		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/ehci-tegra.c:	tegra = devm_kzalloc(&pdev->dev, sizeof(struct tegra_ehci_hcd),
drivers/usb/host/ehci-tegra.c:	hcd = usb_create_hcd(&tegra_ehci_hc_driver, &pdev->dev,
drivers/usb/host/ehci-tegra.c:					dev_name(&pdev->dev));
drivers/usb/host/ehci-tegra.c:		dev_err(&pdev->dev, "Unable to create HCD\n");
drivers/usb/host/ehci-tegra.c:	tegra->clk = devm_clk_get(&pdev->dev, NULL);
drivers/usb/host/ehci-tegra.c:		dev_err(&pdev->dev, "Can't get ehci clock\n");
drivers/usb/host/ehci-tegra.c:	tegra->needs_double_reset = of_property_read_bool(pdev->dev.of_node,
drivers/usb/host/ehci-tegra.c:		dev_err(&pdev->dev, "Failed to get I/O memory\n");
drivers/usb/host/ehci-tegra.c:	hcd->regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/usb/host/ehci-tegra.c:		dev_err(&pdev->dev, "Failed to remap I/O memory\n");
drivers/usb/host/ehci-tegra.c:			dev_err(&pdev->dev, "unknown usb instance\n");
drivers/usb/host/ehci-tegra.c:	tegra->phy = tegra_usb_phy_open(&pdev->dev, instance, hcd->regs,
drivers/usb/host/ehci-tegra.c:		dev_err(&pdev->dev, "Failed to open USB phy\n");
drivers/usb/host/ehci-tegra.c:	u_phy->otg = devm_kzalloc(&pdev->dev, sizeof(struct usb_otg),
drivers/usb/host/ehci-tegra.c:		dev_err(&pdev->dev, "Failed to alloc memory for otg\n");
drivers/usb/host/ehci-tegra.c:		dev_err(&pdev->dev, "Failed to power on the phy\n");
drivers/usb/host/ehci-tegra.c:		dev_err(&pdev->dev, "Failed to get IRQ\n");
drivers/usb/host/ehci-tegra.c:			devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);
drivers/usb/host/ehci-tegra.c:		dev_err(&pdev->dev, "Failed to add USB HCD\n");
drivers/usb/host/ehci-tegra.c:	pm_runtime_set_active(&pdev->dev);
drivers/usb/host/ehci-tegra.c:	pm_runtime_get_noresume(&pdev->dev);
drivers/usb/host/ehci-tegra.c:		pm_runtime_forbid(&pdev->dev);
drivers/usb/host/ehci-tegra.c:	pm_runtime_enable(&pdev->dev);
drivers/usb/host/ehci-tegra.c:	pm_runtime_put_sync(&pdev->dev);
drivers/usb/host/ehci-tegra.c:	pm_runtime_get_sync(&pdev->dev);
drivers/usb/host/ehci-tegra.c:	pm_runtime_disable(&pdev->dev);
drivers/usb/host/ehci-tegra.c:	pm_runtime_put_noidle(&pdev->dev);
drivers/usb/host/isp1760-if.c:	struct isp1760_platform_data *priv = pdev->dev.platform_data;
drivers/usb/host/isp1760-if.c:			       &pdev->dev, dev_name(&pdev->dev), devflags);
drivers/usb/host/isp1760-if.c:	dev_set_drvdata(&pdev->dev, hcd);
drivers/usb/host/isp1760-if.c:	struct usb_hcd *hcd = dev_get_drvdata(&pdev->dev);
drivers/usb/host/u132-hcd.c:			(pdev->dev.platform_data))->vendor;
drivers/usb/host/u132-hcd.c:			(pdev->dev.platform_data))->device;
drivers/usb/host/u132-hcd.c:	u132->board = pdev->dev.platform_data;
drivers/usb/host/u132-hcd.c:	if (pdev->dev.dma_mask)
drivers/usb/host/u132-hcd.c:	hcd = usb_create_hcd(&u132_hc_driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/ehci-sh.c:		dev_err(&pdev->dev,
drivers/usb/host/ehci-sh.c:			dev_name(&pdev->dev));
drivers/usb/host/ehci-sh.c:		dev_err(&pdev->dev,
drivers/usb/host/ehci-sh.c:			dev_name(&pdev->dev));
drivers/usb/host/ehci-sh.c:	pdata = pdev->dev.platform_data;
drivers/usb/host/ehci-sh.c:	hcd = usb_create_hcd(&ehci_sh_hc_driver, &pdev->dev,
drivers/usb/host/ehci-sh.c:			     dev_name(&pdev->dev));
drivers/usb/host/ehci-sh.c:	hcd->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/usb/host/ehci-sh.c:	priv = devm_kzalloc(&pdev->dev, sizeof(struct ehci_sh_priv),
drivers/usb/host/ehci-sh.c:		dev_dbg(&pdev->dev, "error allocating priv data\n");
drivers/usb/host/ehci-sh.c:	priv->fclk = devm_clk_get(&pdev->dev, "usb_fck");
drivers/usb/host/ehci-sh.c:	priv->iclk = devm_clk_get(&pdev->dev, "usb_ick");
drivers/usb/host/ehci-sh.c:		dev_err(&pdev->dev, "Failed to add hcd");
drivers/usb/host/ehci-sh.c:	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), ret);
drivers/usb/host/ohci-pxa27x.c:	struct device_node *np = pdev->dev.of_node;
drivers/usb/host/ohci-pxa27x.c:	if (!pdev->dev.dma_mask)
drivers/usb/host/ohci-pxa27x.c:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/host/ohci-pxa27x.c:	if (!pdev->dev.coherent_dma_mask)
drivers/usb/host/ohci-pxa27x.c:		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/ohci-pxa27x.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/usb/host/ohci-pxa27x.c:	pdev->dev.platform_data = pdata;
drivers/usb/host/ohci-pxa27x.c:	inf = pdev->dev.platform_data;
drivers/usb/host/ohci-pxa27x.c:	usb_clk = clk_get(&pdev->dev, NULL);
drivers/usb/host/ohci-pxa27x.c:	hcd = usb_create_hcd (driver, &pdev->dev, "pxa27x");
drivers/usb/host/ohci-pxa27x.c:	ohci->dev = &pdev->dev;
drivers/usb/host/ohci-pxa27x.c:	if ((retval = pxa27x_start_hc(ohci, &pdev->dev)) < 0) {
drivers/usb/host/ohci-pxa27x.c:	pxa27x_stop_hc(ohci, &pdev->dev);
drivers/usb/host/ohci-pxa27x.c:	pxa27x_stop_hc(ohci, &pdev->dev);
drivers/usb/host/uhci-platform.c:	if (!pdev->dev.dma_mask)
drivers/usb/host/uhci-platform.c:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/host/uhci-platform.c:	if (!pdev->dev.coherent_dma_mask)
drivers/usb/host/uhci-platform.c:		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/uhci-platform.c:	hcd = usb_create_hcd(&uhci_platform_hc_driver, &pdev->dev,
drivers/usb/host/uhci-platform.c:			pdev->name);
drivers/usb/host/uhci-platform.c:	ret = usb_add_hcd(hcd, pdev->resource[1].start, IRQF_DISABLED |
drivers/usb/host/ehci-omap.c:	struct device *dev = &pdev->dev;
drivers/usb/host/ehci-omap.c:	struct device *dev = &pdev->dev;
drivers/usb/host/ehci-omap.c:	struct usb_hcd *hcd = dev_get_drvdata(&pdev->dev);
drivers/usb/host/pci-quirks.c:		dev_warn(&pdev->dev, "HCRESET not completed yet!\n");
drivers/usb/host/pci-quirks.c:		dev_dbg(&pdev->dev, "%s: legsup = 0x%04x\n",
drivers/usb/host/pci-quirks.c:		dev_dbg(&pdev->dev, "%s: cmd = 0x%04x\n",
drivers/usb/host/pci-quirks.c:		dev_dbg(&pdev->dev, "%s: intr = 0x%04x\n",
drivers/usb/host/pci-quirks.c:	dev_dbg(&pdev->dev, "Performing full reset\n");
drivers/usb/host/pci-quirks.c:			dev_warn(&pdev->dev, "OHCI: BIOS handoff failed"
drivers/usb/host/pci-quirks.c:	if (pdev->vendor == 0x8086 && pdev->device == 0x283a) {
drivers/usb/host/pci-quirks.c:		dev_dbg(&pdev->dev, "EHCI: BIOS handoff\n");
drivers/usb/host/pci-quirks.c:			dev_warn(&pdev->dev, "EHCI: BIOS handoff failed"
drivers/usb/host/pci-quirks.c:			dev_warn(&pdev->dev, "EHCI: unrecognized capability "
drivers/usb/host/pci-quirks.c:		dev_printk(KERN_DEBUG, &pdev->dev, "EHCI: capability loop?\n");
drivers/usb/host/pci-quirks.c:	return pdev->class == PCI_CLASS_SERIAL_USB_XHCI &&
drivers/usb/host/pci-quirks.c:		pdev->vendor == PCI_VENDOR_ID_INTEL &&
drivers/usb/host/pci-quirks.c:		pdev->device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI;
drivers/usb/host/pci-quirks.c:	return pdev->class == PCI_CLASS_SERIAL_USB_XHCI &&
drivers/usb/host/pci-quirks.c:		pdev->vendor == PCI_VENDOR_ID_INTEL &&
drivers/usb/host/pci-quirks.c:		(pdev->device == PCI_DEVICE_ID_INTEL_LYNX_POINT_XHCI ||
drivers/usb/host/pci-quirks.c:		 pdev->device == PCI_DEVICE_ID_INTEL_LYNX_POINT_LP_XHCI);
drivers/usb/host/pci-quirks.c:		dev_warn(&xhci_pdev->dev,
drivers/usb/host/pci-quirks.c:		dev_warn(&xhci_pdev->dev,
drivers/usb/host/pci-quirks.c:	dev_dbg(&xhci_pdev->dev, "Configurable ports to enable SuperSpeed: 0x%x\n",
drivers/usb/host/pci-quirks.c:	dev_dbg(&xhci_pdev->dev, "USB 3.0 ports that are now enabled "
drivers/usb/host/pci-quirks.c:	dev_dbg(&xhci_pdev->dev, "Configurable USB 2.0 ports to hand over to xCHI: 0x%x\n",
drivers/usb/host/pci-quirks.c:	dev_dbg(&xhci_pdev->dev, "USB 2.0 ports that are now switched over "
drivers/usb/host/pci-quirks.c:			dev_warn(&pdev->dev,
drivers/usb/host/pci-quirks.c:			dev_warn(&pdev->dev, "xHCI BIOS handoff failed"
drivers/usb/host/pci-quirks.c:		dev_warn(&pdev->dev,
drivers/usb/host/pci-quirks.c:		dev_warn(&pdev->dev,
drivers/usb/host/pci-quirks.c:	if (pdev->vendor == 0x184e)	/* vendor Netlogic */
drivers/usb/host/pci-quirks.c:	if (pdev->class != PCI_CLASS_SERIAL_USB_UHCI &&
drivers/usb/host/pci-quirks.c:			pdev->class != PCI_CLASS_SERIAL_USB_OHCI &&
drivers/usb/host/pci-quirks.c:			pdev->class != PCI_CLASS_SERIAL_USB_EHCI &&
drivers/usb/host/pci-quirks.c:			pdev->class != PCI_CLASS_SERIAL_USB_XHCI)
drivers/usb/host/pci-quirks.c:		dev_warn(&pdev->dev, "Can't enable PCI device, "
drivers/usb/host/pci-quirks.c:	if (pdev->class == PCI_CLASS_SERIAL_USB_UHCI)
drivers/usb/host/pci-quirks.c:	else if (pdev->class == PCI_CLASS_SERIAL_USB_OHCI)
drivers/usb/host/pci-quirks.c:	else if (pdev->class == PCI_CLASS_SERIAL_USB_EHCI)
drivers/usb/host/pci-quirks.c:	else if (pdev->class == PCI_CLASS_SERIAL_USB_XHCI)
drivers/usb/host/ohci-nxp.c:	if (pdev->dev.of_node) {
drivers/usb/host/ohci-nxp.c:		isp1301_node = of_parse_phandle(pdev->dev.of_node,
drivers/usb/host/ohci-nxp.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/ohci-nxp.c:	pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/host/ohci-nxp.c:	dev_dbg(&pdev->dev, "%s: " DRIVER_DESC " (nxp)\n", hcd_name);
drivers/usb/host/ohci-nxp.c:		dev_err(&pdev->dev, "USB is disabled\n");
drivers/usb/host/ohci-nxp.c:	usb_pll_clk = clk_get(&pdev->dev, "ck_pll5");
drivers/usb/host/ohci-nxp.c:		dev_err(&pdev->dev, "failed to acquire USB PLL\n");
drivers/usb/host/ohci-nxp.c:		dev_err(&pdev->dev, "failed to start USB PLL\n");
drivers/usb/host/ohci-nxp.c:		dev_err(&pdev->dev, "failed to set USB clock rate\n");
drivers/usb/host/ohci-nxp.c:	usb_dev_clk = clk_get(&pdev->dev, "ck_usbd");
drivers/usb/host/ohci-nxp.c:		dev_err(&pdev->dev, "failed to acquire USB DEV Clock\n");
drivers/usb/host/ohci-nxp.c:		dev_err(&pdev->dev, "failed to start USB DEV Clock\n");
drivers/usb/host/ohci-nxp.c:	usb_otg_clk = clk_get(&pdev->dev, "ck_usb_otg");
drivers/usb/host/ohci-nxp.c:		dev_err(&pdev->dev, "failed to acquire USB DEV Clock\n");
drivers/usb/host/ohci-nxp.c:		dev_err(&pdev->dev, "failed to start USB DEV Clock\n");
drivers/usb/host/ohci-nxp.c:	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/ohci-nxp.c:		dev_err(&pdev->dev, "Failed to allocate HC buffer\n");
drivers/usb/host/ohci-nxp.c:	hcd->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/usb/host/ohci-nxp.c:	dev_info(&pdev->dev, "at 0x%p, irq %d\n", hcd->regs, hcd->irq);
drivers/usb/host/ohci-octeon.c:		dev_err(&pdev->dev, "No irq assigned\n");
drivers/usb/host/ohci-octeon.c:		dev_err(&pdev->dev, "No register space assigned\n");
drivers/usb/host/ohci-octeon.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/ohci-octeon.c:	pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/host/ohci-octeon.c:	hcd = usb_create_hcd(&ohci_octeon_hc_driver, &pdev->dev, "octeon");
drivers/usb/host/ohci-octeon.c:		dev_err(&pdev->dev, "request_mem_region failed\n");
drivers/usb/host/ohci-octeon.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/usb/host/ohci-octeon.c:		dev_dbg(&pdev->dev, "failed to add hcd with err %d\n", ret);
drivers/usb/host/xhci-mem.c:		dma_free_coherent(&pdev->dev,
drivers/usb/host/xhci-mem.c:		return dma_alloc_coherent(&pdev->dev,
drivers/usb/host/xhci-mem.c:		dma_free_coherent(&pdev->dev, xhci->page_size,
drivers/usb/host/xhci-mem.c:	dma_free_coherent(&pdev->dev, num_sp * sizeof(u64),
drivers/usb/host/xhci-mem.c:		dma_free_coherent(&pdev->dev, size,
drivers/usb/host/xhci-mem.c:		dma_free_coherent(&pdev->dev, sizeof(*xhci->dcbaa),
drivers/usb/host/isp1362-hcd.c:	if (pdev->num_resources < 3) {
drivers/usb/host/isp1362-hcd.c:	if (pdev->dev.dma_mask) {
drivers/usb/host/isp1362-hcd.c:	hcd = usb_create_hcd(&isp1362_hc_driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/isp1362-hcd.c:	isp1362_hcd->board = pdev->dev.platform_data;
drivers/usb/host/isp1362-hcd.c:		pdev->dev.power.power_state = state;
drivers/usb/host/isp1362-hcd.c:	if (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {
drivers/usb/host/isp1362-hcd.c:	pdev->dev.power.power_state = PMSG_ON;
drivers/usb/host/ohci-jz4740.c:		dev_err(&pdev->dev, "Failed to get platform resource\n");
drivers/usb/host/ohci-jz4740.c:		dev_err(&pdev->dev, "Failed to get platform irq\n");
drivers/usb/host/ohci-jz4740.c:	hcd = usb_create_hcd(&ohci_jz4740_hc_driver, &pdev->dev, "jz4740");
drivers/usb/host/ohci-jz4740.c:		dev_err(&pdev->dev, "Failed to create hcd.\n");
drivers/usb/host/ohci-jz4740.c:		dev_err(&pdev->dev, "Failed to request mem region.\n");
drivers/usb/host/ohci-jz4740.c:		dev_err(&pdev->dev, "Failed to ioremap registers.\n");
drivers/usb/host/ohci-jz4740.c:	jz4740_ohci->clk = clk_get(&pdev->dev, "uhc");
drivers/usb/host/ohci-jz4740.c:		dev_err(&pdev->dev, "Failed to get clock: %d\n", ret);
drivers/usb/host/ohci-jz4740.c:	jz4740_ohci->vbus = regulator_get(&pdev->dev, "vbus");
drivers/usb/host/ohci-jz4740.c:		dev_err(&pdev->dev, "Failed to add hcd: %d\n", ret);
drivers/usb/host/uhci-pci.c:	if (pdev->vendor == PCI_VENDOR_ID_INTEL)
drivers/usb/host/uhci-pci.c:		if (pdev->vendor == PCI_VENDOR_ID_INTEL)
drivers/usb/host/ohci-at91.c:	dev_dbg(&pdev->dev, "start\n");
drivers/usb/host/ohci-at91.c:	dev_dbg(&pdev->dev, "stop\n");
drivers/usb/host/ohci-at91.c:	if (pdev->num_resources != 2) {
drivers/usb/host/ohci-at91.c:	if ((pdev->resource[0].flags != IORESOURCE_MEM)
drivers/usb/host/ohci-at91.c:			|| (pdev->resource[1].flags != IORESOURCE_IRQ)) {
drivers/usb/host/ohci-at91.c:	hcd = usb_create_hcd(driver, &pdev->dev, "at91");
drivers/usb/host/ohci-at91.c:	hcd->rsrc_start = pdev->resource[0].start;
drivers/usb/host/ohci-at91.c:	hcd->rsrc_len = resource_size(&pdev->resource[0]);
drivers/usb/host/ohci-at91.c:	iclk = clk_get(&pdev->dev, "ohci_clk");
drivers/usb/host/ohci-at91.c:		dev_err(&pdev->dev, "failed to get ohci_clk\n");
drivers/usb/host/ohci-at91.c:	fclk = clk_get(&pdev->dev, "uhpck");
drivers/usb/host/ohci-at91.c:		dev_err(&pdev->dev, "failed to get uhpck\n");
drivers/usb/host/ohci-at91.c:	hclk = clk_get(&pdev->dev, "hclk");
drivers/usb/host/ohci-at91.c:		dev_err(&pdev->dev, "failed to get hclk\n");
drivers/usb/host/ohci-at91.c:	retval = usb_add_hcd(hcd, pdev->resource[1].start, IRQF_SHARED);
drivers/usb/host/ohci-at91.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/usb/host/ohci-at91.c:	struct at91_usbh_data *pdata = pdev->dev.platform_data;
drivers/usb/host/ohci-at91.c:		dev_err(& pdev->dev, "overcurrent interrupt from unknown GPIO\n");
drivers/usb/host/ohci-at91.c:	dev_dbg(& pdev->dev, "overcurrent situation %s\n",
drivers/usb/host/ohci-at91.c:	struct device_node *np = pdev->dev.of_node;
drivers/usb/host/ohci-at91.c:	if (!pdev->dev.dma_mask)
drivers/usb/host/ohci-at91.c:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/host/ohci-at91.c:	if (!pdev->dev.coherent_dma_mask)
drivers/usb/host/ohci-at91.c:		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/ohci-at91.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/usb/host/ohci-at91.c:	pdev->dev.platform_data = pdata;
drivers/usb/host/ohci-at91.c:	pdata = pdev->dev.platform_data;
drivers/usb/host/ohci-at91.c:				dev_err(&pdev->dev,
drivers/usb/host/ohci-at91.c:				dev_err(&pdev->dev,
drivers/usb/host/ohci-at91.c:				dev_err(&pdev->dev,
drivers/usb/host/ohci-at91.c:				dev_err(&pdev->dev,
drivers/usb/host/ohci-at91.c:				dev_err(&pdev->dev,
drivers/usb/host/ohci-at91.c:	device_init_wakeup(&pdev->dev, 1);
drivers/usb/host/ohci-at91.c:	struct at91_usbh_data	*pdata = pdev->dev.platform_data;
drivers/usb/host/ohci-at91.c:	device_init_wakeup(&pdev->dev, 0);
drivers/usb/host/ohci-at91.c:	if (device_may_wakeup(&pdev->dev))
drivers/usb/host/ohci-at91.c:	if (device_may_wakeup(&pdev->dev))
drivers/usb/host/ohci-omap3.c:	struct device		*dev = &pdev->dev;
drivers/usb/host/ohci-omap3.c:	struct device *dev	= &pdev->dev;
drivers/usb/host/ohci-omap3.c:	struct usb_hcd *hcd = dev_get_drvdata(&pdev->dev);
drivers/usb/host/ehci-mv.c:	struct mv_usb_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/host/ehci-mv.c:		dev_err(&pdev->dev, "missing platform_data\n");
drivers/usb/host/ehci-mv.c:	hcd = usb_create_hcd(&mv_ehci_hc_driver, &pdev->dev, "mv ehci");
drivers/usb/host/ehci-mv.c:	ehci_mv = devm_kzalloc(&pdev->dev, sizeof(*ehci_mv), GFP_KERNEL);
drivers/usb/host/ehci-mv.c:		dev_err(&pdev->dev, "cannot allocate ehci_hcd_mv\n");
drivers/usb/host/ehci-mv.c:	ehci_mv->clk = devm_clk_get(&pdev->dev, NULL);
drivers/usb/host/ehci-mv.c:		dev_err(&pdev->dev, "error getting clock\n");
drivers/usb/host/ehci-mv.c:		dev_err(&pdev->dev, "no phy I/O memory resource defined\n");
drivers/usb/host/ehci-mv.c:	ehci_mv->phy_regs = devm_ioremap(&pdev->dev, r->start,
drivers/usb/host/ehci-mv.c:		dev_err(&pdev->dev, "failed to map phy I/O memory\n");
drivers/usb/host/ehci-mv.c:		dev_err(&pdev->dev, "no I/O memory resource defined\n");
drivers/usb/host/ehci-mv.c:	ehci_mv->cap_regs = devm_ioremap(&pdev->dev, r->start,
drivers/usb/host/ehci-mv.c:		dev_err(&pdev->dev, "failed to map I/O memory\n");
drivers/usb/host/ehci-mv.c:		dev_err(&pdev->dev, "init phy error %d\n", retval);
drivers/usb/host/ehci-mv.c:		dev_err(&pdev->dev, "Cannot get irq.");
drivers/usb/host/ehci-mv.c:		ehci_mv->otg = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);
drivers/usb/host/ehci-mv.c:				dev_info(&pdev->dev, "MV_USB_MODE_OTG "
drivers/usb/host/ehci-mv.c:				dev_err(&pdev->dev,
drivers/usb/host/ehci-mv.c:			dev_err(&pdev->dev,
drivers/usb/host/ehci-mv.c:			dev_err(&pdev->dev,
drivers/usb/host/ehci-mv.c:	dev_info(&pdev->dev,
drivers/usb/host/ohci-tilegx.c:	struct tilegx_usb_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/host/ohci-tilegx.c:	hcd = usb_create_hcd(&ohci_tilegx_hc_driver, &pdev->dev,
drivers/usb/host/ohci-tilegx.c:			     dev_name(&pdev->dev));
drivers/usb/host/ohci-tilegx.c:	struct tilegx_usb_platform_data* pdata = pdev->dev.platform_data;
drivers/usb/host/ehci-octeon.c:		dev_err(&pdev->dev, "No irq assigned\n");
drivers/usb/host/ehci-octeon.c:		dev_err(&pdev->dev, "No register space assigned\n");
drivers/usb/host/ehci-octeon.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/ehci-octeon.c:	pdev->dev.dma_mask = &ehci_octeon_dma_mask;
drivers/usb/host/ehci-octeon.c:	hcd = usb_create_hcd(&ehci_octeon_hc_driver, &pdev->dev, "octeon");
drivers/usb/host/ehci-octeon.c:		dev_err(&pdev->dev, "request_mem_region failed\n");
drivers/usb/host/ehci-octeon.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/usb/host/ehci-octeon.c:		dev_dbg(&pdev->dev, "failed to add hcd with err %d\n", ret);
drivers/usb/host/xhci-pci.c:	if (pdev->vendor == PCI_VENDOR_ID_FRESCO_LOGIC &&
drivers/usb/host/xhci-pci.c:			(pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK ||
drivers/usb/host/xhci-pci.c:			 pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_FL1400)) {
drivers/usb/host/xhci-pci.c:		if (pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK &&
drivers/usb/host/xhci-pci.c:				pdev->revision == 0x0) {
drivers/usb/host/xhci-pci.c:				pdev->revision);
drivers/usb/host/xhci-pci.c:	if (pdev->vendor == PCI_VENDOR_ID_NEC)
drivers/usb/host/xhci-pci.c:	if (pdev->vendor == PCI_VENDOR_ID_AMD && xhci->hci_version == 0x96)
drivers/usb/host/xhci-pci.c:	if (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_find_chipset_info())
drivers/usb/host/xhci-pci.c:	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
drivers/usb/host/xhci-pci.c:	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
drivers/usb/host/xhci-pci.c:			pdev->device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {
drivers/usb/host/xhci-pci.c:	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
drivers/usb/host/xhci-pci.c:			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {
drivers/usb/host/xhci-pci.c:	if (pdev->vendor == PCI_VENDOR_ID_VIA)
drivers/usb/host/xhci-pci.c:		pdev->no_d3cold = true;
drivers/usb/host/ohci-platform.c:	struct usb_ohci_pdata *pdata = pdev->dev.platform_data;
drivers/usb/host/ohci-ep93xx.c:	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
drivers/usb/host/ohci-ep93xx.c:		dev_dbg(&pdev->dev, "resource[1] is not IORESOURCE_IRQ\n");
drivers/usb/host/ohci-ep93xx.c:	hcd = usb_create_hcd(driver, &pdev->dev, "ep93xx");
drivers/usb/host/ohci-ep93xx.c:	hcd->rsrc_start = pdev->resource[0].start;
drivers/usb/host/ohci-ep93xx.c:	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
drivers/usb/host/ohci-ep93xx.c:		dev_dbg(&pdev->dev, "ioremap failed\n");
drivers/usb/host/ohci-ep93xx.c:	usb_host_clock = clk_get(&pdev->dev, NULL);
drivers/usb/host/ohci-ep93xx.c:		dev_dbg(&pdev->dev, "clk_get failed\n");
drivers/usb/host/ohci-ep93xx.c:	ep93xx_start_hc(&pdev->dev);
drivers/usb/host/ohci-ep93xx.c:	retval = usb_add_hcd(hcd, pdev->resource[1].start, 0);
drivers/usb/host/ohci-ep93xx.c:	ep93xx_stop_hc(&pdev->dev);
drivers/usb/host/ohci-ep93xx.c:	ep93xx_stop_hc(&pdev->dev);
drivers/usb/host/ohci-ep93xx.c:	ep93xx_stop_hc(&pdev->dev);
drivers/usb/host/ohci-ep93xx.c:	ep93xx_start_hc(&pdev->dev);
drivers/usb/host/r8a66597-hcd.c:	struct r8a66597		*r8a66597 = dev_get_drvdata(&pdev->dev);
drivers/usb/host/r8a66597-hcd.c:	if (pdev->dev.dma_mask) {
drivers/usb/host/r8a66597-hcd.c:		dev_err(&pdev->dev, "dma not supported\n");
drivers/usb/host/r8a66597-hcd.c:		dev_err(&pdev->dev, "platform_get_resource error.\n");
drivers/usb/host/r8a66597-hcd.c:		dev_err(&pdev->dev,
drivers/usb/host/r8a66597-hcd.c:		dev_err(&pdev->dev, "ioremap error.\n");
drivers/usb/host/r8a66597-hcd.c:	if (pdev->dev.platform_data == NULL) {
drivers/usb/host/r8a66597-hcd.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/usb/host/r8a66597-hcd.c:	hcd = usb_create_hcd(&r8a66597_hc_driver, &pdev->dev, (char *)hcd_name);
drivers/usb/host/r8a66597-hcd.c:		dev_err(&pdev->dev, "Failed to create hcd\n");
drivers/usb/host/r8a66597-hcd.c:	dev_set_drvdata(&pdev->dev, r8a66597);
drivers/usb/host/r8a66597-hcd.c:	r8a66597->pdata = pdev->dev.platform_data;
drivers/usb/host/r8a66597-hcd.c:		snprintf(clk_name, sizeof(clk_name), "usb%d", pdev->id);
drivers/usb/host/r8a66597-hcd.c:		r8a66597->clk = clk_get(&pdev->dev, clk_name);
drivers/usb/host/r8a66597-hcd.c:			dev_err(&pdev->dev, "cannot get clock \"%s\"\n",
drivers/usb/host/r8a66597-hcd.c:		dev_err(&pdev->dev, "Failed to add hcd\n");
drivers/usb/host/ohci-exynos.c:	struct exynos4_ohci_platdata *pdata = pdev->dev.platform_data;
drivers/usb/host/ohci-exynos.c:	if (!pdev->dev.dma_mask)
drivers/usb/host/ohci-exynos.c:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/host/ohci-exynos.c:	if (!pdev->dev.coherent_dma_mask)
drivers/usb/host/ohci-exynos.c:		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/ohci-exynos.c:	exynos_ohci = devm_kzalloc(&pdev->dev, sizeof(struct exynos_ohci_hcd),
drivers/usb/host/ohci-exynos.c:	if (of_device_is_compatible(pdev->dev.of_node,
drivers/usb/host/ohci-exynos.c:	phy = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);
drivers/usb/host/ohci-exynos.c:			dev_warn(&pdev->dev, "no platform data or transceiver defined\n");
drivers/usb/host/ohci-exynos.c:	exynos_ohci->dev = &pdev->dev;
drivers/usb/host/ohci-exynos.c:	hcd = usb_create_hcd(&exynos_ohci_hc_driver, &pdev->dev,
drivers/usb/host/ohci-exynos.c:					dev_name(&pdev->dev));
drivers/usb/host/ohci-exynos.c:		dev_err(&pdev->dev, "Unable to create HCD\n");
drivers/usb/host/ohci-exynos.c:	exynos_ohci->clk = devm_clk_get(&pdev->dev, "usbhost");
drivers/usb/host/ohci-exynos.c:		dev_err(&pdev->dev, "Failed to get usbhost clock\n");
drivers/usb/host/ohci-exynos.c:		dev_err(&pdev->dev, "Failed to get I/O memory\n");
drivers/usb/host/ohci-exynos.c:	hcd->regs = devm_ioremap(&pdev->dev, res->start, hcd->rsrc_len);
drivers/usb/host/ohci-exynos.c:		dev_err(&pdev->dev, "Failed to remap I/O memory\n");
drivers/usb/host/ohci-exynos.c:		dev_err(&pdev->dev, "Failed to get IRQ\n");
drivers/usb/host/ohci-exynos.c:		dev_err(&pdev->dev, "Failed to add USB HCD\n");
drivers/usb/host/isp116x-hcd.c:	if (pdev->num_resources < 3) {
drivers/usb/host/isp116x-hcd.c:	if (pdev->dev.dma_mask) {
drivers/usb/host/isp116x-hcd.c:	hcd = usb_create_hcd(&isp116x_hc_driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/isp116x-hcd.c:	isp116x->board = pdev->dev.platform_data;
drivers/usb/host/ohci-spear.c:	if (!pdev->dev.dma_mask)
drivers/usb/host/ohci-spear.c:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/usb/host/ohci-spear.c:	if (!pdev->dev.coherent_dma_mask)
drivers/usb/host/ohci-spear.c:		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/host/ohci-spear.c:	usbh_clk = devm_clk_get(&pdev->dev, NULL);
drivers/usb/host/ohci-spear.c:		dev_err(&pdev->dev, "Error getting interface clock\n");
drivers/usb/host/ohci-spear.c:	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/host/ohci-spear.c:	hcd->rsrc_start = pdev->resource[0].start;
drivers/usb/host/ohci-spear.c:	if (!devm_request_mem_region(&pdev->dev, hcd->rsrc_start, hcd->rsrc_len,
drivers/usb/host/ohci-spear.c:		dev_dbg(&pdev->dev, "request_mem_region failed\n");
drivers/usb/host/ohci-spear.c:	hcd->regs = devm_ioremap(&pdev->dev, hcd->rsrc_start, hcd->rsrc_len);
drivers/usb/host/ohci-spear.c:		dev_dbg(&pdev->dev, "ioremap failed\n");
drivers/usb/host/ohci-spear.c:	dev_err(&pdev->dev, "init fail, %d\n", retval);
drivers/usb/host/ehci-sead3.c:	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
drivers/usb/host/ehci-sead3.c:	hcd = usb_create_hcd(&ehci_sead3_hc_driver, &pdev->dev, "SEAD-3");
drivers/usb/host/ehci-sead3.c:	hcd->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/usb/host/ehci-sead3.c:	ret = usb_add_hcd(hcd, pdev->resource[1].start,
drivers/usb/musb/davinci.c:	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
drivers/usb/musb/davinci.c:		dev_err(&pdev->dev, "failed to allocate glue context\n");
drivers/usb/musb/davinci.c:		dev_err(&pdev->dev, "failed to allocate musb device\n");
drivers/usb/musb/davinci.c:	clk = clk_get(&pdev->dev, "usb");
drivers/usb/musb/davinci.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/usb/musb/davinci.c:		dev_err(&pdev->dev, "failed to enable clock\n");
drivers/usb/musb/davinci.c:	musb->dev.parent		= &pdev->dev;
drivers/usb/musb/davinci.c:	glue->dev			= &pdev->dev;
drivers/usb/musb/davinci.c:	ret = platform_device_add_resources(musb, pdev->resource,
drivers/usb/musb/davinci.c:			pdev->num_resources);
drivers/usb/musb/davinci.c:		dev_err(&pdev->dev, "failed to add resources\n");
drivers/usb/musb/davinci.c:		dev_err(&pdev->dev, "failed to add platform_data\n");
drivers/usb/musb/davinci.c:		dev_err(&pdev->dev, "failed to register musb device\n");
drivers/usb/musb/am35x.c:	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
drivers/usb/musb/am35x.c:		dev_err(&pdev->dev, "failed to allocate glue context\n");
drivers/usb/musb/am35x.c:		dev_err(&pdev->dev, "failed to allocate musb device\n");
drivers/usb/musb/am35x.c:	phy_clk = clk_get(&pdev->dev, "fck");
drivers/usb/musb/am35x.c:		dev_err(&pdev->dev, "failed to get PHY clock\n");
drivers/usb/musb/am35x.c:	clk = clk_get(&pdev->dev, "ick");
drivers/usb/musb/am35x.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/usb/musb/am35x.c:		dev_err(&pdev->dev, "failed to enable PHY clock\n");
drivers/usb/musb/am35x.c:		dev_err(&pdev->dev, "failed to enable clock\n");
drivers/usb/musb/am35x.c:	musb->dev.parent		= &pdev->dev;
drivers/usb/musb/am35x.c:	glue->dev			= &pdev->dev;
drivers/usb/musb/am35x.c:	ret = platform_device_add_resources(musb, pdev->resource,
drivers/usb/musb/am35x.c:			pdev->num_resources);
drivers/usb/musb/am35x.c:		dev_err(&pdev->dev, "failed to add resources\n");
drivers/usb/musb/am35x.c:		dev_err(&pdev->dev, "failed to add platform_data\n");
drivers/usb/musb/am35x.c:		dev_err(&pdev->dev, "failed to register musb device\n");
drivers/usb/musb/da8xx.c:	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
drivers/usb/musb/da8xx.c:		dev_err(&pdev->dev, "failed to allocate glue context\n");
drivers/usb/musb/da8xx.c:		dev_err(&pdev->dev, "failed to allocate musb device\n");
drivers/usb/musb/da8xx.c:	clk = clk_get(&pdev->dev, "usb20");
drivers/usb/musb/da8xx.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/usb/musb/da8xx.c:		dev_err(&pdev->dev, "failed to enable clock\n");
drivers/usb/musb/da8xx.c:	musb->dev.parent		= &pdev->dev;
drivers/usb/musb/da8xx.c:	glue->dev			= &pdev->dev;
drivers/usb/musb/da8xx.c:	ret = platform_device_add_resources(musb, pdev->resource,
drivers/usb/musb/da8xx.c:			pdev->num_resources);
drivers/usb/musb/da8xx.c:		dev_err(&pdev->dev, "failed to add resources\n");
drivers/usb/musb/da8xx.c:		dev_err(&pdev->dev, "failed to add platform_data\n");
drivers/usb/musb/da8xx.c:		dev_err(&pdev->dev, "failed to register musb device\n");
drivers/usb/musb/musb_core.c:	struct musb	*musb = dev_to_musb(&pdev->dev);
drivers/usb/musb/musb_core.c:	struct device	*dev = &pdev->dev;
drivers/usb/musb/musb_core.c:	struct device	*dev = &pdev->dev;
drivers/usb/musb/tusb6010.c:	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
drivers/usb/musb/tusb6010.c:		dev_err(&pdev->dev, "failed to allocate glue context\n");
drivers/usb/musb/tusb6010.c:		dev_err(&pdev->dev, "failed to allocate musb device\n");
drivers/usb/musb/tusb6010.c:	musb->dev.parent		= &pdev->dev;
drivers/usb/musb/tusb6010.c:	glue->dev			= &pdev->dev;
drivers/usb/musb/tusb6010.c:	ret = platform_device_add_resources(musb, pdev->resource,
drivers/usb/musb/tusb6010.c:			pdev->num_resources);
drivers/usb/musb/tusb6010.c:		dev_err(&pdev->dev, "failed to add resources\n");
drivers/usb/musb/tusb6010.c:		dev_err(&pdev->dev, "failed to add platform_data\n");
drivers/usb/musb/tusb6010.c:		dev_err(&pdev->dev, "failed to register musb device\n");
drivers/usb/musb/blackfin.c:	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
drivers/usb/musb/blackfin.c:		dev_err(&pdev->dev, "failed to allocate glue context\n");
drivers/usb/musb/blackfin.c:		dev_err(&pdev->dev, "failed to allocate musb device\n");
drivers/usb/musb/blackfin.c:	musb->dev.parent		= &pdev->dev;
drivers/usb/musb/blackfin.c:	glue->dev			= &pdev->dev;
drivers/usb/musb/blackfin.c:	ret = platform_device_add_resources(musb, pdev->resource,
drivers/usb/musb/blackfin.c:			pdev->num_resources);
drivers/usb/musb/blackfin.c:		dev_err(&pdev->dev, "failed to add resources\n");
drivers/usb/musb/blackfin.c:		dev_err(&pdev->dev, "failed to add platform_data\n");
drivers/usb/musb/blackfin.c:		dev_err(&pdev->dev, "failed to register musb device\n");
drivers/usb/musb/musb_dsps.c:			mod_timer(&glue->timer[pdev->id],
drivers/usb/musb/musb_dsps.c:		del_timer(&glue->timer[pdev->id]);
drivers/usb/musb/musb_dsps.c:		glue->last_timer[pdev->id] = jiffies;
drivers/usb/musb/musb_dsps.c:	if (time_after(glue->last_timer[pdev->id], timeout) &&
drivers/usb/musb/musb_dsps.c:				timer_pending(&glue->timer[pdev->id])) {
drivers/usb/musb/musb_dsps.c:	glue->last_timer[pdev->id] = timeout;
drivers/usb/musb/musb_dsps.c:	mod_timer(&glue->timer[pdev->id], timeout);
drivers/usb/musb/musb_dsps.c:			mod_timer(&glue->timer[pdev->id],
drivers/usb/musb/musb_dsps.c:			del_timer(&glue->timer[pdev->id]);
drivers/usb/musb/musb_dsps.c:		mod_timer(&glue->timer[pdev->id],
drivers/usb/musb/musb_dsps.c:	setup_timer(&glue->timer[pdev->id], otg_timer, (unsigned long) musb);
drivers/usb/musb/musb_dsps.c:	musb_dsps_phy_control(glue, pdev->id, 1);
drivers/usb/musb/musb_dsps.c:	del_timer_sync(&glue->timer[pdev->id]);
drivers/usb/musb/musb_dsps.c:	musb_dsps_phy_control(glue, pdev->id, 0);
drivers/usb/musb/musb_dsps.c:	struct device_node *np = pdev->dev.of_node;
drivers/usb/musb/musb_dsps.c:	glue->usb_ctrl[id] = devm_ioremap_resource(&pdev->dev, resources);
drivers/usb/musb/musb_dsps.c:		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/usb/musb/musb_dsps.c:			dev_err(&pdev->dev,
drivers/usb/musb/musb_dsps.c:		config = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);
drivers/usb/musb/musb_dsps.c:			dev_err(&pdev->dev,
drivers/usb/musb/musb_dsps.c:	match = of_match_node(musb_dsps_of_match, pdev->dev.of_node);
drivers/usb/musb/musb_dsps.c:		dev_err(&pdev->dev, "fail to get matching of_match struct\n");
drivers/usb/musb/musb_dsps.c:		dev_err(&pdev->dev, "unable to allocate glue memory\n");
drivers/usb/musb/musb_dsps.c:		dev_err(&pdev->dev, "failed to get usbss mem resourse\n");
drivers/usb/musb/musb_dsps.c:	glue->dev = &pdev->dev;
drivers/usb/musb/musb_dsps.c:		dev_err(&pdev->dev, "failed to duplicate wrapper struct memory\n");
drivers/usb/musb/musb_dsps.c:	pm_runtime_enable(&pdev->dev);
drivers/usb/musb/musb_dsps.c:	ret = pm_runtime_get_sync(&pdev->dev);
drivers/usb/musb/musb_dsps.c:		dev_err(&pdev->dev, "pm_runtime_get_sync FAILED");
drivers/usb/musb/musb_dsps.c:			dev_err(&pdev->dev, "failed to create child pdev\n");
drivers/usb/musb/musb_dsps.c:	pm_runtime_put(&pdev->dev);
drivers/usb/musb/musb_dsps.c:	pm_runtime_disable(&pdev->dev);
drivers/usb/musb/musb_dsps.c:	pm_runtime_put(&pdev->dev);
drivers/usb/musb/musb_dsps.c:	pm_runtime_disable(&pdev->dev);
drivers/usb/musb/ux500.c:	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
drivers/usb/musb/ux500.c:		dev_err(&pdev->dev, "failed to allocate glue context\n");
drivers/usb/musb/ux500.c:		dev_err(&pdev->dev, "failed to allocate musb device\n");
drivers/usb/musb/ux500.c:	clk = clk_get(&pdev->dev, "usb");
drivers/usb/musb/ux500.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/usb/musb/ux500.c:		dev_err(&pdev->dev, "failed to enable clock\n");
drivers/usb/musb/ux500.c:	musb->dev.parent		= &pdev->dev;
drivers/usb/musb/ux500.c:	musb->dev.dma_mask		= pdev->dev.dma_mask;
drivers/usb/musb/ux500.c:	musb->dev.coherent_dma_mask	= pdev->dev.coherent_dma_mask;
drivers/usb/musb/ux500.c:	glue->dev			= &pdev->dev;
drivers/usb/musb/ux500.c:	ret = platform_device_add_resources(musb, pdev->resource,
drivers/usb/musb/ux500.c:			pdev->num_resources);
drivers/usb/musb/ux500.c:		dev_err(&pdev->dev, "failed to add resources\n");
drivers/usb/musb/ux500.c:		dev_err(&pdev->dev, "failed to add platform_data\n");
drivers/usb/musb/ux500.c:		dev_err(&pdev->dev, "failed to register musb device\n");
drivers/usb/musb/omap2430.c:	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
drivers/usb/musb/omap2430.c:	struct device_node		*np = pdev->dev.of_node;
drivers/usb/musb/omap2430.c:	glue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);
drivers/usb/musb/omap2430.c:		dev_err(&pdev->dev, "failed to allocate glue context\n");
drivers/usb/musb/omap2430.c:		dev_err(&pdev->dev, "failed to allocate musb device\n");
drivers/usb/musb/omap2430.c:	musb->dev.parent		= &pdev->dev;
drivers/usb/musb/omap2430.c:	glue->dev			= &pdev->dev;
drivers/usb/musb/omap2430.c:		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/usb/musb/omap2430.c:			dev_err(&pdev->dev,
drivers/usb/musb/omap2430.c:		data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/usb/musb/omap2430.c:			dev_err(&pdev->dev,
drivers/usb/musb/omap2430.c:		config = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);
drivers/usb/musb/omap2430.c:			dev_err(&pdev->dev,
drivers/usb/musb/omap2430.c:			dev_vdbg(&pdev->dev, "Failed to get control device\n");
drivers/usb/musb/omap2430.c:	ret = platform_device_add_resources(musb, pdev->resource,
drivers/usb/musb/omap2430.c:			pdev->num_resources);
drivers/usb/musb/omap2430.c:		dev_err(&pdev->dev, "failed to add resources\n");
drivers/usb/musb/omap2430.c:		dev_err(&pdev->dev, "failed to add platform_data\n");
drivers/usb/musb/omap2430.c:	pm_runtime_enable(&pdev->dev);
drivers/usb/musb/omap2430.c:		dev_err(&pdev->dev, "failed to register musb device\n");
drivers/usb/c67x00/c67x00-drv.c:		dev_warn(&c67x00->pdev->dev, "Not all interrupts handled! "
drivers/usb/c67x00/c67x00-drv.c:	pdata = pdev->dev.platform_data;
drivers/usb/c67x00/c67x00-drv.c:				pdev->name)) {
drivers/usb/c67x00/c67x00-drv.c:		dev_err(&pdev->dev, "Memory region busy\n");
drivers/usb/c67x00/c67x00-drv.c:		dev_err(&pdev->dev, "Unable to map HPI registers\n");
drivers/usb/c67x00/c67x00-drv.c:	c67x00->pdata = pdev->dev.platform_data;
drivers/usb/c67x00/c67x00-drv.c:	ret = request_irq(res2->start, c67x00_irq, 0, pdev->name, c67x00);
drivers/usb/c67x00/c67x00-drv.c:		dev_err(&pdev->dev, "Cannot claim IRQ\n");
drivers/usb/c67x00/c67x00-drv.c:		dev_err(&pdev->dev, "Device reset failed\n");
drivers/usb/c67x00/c67x00-ll-hpi.c:		dev_err(&dev->pdev->dev,
drivers/usb/c67x00/c67x00.h:#define sie_dev(s)	(&(s)->dev->pdev->dev)
drivers/usb/dwc3/dwc3-exynos.c:	struct device		*dev = &pdev->dev;
drivers/usb/dwc3/dwc3-exynos.c:	device_for_each_child(&pdev->dev, NULL, dwc3_exynos_remove_child);
drivers/usb/dwc3/core.c:	struct device_node	*node = pdev->dev.of_node;
drivers/usb/dwc3/core.c:	struct device		*dev = &pdev->dev;
drivers/usb/dwc3/core.c:	pm_runtime_put(&pdev->dev);
drivers/usb/dwc3/core.c:	pm_runtime_disable(&pdev->dev);
drivers/usb/dwc3/dwc3-omap.c:	struct device_node	*node = pdev->dev.of_node;
drivers/usb/dwc3/dwc3-omap.c:	struct device		*dev = &pdev->dev;
drivers/usb/dwc3/dwc3-omap.c:		dev_err(&pdev->dev, "failed to create dwc3 core\n");
drivers/usb/dwc3/dwc3-omap.c:	pm_runtime_put_sync(&pdev->dev);
drivers/usb/dwc3/dwc3-omap.c:	pm_runtime_disable(&pdev->dev);
drivers/usb/dwc3/dwc3-omap.c:	device_for_each_child(&pdev->dev, NULL, dwc3_omap_remove_core);
drivers/usb/renesas_usbhs/common.c:	return dev_get_drvdata(&pdev->dev);
drivers/usb/renesas_usbhs/common.c:		dev_dbg(&pdev->dev, "%s enable\n", __func__);
drivers/usb/renesas_usbhs/common.c:		dev_dbg(&pdev->dev, "%s disable\n", __func__);
drivers/usb/renesas_usbhs/common.c:	struct renesas_usbhs_platform_info *info = pdev->dev.platform_data;
drivers/usb/renesas_usbhs/common.c:		dev_err(&pdev->dev, "no platform information\n");
drivers/usb/renesas_usbhs/common.c:		dev_err(&pdev->dev, "Not enough Renesas USB platform resources.\n");
drivers/usb/renesas_usbhs/common.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
drivers/usb/renesas_usbhs/common.c:		dev_err(&pdev->dev, "Could not allocate priv\n");
drivers/usb/renesas_usbhs/common.c:	priv->base = devm_ioremap_resource(&pdev->dev, res);
drivers/usb/renesas_usbhs/common.c:	dev_set_drvdata(&pdev->dev, priv);
drivers/usb/renesas_usbhs/common.c:		dev_err(&pdev->dev, "platform prove failed.\n");
drivers/usb/renesas_usbhs/common.c:	pm_runtime_enable(&pdev->dev);
drivers/usb/renesas_usbhs/common.c:	dev_info(&pdev->dev, "probed\n");
drivers/usb/renesas_usbhs/common.c:	dev_info(&pdev->dev, "probe failed\n");
drivers/usb/renesas_usbhs/common.c:	struct renesas_usbhs_platform_info *info = pdev->dev.platform_data;
drivers/usb/renesas_usbhs/common.c:	dev_dbg(&pdev->dev, "usb remove\n");
drivers/usb/renesas_usbhs/common.c:	pm_runtime_disable(&pdev->dev);
drivers/usb/renesas_usbhs/common.h:#define usbhs_priv_to_dev(priv)		(&priv->pdev->dev)
drivers/usb/gadget/imx_udc.c:		dev_err(&pdev->dev, "can't get device resources\n");
drivers/usb/gadget/imx_udc.c:	pdata = pdev->dev.platform_data;
drivers/usb/gadget/imx_udc.c:		dev_err(&pdev->dev, "driver needs platform data\n");
drivers/usb/gadget/imx_udc.c:		dev_err(&pdev->dev, "can't allocate %d bytes at %d address\n",
drivers/usb/gadget/imx_udc.c:		ret = pdata->init(&pdev->dev);
drivers/usb/gadget/imx_udc.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/usb/gadget/imx_udc.c:		dev_err(&pdev->dev, "can't get USB clock\n");
drivers/usb/gadget/imx_udc.c:		D_INI(&pdev->dev,
drivers/usb/gadget/imx_udc.c:			dev_err(&pdev->dev,
drivers/usb/gadget/imx_udc.c:			dev_err(&pdev->dev, "can't get irq number\n");
drivers/usb/gadget/imx_udc.c:			dev_err(&pdev->dev, "can't get irq %i, err %d\n",
drivers/usb/gadget/imx_udc.c:	imx_usb->dev = &pdev->dev;
drivers/usb/gadget/imx_udc.c:	ret = usb_add_gadget_udc(&pdev->dev, &imx_usb->gadget);
drivers/usb/gadget/imx_udc.c:		pdata->exit(&pdev->dev);
drivers/usb/gadget/imx_udc.c:	struct imxusb_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/gadget/imx_udc.c:		pdata->exit(&pdev->dev);
drivers/usb/gadget/net2280.c:	else if (dev->pdev->device != 0x2280) {
drivers/usb/gadget/net2280.c:		if (dev->pdev->device == 0x2280)
drivers/usb/gadget/net2280.c:	if (!ep->is_in || ep->dev->pdev->device == 0x2280) {
drivers/usb/gadget/net2280.c:	if (ep->dev->pdev->device == 0x2280)
drivers/usb/gadget/net2280.c:			|| ep->dev->pdev->device != 0x2280)
drivers/usb/gadget/net2280.c:	if (ep->dev->pdev->device != 0x2280)
drivers/usb/gadget/net2280.c:	retval = device_create_file (&dev->pdev->dev, &dev_attr_function);
drivers/usb/gadget/net2280.c:	retval = device_create_file (&dev->pdev->dev, &dev_attr_queues);
drivers/usb/gadget/net2280.c:	device_remove_file (&dev->pdev->dev, &dev_attr_function);
drivers/usb/gadget/net2280.c:	device_remove_file (&dev->pdev->dev, &dev_attr_function);
drivers/usb/gadget/net2280.c:	device_remove_file (&dev->pdev->dev, &dev_attr_queues);
drivers/usb/gadget/net2280.c:	if (!ep->is_in || ep->dev->pdev->device == 0x2280)
drivers/usb/gadget/net2280.c:		if (ep->dev->pdev->device == 0x2280)
drivers/usb/gadget/net2280.c:	if (dev->pdev->device == 0x2280)
drivers/usb/gadget/net2280.c:		free_irq (pdev->irq, dev);
drivers/usb/gadget/net2280.c:	device_remove_file (&pdev->dev, &dev_attr_registers);
drivers/usb/gadget/net2280.c:	if (!pdev->irq) {
drivers/usb/gadget/net2280.c:	if (request_irq (pdev->irq, net2280_irq, IRQF_SHARED, driver_name, dev)
drivers/usb/gadget/net2280.c:		ERROR (dev, "request interrupt %d failed\n", pdev->irq);
drivers/usb/gadget/net2280.c:			pdev->irq, base, dev->chiprev);
drivers/usb/gadget/net2280.c:	retval = device_create_file (&pdev->dev, &dev_attr_registers);
drivers/usb/gadget/net2280.c:	retval = usb_add_gadget_udc_release(&pdev->dev, &dev->gadget,
drivers/usb/gadget/amd5536udc.h:#define DBG(udc , args...)	dev_dbg(&(udc)->pdev->dev, args)
drivers/usb/gadget/amd5536udc.c:		dev_info(&dev->pdev->dev, "DMA mode (%s)\n", "PPBNDU");
drivers/usb/gadget/amd5536udc.c:		dev_info(&dev->pdev->dev, "DMA mode (%s)\n", "PPBDU");
drivers/usb/gadget/amd5536udc.c:		dev_info(&dev->pdev->dev, "DMA mode (%s)\n", "BF");
drivers/usb/gadget/amd5536udc.c:		dev_info(&dev->pdev->dev, "FIFO mode\n");
drivers/usb/gadget/amd5536udc.c:	dev_info(&dev->pdev->dev, "USB Connect\n");
drivers/usb/gadget/amd5536udc.c:	dev_info(&dev->pdev->dev, "USB Disconnect\n");
drivers/usb/gadget/amd5536udc.c:		dev_err(&dev->pdev->dev, "HE ep%dout occurred\n", ep->num);
drivers/usb/gadget/amd5536udc.c:			dev_err(&dev->pdev->dev,
drivers/usb/gadget/amd5536udc.c:		dev_err(&dev->pdev->dev,
drivers/usb/gadget/amd5536udc.c:		dev_info(&dev->pdev->dev, "Connect: %s\n",
drivers/usb/gadget/amd5536udc.c:		free_irq(pdev->irq, dev);
drivers/usb/gadget/amd5536udc.c:		dev_dbg(&pdev->dev, "already probed\n");
drivers/usb/gadget/amd5536udc.c:		dev_dbg(&pdev->dev, "pci device used already\n");
drivers/usb/gadget/amd5536udc.c:		dev_dbg(&pdev->dev, "start address cannot be mapped\n");
drivers/usb/gadget/amd5536udc.c:	if (!pdev->irq) {
drivers/usb/gadget/amd5536udc.c:		dev_err(&pdev->dev, "irq not set\n");
drivers/usb/gadget/amd5536udc.c:	if (request_irq(pdev->irq, udc_irq, IRQF_SHARED, name, dev) != 0) {
drivers/usb/gadget/amd5536udc.c:		dev_dbg(&pdev->dev, "request_irq(%d) fail\n", pdev->irq);
drivers/usb/gadget/amd5536udc.c:	dev->chiprev = pdev->revision;
drivers/usb/gadget/amd5536udc.c:	dev->irq = pdev->irq;
drivers/usb/gadget/amd5536udc.c:	dev_info(&dev->pdev->dev, "%s\n", mod_desc);
drivers/usb/gadget/amd5536udc.c:	dev_info(&dev->pdev->dev,
drivers/usb/gadget/amd5536udc.c:		dev_err(&dev->pdev->dev, "chip revision is A0; too old\n");
drivers/usb/gadget/amd5536udc.c:	dev_info(&dev->pdev->dev,
drivers/usb/gadget/amd5536udc.c:	retval = usb_add_gadget_udc_release(&udc->pdev->dev, &dev->gadget,
drivers/usb/gadget/at91_udc.c:	udc->gadget.dev.of_node = udc->pdev->dev.of_node;
drivers/usb/gadget/at91_udc.c:	struct device	*dev = &pdev->dev;
drivers/usb/gadget/at91_udc.c:	if (!dev->platform_data && !pdev->dev.of_node) {
drivers/usb/gadget/at91_udc.c:	if (pdev->num_resources != 2) {
drivers/usb/gadget/at91_udc.c:	if ((pdev->resource[0].flags != IORESOURCE_MEM)
drivers/usb/gadget/at91_udc.c:			|| (pdev->resource[1].flags != IORESOURCE_IRQ)) {
drivers/usb/gadget/at91_udc.c:	if (pdev->dev.of_node)
drivers/usb/gadget/at91_udc.c:		at91udc_of_init(udc, pdev->dev.of_node);
drivers/usb/gadget/at91_udc.c:	device_init_wakeup(&pdev->dev, 0);
drivers/usb/gadget/at91_udc.c:	int		wake = udc->driver && device_may_wakeup(&pdev->dev);
drivers/usb/gadget/s3c-hsudc.c:	struct device *dev = &pdev->dev;
drivers/usb/gadget/s3c-hsudc.c:	struct s3c24xx_hsudc_platdata *pd = pdev->dev.platform_data;
drivers/usb/gadget/s3c-hsudc.c:	hsudc = devm_kzalloc(&pdev->dev, sizeof(struct s3c_hsudc) +
drivers/usb/gadget/s3c-hsudc.c:	hsudc->pd = pdev->dev.platform_data;
drivers/usb/gadget/s3c-hsudc.c:	hsudc->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/usb/gadget/s3c-hsudc.c:	ret = devm_request_irq(&pdev->dev, hsudc->irq, s3c_hsudc_irq, 0,
drivers/usb/gadget/s3c-hsudc.c:	hsudc->uclk = devm_clk_get(&pdev->dev, "usb-device");
drivers/usb/gadget/s3c-hsudc.c:	ret = usb_add_gadget_udc(&pdev->dev, &hsudc->gadget);
drivers/usb/gadget/bcm63xx_udc.c:	struct device *dev = &pdev->dev;
drivers/usb/gadget/fsl_mxc_udc.c:	pdata = pdev->dev.platform_data;
drivers/usb/gadget/fsl_mxc_udc.c:	mxc_ipg_clk = devm_clk_get(&pdev->dev, "ipg");
drivers/usb/gadget/fsl_mxc_udc.c:		dev_err(&pdev->dev, "clk_get(\"ipg\") failed\n");
drivers/usb/gadget/fsl_mxc_udc.c:	mxc_ahb_clk = devm_clk_get(&pdev->dev, "ahb");
drivers/usb/gadget/fsl_mxc_udc.c:		dev_err(&pdev->dev, "clk_get(\"ahb\") failed\n");
drivers/usb/gadget/fsl_mxc_udc.c:	mxc_per_clk = devm_clk_get(&pdev->dev, "per");
drivers/usb/gadget/fsl_mxc_udc.c:		dev_err(&pdev->dev, "clk_get(\"per\") failed\n");
drivers/usb/gadget/fsl_mxc_udc.c:	if (!strcmp(pdev->id_entry->name, "imx-udc-mx27")) {
drivers/usb/gadget/fsl_mxc_udc.c:			dev_err(&pdev->dev, "USB_CLK=%lu, should be 60MHz\n", freq);
drivers/usb/gadget/fsl_mxc_udc.c:	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/gadget/fsl_mxc_udc.c:			dev_err(&pdev->dev, "ioremap for phy address fails\n");
drivers/usb/gadget/m66592-udc.c:	struct m66592		*m66592 = dev_get_drvdata(&pdev->dev);
drivers/usb/gadget/m66592-udc.c:		dev_err(&pdev->dev,
drivers/usb/gadget/m66592-udc.c:	if (pdev->dev.platform_data == NULL) {
drivers/usb/gadget/m66592-udc.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/usb/gadget/m66592-udc.c:	m66592->pdata = pdev->dev.platform_data;
drivers/usb/gadget/m66592-udc.c:	dev_set_drvdata(&pdev->dev, m66592);
drivers/usb/gadget/m66592-udc.c:		snprintf(clk_name, sizeof(clk_name), "usbf%d", pdev->id);
drivers/usb/gadget/m66592-udc.c:		m66592->clk = clk_get(&pdev->dev, clk_name);
drivers/usb/gadget/m66592-udc.c:			dev_err(&pdev->dev, "cannot get clock \"%s\"\n",
drivers/usb/gadget/m66592-udc.c:	ret = usb_add_gadget_udc(&pdev->dev, &m66592->gadget);
drivers/usb/gadget/m66592-udc.c:	dev_info(&pdev->dev, "version %s\n", DRIVER_VERSION);
drivers/usb/gadget/atmel_usba_udc.c:	dev_err(&ep->udc->pdev->dev,
drivers/usb/gadget/atmel_usba_udc.c:	dev_err(&udc->pdev->dev, "debugfs is not available\n");
drivers/usb/gadget/atmel_usba_udc.c:		dev_err(&ep->udc->pdev->dev,
drivers/usb/gadget/atmel_usba_udc.c:	struct device *dev = &udc->pdev->dev;
drivers/usb/gadget/atmel_usba_udc.c:			dev_warn(&udc->pdev->dev, "ep_irq: queue empty\n");
drivers/usb/gadget/atmel_usba_udc.c:		dev_err(&udc->pdev->dev,
drivers/usb/gadget/atmel_usba_udc.c:		dev_err(&udc->pdev->dev,
drivers/usb/gadget/atmel_usba_udc.c:			dev_dbg(&udc->pdev->dev,
drivers/usb/gadget/atmel_usba_udc.c:	struct usba_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/gadget/atmel_usba_udc.c:	pclk = clk_get(&pdev->dev, "pclk");
drivers/usb/gadget/atmel_usba_udc.c:	hclk = clk_get(&pdev->dev, "hclk");
drivers/usb/gadget/atmel_usba_udc.c:		dev_err(&pdev->dev, "Unable to map I/O memory, aborting.\n");
drivers/usb/gadget/atmel_usba_udc.c:	dev_info(&pdev->dev, "MMIO registers at 0x%08lx mapped at %p\n",
drivers/usb/gadget/atmel_usba_udc.c:		dev_err(&pdev->dev, "Unable to map FIFO, aborting.\n");
drivers/usb/gadget/atmel_usba_udc.c:	dev_info(&pdev->dev, "FIFO at 0x%08lx mapped at %p\n",
drivers/usb/gadget/atmel_usba_udc.c:		dev_err(&pdev->dev, "Cannot request irq %d (error %d)\n",
drivers/usb/gadget/atmel_usba_udc.c:				dev_warn(&udc->pdev->dev,
drivers/usb/gadget/atmel_usba_udc.c:	ret = usb_add_gadget_udc(&pdev->dev, &udc->gadget);
drivers/usb/gadget/atmel_usba_udc.c:	struct usba_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/gadget/goku_udc.c:		free_irq(pdev->irq, dev);
drivers/usb/gadget/goku_udc.c:	if (!pdev->irq) {
drivers/usb/gadget/goku_udc.c:	INFO(dev, "irq %d, pci mem %p\n", pdev->irq, base);
drivers/usb/gadget/goku_udc.c:	if (request_irq(pdev->irq, goku_irq, IRQF_SHARED,
drivers/usb/gadget/goku_udc.c:		DBG(dev, "request interrupt %d failed\n", pdev->irq);
drivers/usb/gadget/goku_udc.c:	retval = usb_add_gadget_udc_release(&pdev->dev, &dev->gadget,
drivers/usb/gadget/s3c2410_udc.c:	struct device *dev = &pdev->dev;
drivers/usb/gadget/s3c2410_udc.c:	if (strncmp(pdev->name, "s3c2440", 7) == 0) {
drivers/usb/gadget/s3c2410_udc.c:	udc_info = pdev->dev.platform_data;
drivers/usb/gadget/s3c2410_udc.c:	retval = usb_add_gadget_udc(&pdev->dev, &udc->gadget);
drivers/usb/gadget/s3c2410_udc.c:	dev_dbg(&pdev->dev, "%s()\n", __func__);
drivers/usb/gadget/s3c2410_udc.c:	dev_dbg(&pdev->dev, "%s: remove ok\n", __func__);
drivers/usb/gadget/pxa25x_udc.c:	dev->clk = clk_get(&pdev->dev, NULL);
drivers/usb/gadget/pxa25x_udc.c:	dev->dev = &pdev->dev;
drivers/usb/gadget/pxa25x_udc.c:	dev->mach = pdev->dev.platform_data;
drivers/usb/gadget/pxa25x_udc.c:			dev_dbg(&pdev->dev,
drivers/usb/gadget/pxa25x_udc.c:	retval = usb_add_gadget_udc(&pdev->dev, &dev->gadget);
drivers/usb/gadget/s3c-hsotg.c:	struct s3c_hsotg_plat *plat = pdev->dev.platform_data;
drivers/usb/gadget/s3c-hsotg.c:	struct device *dev = &pdev->dev;
drivers/usb/gadget/s3c-hsotg.c:	hsotg = devm_kzalloc(&pdev->dev, sizeof(struct s3c_hsotg), GFP_KERNEL);
drivers/usb/gadget/s3c-hsotg.c:		plat = pdev->dev.platform_data;
drivers/usb/gadget/s3c-hsotg.c:			dev_err(&pdev->dev, "no platform data or transceiver defined\n");
drivers/usb/gadget/s3c-hsotg.c:	hsotg->clk = devm_clk_get(&pdev->dev, "otg");
drivers/usb/gadget/s3c-hsotg.c:	hsotg->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/usb/gadget/s3c-hsotg.c:	ret = devm_request_irq(&pdev->dev, hsotg->irq, s3c_hsotg_irq, 0,
drivers/usb/gadget/s3c-hsotg.c:	ret = usb_add_gadget_udc(&pdev->dev, &hsotg->gadget);
drivers/usb/gadget/hid.c:	struct hidg_func_descriptor *func = pdev->dev.platform_data;
drivers/usb/gadget/hid.c:		dev_err(&pdev->dev, "Platform data missing\n");
drivers/usb/gadget/pch_udc.c:		dev_err(&dev->pdev->dev, "%s: wait error\n", __func__);
drivers/usb/gadget/pch_udc.c:			dev_err(&dev->pdev->dev, "%s: RxFIFO not Empty\n",
drivers/usb/gadget/pch_udc.c:		dev_err(&dev->pdev->dev, "%s: Clear NAK not set for ep%d%s\n",
drivers/usb/gadget/pch_udc.c:		dev_err(&ep->dev->pdev->dev, "%s: wait error\n", __func__);
drivers/usb/gadget/pch_udc.c:			dev_dbg(&dev->pdev->dev, "VBUS fell");
drivers/usb/gadget/pch_udc.c:		dev_dbg(&dev->pdev->dev, "VBUS rose");
drivers/usb/gadget/pch_udc.c:				dma_unmap_single(&dev->pdev->dev, req->req.dma,
drivers/usb/gadget/pch_udc.c:				dma_unmap_single(&dev->pdev->dev, req->req.dma,
drivers/usb/gadget/pch_udc.c:				dma_unmap_single(&dev->pdev->dev, req->dma,
drivers/usb/gadget/pch_udc.c:				dma_unmap_single(&dev->pdev->dev, req->dma,
drivers/usb/gadget/pch_udc.c:		dev_err(&dev->pdev->dev, "%s: %s req=0x%p queue not empty\n",
drivers/usb/gadget/pch_udc.c:				usbreq->dma = dma_map_single(&dev->pdev->dev,
drivers/usb/gadget/pch_udc.c:				usbreq->dma = dma_map_single(&dev->pdev->dev,
drivers/usb/gadget/pch_udc.c:				req->dma = dma_map_single(&dev->pdev->dev,
drivers/usb/gadget/pch_udc.c:				req->dma = dma_map_single(&dev->pdev->dev,
drivers/usb/gadget/pch_udc.c:		dev_err(&dev->pdev->dev, "Invalid RXTX status (0x%08x) "
drivers/usb/gadget/pch_udc.c:			dev_err(&dev->pdev->dev, "Invalid RXTX status=0x%08x "
drivers/usb/gadget/pch_udc.c:			dev_err(&dev->pdev->dev, "Not complete RX descriptor");
drivers/usb/gadget/pch_udc.c:		dev_dbg(&dev->pdev->dev, "USB_RESET\n");
drivers/usb/gadget/pch_udc.c:		dev_dbg(&dev->pdev->dev, "USB_ENUM\n");
drivers/usb/gadget/pch_udc.c:		dev_dbg(&dev->pdev->dev, "USB_SUSPEND\n");
drivers/usb/gadget/pch_udc.c:		dev_dbg(&dev->pdev->dev, "SOF\n");
drivers/usb/gadget/pch_udc.c:		dev_dbg(&dev->pdev->dev, "ES\n");
drivers/usb/gadget/pch_udc.c:		dev_dbg(&dev->pdev->dev, "RWKP\n");
drivers/usb/gadget/pch_udc.c:			dev_dbg(&dev->pdev->dev, "UDC: Hung up\n");
drivers/usb/gadget/pch_udc.c:		dev_err(&dev->pdev->dev, "%s: can't get request data pool\n",
drivers/usb/gadget/pch_udc.c:		dev_err(&dev->pdev->dev, "%s: can't get setup request pool\n",
drivers/usb/gadget/pch_udc.c:		dev_err(&dev->pdev->dev,
drivers/usb/gadget/pch_udc.c:		dev_err(&dev->pdev->dev,
drivers/usb/gadget/pch_udc.c:	dev->dma_addr = dma_map_single(&dev->pdev->dev, dev->ep0out_buf,
drivers/usb/gadget/pch_udc.c:		dev_err(&pdev->dev,
drivers/usb/gadget/pch_udc.c:		dma_unmap_single(&dev->pdev->dev, dev->dma_addr,
drivers/usb/gadget/pch_udc.c:		free_irq(pdev->irq, dev);
drivers/usb/gadget/pch_udc.c:		dev_err(&pdev->dev,
drivers/usb/gadget/pch_udc.c:		dev_err(&pdev->dev, "%s: pci_enable_device failed\n", __func__);
drivers/usb/gadget/pch_udc.c:		dev_err(&pdev->dev, "%s: pci device used already\n", __func__);
drivers/usb/gadget/pch_udc.c:	if (!pdev->irq) {
drivers/usb/gadget/pch_udc.c:		dev_err(&pdev->dev, "%s: irq not set\n", __func__);
drivers/usb/gadget/pch_udc.c:	if (request_irq(pdev->irq, pch_udc_isr, IRQF_SHARED, KBUILD_MODNAME,
drivers/usb/gadget/pch_udc.c:		dev_err(&pdev->dev, "%s: request_irq(%d) fail\n", __func__,
drivers/usb/gadget/pch_udc.c:			pdev->irq);
drivers/usb/gadget/pch_udc.c:	dev->irq = pdev->irq;
drivers/usb/gadget/pch_udc.c:	retval = usb_add_gadget_udc_release(&pdev->dev, &dev->gadget,
drivers/usb/gadget/mv_udc_core.c:		dma_free_coherent(&pdev->dev, udc->ep_dqh_size,
drivers/usb/gadget/mv_udc_core.c:	struct mv_usb_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/gadget/mv_udc_core.c:		dev_err(&pdev->dev, "missing platform_data\n");
drivers/usb/gadget/mv_udc_core.c:	udc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);
drivers/usb/gadget/mv_udc_core.c:		dev_err(&pdev->dev, "failed to allocate memory for udc\n");
drivers/usb/gadget/mv_udc_core.c:	udc->pdata = pdev->dev.platform_data;
drivers/usb/gadget/mv_udc_core.c:		udc->transceiver = devm_usb_get_phy(&pdev->dev,
drivers/usb/gadget/mv_udc_core.c:	udc->clk = devm_clk_get(&pdev->dev, NULL);
drivers/usb/gadget/mv_udc_core.c:		dev_err(&pdev->dev, "no I/O memory resource defined\n");
drivers/usb/gadget/mv_udc_core.c:		devm_ioremap(&pdev->dev, r->start, resource_size(r));
drivers/usb/gadget/mv_udc_core.c:		dev_err(&pdev->dev, "failed to map I/O memory\n");
drivers/usb/gadget/mv_udc_core.c:		dev_err(&pdev->dev, "no phy I/O memory resource defined\n");
drivers/usb/gadget/mv_udc_core.c:		dev_err(&pdev->dev, "failed to map phy I/O memory\n");
drivers/usb/gadget/mv_udc_core.c:	udc->ep_dqh = dma_alloc_coherent(&pdev->dev, size,
drivers/usb/gadget/mv_udc_core.c:		dev_err(&pdev->dev, "allocate dQH memory failed\n");
drivers/usb/gadget/mv_udc_core.c:			&pdev->dev,
drivers/usb/gadget/mv_udc_core.c:	udc->eps = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
drivers/usb/gadget/mv_udc_core.c:		dev_err(&pdev->dev, "allocate ep memory failed\n");
drivers/usb/gadget/mv_udc_core.c:	udc->status_req = devm_kzalloc(&pdev->dev, sizeof(struct mv_req),
drivers/usb/gadget/mv_udc_core.c:		dev_err(&pdev->dev, "allocate status_req memory failed\n");
drivers/usb/gadget/mv_udc_core.c:		dev_err(&pdev->dev, "no IRQ resource defined\n");
drivers/usb/gadget/mv_udc_core.c:	if (devm_request_irq(&pdev->dev, udc->irq, mv_udc_irq,
drivers/usb/gadget/mv_udc_core.c:		dev_err(&pdev->dev, "Request irq %d for UDC failed\n",
drivers/usb/gadget/mv_udc_core.c:		retval = devm_request_threaded_irq(&pdev->dev,
drivers/usb/gadget/mv_udc_core.c:			dev_info(&pdev->dev,
drivers/usb/gadget/mv_udc_core.c:			dev_err(&pdev->dev, "cannot create workqueue\n");
drivers/usb/gadget/mv_udc_core.c:	retval = usb_add_gadget_udc_release(&pdev->dev, &udc->gadget,
drivers/usb/gadget/mv_udc_core.c:	dev_info(&pdev->dev, "successful probe UDC device %s clock gating.\n",
drivers/usb/gadget/mv_udc_core.c:	dma_free_coherent(&pdev->dev, udc->ep_dqh_size,
drivers/usb/gadget/pxa27x_udc.c:	udc->dev = &pdev->dev;
drivers/usb/gadget/pxa27x_udc.c:	udc->mach = pdev->dev.platform_data;
drivers/usb/gadget/pxa27x_udc.c:		dev_err(&pdev->dev, "Couldn't request gpio %d : %d\n",
drivers/usb/gadget/pxa27x_udc.c:	udc->clk = clk_get(&pdev->dev, NULL);
drivers/usb/gadget/pxa27x_udc.c:		dev_err(&pdev->dev, "Unable to map UDC I/O memory\n");
drivers/usb/gadget/pxa27x_udc.c:	retval = usb_add_gadget_udc(&pdev->dev, &udc->gadget);
drivers/usb/gadget/dummy_hcd.c:	dum = *((void **)dev_get_platdata(&pdev->dev));
drivers/usb/gadget/dummy_hcd.c:	dum->gadget.dev.parent = &pdev->dev;
drivers/usb/gadget/dummy_hcd.c:	rc = usb_add_gadget_udc(&pdev->dev, &dum->gadget);
drivers/usb/gadget/dummy_hcd.c:	dev_dbg(&pdev->dev, "%s\n", __func__);
drivers/usb/gadget/dummy_hcd.c:	dev_dbg(&pdev->dev, "%s\n", __func__);
drivers/usb/gadget/dummy_hcd.c:	dev_info(&pdev->dev, "%s, driver " DRIVER_VERSION "\n", driver_desc);
drivers/usb/gadget/dummy_hcd.c:	dum = *((void **)dev_get_platdata(&pdev->dev));
drivers/usb/gadget/dummy_hcd.c:	hs_hcd = usb_create_hcd(&dummy_hcd, &pdev->dev, dev_name(&pdev->dev));
drivers/usb/gadget/dummy_hcd.c:		ss_hcd = usb_create_shared_hcd(&dummy_hcd, &pdev->dev,
drivers/usb/gadget/dummy_hcd.c:					dev_name(&pdev->dev), hs_hcd);
drivers/usb/gadget/dummy_hcd.c:	dev_dbg(&pdev->dev, "%s\n", __func__);
drivers/usb/gadget/dummy_hcd.c:		dev_warn(&pdev->dev, "Root hub isn't suspended!\n");
drivers/usb/gadget/dummy_hcd.c:	dev_dbg(&pdev->dev, "%s\n", __func__);
drivers/usb/gadget/lpc32xx_udc.c:	struct device *dev = &pdev->dev;
drivers/usb/gadget/lpc32xx_udc.c:	udc->dev = &pdev->dev;
drivers/usb/gadget/lpc32xx_udc.c:	if (pdev->dev.of_node) {
drivers/usb/gadget/lpc32xx_udc.c:		isp1301_node = of_parse_phandle(pdev->dev.of_node,
drivers/usb/gadget/lpc32xx_udc.c:	pdev->dev.dma_mask = &lpc32xx_usbd_dmamask;
drivers/usb/gadget/lpc32xx_udc.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/usb/gadget/lpc32xx_udc.c:	udc->usb_pll_clk = clk_get(&pdev->dev, "ck_pll5");
drivers/usb/gadget/lpc32xx_udc.c:	udc->usb_slv_clk = clk_get(&pdev->dev, "ck_usbd");
drivers/usb/gadget/lpc32xx_udc.c:	udc->usb_otg_clk = clk_get(&pdev->dev, "ck_usb_otg");
drivers/usb/gadget/lpc32xx_udc.c:	udc->udca_v_base = dma_alloc_coherent(&pdev->dev, UDCA_BUFF_SIZE,
drivers/usb/gadget/lpc32xx_udc.c:	dma_free_coherent(&pdev->dev, UDCA_BUFF_SIZE,
drivers/usb/gadget/lpc32xx_udc.c:	device_init_wakeup(&pdev->dev, 0);
drivers/usb/gadget/lpc32xx_udc.c:	dma_free_coherent(&pdev->dev, UDCA_BUFF_SIZE,
drivers/usb/gadget/omap_udc.c:	struct omap_usb_config	*config = pdev->dev.platform_data;
drivers/usb/gadget/omap_udc.c:	if (!request_mem_region(pdev->resource[0].start,
drivers/usb/gadget/omap_udc.c:			pdev->resource[0].end - pdev->resource[0].start + 1,
drivers/usb/gadget/omap_udc.c:		dc_clk = clk_get(&pdev->dev, "usb_dc_ck");
drivers/usb/gadget/omap_udc.c:		hhc_clk = clk_get(&pdev->dev, "usb_hhc_ck");
drivers/usb/gadget/omap_udc.c:		dc_clk = clk_get(&pdev->dev, "usb_dc_ck");
drivers/usb/gadget/omap_udc.c:		hhc_clk = clk_get(&pdev->dev, "l3_ocpi_ck");
drivers/usb/gadget/omap_udc.c:	status = request_irq(pdev->resource[1].start, omap_udc_irq,
drivers/usb/gadget/omap_udc.c:			(int) pdev->resource[1].start, status);
drivers/usb/gadget/omap_udc.c:	status = request_irq(pdev->resource[2].start, omap_udc_pio_irq,
drivers/usb/gadget/omap_udc.c:			(int) pdev->resource[2].start, status);
drivers/usb/gadget/omap_udc.c:	status = request_irq(pdev->resource[3].start, omap_udc_iso_irq,
drivers/usb/gadget/omap_udc.c:			(int) pdev->resource[3].start, status);
drivers/usb/gadget/omap_udc.c:	status = usb_add_gadget_udc_release(&pdev->dev, &udc->gadget,
drivers/usb/gadget/omap_udc.c:	free_irq(pdev->resource[2].start, udc);
drivers/usb/gadget/omap_udc.c:	free_irq(pdev->resource[1].start, udc);
drivers/usb/gadget/omap_udc.c:	release_mem_region(pdev->resource[0].start,
drivers/usb/gadget/omap_udc.c:			pdev->resource[0].end - pdev->resource[0].start + 1);
drivers/usb/gadget/omap_udc.c:	free_irq(pdev->resource[3].start, udc);
drivers/usb/gadget/omap_udc.c:	free_irq(pdev->resource[2].start, udc);
drivers/usb/gadget/omap_udc.c:	free_irq(pdev->resource[1].start, udc);
drivers/usb/gadget/omap_udc.c:	release_mem_region(pdev->resource[0].start,
drivers/usb/gadget/omap_udc.c:			pdev->resource[0].end - pdev->resource[0].start + 1);
drivers/usb/gadget/r8a66597-udc.c:	struct r8a66597		*r8a66597 = dev_get_drvdata(&pdev->dev);
drivers/usb/gadget/r8a66597-udc.c:		dev_err(&pdev->dev, "platform_get_resource error(sudmac).\n");
drivers/usb/gadget/r8a66597-udc.c:		dev_err(&pdev->dev, "ioremap error(sudmac).\n");
drivers/usb/gadget/r8a66597-udc.c:		dev_err(&pdev->dev, "platform_get_resource error.\n");
drivers/usb/gadget/r8a66597-udc.c:		dev_err(&pdev->dev, "platform_get_irq error.\n");
drivers/usb/gadget/r8a66597-udc.c:		dev_err(&pdev->dev, "ioremap error.\n");
drivers/usb/gadget/r8a66597-udc.c:		dev_err(&pdev->dev, "kzalloc error\n");
drivers/usb/gadget/r8a66597-udc.c:	dev_set_drvdata(&pdev->dev, r8a66597);
drivers/usb/gadget/r8a66597-udc.c:	r8a66597->pdata = pdev->dev.platform_data;
drivers/usb/gadget/r8a66597-udc.c:		snprintf(clk_name, sizeof(clk_name), "usb%d", pdev->id);
drivers/usb/gadget/r8a66597-udc.c:		r8a66597->clk = clk_get(&pdev->dev, clk_name);
drivers/usb/gadget/r8a66597-udc.c:			dev_err(&pdev->dev, "cannot get clock \"%s\"\n",
drivers/usb/gadget/r8a66597-udc.c:		dev_err(&pdev->dev, "request_irq error (%d)\n", ret);
drivers/usb/gadget/r8a66597-udc.c:	ret = usb_add_gadget_udc(&pdev->dev, &r8a66597->gadget);
drivers/usb/gadget/r8a66597-udc.c:	dev_info(&pdev->dev, "version %s\n", DRIVER_VERSION);
drivers/usb/gadget/fusb300_udc.c:	struct fusb300 *fusb300 = dev_get_drvdata(&pdev->dev);
drivers/usb/gadget/fusb300_udc.c:		dev_err(&pdev->dev,
drivers/usb/gadget/fusb300_udc.c:		dev_err(&pdev->dev,
drivers/usb/gadget/fusb300_udc.c:	dev_set_drvdata(&pdev->dev, fusb300);
drivers/usb/gadget/fusb300_udc.c:	ret = usb_add_gadget_udc(&pdev->dev, &fusb300->gadget);
drivers/usb/gadget/fusb300_udc.c:	dev_info(&pdev->dev, "version %s\n", DRIVER_VERSION);
drivers/usb/gadget/fsl_udc_core.c:	pdata = pdev->dev.platform_data;
drivers/usb/gadget/fsl_udc_core.c:	udc->ep_qh = dma_alloc_coherent(&pdev->dev, size,
drivers/usb/gadget/fsl_udc_core.c:	pdata = pdev->dev.platform_data;
drivers/usb/gadget/fsl_udc_core.c:			ERR("request mem region for %s failed\n", pdev->name);
drivers/usb/gadget/fsl_udc_core.c:	udc_controller->gadget.dev.of_node = pdev->dev.of_node;
drivers/usb/gadget/fsl_udc_core.c:	udc_controller->td_pool = dma_pool_create("udc_td", &pdev->dev,
drivers/usb/gadget/fsl_udc_core.c:	ret = usb_add_gadget_udc_release(&pdev->dev, &udc_controller->gadget,
drivers/usb/gadget/fsl_udc_core.c:	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
drivers/usb/gadget/net2272.c:	dev = net2272_probe_init(&pdev->dev, pdev->irq);
drivers/usb/gadget/net2272.c:	dev->dev_id = pdev->device;
drivers/usb/gadget/net2272.c:	switch (pdev->device) {
drivers/usb/gadget/net2272.c:	switch (pdev->device) {
drivers/usb/gadget/net2272.c:		dev_err(&pdev->dev, "must provide irq/base addr");
drivers/usb/gadget/net2272.c:	dev = net2272_probe_init(&pdev->dev, irq_res->start);
drivers/usb/gadget/net2272.c:	dev_info(&pdev->dev, "running in 16-bit, %sbyte swap local bus mode\n",
drivers/usb/gadget/net2272.c:	release_mem_region(pdev->resource[0].start,
drivers/usb/gadget/net2272.c:		resource_size(&pdev->resource[0]));
drivers/usb/gadget/f_uac2.c:	sprintf(card->longname, "UAC2_Gadget %i", pdev->id);
drivers/usb/gadget/f_uac2.c:	snd_card_set_dev(card, &pdev->dev);
drivers/ata/sata_sis.c:		switch (pdev->device) {
drivers/ata/sata_sis.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_sis.c:			dev_info(&pdev->dev,
drivers/ata/sata_sis.c:			dev_info(&pdev->dev,
drivers/ata/sata_sis.c:			dev_info(&pdev->dev, "Detected SiS 182/965 chipset\n");
drivers/ata/sata_sis.c:			dev_info(&pdev->dev, "Detected SiS 182/965L chipset\n");
drivers/ata/sata_sis.c:		dev_info(&pdev->dev,
drivers/ata/sata_sis.c:		dev_info(&pdev->dev,
drivers/ata/sata_sis.c:	return ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,
drivers/ata/pata_scc.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_scc.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, 1);
drivers/ata/pata_scc.c:	return ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,
drivers/ata/pata_oldpiix.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_rz1000.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_rz1000.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_cs5520.c:		dev_warn(&pdev->dev, "DMA mode disabled. Enabling.\n");
drivers/ata/pata_cs5520.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);
drivers/ata/pata_cs5520.c:	iomap[0] = devm_ioport_map(&pdev->dev, cmd_port[0], 8);
drivers/ata/pata_cs5520.c:	iomap[1] = devm_ioport_map(&pdev->dev, ctl_port[0], 1);
drivers/ata/pata_cs5520.c:	iomap[2] = devm_ioport_map(&pdev->dev, cmd_port[1], 8);
drivers/ata/pata_cs5520.c:	iomap[3] = devm_ioport_map(&pdev->dev, ctl_port[1], 1);
drivers/ata/pata_cs5520.c:		rc = devm_request_irq(&pdev->dev, irq[ap->port_no],
drivers/ata/pata_cs5520.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_cs5520.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/sata_rcar.c:	priv = devm_kzalloc(&pdev->dev, sizeof(struct sata_rcar_priv),
drivers/ata/sata_rcar.c:	priv->clk = devm_clk_get(&pdev->dev, NULL);
drivers/ata/sata_rcar.c:		dev_err(&pdev->dev, "failed to get access to sata clock\n");
drivers/ata/sata_rcar.c:	host = ata_host_alloc(&pdev->dev, 1);
drivers/ata/sata_rcar.c:		dev_err(&pdev->dev, "ata_host_alloc failed\n");
drivers/ata/sata_rcar.c:	priv->base = devm_ioremap_resource(&pdev->dev, mem);
drivers/ata/sata_rcar.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_cypress.c:	if (PCI_FUNC(pdev->devfn) != 1)
drivers/ata/pata_efar.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_ns87415.c:	if (PCI_SLOT(pdev->devfn) == 0x0E)
drivers/ata/pata_ns87415.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_ns87415.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_via.c:	if (pdev->subsystem_vendor == 0x161F && pdev->subsystem_device == 0x2032)
drivers/ata/pata_via.c:	vp = devm_kzalloc(&pdev->dev, sizeof(struct via_port), GFP_KERNEL);
drivers/ata/pata_via.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_via.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_rdc.c:	struct device *dev = &pdev->dev;
drivers/ata/pata_rdc.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_rdc.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_imx.c:	priv = devm_kzalloc(&pdev->dev,
drivers/ata/pata_imx.c:	priv->clk = devm_clk_get(&pdev->dev, NULL);
drivers/ata/pata_imx.c:		dev_err(&pdev->dev, "Failed to get clock\n");
drivers/ata/pata_imx.c:	host = ata_host_alloc(&pdev->dev, 1);
drivers/ata/pata_imx.c:	priv->host_regs = devm_ioremap(&pdev->dev, io_res->start,
drivers/ata/pata_imx.c:		dev_err(&pdev->dev, "failed to map IO/CTL base\n");
drivers/ata/pata_imx.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/ahci.c:	if (pdev->vendor == PCI_VENDOR_ID_JMICRON && pdev->device == 0x2361) {
drivers/ata/ahci.c:		dev_info(&pdev->dev, "JMB361 has only one port\n");
drivers/ata/ahci.c:		if (pdev->device == 0x6121)
drivers/ata/ahci.c:		dev_info(&pdev->dev,
drivers/ata/ahci.c:	ahci_save_initial_config(&pdev->dev, hpriv, force_port_map,
drivers/ata/ahci.c:	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
drivers/ata/ahci.c:		if (pdev->device == 0x6121)
drivers/ata/ahci.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/ahci.c:		dev_err(&pdev->dev,
drivers/ata/ahci.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/ahci.c:	if (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {
drivers/ata/ahci.c:	if (pdev->dma_mask && pdev->dma_mask < DMA_BIT_MASK(32))
drivers/ata/ahci.c:				dev_err(&pdev->dev,
drivers/ata/ahci.c:			dev_err(&pdev->dev, "32-bit DMA enable failed\n");
drivers/ata/ahci.c:			dev_err(&pdev->dev,
drivers/ata/ahci.c:	if (pdev->bus->number == 0 && pdev->devfn == PCI_DEVFN(0x1f, 2) &&
drivers/ata/ahci.c:		dev_info(&pdev->dev,
drivers/ata/ahci.c:	if (pdev->bus->number != 0 || pdev->devfn != PCI_DEVFN(0x12, 0) ||
drivers/ata/ahci.c:		dev_warn(&pdev->dev,
drivers/ata/ahci.c:	dev_warn(&pdev->dev, "%s: enabling 64bit DMA\n", match->ident);
drivers/ata/ahci.c:		return slot == PCI_SLOT(pdev->devfn);
drivers/ata/ahci.c:	if (!dmi || pdev->bus->number || pdev->devfn != PCI_DEVFN(0x1f, 2))
drivers/ata/ahci.c:	return pdev->bus->number == (val >> 8) && pdev->devfn == (val & 0xff);
drivers/ata/ahci.c:	struct device *dev = &pdev->dev;
drivers/ata/ahci.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/ahci.c:	if (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable)
drivers/ata/ahci.c:	if (pdev->vendor == PCI_VENDOR_ID_NVIDIA &&
drivers/ata/ahci.c:	    pdev->device == PCI_DEVICE_ID_NVIDIA_NFORCE_MCP89_SATA &&
drivers/ata/ahci.c:	    pdev->subsystem_vendor == PCI_VENDOR_ID_APPLE &&
drivers/ata/ahci.c:	    pdev->subsystem_device == 0xcb89)
drivers/ata/ahci.c:	if (pdev->vendor == PCI_VENDOR_ID_PROMISE)
drivers/ata/ahci.c:		dev_info(&pdev->dev,
drivers/ata/ahci.c:	if (pdev->vendor == PCI_VENDOR_ID_STMICRO && pdev->device == 0xCC06)
drivers/ata/ahci.c:	else if (pdev->vendor == 0x1c44 && pdev->device == 0x8000)
drivers/ata/ahci.c:	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
drivers/ata/ahci.c:	    (pdev->device == 0x2652 || pdev->device == 0x2653)) {
drivers/ata/ahci.c:			dev_info(&pdev->dev,
drivers/ata/ahci.c:	    (pdev->revision == 0xa1 || pdev->revision == 0xa2))
drivers/ata/ahci.c:	if (board_id == board_ahci_sb700 && pdev->revision >= 0x40)
drivers/ata/ahci.c:		dev_info(&pdev->dev,
drivers/ata/ahci.c:		dev_warn(&pdev->dev,
drivers/ata/ahci.c:		dev_info(&pdev->dev,
drivers/ata/ahci.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
drivers/ata/ahci.c:		return ahci_host_activate(host, pdev->irq, n_msis);
drivers/ata/ahci.c:	return ata_host_activate(host, pdev->irq, ahci_interrupt, IRQF_SHARED,
drivers/ata/pata_hpt37x.c:	if (PCI_FUNC(pdev->devfn) & 1) {
drivers/ata/pata_hpt37x.c:		pdev_0 = pci_get_slot(pdev->bus, pdev->devfn - 1);
drivers/ata/pata_amd.c:		dev_err(&pdev->dev, "unknown mode %d\n", speed);
drivers/ata/pata_amd.c:	if (pdev->device == PCI_DEVICE_ID_AMD_VIPER_7411) /* FIFO is broken */
drivers/ata/pata_amd.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_amd.c:	if (type == 1 && pdev->revision > 0x7)
drivers/ata/pata_amd.c:	if (type == 5 && pdev->subsystem_vendor == PCI_VENDOR_ID_AMD &&
drivers/ata/pata_amd.c:			 pdev->subsystem_device == PCI_DEVICE_ID_AMD_SERENADE)
drivers/ata/pata_amd.c:	if (pdev->vendor == PCI_VENDOR_ID_AMD)
drivers/ata/pata_amd.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_amd.c:	if (pdev->vendor == PCI_VENDOR_ID_AMD) {
drivers/ata/pata_amd.c:		if (pdev->device == PCI_DEVICE_ID_AMD_VIPER_7409 ||
drivers/ata/pata_amd.c:		    pdev->device == PCI_DEVICE_ID_AMD_COBRA_7401)
drivers/ata/pata_macio.c:			dev_err(&priv->pdev->dev,
drivers/ata/pata_macio.c:		dev_err(&pdev->dev,
drivers/ata/pata_macio.c:		dev_err(&pdev->dev,
drivers/ata/pata_macio.c:	priv = devm_kzalloc(&pdev->dev,
drivers/ata/pata_macio.c:		dev_err(&pdev->dev,
drivers/ata/pata_macio.c:	priv->dev = &pdev->dev;
drivers/ata/pata_macio.c:		dev_err(&pdev->dev,
drivers/ata/pata_macio.c:				   pdev->irq))
drivers/ata/pata_macio.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_macio.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_macio.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_triflex.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/sata_sx4.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_sx4.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, 4);
drivers/ata/sata_sx4.c:	hpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);
drivers/ata/sata_sx4.c:	return ata_host_activate(host, pdev->irq, pdc20621_interrupt,
drivers/ata/pata_samsung_cf.c:	struct s3c_ide_platdata *pdata = pdev->dev.platform_data;
drivers/ata/pata_samsung_cf.c:	struct device *dev = &pdev->dev;
drivers/ata/pata_samsung_cf.c:	info->clk = devm_clk_get(&pdev->dev, "cfcon");
drivers/ata/pata_samsung_cf.c:	struct s3c_ide_platdata *pdata = pdev->dev.platform_data;
drivers/ata/pata_platform.c:	struct pata_platform_info *pp_info = pdev->dev.platform_data;
drivers/ata/pata_platform.c:	if ((pdev->num_resources != 3) && (pdev->num_resources != 2)) {
drivers/ata/pata_platform.c:		dev_err(&pdev->dev, "invalid number of resources\n");
drivers/ata/pata_platform.c:	return __pata_platform_probe(&pdev->dev, io_res, ctl_res, irq_res,
drivers/ata/sata_vsc.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_vsc.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, 4);
drivers/ata/sata_vsc.c:	return ata_host_activate(host, pdev->irq, vsc_sata_interrupt,
drivers/ata/pata_marvell.c:	if (pdev->device != 0x6145)
drivers/ata/pata_marvell.c:	if (pdev->device == 0x6145 && ap->port_no == 0 &&
drivers/ata/pata_marvell.c:	if (pdev->device == 0x6101)
drivers/ata/sata_nv.c:	if (pdev->device == PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SATA ||
drivers/ata/sata_nv.c:		pdev->device == PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SATA2)
drivers/ata/sata_nv.c:	if (pdev->device == PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SATA ||
drivers/ata/sata_nv.c:		pdev->device == PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SATA2) {
drivers/ata/sata_nv.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_nv.c:		dev_notice(&pdev->dev, "Using ADMA mode\n");
drivers/ata/sata_nv.c:		dev_notice(&pdev->dev, "Using SWNCQ mode\n");
drivers/ata/sata_nv.c:	hpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);
drivers/ata/sata_nv.c:		dev_notice(&pdev->dev, "Using MSI\n");
drivers/ata/sata_nv.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/sata_nv.c:	if (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {
drivers/ata/pata_pxa.c:	struct pata_pxa_pdata *pdata = pdev->dev.platform_data;
drivers/ata/pata_pxa.c:	if (pdev->num_resources != 4) {
drivers/ata/pata_pxa.c:		dev_err(&pdev->dev, "invalid number of resources\n");
drivers/ata/pata_pxa.c:	host = ata_host_alloc(&pdev->dev, 1);
drivers/ata/pata_pxa.c:	ap->ioaddr.cmd_addr	= devm_ioremap(&pdev->dev, cmd_res->start,
drivers/ata/pata_pxa.c:	ap->ioaddr.ctl_addr	= devm_ioremap(&pdev->dev, ctl_res->start,
drivers/ata/pata_pxa.c:	ap->ioaddr.bmdma_addr	= devm_ioremap(&pdev->dev, dma_res->start,
drivers/ata/pata_pxa.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct pata_pxa_data),
drivers/ata/pata_pxa.c:	data->dma_desc = dmam_alloc_coherent(&pdev->dev, PAGE_SIZE,
drivers/ata/pata_pxa.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_radisys.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_legacy.c:	if (devm_request_region(&pdev->dev, io, 8, "pata_legacy") == NULL ||
drivers/ata/pata_legacy.c:	    devm_request_region(&pdev->dev, io + 0x0206, 1,
drivers/ata/pata_legacy.c:	io_addr = devm_ioport_map(&pdev->dev, io, 8);
drivers/ata/pata_legacy.c:	ctrl_addr = devm_ioport_map(&pdev->dev, io + 0x0206, 1);
drivers/ata/pata_legacy.c:	host = ata_host_alloc(&pdev->dev, 1);
drivers/ata/libata-acpi.c:	if ((pdev->class >> 8) != PCI_CLASS_STORAGE_SATA &&
drivers/ata/libata-acpi.c:	    (pdev->class >> 8) != PCI_CLASS_STORAGE_IDE)
drivers/ata/pata_sis.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_sis.c:			dev_info(&pdev->dev,
drivers/ata/pata_sis.c:				dev_info(&pdev->dev,
drivers/ata/pata_sis.c:			lpc_bridge = pci_get_slot(pdev->bus, 0x10); /* Bus 0 Dev 2 Fn 0 */
drivers/ata/pata_sis.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_ns87410.c:		dev_err(&pdev->dev, "unknown mode %d\n", adev->pio_mode);
drivers/ata/pata_arasan_cf.c:	struct arasan_cf_pdata *pdata = dev_get_platdata(&pdev->dev);
drivers/ata/pata_arasan_cf.c:	if (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),
drivers/ata/pata_arasan_cf.c:		dev_warn(&pdev->dev, "Failed to get memory region resource\n");
drivers/ata/pata_arasan_cf.c:	acdev = devm_kzalloc(&pdev->dev, sizeof(*acdev), GFP_KERNEL);
drivers/ata/pata_arasan_cf.c:		dev_warn(&pdev->dev, "kzalloc fail\n");
drivers/ata/pata_arasan_cf.c:	acdev->vbase = devm_ioremap_nocache(&pdev->dev, res->start,
drivers/ata/pata_arasan_cf.c:		dev_warn(&pdev->dev, "ioremap fail\n");
drivers/ata/pata_arasan_cf.c:	acdev->clk = clk_get(&pdev->dev, NULL);
drivers/ata/pata_arasan_cf.c:		dev_warn(&pdev->dev, "Clock not found\n");
drivers/ata/pata_arasan_cf.c:	host = ata_host_alloc(&pdev->dev, 1);
drivers/ata/pata_arasan_cf.c:		dev_warn(&pdev->dev, "alloc host fail\n");
drivers/ata/pata_arasan_cf.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_cs5530.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_ixp4xx_cf.c:	struct ixp4xx_pata_data *data = pdev->dev.platform_data;
drivers/ata/pata_ixp4xx_cf.c:	host = ata_host_alloc(&pdev->dev, 1);
drivers/ata/pata_ixp4xx_cf.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/ata/pata_ixp4xx_cf.c:	data->cs0 = devm_ioremap(&pdev->dev, cs0->start, 0x1000);
drivers/ata/pata_ixp4xx_cf.c:	data->cs1 = devm_ioremap(&pdev->dev, cs1->start, 0x1000);
drivers/ata/pata_ixp4xx_cf.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_mv.c:	early_5080 = (pdev->device == 0x5080) && (pdev->revision == 0);
drivers/ata/sata_mv.c:		switch (pdev->revision) {
drivers/ata/sata_mv.c:			dev_warn(&pdev->dev,
drivers/ata/sata_mv.c:		switch (pdev->revision) {
drivers/ata/sata_mv.c:			dev_warn(&pdev->dev,
drivers/ata/sata_mv.c:		switch (pdev->revision) {
drivers/ata/sata_mv.c:			dev_warn(&pdev->dev,
drivers/ata/sata_mv.c:		if (pdev->vendor == PCI_VENDOR_ID_TTI &&
drivers/ata/sata_mv.c:		    (pdev->device == 0x2300 || pdev->device == 0x2310))
drivers/ata/sata_mv.c:		switch (pdev->revision) {
drivers/ata/sata_mv.c:			dev_warn(&pdev->dev,
drivers/ata/sata_mv.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_mv.c:	if (unlikely(pdev->num_resources != 2)) {
drivers/ata/sata_mv.c:		dev_err(&pdev->dev, "invalid number of resources\n");
drivers/ata/sata_mv.c:	if (pdev->dev.of_node) {
drivers/ata/sata_mv.c:		of_property_read_u32(pdev->dev.of_node, "nr-ports", &n_ports);
drivers/ata/sata_mv.c:		irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
drivers/ata/sata_mv.c:		mv_platform_data = pdev->dev.platform_data;
drivers/ata/sata_mv.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
drivers/ata/sata_mv.c:	hpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);
drivers/ata/sata_mv.c:	hpriv->port_clks = devm_kzalloc(&pdev->dev,
drivers/ata/sata_mv.c:	hpriv->base = devm_ioremap(&pdev->dev, res->start,
drivers/ata/sata_mv.c:	hpriv->clk = clk_get(&pdev->dev, NULL);
drivers/ata/sata_mv.c:		dev_notice(&pdev->dev, "cannot get optional clkdev\n");
drivers/ata/sata_mv.c:		hpriv->port_clks[port] = clk_get(&pdev->dev, port_number);
drivers/ata/sata_mv.c:	rc = mv_create_dma_pools(hpriv, &pdev->dev);
drivers/ata/sata_mv.c:	if (pdev->dev.of_node &&
drivers/ata/sata_mv.c:		of_device_is_compatible(pdev->dev.of_node,
drivers/ata/sata_mv.c:	dev_info(&pdev->dev, "slots %u ports %d\n",
drivers/ata/sata_mv.c:				dev_err(&pdev->dev,
drivers/ata/sata_mv.c:			dev_err(&pdev->dev, "32-bit DMA enable failed\n");
drivers/ata/sata_mv.c:			dev_err(&pdev->dev,
drivers/ata/sata_mv.c:	dev_info(&pdev->dev, "Gen-%s %u slots %u ports %s mode IRQ via %s\n",
drivers/ata/sata_mv.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_mv.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
drivers/ata/sata_mv.c:	hpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);
drivers/ata/sata_mv.c:	rc = mv_create_dma_pools(hpriv, &pdev->dev);
drivers/ata/sata_mv.c:	return ata_host_activate(host, pdev->irq, mv_interrupt, IRQF_SHARED,
drivers/ata/sata_via.c:		WARN_ON(pdev->device != 0x5287);
drivers/ata/sata_via.c:		WARN_ON(pdev->device != 0x5287);
drivers/ata/sata_via.c:		dev_err(&pdev->dev, "failed to iomap PCI BAR 5\n");
drivers/ata/sata_via.c:	*r_host = host = ata_host_alloc_pinfo(&pdev->dev, ppi, ARRAY_SIZE(ppi));
drivers/ata/sata_via.c:		dev_err(&pdev->dev, "failed to allocate host\n");
drivers/ata/sata_via.c:		dev_err(&pdev->dev, "failed to request/iomap PCI BARs (errno=%d)\n",
drivers/ata/sata_via.c:		dev_err(&pdev->dev, "failed to iomap PCI BAR 5\n");
drivers/ata/sata_via.c:	dev_info(&pdev->dev, "routed to hard irq line %d\n",
drivers/ata/sata_via.c:		dev_dbg(&pdev->dev, "enabling SATA channels (0x%x)\n",
drivers/ata/sata_via.c:		dev_dbg(&pdev->dev, "enabling SATA channel interrupts (0x%x)\n",
drivers/ata/sata_via.c:		dev_dbg(&pdev->dev,
drivers/ata/sata_via.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_via.c:			dev_err(&pdev->dev,
drivers/ata/sata_via.c:	return ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,
drivers/ata/pata_atp867x.c:	   (pdev->device == PCI_DEVICE_ID_ARTOP_ATP867B ||
drivers/ata/pata_atp867x.c:	if (pdev->subsystem_vendor == PCI_VENDOR_ID_ARTOP &&
drivers/ata/pata_atp867x.c:		(pdev->subsystem_device == PCI_DEVICE_ID_ARTOP_ATP867A ||
drivers/ata/pata_atp867x.c:		 pdev->subsystem_device == PCI_DEVICE_ID_ARTOP_ATP867B)) {
drivers/ata/pata_atp867x.c:		devm_kzalloc(&pdev->dev, sizeof(*dp), GFP_KERNEL);
drivers/ata/pata_atp867x.c:	if (pdev->device == PCI_DEVICE_ID_ARTOP_ATP867B)
drivers/ata/pata_atp867x.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_atp867x.c:		pdev->device);
drivers/ata/pata_atp867x.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, ATP867X_NUM_PORTS);
drivers/ata/pata_atp867x.c:		dev_err(&pdev->dev, "failed to allocate ATA host\n");
drivers/ata/pata_atp867x.c:		dev_err(&pdev->dev, "failed to init host\n");
drivers/ata/pata_atp867x.c:	rc = ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,
drivers/ata/pata_atp867x.c:		dev_err(&pdev->dev, "failed to activate host\n");
drivers/ata/pata_atp867x.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_bf54x.c:	if (unlikely(pdev->num_resources != 2)) {
drivers/ata/pata_bf54x.c:		dev_err(&pdev->dev, "invalid number of resources\n");
drivers/ata/pata_bf54x.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, 1);
drivers/ata/pata_bf54x.c:		dev_err(&pdev->dev, "Requesting Peripherals failed\n");
drivers/ata/pata_bf54x.c:		dev_err(&pdev->dev, "Fail to reset ATAPI device\n");
drivers/ata/pata_bf54x.c:		dev_err(&pdev->dev, "Fail to attach ATAPI device\n");
drivers/ata/pata_bf54x.c:	dev_set_drvdata(&pdev->dev, host);
drivers/ata/pata_bf54x.c:	struct device *dev = &pdev->dev;
drivers/ata/pata_bf54x.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/ata/pata_bf54x.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_bf54x.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_sil680.c:			      pdev->revision ? 1 : 255);
drivers/ata/pata_sil680.c:	dev_dbg(&pdev->dev, "sil680: BA5_EN = %d clock = %02X\n",
drivers/ata/pata_sil680.c:	dev_dbg(&pdev->dev, "sil680: BA5_EN = %d clock = %02X\n",
drivers/ata/pata_sil680.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_sil680.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);
drivers/ata/pata_sil680.c:	return ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,
drivers/ata/pata_sil680.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_at32.c:	struct device		 *dev = &pdev->dev;
drivers/ata/pata_at32.c:	struct ide_platform_data *board = pdev->dev.platform_data;
drivers/ata/pata_ep93xx.c:		dev_err(&pdev->dev, "failed to configure rx dma channel\n");
drivers/ata/pata_ep93xx.c:		dev_err(&pdev->dev, "failed to configure tx dma channel\n");
drivers/ata/pata_ep93xx.c:	ide_base = devm_ioremap_resource(&pdev->dev, mem_res);
drivers/ata/pata_ep93xx.c:	drv_data = devm_kzalloc(&pdev->dev, sizeof(*drv_data), GFP_KERNEL);
drivers/ata/pata_ep93xx.c:	host = ata_host_alloc(&pdev->dev, 1);
drivers/ata/pata_ep93xx.c:	ap->dev = &pdev->dev;
drivers/ata/pata_ep93xx.c:	dev_info(&pdev->dev, "version " DRV_VERSION "\n");
drivers/ata/pata_rb532_cf.c:		dev_err(&pdev->dev, "no IOMEM resource found\n");
drivers/ata/pata_rb532_cf.c:		dev_err(&pdev->dev, "no IRQ resource found\n");
drivers/ata/pata_rb532_cf.c:		dev_err(&pdev->dev, "no GPIO found for irq%d\n", irq);
drivers/ata/pata_rb532_cf.c:		dev_err(&pdev->dev, "GPIO request failed\n");
drivers/ata/pata_rb532_cf.c:	ah = ata_host_alloc(&pdev->dev, RB500_CF_MAXPORTS);
drivers/ata/pata_rb532_cf.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
drivers/ata/pata_rb532_cf.c:	info->iobase = devm_ioremap_nocache(&pdev->dev, res->start,
drivers/ata/pata_rb532_cf.c:		dev_err(&pdev->dev, "unable to set GPIO direction, err=%d\n",
drivers/ata/sata_qstor.c:				dev_err(&pdev->dev,
drivers/ata/sata_qstor.c:			dev_err(&pdev->dev, "32-bit DMA enable failed\n");
drivers/ata/sata_qstor.c:			dev_err(&pdev->dev,
drivers/ata/sata_qstor.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_qstor.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, QS_PORTS);
drivers/ata/sata_qstor.c:	return ata_host_activate(host, pdev->irq, qs_intr, IRQF_SHARED,
drivers/ata/pata_cmd64x.c:	struct pci_dev *bridge = pdev->bus->self;
drivers/ata/pata_cmd64x.c:	if (pdev->device == PCI_DEVICE_ID_CMD_646)
drivers/ata/pata_cmd64x.c:		switch (pdev->revision) {
drivers/ata/pata_cmd64x.c:		dev_notice(&pdev->dev, "Mobility Bridge detected, ignoring CNTRL port enable/disable\n");
drivers/ata/pata_cmd64x.c:		dev_notice(&pdev->dev, "Primary port is disabled\n");
drivers/ata/pata_cmd64x.c:		dev_notice(&pdev->dev, "Secondary port is disabled\n");
drivers/ata/pata_cmd64x.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_netcell.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_promise.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_promise.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
drivers/ata/sata_promise.c:		dev_err(&pdev->dev, "failed to allocate host\n");
drivers/ata/sata_promise.c:	hpriv = devm_kzalloc(&pdev->dev, sizeof *hpriv, GFP_KERNEL);
drivers/ata/sata_promise.c:	return ata_host_activate(host, pdev->irq, pdc_interrupt, IRQF_SHARED,
drivers/ata/libata-sff.c:	if (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL))
drivers/ata/libata-sff.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);
drivers/ata/libata-sff.c:		dev_err(&pdev->dev, "failed to allocate ATA host\n");
drivers/ata/libata-sff.c:	devres_remove_group(&pdev->dev, NULL);
drivers/ata/libata-sff.c:	devres_release_group(&pdev->dev, NULL);
drivers/ata/libata-sff.c:	if ((pdev->class >> 8) == PCI_CLASS_STORAGE_IDE) {
drivers/ata/libata-sff.c:	if (!legacy_mode && pdev->irq) {
drivers/ata/libata-sff.c:		rc = devm_request_irq(dev, pdev->irq, irq_handler,
drivers/ata/libata-sff.c:			ata_port_desc(host->ports[i], "irq %d", pdev->irq);
drivers/ata/libata-sff.c:	struct device *dev = &pdev->dev;
drivers/ata/libata-sff.c:		dev_err(&pdev->dev, "no valid port_info specified\n");
drivers/ata/libata-sff.c:		devres_remove_group(&pdev->dev, NULL);
drivers/ata/libata-sff.c:		devres_release_group(&pdev->dev, NULL);
drivers/ata/pata_pcmcia.c:	if ((pdev->resource[0]->flags & IO_DATA_PATH_WIDTH)
drivers/ata/pata_pcmcia.c:		pdev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;
drivers/ata/pata_pcmcia.c:		pdev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;
drivers/ata/pata_pcmcia.c:	pdev->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;
drivers/ata/pata_pcmcia.c:	pdev->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;
drivers/ata/pata_pcmcia.c:	if (pdev->resource[1]->end) {
drivers/ata/pata_pcmcia.c:		pdev->resource[0]->end = 8;
drivers/ata/pata_pcmcia.c:		pdev->resource[1]->end = (*is_kme) ? 2 : 1;
drivers/ata/pata_pcmcia.c:		if (pdev->resource[0]->end < 16)
drivers/ata/pata_pcmcia.c:	pdev->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO |
drivers/ata/pata_pcmcia.c:	is_kme = ((pdev->manf_id == MANFID_KME) &&
drivers/ata/pata_pcmcia.c:		  ((pdev->card_id == PRODID_KME_KXLC005_A) ||
drivers/ata/pata_pcmcia.c:		   (pdev->card_id == PRODID_KME_KXLC005_B)));
drivers/ata/pata_pcmcia.c:		pdev->config_flags &= ~CONF_AUTO_CHECK_VCC;
drivers/ata/pata_pcmcia.c:	io_base = pdev->resource[0]->start;
drivers/ata/pata_pcmcia.c:	if (pdev->resource[1]->end)
drivers/ata/pata_pcmcia.c:		ctl_base = pdev->resource[1]->start;
drivers/ata/pata_pcmcia.c:		ctl_base = pdev->resource[0]->start + 0x0e;
drivers/ata/pata_pcmcia.c:	if (!pdev->irq)
drivers/ata/pata_pcmcia.c:	io_addr = devm_ioport_map(&pdev->dev, io_base, 8);
drivers/ata/pata_pcmcia.c:	ctl_addr = devm_ioport_map(&pdev->dev, ctl_base, 1);
drivers/ata/pata_pcmcia.c:	if (resource_size(pdev->resource[0]) >= 0x20)
drivers/ata/pata_pcmcia.c:	if (pdev->manf_id == 0x0097 && pdev->card_id == 0x1620)
drivers/ata/pata_pcmcia.c:	host = ata_host_alloc(&pdev->dev, n_ports);
drivers/ata/pata_pcmcia.c:	ret = ata_host_activate(host, pdev->irq, ata_sff_interrupt,
drivers/ata/pata_pcmcia.c:	pdev->priv = host;
drivers/ata/pata_pcmcia.c:	struct ata_host *host = pdev->priv;
drivers/ata/pata_palmld.c:	host = ata_host_alloc(&pdev->dev, 1);
drivers/ata/pata_palmld.c:	mem = devm_ioremap(&pdev->dev, PALMLD_IDE_PHYS, 0x1000);
drivers/ata/pata_ninja32.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_it821x.c:	itdev = devm_kzalloc(&pdev->dev, sizeof(struct it821x_dev), GFP_KERNEL);
drivers/ata/pata_it821x.c:	if (pdev->revision == 0x10) {
drivers/ata/pata_it821x.c:	if (pdev->vendor != PCI_VENDOR_ID_ITE ||
drivers/ata/pata_it821x.c:			pdev->device != PCI_DEVICE_ID_ITE_8212)
drivers/ata/pata_it821x.c:	if (pdev->vendor == PCI_VENDOR_ID_RDC) {
drivers/ata/pata_it821x.c:		if (pdev->revision == 0x11)
drivers/ata/pata_it821x.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_it8213.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_serverworks.c:	if (pdev->subsystem_device & (1 << (ap->port_no + 14)))
drivers/ata/pata_serverworks.c:		if (cb->device == pdev->device &&
drivers/ata/pata_serverworks.c:		    (cb->subvendor == pdev->subsystem_vendor ||
drivers/ata/pata_serverworks.c:	switch (pdev->device) {
drivers/ata/pata_serverworks.c:	if (!(PCI_FUNC(pdev->devfn) & 1)) {
drivers/ata/pata_serverworks.c:	if (!(PCI_FUNC(pdev->devfn) & 1))
drivers/ata/pata_serverworks.c:		btr |= (pdev->revision >= SVWKS_CSB5_REVISION_NEW) ? 0x3 : 0x2;
drivers/ata/pata_serverworks.c:	switch (pdev->device) {
drivers/ata/pata_serverworks.c:	if (pdev->device == PCI_DEVICE_ID_SERVERWORKS_OSB4IDE) {
drivers/ata/pata_serverworks.c:	else if ((pdev->device == PCI_DEVICE_ID_SERVERWORKS_CSB5IDE) ||
drivers/ata/pata_serverworks.c:		 (pdev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE) ||
drivers/ata/pata_serverworks.c:		 (pdev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2)) {
drivers/ata/pata_serverworks.c:		if (pdev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2)
drivers/ata/pata_serverworks.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_cmd640.c:	timing = devm_kzalloc(&pdev->dev, sizeof(struct cmd640_reg), GFP_KERNEL);
drivers/ata/pata_cmd640.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/sata_sil24.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_sil24.c:			dev_info(&pdev->dev,
drivers/ata/sata_sil24.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi,
drivers/ata/sata_sil24.c:				dev_err(&pdev->dev,
drivers/ata/sata_sil24.c:			dev_err(&pdev->dev, "32-bit DMA enable failed\n");
drivers/ata/sata_sil24.c:			dev_err(&pdev->dev,
drivers/ata/sata_sil24.c:		dev_info(&pdev->dev, "Using MSI\n");
drivers/ata/sata_sil24.c:	return ata_host_activate(host, pdev->irq, sil24_interrupt, IRQF_SHARED,
drivers/ata/sata_sil24.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/sata_sil24.c:	if (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND)
drivers/ata/acard-ahci.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/acard-ahci.c:		dev_err(&pdev->dev,
drivers/ata/acard-ahci.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/acard-ahci.c:	if (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {
drivers/ata/acard-ahci.c:				dev_err(&pdev->dev,
drivers/ata/acard-ahci.c:			dev_err(&pdev->dev, "32-bit DMA enable failed\n");
drivers/ata/acard-ahci.c:			dev_err(&pdev->dev,
drivers/ata/acard-ahci.c:	struct device *dev = &pdev->dev;
drivers/ata/acard-ahci.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/acard-ahci.c:	ahci_save_initial_config(&pdev->dev, hpriv, 0, 0);
drivers/ata/acard-ahci.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
drivers/ata/acard-ahci.c:	return ata_host_activate(host, pdev->irq, ahci_interrupt, IRQF_SHARED,
drivers/ata/pata_octeon_cf.c:	node = pdev->dev.of_node;
drivers/ata/pata_octeon_cf.c:				cf_port->dma_base = (u64)devm_ioremap_nocache(&pdev->dev, res_dma->start,
drivers/ata/pata_octeon_cf.c:		cs1 = devm_ioremap_nocache(&pdev->dev, res_cs1->start,
drivers/ata/pata_octeon_cf.c:	cs0 = devm_ioremap_nocache(&pdev->dev, res_cs0->start,
drivers/ata/pata_octeon_cf.c:	host = ata_host_alloc(&pdev->dev, 1);
drivers/ata/pata_octeon_cf.c:	pdev->dev.platform_data = cf_port;
drivers/ata/pata_octeon_cf.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(64);
drivers/ata/pata_octeon_cf.c:	pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/ata/pata_octeon_cf.c:	dev_info(&pdev->dev, "version " DRV_VERSION" %d bit%s.\n",
drivers/ata/sata_sil.c:		dev_warn(&pdev->dev,
drivers/ata/sata_sil.c:				dev_info(&pdev->dev,
drivers/ata/sata_sil.c:		return slot == PCI_SLOT(pdev->devfn);
drivers/ata/sata_sil.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_sil.c:		dev_info(&pdev->dev, "quirky BIOS, skipping spindown "
drivers/ata/sata_sil.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
drivers/ata/sata_sil.c:	return ata_host_activate(host, pdev->irq, sil_interrupt, IRQF_SHARED,
drivers/ata/sata_sil.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_acpi.c:	acpi = ap->private_data = devm_kzalloc(&pdev->dev, sizeof(struct pata_acpi), GFP_KERNEL);
drivers/ata/pata_acpi.c:	if (pdev->vendor == PCI_VENDOR_ID_ATI) {
drivers/ata/pata_sch.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_hpt3x3.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_hpt3x3.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);
drivers/ata/pata_hpt3x3.c:	return ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,
drivers/ata/pata_pdc2027x.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_pdc2027x.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);
drivers/ata/pata_pdc2027x.c:	return ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,
drivers/ata/pata_pdc2027x.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_pdc2027x.c:	if (pdev->device == PCI_DEVICE_ID_PROMISE_20268 ||
drivers/ata/pata_pdc2027x.c:	    pdev->device == PCI_DEVICE_ID_PROMISE_20270)
drivers/ata/sata_inic162x.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/sata_inic162x.c:	if (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {
drivers/ata/sata_inic162x.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_inic162x.c:	dev_alert(&pdev->dev, "inic162x support is broken with common data corruption issues and will be disabled by default, contact linux-ide@vger.kernel.org if in production use\n");
drivers/ata/sata_inic162x.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, NR_PORTS);
drivers/ata/sata_inic162x.c:	hpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);
drivers/ata/sata_inic162x.c:		dev_err(&pdev->dev, "32-bit DMA enable failed\n");
drivers/ata/sata_inic162x.c:		dev_err(&pdev->dev, "32-bit consistent DMA enable failed\n");
drivers/ata/sata_inic162x.c:		dev_err(&pdev->dev, "failed to set the maximum segment size\n");
drivers/ata/sata_inic162x.c:		dev_err(&pdev->dev, "failed to initialize controller\n");
drivers/ata/sata_inic162x.c:	return ata_host_activate(host, pdev->irq, inic_interrupt, IRQF_SHARED,
drivers/ata/pata_at91.c:	struct at91_cf_data *board = pdev->dev.platform_data;
drivers/ata/pata_at91.c:	struct device *dev = &pdev->dev;
drivers/ata/pata_at91.c:	if (pdev->num_resources != 1) {
drivers/ata/pata_at91.c:		dev_err(&pdev->dev, "invalid number of resources\n");
drivers/ata/pata_at91.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/sata_uli.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_uli.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
drivers/ata/sata_uli.c:	hpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);
drivers/ata/sata_uli.c:	return ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,
drivers/ata/pdc_adma.c:		dev_err(&pdev->dev, "32-bit DMA enable failed\n");
drivers/ata/pdc_adma.c:		dev_err(&pdev->dev, "32-bit consistent DMA enable failed\n");
drivers/ata/pdc_adma.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pdc_adma.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, ADMA_PORTS);
drivers/ata/pdc_adma.c:	return ata_host_activate(host, pdev->irq, adma_intr, IRQF_SHARED,
drivers/ata/pata_sl82c105.c:	bridge = pci_get_slot(pdev->bus,
drivers/ata/pata_sl82c105.c:			       PCI_DEVFN(PCI_SLOT(pdev->devfn), 0));
drivers/ata/pata_sl82c105.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/libata-core.c:		dev_err(&pdev->dev,
drivers/ata/ahci_platform.c:	struct device *dev = &pdev->dev;
drivers/ata/pata_artop.c:	if ((pdev->device & 1) &&
drivers/ata/pata_artop.c:	if (pdev->device == 0x0005)
drivers/ata/pata_artop.c:	else if (pdev->device == 0x0008 || pdev->device == 0x0009) {
drivers/ata/pata_artop.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/pata_artop.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/ata_piix.c:		if (lap->device == pdev->device &&
drivers/ata/ata_piix.c:		    lap->subvendor == pdev->subsystem_vendor &&
drivers/ata/ata_piix.c:		    lap->subdevice == pdev->subsystem_device)
drivers/ata/ata_piix.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/ata_piix.c:		if (pdev->current_state == PCI_D0)
drivers/ata/ata_piix.c:			pdev->current_state = PCI_UNKNOWN;
drivers/ata/ata_piix.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/ata_piix.c:			dev_err(&pdev->dev,
drivers/ata/ata_piix.c:		if (pdev->revision == 0x00)
drivers/ata/ata_piix.c:		else if (cfg & (1<<14) && pdev->revision < 5)
drivers/ata/ata_piix.c:	dev_info(&pdev->dev, "MAP [");
drivers/ata/ata_piix.c:		dev_err(&pdev->dev, "invalid MAP value %u\n", map_value);
drivers/ata/ata_piix.c:	if (pdev->vendor == PCI_VENDOR_ID_INTEL && pdev->device == 0x2920 &&
drivers/ata/ata_piix.c:	    pdev->subsystem_vendor == PCI_VENDOR_ID_SAMSUNG &&
drivers/ata/ata_piix.c:	    pdev->subsystem_device == 0xb049) {
drivers/ata/ata_piix.c:		dev_info(&pdev->dev, "applying IOCFG bit18 quirk\n");
drivers/ata/ata_piix.c:		return slot == PCI_SLOT(pdev->devfn);
drivers/ata/ata_piix.c:	struct device *dev = &pdev->dev;
drivers/ata/ata_piix.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/ata_piix.c:		dev_info(&pdev->dev, "quirky BIOS, skipping spindown "
drivers/ata/ata_piix.c:	if (pdev->vendor == PCI_VENDOR_ID_INTEL && pdev->device == 0x2652) {
drivers/ata/ata_piix.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/pata_ali.c:	if (pdev->subsystem_vendor == 0x10CF && pdev->subsystem_device == 0x10AF)
drivers/ata/pata_ali.c:	if (pdev->subsystem_vendor == 0x1071 && pdev->subsystem_device == 0x8317)
drivers/ata/pata_ali.c:	if (pdev->revision <= 0x20) {
drivers/ata/pata_ali.c:		if (pdev->revision < 0xC2)
drivers/ata/pata_ali.c:		if (pdev->revision >= 0xc2)
drivers/ata/pata_ali.c:		if (pdev->revision >= 0xc7)
drivers/ata/pata_ali.c:		if (pdev->revision == 0xC2)
drivers/ata/pata_ali.c:		else if (pdev->revision > 0xC2 && pdev->revision < 0xC5)
drivers/ata/pata_ali.c:	if (pdev->revision < 0x20) {
drivers/ata/pata_ali.c:	} else if (pdev->revision < 0xC2) {
drivers/ata/pata_ali.c:	} else if (pdev->revision == 0xC2) {
drivers/ata/pata_ali.c:	} else if (pdev->revision == 0xC3) {
drivers/ata/pata_ali.c:	} else if (pdev->revision == 0xC4) {
drivers/ata/pata_ali.c:	if (ali_isa_bridge && pdev->revision >= 0x20 && pdev->revision < 0xC2) {
drivers/ata/pata_ali.c:	struct ata_host *host = dev_get_drvdata(&pdev->dev);
drivers/ata/sata_highbank.c:	struct device *dev = &pdev->dev;
drivers/ata/sata_svw.c:	ata_print_version_once(&pdev->dev, DRV_VERSION);
drivers/ata/sata_svw.c:	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
drivers/ata/sata_svw.c:	return ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,
drivers/uio/uio_aec.c:	dev_info(&pdev->dev, "PCI-TC board vendor: %x%x number: %x%x"
drivers/uio/uio_aec.c:	info->irq = pdev->irq;
drivers/uio/uio_aec.c:	ret = uio_register_device(&pdev->dev, info);
drivers/uio/uio_aec.c:		dev_err(&pdev->dev, "aectc: interrupts not enabled\n");
drivers/uio/uio_pdrv_genirq.c:	pm_runtime_get_sync(&priv->pdev->dev);
drivers/uio/uio_pdrv_genirq.c:	pm_runtime_put_sync(&priv->pdev->dev);
drivers/uio/uio_pdrv_genirq.c:	struct uio_info *uioinfo = pdev->dev.platform_data;
drivers/uio/uio_pdrv_genirq.c:	if (pdev->dev.of_node) {
drivers/uio/uio_pdrv_genirq.c:			dev_err(&pdev->dev, "unable to kmalloc\n");
drivers/uio/uio_pdrv_genirq.c:		uioinfo->name = pdev->dev.of_node->name;
drivers/uio/uio_pdrv_genirq.c:		dev_err(&pdev->dev, "missing platform_data\n");
drivers/uio/uio_pdrv_genirq.c:		dev_err(&pdev->dev, "interrupt configuration error\n");
drivers/uio/uio_pdrv_genirq.c:		dev_err(&pdev->dev, "unable to kmalloc\n");
drivers/uio/uio_pdrv_genirq.c:			dev_err(&pdev->dev, "failed to get IRQ\n");
drivers/uio/uio_pdrv_genirq.c:	for (i = 0; i < pdev->num_resources; ++i) {
drivers/uio/uio_pdrv_genirq.c:		struct resource *r = &pdev->resource[i];
drivers/uio/uio_pdrv_genirq.c:			dev_warn(&pdev->dev, "device has more than "
drivers/uio/uio_pdrv_genirq.c:	pm_runtime_enable(&pdev->dev);
drivers/uio/uio_pdrv_genirq.c:	ret = uio_register_device(&pdev->dev, priv->uioinfo);
drivers/uio/uio_pdrv_genirq.c:		dev_err(&pdev->dev, "unable to register uio device\n");
drivers/uio/uio_pdrv_genirq.c:	pm_runtime_disable(&pdev->dev);
drivers/uio/uio_pdrv_genirq.c:	if (pdev->dev.of_node)
drivers/uio/uio_pdrv_genirq.c:	pm_runtime_disable(&pdev->dev);
drivers/uio/uio_pdrv_genirq.c:	if (pdev->dev.of_node)
drivers/uio/uio_pdrv.c:	struct uio_info *uioinfo = pdev->dev.platform_data;
drivers/uio/uio_pdrv.c:		dev_dbg(&pdev->dev, "%s: err_uioinfo\n", __func__);
drivers/uio/uio_pdrv.c:		dev_dbg(&pdev->dev, "%s: err_alloc_pdata\n", __func__);
drivers/uio/uio_pdrv.c:	for (i = 0; i < pdev->num_resources; ++i) {
drivers/uio/uio_pdrv.c:		struct resource *r = &pdev->resource[i];
drivers/uio/uio_pdrv.c:			dev_warn(&pdev->dev, "device has more than "
drivers/uio/uio_pdrv.c:	ret = uio_register_device(&pdev->dev, pdata->uioinfo);
drivers/uio/uio_pci_generic.c:		dev_err(&pdev->dev, "%s: pci_enable_device failed: %d\n",
drivers/uio/uio_pci_generic.c:	if (!pdev->irq) {
drivers/uio/uio_pci_generic.c:		dev_warn(&pdev->dev, "No IRQ assigned to device: "
drivers/uio/uio_pci_generic.c:	gdev->info.irq = pdev->irq;
drivers/uio/uio_pci_generic.c:	if (uio_register_device(&pdev->dev, &gdev->info))
drivers/uio/uio_dmem_genirq.c:		addr = dma_alloc_coherent(&priv->pdev->dev, uiomem->size,
drivers/uio/uio_dmem_genirq.c:	pm_runtime_get_sync(&priv->pdev->dev);
drivers/uio/uio_dmem_genirq.c:	pm_runtime_put_sync(&priv->pdev->dev);
drivers/uio/uio_dmem_genirq.c:			dma_free_coherent(&priv->pdev->dev, uiomem->size,
drivers/uio/uio_dmem_genirq.c:	struct uio_dmem_genirq_pdata *pdata = pdev->dev.platform_data;
drivers/uio/uio_dmem_genirq.c:	if (pdev->dev.of_node) {
drivers/uio/uio_dmem_genirq.c:			dev_err(&pdev->dev, "unable to kmalloc\n");
drivers/uio/uio_dmem_genirq.c:		uioinfo->name = pdev->dev.of_node->name;
drivers/uio/uio_dmem_genirq.c:		dev_err(&pdev->dev, "missing platform_data\n");
drivers/uio/uio_dmem_genirq.c:		dev_err(&pdev->dev, "interrupt configuration error\n");
drivers/uio/uio_dmem_genirq.c:		dev_err(&pdev->dev, "unable to kmalloc\n");
drivers/uio/uio_dmem_genirq.c:	dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
drivers/uio/uio_dmem_genirq.c:			dev_err(&pdev->dev, "failed to get IRQ\n");
drivers/uio/uio_dmem_genirq.c:	for (i = 0; i < pdev->num_resources; ++i) {
drivers/uio/uio_dmem_genirq.c:		struct resource *r = &pdev->resource[i];
drivers/uio/uio_dmem_genirq.c:			dev_warn(&pdev->dev, "device has more than "
drivers/uio/uio_dmem_genirq.c:			dev_warn(&pdev->dev, "device has more than "
drivers/uio/uio_dmem_genirq.c:	pm_runtime_enable(&pdev->dev);
drivers/uio/uio_dmem_genirq.c:	ret = uio_register_device(&pdev->dev, priv->uioinfo);
drivers/uio/uio_dmem_genirq.c:		dev_err(&pdev->dev, "unable to register uio device\n");
drivers/uio/uio_dmem_genirq.c:	pm_runtime_disable(&pdev->dev);
drivers/uio/uio_dmem_genirq.c:	if (pdev->dev.of_node)
drivers/uio/uio_dmem_genirq.c:	pm_runtime_disable(&pdev->dev);
drivers/uio/uio_dmem_genirq.c:	if (pdev->dev.of_node)
drivers/mfd/htc-egpio.c:	struct htc_egpio_platform_data *pdata = pdev->dev.platform_data;
drivers/mfd/htc-egpio.c:		ei->chip[i].dev = &(pdev->dev);
drivers/mfd/htc-egpio.c:		chip->dev             = &pdev->dev;
drivers/mfd/htc-egpio.c:		device_init_wakeup(&pdev->dev, 1);
drivers/mfd/htc-egpio.c:		device_init_wakeup(&pdev->dev, 0);
drivers/mfd/htc-egpio.c:	if (ei->chained_irq && device_may_wakeup(&pdev->dev))
drivers/mfd/htc-egpio.c:	if (ei->chained_irq && device_may_wakeup(&pdev->dev))
drivers/mfd/ti_am335x_tscadc.c:	struct mfd_tscadc_board	*pdata = pdev->dev.platform_data;
drivers/mfd/ti_am335x_tscadc.c:		dev_err(&pdev->dev, "Could not find platform data\n");
drivers/mfd/ti_am335x_tscadc.c:		dev_err(&pdev->dev, "Number of i/p channels more than 8\n");
drivers/mfd/ti_am335x_tscadc.c:		dev_err(&pdev->dev, "no memory resource defined.\n");
drivers/mfd/ti_am335x_tscadc.c:	tscadc = devm_kzalloc(&pdev->dev,
drivers/mfd/ti_am335x_tscadc.c:		dev_err(&pdev->dev, "failed to allocate memory.\n");
drivers/mfd/ti_am335x_tscadc.c:	tscadc->dev = &pdev->dev;
drivers/mfd/ti_am335x_tscadc.c:		dev_err(&pdev->dev, "no irq ID is specified.\n");
drivers/mfd/ti_am335x_tscadc.c:	res = devm_request_mem_region(&pdev->dev,
drivers/mfd/ti_am335x_tscadc.c:			res->start, resource_size(res), pdev->name);
drivers/mfd/ti_am335x_tscadc.c:		dev_err(&pdev->dev, "failed to reserve registers.\n");
drivers/mfd/ti_am335x_tscadc.c:	tscadc->tscadc_base = devm_ioremap(&pdev->dev,
drivers/mfd/ti_am335x_tscadc.c:		dev_err(&pdev->dev, "failed to map registers.\n");
drivers/mfd/ti_am335x_tscadc.c:	tscadc->regmap_tscadc = devm_regmap_init_mmio(&pdev->dev,
drivers/mfd/ti_am335x_tscadc.c:		dev_err(&pdev->dev, "regmap init failed\n");
drivers/mfd/ti_am335x_tscadc.c:	pm_runtime_enable(&pdev->dev);
drivers/mfd/ti_am335x_tscadc.c:	pm_runtime_get_sync(&pdev->dev);
drivers/mfd/ti_am335x_tscadc.c:	clk = clk_get(&pdev->dev, "adc_tsc_fck");
drivers/mfd/ti_am335x_tscadc.c:		dev_err(&pdev->dev, "failed to get TSC fck\n");
drivers/mfd/ti_am335x_tscadc.c:		dev_err(&pdev->dev, "clock input less than min clock requirement\n");
drivers/mfd/ti_am335x_tscadc.c:	err = mfd_add_devices(&pdev->dev, pdev->id, tscadc->cells,
drivers/mfd/ti_am335x_tscadc.c:	device_init_wakeup(&pdev->dev, true);
drivers/mfd/ti_am335x_tscadc.c:	pm_runtime_put_sync(&pdev->dev);
drivers/mfd/ti_am335x_tscadc.c:	pm_runtime_disable(&pdev->dev);
drivers/mfd/ti_am335x_tscadc.c:	pm_runtime_put_sync(&pdev->dev);
drivers/mfd/ti_am335x_tscadc.c:	pm_runtime_disable(&pdev->dev);
drivers/mfd/mfd-core.c:	pdev->mfd_cell = kmemdup(cell, sizeof(*cell), GFP_KERNEL);
drivers/mfd/mfd-core.c:	if (!pdev->mfd_cell)
drivers/mfd/mfd-core.c:	pdev->dev.parent = parent;
drivers/mfd/mfd-core.c:	pdev->dev.type = &mfd_dev_type;
drivers/mfd/mfd-core.c:				pdev->dev.of_node = np;
drivers/mfd/mfd-core.c:		pm_runtime_no_callbacks(&pdev->dev);
drivers/mfd/mfd-core.c:		if (mfd_add_device(pdev->dev.parent, -1, &cell_entry, NULL, 0,
drivers/mfd/twl-core.c:	pdev->dev.parent = &twl->client->dev;
drivers/mfd/twl-core.c:			dev_dbg(&pdev->dev, "can't add platform_data\n");
drivers/mfd/twl-core.c:			dev_dbg(&pdev->dev, "can't add irqs\n");
drivers/mfd/twl-core.c:		device_init_wakeup(&pdev->dev, can_wakeup);
drivers/mfd/twl-core.c:	return &pdev->dev;
drivers/mfd/twl-core.c:	clocks_init(&pdev->dev, pdata ? pdata->clock : NULL);
drivers/mfd/ab8500-core.c:	struct ab8500_platform_data *plat = dev_get_platdata(&pdev->dev);
drivers/mfd/ab8500-core.c:	struct device_node *np = pdev->dev.of_node;
drivers/mfd/ab8500-core.c:	ab8500 = devm_kzalloc(&pdev->dev, sizeof *ab8500, GFP_KERNEL);
drivers/mfd/ab8500-core.c:	ab8500->dev = &pdev->dev;
drivers/mfd/ab8500-core.c:	ab8500->mask = devm_kzalloc(&pdev->dev, ab8500->mask_size, GFP_KERNEL);
drivers/mfd/ab8500-core.c:	ab8500->oldmask = devm_kzalloc(&pdev->dev, ab8500->mask_size, GFP_KERNEL);
drivers/mfd/ab8500-core.c:	ret = devm_request_threaded_irq(&pdev->dev, ab8500->irq, NULL,
drivers/mfd/asic3.c:	struct asic3 *asic = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/asic3.c:	struct asic3 *asic = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/asic3.c:	struct asic3 *asic = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/asic3.c:	struct asic3 *asic = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/asic3.c:	struct asic3 *asic = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/asic3.c:	struct asic3 *asic = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/asic3.c:	struct asic3 *asic = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/asic3.c:	struct asic3 *asic = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/asic3.c:	struct asic3 *asic = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/asic3.c:		ret = mfd_add_devices(&pdev->dev, pdev->id,
drivers/mfd/asic3.c:		ret = mfd_add_devices(&pdev->dev, pdev->id,
drivers/mfd/asic3.c:		ret = mfd_add_devices(&pdev->dev, 0,
drivers/mfd/asic3.c:	mfd_remove_devices(&pdev->dev);
drivers/mfd/asic3.c:	struct asic3_platform_data *pdata = pdev->dev.platform_data;
drivers/mfd/asic3.c:	asic->dev = &pdev->dev;
drivers/mfd/vx855.c:		dev_warn(&pdev->dev,
drivers/mfd/vx855.c:	ret = mfd_add_devices(&pdev->dev, -1, vx855_cells, ARRAY_SIZE(vx855_cells),
drivers/mfd/vx855.c:	mfd_remove_devices(&pdev->dev);
drivers/mfd/tps65911-comparator.c:	struct tps65910 *tps65910 = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/tps65911-comparator.c:		dev_err(&pdev->dev, "cannot set COMP1 threshold\n");
drivers/mfd/tps65911-comparator.c:		dev_err(&pdev->dev, "cannot set COMP2 threshold\n");
drivers/mfd/tps65911-comparator.c:	ret = device_create_file(&pdev->dev, &dev_attr_comp1_threshold);
drivers/mfd/tps65911-comparator.c:		dev_err(&pdev->dev, "failed to add COMP1 sysfs file\n");
drivers/mfd/tps65911-comparator.c:	ret = device_create_file(&pdev->dev, &dev_attr_comp2_threshold);
drivers/mfd/tps65911-comparator.c:		dev_err(&pdev->dev, "failed to add COMP2 sysfs file\n");
drivers/mfd/tps65911-comparator.c:	tps65910 = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/tps65911-comparator.c:	device_remove_file(&pdev->dev, &dev_attr_comp2_threshold);
drivers/mfd/tps65911-comparator.c:	device_remove_file(&pdev->dev, &dev_attr_comp1_threshold);
drivers/mfd/tps6586x.c:		pdev->dev.parent = tps6586x->dev;
drivers/mfd/tps6586x.c:		pdev->dev.platform_data = subdev->platform_data;
drivers/mfd/tps6586x.c:		pdev->dev.of_node = subdev->of_node;
drivers/mfd/pcf50633-adc.c:	adc->pcf = dev_to_pcf50633(pdev->dev.parent);
drivers/mfd/syscon.c:	struct device *dev = &pdev->dev;
drivers/mfd/ab3100-otp.c:		dev_err(&pdev->dev, "could not allocate AB3100 OTP device\n");
drivers/mfd/ab3100-otp.c:	otp->dev = &pdev->dev;
drivers/mfd/ab3100-otp.c:	dev_info(&pdev->dev, "AB3100 OTP readout registered\n");
drivers/mfd/ab3100-otp.c:		err = device_create_file(&pdev->dev,
drivers/mfd/ab3100-otp.c:	err = ab3100_otp_init_debugfs(&pdev->dev, otp);
drivers/mfd/ab3100-otp.c:		device_remove_file(&pdev->dev, &ab3100_otp_attrs[i]);
drivers/mfd/ab3100-otp.c:		device_remove_file(&pdev->dev,
drivers/mfd/twl4030-madc.c:	struct twl4030_madc_platform_data *pdata = pdev->dev.platform_data;
drivers/mfd/twl4030-madc.c:		dev_err(&pdev->dev, "platform_data not available\n");
drivers/mfd/twl4030-madc.c:	madc->dev = &pdev->dev;
drivers/mfd/twl4030-madc.c:		dev_err(&pdev->dev, "unable to read reg BCI CTL1 0x%X\n",
drivers/mfd/twl4030-madc.c:		dev_err(&pdev->dev, "unable to write reg BCI Ctl1 0x%X\n",
drivers/mfd/twl4030-madc.c:		dev_err(&pdev->dev, "unable to read reg GPBR1 0x%X\n",
drivers/mfd/twl4030-madc.c:		dev_info(&pdev->dev, "clk disabled, enabling\n");
drivers/mfd/twl4030-madc.c:			dev_err(&pdev->dev, "unable to write reg GPBR1 0x%X\n",
drivers/mfd/twl4030-madc.c:		dev_dbg(&pdev->dev, "could not request irq\n");
drivers/mfd/ab8500-sysctrl.c:	struct ab8500 *ab8500 = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/ab8500-sysctrl.c:	plat = dev_get_platdata(pdev->dev.parent);
drivers/mfd/ab8500-sysctrl.c:	sysctrl_dev = &pdev->dev;
drivers/mfd/ab8500-sysctrl.c:			dev_dbg(&pdev->dev,
drivers/mfd/ab8500-sysctrl.c:				dev_err(&pdev->dev,
drivers/mfd/cs5535-mfd.c:		dev_err(&pdev->dev, "can't fetch device resource info\n");
drivers/mfd/cs5535-mfd.c:		dev_err(&pdev->dev, "can't request region\n");
drivers/mfd/cs5535-mfd.c:		dev_err(&pdev->dev, "can't fetch device resource info\n");
drivers/mfd/cs5535-mfd.c:	err = mfd_add_devices(&pdev->dev, -1, cs5535_mfd_cells,
drivers/mfd/cs5535-mfd.c:		dev_err(&pdev->dev, "MFD add devices failed: %d\n", err);
drivers/mfd/cs5535-mfd.c:	dev_info(&pdev->dev, "%zu devices registered.\n",
drivers/mfd/cs5535-mfd.c:	mfd_remove_devices(&pdev->dev);
drivers/mfd/omap-usb-host.c:	struct device				*dev = &pdev->dev;
drivers/mfd/omap-usb-host.c:	struct device			*dev =  &pdev->dev;
drivers/mfd/omap-usb-host.c:	pm_runtime_disable(&pdev->dev);
drivers/mfd/omap-usb-host.c:	device_for_each_child(&pdev->dev, NULL, usbhs_omap_remove_child);
drivers/mfd/dm355evm_msp.c:	device_init_wakeup(&pdev->dev, can_wakeup);
drivers/mfd/dm355evm_msp.c:	pdev->dev.parent = &client->dev;
drivers/mfd/dm355evm_msp.c:			dev_dbg(&pdev->dev, "can't add platform_data\n");
drivers/mfd/dm355evm_msp.c:			dev_dbg(&pdev->dev, "can't add irq\n");
drivers/mfd/dm355evm_msp.c:	return &pdev->dev;
drivers/mfd/pcf50633-core.c:		pdev->dev.parent = pcf->dev;
drivers/mfd/da903x.c:		pdev->dev.parent = chip->dev;
drivers/mfd/da903x.c:		pdev->dev.platform_data = subdev->platform_data;
drivers/mfd/sm501.c:	for (ptr = 0; ptr < pdev->num_resources; ptr++) {
drivers/mfd/sm501.c:		       pdev->name, ptr, &pdev->resource[ptr]);
drivers/mfd/sm501.c:		dev_dbg(sm->dev, "registered %s\n", pdev->name);
drivers/mfd/sm501.c:			pdev->name, ret);
drivers/mfd/sm501.c:	sm501_create_subio(sm, &pdev->resource[0], 0x40000, 0x20000);
drivers/mfd/sm501.c:	sm501_create_mem(sm, &pdev->resource[1], mem_avail, 256*1024);
drivers/mfd/sm501.c:	sm501_create_irq(sm, &pdev->resource[2]);
drivers/mfd/sm501.c:	uart_data = pdev->dev.platform_data;
drivers/mfd/sm501.c:	pdev->id = PLAT8250_DEV_SM501;
drivers/mfd/sm501.c:	sm501_create_subio(sm, &pdev->resource[0], 0x80000, 0x10000);
drivers/mfd/sm501.c:	sm501_create_subio(sm, &pdev->resource[1], 0x100000, 0x50000);
drivers/mfd/sm501.c:	sm501_create_mem(sm, &pdev->resource[2], mem_avail, *mem_avail);
drivers/mfd/sm501.c:	sm501_create_irq(sm, &pdev->resource[3]);
drivers/mfd/sm501.c:	icd = pdev->dev.platform_data;
drivers/mfd/sm501.c:	pdev->id = iic->bus_num;
drivers/mfd/jz4740-adc.c:	struct jz4740_adc *adc = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/jz4740-adc.c:	jz4740_adc_set_enabled(adc, pdev->id, true);
drivers/mfd/jz4740-adc.c:	struct jz4740_adc *adc = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/jz4740-adc.c:	jz4740_adc_set_enabled(adc, pdev->id, false);
drivers/mfd/jz4740-adc.c:	adc = devm_kzalloc(&pdev->dev, sizeof(*adc), GFP_KERNEL);
drivers/mfd/jz4740-adc.c:		dev_err(&pdev->dev, "Failed to allocate driver structure\n");
drivers/mfd/jz4740-adc.c:		dev_err(&pdev->dev, "Failed to get platform irq: %d\n", ret);
drivers/mfd/jz4740-adc.c:		dev_err(&pdev->dev, "Failed to get irq base: %d\n", irq_base);
drivers/mfd/jz4740-adc.c:		dev_err(&pdev->dev, "Failed to get platform mmio resource\n");
drivers/mfd/jz4740-adc.c:					pdev->name);
drivers/mfd/jz4740-adc.c:		dev_err(&pdev->dev, "Failed to request mmio memory region\n");
drivers/mfd/jz4740-adc.c:		dev_err(&pdev->dev, "Failed to ioremap mmio memory\n");
drivers/mfd/jz4740-adc.c:	adc->clk = clk_get(&pdev->dev, "adc");
drivers/mfd/jz4740-adc.c:		dev_err(&pdev->dev, "Failed to get clock: %d\n", ret);
drivers/mfd/jz4740-adc.c:	ret = mfd_add_devices(&pdev->dev, 0, jz4740_adc_cells,
drivers/mfd/jz4740-adc.c:	mfd_remove_devices(&pdev->dev);
drivers/mfd/intel_msic.c:	struct intel_msic_platform_data *pdata = pdev->dev.platform_data;
drivers/mfd/intel_msic.c:		ret = devm_gpio_request_one(&pdev->dev, gpio,
drivers/mfd/intel_msic.c:			dev_err(&pdev->dev, "failed to register OCD GPIO\n");
drivers/mfd/intel_msic.c:			dev_err(&pdev->dev, "no IRQ number for OCD GPIO\n");
drivers/mfd/intel_msic.c:		ret = mfd_add_devices(&pdev->dev, -1, &msic_devs[i], 1, NULL,
drivers/mfd/intel_msic.c:	ret = mfd_add_devices(&pdev->dev, 0, msic_other_devs,
drivers/mfd/intel_msic.c:	mfd_remove_devices(&pdev->dev);
drivers/mfd/intel_msic.c:	mfd_remove_devices(&pdev->dev);
drivers/mfd/intel_msic.c:	struct intel_msic_platform_data *pdata = pdev->dev.platform_data;
drivers/mfd/intel_msic.c:		dev_err(&pdev->dev, "no platform data passed\n");
drivers/mfd/intel_msic.c:		dev_err(&pdev->dev, "failed to identify the MSIC chip (ID0)\n");
drivers/mfd/intel_msic.c:		dev_err(&pdev->dev, "failed to identify the MSIC chip (ID1)\n");
drivers/mfd/intel_msic.c:		dev_err(&pdev->dev, "invalid vendor ID: %x, %x\n", id0, id1);
drivers/mfd/intel_msic.c:	msic = devm_kzalloc(&pdev->dev, sizeof(*msic), GFP_KERNEL);
drivers/mfd/intel_msic.c:	msic->irq_base = devm_ioremap_resource(&pdev->dev, res);
drivers/mfd/intel_msic.c:		dev_err(&pdev->dev, "failed to initialize MSIC devices\n");
drivers/mfd/intel_msic.c:	dev_info(&pdev->dev, "Intel MSIC version %c%d (vendor %#x)\n",
drivers/mfd/sta2x11-mfd.c:		dev_warn(&pdev->dev, ": can't access sctl regs\n");
drivers/mfd/sta2x11-mfd.c:		dev_warn(&pdev->dev, ": system ctl not initialized\n");
drivers/mfd/sta2x11-mfd.c:	dev_info(&pdev->dev, "%s\n", __func__);
drivers/mfd/sta2x11-mfd.c:		dev_err(&pdev->dev, "Can't enable device.\n");
drivers/mfd/sta2x11-mfd.c:		dev_info(&pdev->dev, "Enable msi failed\n");
drivers/mfd/sta2x11-mfd.c:		err = mfd_add_devices(&pdev->dev, -1,
drivers/mfd/sta2x11-mfd.c:				      &pdev->resource[i],
drivers/mfd/sta2x11-mfd.c:			dev_err(&pdev->dev,
drivers/mfd/sta2x11-mfd.c:	mfd_remove_devices(&pdev->dev);
drivers/mfd/pm8921-core.c:	const struct pm8921_platform_data *pdata = pdev->dev.platform_data;
drivers/mfd/pm8921-core.c:	rc = ssbi_read(pdev->dev.parent, REG_HWREV, &val, sizeof(val));
drivers/mfd/pm8921-core.c:	rc = ssbi_read(pdev->dev.parent, REG_HWREV_2, &val, sizeof(val));
drivers/mfd/pm8921-core.c:	pmic->dev = &pdev->dev;
drivers/mfd/ab8500-gpadc.c:		dev_err(&pdev->dev, "Error: No memory\n");
drivers/mfd/ab8500-gpadc.c:	gpadc->dev = &pdev->dev;
drivers/mfd/ab8500-gpadc.c:	gpadc->parent = dev_get_drvdata(pdev->dev.parent);
drivers/mfd/ab8500-gpadc.c:	gpadc->regu = devm_regulator_get(&pdev->dev, "vddadc");
drivers/mfd/rdc321x-southbridge.c:		dev_err(&pdev->dev, "failed to enable device\n");
drivers/mfd/rdc321x-southbridge.c:	return mfd_add_devices(&pdev->dev, -1,
drivers/mfd/rdc321x-southbridge.c:	mfd_remove_devices(&pdev->dev);
drivers/mfd/davinci_voicecodec.c:		dev_dbg(&pdev->dev,
drivers/mfd/davinci_voicecodec.c:	davinci_vc->clk = clk_get(&pdev->dev, NULL);
drivers/mfd/davinci_voicecodec.c:		dev_dbg(&pdev->dev,
drivers/mfd/davinci_voicecodec.c:		dev_err(&pdev->dev, "no mem resource\n");
drivers/mfd/davinci_voicecodec.c:				 pdev->name);
drivers/mfd/davinci_voicecodec.c:		dev_err(&pdev->dev, "VCIF region already claimed\n");
drivers/mfd/davinci_voicecodec.c:		dev_err(&pdev->dev, "can't ioremap mem resource.\n");
drivers/mfd/davinci_voicecodec.c:		dev_err(&pdev->dev, "no DMA resource\n");
drivers/mfd/davinci_voicecodec.c:		dev_err(&pdev->dev, "no DMA resource\n");
drivers/mfd/davinci_voicecodec.c:	davinci_vc->dev = &pdev->dev;
drivers/mfd/davinci_voicecodec.c:	ret = mfd_add_devices(&pdev->dev, pdev->id, davinci_vc->cells,
drivers/mfd/davinci_voicecodec.c:		dev_err(&pdev->dev, "fail to register client devices\n");
drivers/mfd/davinci_voicecodec.c:	mfd_remove_devices(&pdev->dev);
drivers/mfd/db8500-prcmu.c:		dev_err(&pdev->dev,
drivers/mfd/db8500-prcmu.c:		dev_err(&pdev->dev, "no prcmu tcpm mem region provided\n");
drivers/mfd/db8500-prcmu.c:	struct device_node *np = pdev->dev.of_node;
drivers/mfd/db8500-prcmu.c:	struct prcmu_pdata *pdata = dev_get_platdata(&pdev->dev);
drivers/mfd/db8500-prcmu.c:		dev_err(&pdev->dev, "no prcmu memory region provided\n");
drivers/mfd/db8500-prcmu.c:	prcmu_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/mfd/db8500-prcmu.c:		dev_err(&pdev->dev,
drivers/mfd/db8500-prcmu.c:		dev_err(&pdev->dev, "no prcmu tcdm region provided\n");
drivers/mfd/db8500-prcmu.c:	tcdm_base = devm_ioremap(&pdev->dev, res->start,
drivers/mfd/db8500-prcmu.c:		dev_err(&pdev->dev, "no prcmu irq provided\n");
drivers/mfd/db8500-prcmu.c:	err = mfd_add_devices(&pdev->dev, 0, common_prcmu_devs,
drivers/mfd/db8500-prcmu.c:		err = mfd_add_devices(&pdev->dev, 0, db8500_prcmu_devs,
drivers/mfd/db8500-prcmu.c:			mfd_remove_devices(&pdev->dev);
drivers/mfd/db8500-prcmu.c:	err = db8500_prcmu_register_ab8500(&pdev->dev, pdata->ab_platdata,
drivers/mfd/db8500-prcmu.c:		mfd_remove_devices(&pdev->dev);
drivers/mfd/ezx-pcap.c:	pdev->dev.parent = &pcap->spi->dev;
drivers/mfd/ezx-pcap.c:	pdev->dev.platform_data = subdev->platform_data;
drivers/mfd/omap-usb-tll.c:	struct device				*dev =  &pdev->dev;
drivers/mfd/omap-usb-tll.c:	pm_runtime_disable(&pdev->dev);
drivers/mfd/twl6030-irq.c:	if (pdev->id) {
drivers/mfd/twl6030-irq.c:		pr_err("Unknown MMC controller %d in %s\n", pdev->id, __func__);
drivers/mfd/janz-cmodio.c:		dev_dbg(&priv->pdev->dev, "MODULbus %d: name %s\n", i, name);
drivers/mfd/janz-cmodio.c:		dev_err(&priv->pdev->dev, "no MODULbus modules specified, "
drivers/mfd/janz-cmodio.c:	return mfd_add_devices(&pdev->dev, 0, priv->cells,
drivers/mfd/janz-cmodio.c:			       num_probed, NULL, pdev->irq, NULL);
drivers/mfd/twl4030-audio.c:	struct twl4030_audio_data *pdata = pdev->dev.platform_data;
drivers/mfd/twl4030-audio.c:	struct device_node *node = pdev->dev.of_node;
drivers/mfd/twl4030-audio.c:		dev_err(&pdev->dev, "Platform data is missing\n");
drivers/mfd/twl4030-audio.c:	audio = devm_kzalloc(&pdev->dev, sizeof(struct twl4030_audio),
drivers/mfd/twl4030-audio.c:		dev_err(&pdev->dev, "Invalid audio_mclk\n");
drivers/mfd/twl4030-audio.c:		ret = mfd_add_devices(&pdev->dev, pdev->id, audio->cells,
drivers/mfd/twl4030-audio.c:		dev_err(&pdev->dev, "No platform data found for childs\n");
drivers/mfd/twl4030-audio.c:	mfd_remove_devices(&pdev->dev);
drivers/mfd/ti-ssp.c:	const struct ti_ssp_data *pdata = pdev->dev.platform_data;
drivers/mfd/ti-ssp.c:	struct device *dev = &pdev->dev;
drivers/mfd/ti-ssp.c:				pdev->name)) {
drivers/mfd/ti-ssp.c:	struct device *dev = &pdev->dev;
drivers/mfd/htc-pasic3.c:	struct device *dev = pdev->dev.parent;
drivers/mfd/htc-pasic3.c:	struct device *dev = pdev->dev.parent;
drivers/mfd/htc-pasic3.c:	struct pasic3_platform_data *pdata = pdev->dev.platform_data;
drivers/mfd/htc-pasic3.c:	struct device *dev = &pdev->dev;
drivers/mfd/htc-pasic3.c:		ret = mfd_add_devices(&pdev->dev, pdev->id,
drivers/mfd/htc-pasic3.c:		ret = mfd_add_devices(&pdev->dev, pdev->id, &led_cell, 1, r,
drivers/mfd/htc-pasic3.c:	mfd_remove_devices(&pdev->dev);
drivers/mfd/htc-i2cpld.c:	struct device *dev = &pdev->dev;
drivers/mfd/htc-i2cpld.c:	struct device *dev = &pdev->dev;
drivers/mfd/htc-i2cpld.c:	struct device *dev = &pdev->dev;
drivers/mfd/htc-i2cpld.c:	struct device *dev = &pdev->dev;
drivers/mfd/htc-i2cpld.c:	struct device *dev = &pdev->dev;
drivers/mfd/htc-i2cpld.c:					   flags, pdev->name, htcpld);
drivers/mfd/vexpress-sysreg.c:		if (pdev->num_resources == 1 &&
drivers/mfd/vexpress-sysreg.c:				pdev->resource[0].flags == IORESOURCE_BUS)
drivers/mfd/vexpress-sysreg.c:			site = pdev->resource[0].start;
drivers/mfd/vexpress-sysreg.c:		if (pdev->num_resources == 1 &&
drivers/mfd/vexpress-sysreg.c:				pdev->resource[0].flags == IORESOURCE_BUS) {
drivers/mfd/vexpress-sysreg.c:			site = pdev->resource[0].start;
drivers/mfd/vexpress-sysreg.c:			func_device[0] = pdev->resource[0].end;
drivers/mfd/vexpress-sysreg.c:			func_device[1] = pdev->id;
drivers/mfd/vexpress-sysreg.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
drivers/mfd/vexpress-sysreg.c:			resource_size(res), pdev->name)) {
drivers/mfd/vexpress-sysreg.c:		dev_err(&pdev->dev, "Failed to request memory region!\n");
drivers/mfd/vexpress-sysreg.c:		vexpress_sysreg_base = devm_ioremap(&pdev->dev, res->start,
drivers/mfd/vexpress-sysreg.c:		vexpress_sysreg_setup(pdev->dev.of_node);
drivers/mfd/vexpress-sysreg.c:		dev_err(&pdev->dev, "Failed to obtain base address!\n");
drivers/mfd/vexpress-sysreg.c:	vexpress_sysreg_gpio_chip.dev = &pdev->dev;
drivers/mfd/vexpress-sysreg.c:		dev_err(&pdev->dev, "Failed to register GPIO chip! (%d)\n",
drivers/mfd/vexpress-sysreg.c:	vexpress_sysreg_dev = &pdev->dev;
drivers/edac/i5400_edac.c:		if (PCI_FUNC(pdev->devfn) == 1)
drivers/edac/i5400_edac.c:		if (PCI_FUNC(pdev->devfn) == 2)
drivers/edac/i5400_edac.c:		 pdev->bus->number,
drivers/edac/i5400_edac.c:		 PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
drivers/edac/i5400_edac.c:	if (PCI_FUNC(pdev->devfn) != 0)
drivers/edac/i5400_edac.c:	mci->pdev = &pdev->dev;	/* record ptr  to the generic device */
drivers/edac/i5400_edac.c:	i5400_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
drivers/edac/i5400_edac.c:	mci = edac_mc_del_mc(&pdev->dev);
drivers/edac/octeon_edac-pci.c:	pci->dev = &pdev->dev;
drivers/edac/octeon_edac-pci.c:	pci->dev_name = dev_name(&pdev->dev);
drivers/edac/octeon_edac-pci.c:	edac_pci_del_device(&pdev->dev);
drivers/edac/sb_edac.c:			 pdev->bus->number,
drivers/edac/sb_edac.c:			 PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
drivers/edac/sb_edac.c:	bus = pdev->bus->number;
drivers/edac/sb_edac.c:	if (unlikely(PCI_SLOT(pdev->devfn) != dev_descr->dev ||
drivers/edac/sb_edac.c:			PCI_FUNC(pdev->devfn) != dev_descr->func)) {
drivers/edac/sb_edac.c:			bus, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
drivers/edac/sb_edac.c:		slot = PCI_SLOT(pdev->devfn);
drivers/edac/sb_edac.c:		func = PCI_FUNC(pdev->devfn);
drivers/edac/sb_edac.c:			 PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
drivers/edac/mv64x60_edac.c:	if (!devres_open_group(&pdev->dev, mv64x60_pci_err_probe, GFP_KERNEL))
drivers/edac/mv64x60_edac.c:	pdata->pci_hose = pdev->id;
drivers/edac/mv64x60_edac.c:	pci->dev = &pdev->dev;
drivers/edac/mv64x60_edac.c:	pci->dev_name = dev_name(&pdev->dev);
drivers/edac/mv64x60_edac.c:	if (!devm_request_mem_region(&pdev->dev,
drivers/edac/mv64x60_edac.c:	pdata->pci_vbase = devm_ioremap(&pdev->dev,
drivers/edac/mv64x60_edac.c:		res = devm_request_irq(&pdev->dev,
drivers/edac/mv64x60_edac.c:	devres_remove_group(&pdev->dev, mv64x60_pci_err_probe);
drivers/edac/mv64x60_edac.c:	edac_pci_del_device(&pdev->dev);
drivers/edac/mv64x60_edac.c:	devres_release_group(&pdev->dev, mv64x60_pci_err_probe);
drivers/edac/mv64x60_edac.c:	edac_pci_del_device(&pdev->dev);
drivers/edac/mv64x60_edac.c:	if (!devres_open_group(&pdev->dev, mv64x60_sram_err_probe, GFP_KERNEL))
drivers/edac/mv64x60_edac.c:		devres_release_group(&pdev->dev, mv64x60_sram_err_probe);
drivers/edac/mv64x60_edac.c:	edac_dev->dev = &pdev->dev;
drivers/edac/mv64x60_edac.c:	edac_dev->dev_name = dev_name(&pdev->dev);
drivers/edac/mv64x60_edac.c:	if (!devm_request_mem_region(&pdev->dev,
drivers/edac/mv64x60_edac.c:	pdata->sram_vbase = devm_ioremap(&pdev->dev,
drivers/edac/mv64x60_edac.c:		res = devm_request_irq(&pdev->dev,
drivers/edac/mv64x60_edac.c:	devres_remove_group(&pdev->dev, mv64x60_sram_err_probe);
drivers/edac/mv64x60_edac.c:	edac_device_del_device(&pdev->dev);
drivers/edac/mv64x60_edac.c:	devres_release_group(&pdev->dev, mv64x60_sram_err_probe);
drivers/edac/mv64x60_edac.c:	edac_device_del_device(&pdev->dev);
drivers/edac/mv64x60_edac.c:	if (!devres_open_group(&pdev->dev, mv64x60_cpu_err_probe, GFP_KERNEL))
drivers/edac/mv64x60_edac.c:		devres_release_group(&pdev->dev, mv64x60_cpu_err_probe);
drivers/edac/mv64x60_edac.c:	edac_dev->dev = &pdev->dev;
drivers/edac/mv64x60_edac.c:	edac_dev->dev_name = dev_name(&pdev->dev);
drivers/edac/mv64x60_edac.c:	if (!devm_request_mem_region(&pdev->dev,
drivers/edac/mv64x60_edac.c:	pdata->cpu_vbase[0] = devm_ioremap(&pdev->dev,
drivers/edac/mv64x60_edac.c:	if (!devm_request_mem_region(&pdev->dev,
drivers/edac/mv64x60_edac.c:	pdata->cpu_vbase[1] = devm_ioremap(&pdev->dev,
drivers/edac/mv64x60_edac.c:		res = devm_request_irq(&pdev->dev,
drivers/edac/mv64x60_edac.c:	devres_remove_group(&pdev->dev, mv64x60_cpu_err_probe);
drivers/edac/mv64x60_edac.c:	edac_device_del_device(&pdev->dev);
drivers/edac/mv64x60_edac.c:	devres_release_group(&pdev->dev, mv64x60_cpu_err_probe);
drivers/edac/mv64x60_edac.c:	edac_device_del_device(&pdev->dev);
drivers/edac/mv64x60_edac.c:	if (!devres_open_group(&pdev->dev, mv64x60_mc_err_probe, GFP_KERNEL))
drivers/edac/mv64x60_edac.c:		devres_release_group(&pdev->dev, mv64x60_mc_err_probe);
drivers/edac/mv64x60_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/mv64x60_edac.c:	mci->dev_name = dev_name(&pdev->dev);
drivers/edac/mv64x60_edac.c:	if (!devm_request_mem_region(&pdev->dev,
drivers/edac/mv64x60_edac.c:	pdata->mc_vbase = devm_ioremap(&pdev->dev,
drivers/edac/mv64x60_edac.c:		res = devm_request_irq(&pdev->dev,
drivers/edac/mv64x60_edac.c:	edac_mc_del_mc(&pdev->dev);
drivers/edac/mv64x60_edac.c:	devres_release_group(&pdev->dev, mv64x60_mc_err_probe);
drivers/edac/mv64x60_edac.c:	edac_mc_del_mc(&pdev->dev);
drivers/edac/i3200_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/i3200_edac.c:	mci = edac_mc_del_mc(&pdev->dev);
drivers/edac/i5100_edac.c:	if (PCI_FUNC(pdev->devfn) != 1)
drivers/edac/i5100_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/i5100_edac.c:	mci = edac_mc_del_mc(&pdev->dev);
drivers/edac/e7xxx_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/e7xxx_edac.c:	e7xxx_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
drivers/edac/e7xxx_edac.c:	if ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)
drivers/edac/cell_edac.c:	regs = cbe_get_cpu_mic_tm_regs(cbe_node_to_cpu(pdev->id));
drivers/edac/cell_edac.c:	dev_dbg(&pdev->dev, "MIC_MNT_CFG = 0x%016llx\n", reg);
drivers/edac/cell_edac.c:		dev_warn(&pdev->dev,
drivers/edac/cell_edac.c:	dev_dbg(&pdev->dev, "Initial FIR = 0x%016llx\n",
drivers/edac/cell_edac.c:	mci = edac_mc_alloc(pdev->id, ARRAY_SIZE(layers), layers,
drivers/edac/cell_edac.c:	priv->node = pdev->id;
drivers/edac/cell_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/cell_edac.c:	mci->dev_name = dev_name(&pdev->dev);
drivers/edac/cell_edac.c:		dev_err(&pdev->dev, "failed to register with EDAC core\n");
drivers/edac/cell_edac.c:	struct mem_ctl_info *mci = edac_mc_del_mc(&pdev->dev);
drivers/edac/e752x_edac.c:		pvt->bridge_ck = pci_scan_single_device(pdev->bus,
drivers/edac/e752x_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/e752x_edac.c:	e752x_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
drivers/edac/e752x_edac.c:	if ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)
drivers/edac/i82875p_edac.c:		dev = pci_scan_single_device(pdev->bus, PCI_DEVFN(6, 0));
drivers/edac/i82875p_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/i82875p_edac.c:	i82875p_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
drivers/edac/i82875p_edac.c:	if ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)
drivers/edac/octeon_edac-pc.c:	struct co_cache_error *p = devm_kzalloc(&pdev->dev, sizeof(*p),
drivers/edac/octeon_edac-pc.c:	p->ed->dev = &pdev->dev;
drivers/edac/octeon_edac-pc.c:	p->ed->dev_name = dev_name(&pdev->dev);
drivers/edac/octeon_edac-pc.c:	edac_device_del_device(&pdev->dev);
drivers/edac/octeon_edac-l2c.c:	l2c->dev = &pdev->dev;
drivers/edac/octeon_edac-l2c.c:	l2c->dev_name = dev_name(&pdev->dev);
drivers/edac/octeon_edac-l2c.c:	edac_device_del_device(&pdev->dev);
drivers/edac/tile_edac.c:	sprintf(hv_file, "mshim/%d", pdev->id);
drivers/edac/tile_edac.c:	mci = edac_mc_alloc(pdev->id, ARRAY_SIZE(layers), layers,
drivers/edac/tile_edac.c:	priv->node = pdev->id;
drivers/edac/tile_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/tile_edac.c:	mci->dev_name = dev_name(&pdev->dev);
drivers/edac/tile_edac.c:		dev_err(&pdev->dev, "failed to register with EDAC core\n");
drivers/edac/tile_edac.c:	edac_mc_del_mc(&pdev->dev);
drivers/edac/i82443bxgx_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/i82443bxgx_edac.c:	i82443bxgx_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
drivers/edac/i82443bxgx_edac.c:	if ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)
drivers/edac/amd64_edac.c:			   func, PCI_FUNC(pdev->devfn), offset);
drivers/edac/amd64_edac.c:			   func, PCI_FUNC(pdev->devfn), offset);
drivers/edac/amd64_edac.c:	mci = find_mci_by_dev(&pdev->dev);
drivers/edac/amd64_edac.c:	mci = edac_mc_del_mc(&pdev->dev);
drivers/edac/i82975x_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/i82975x_edac.c:	mci = edac_mc_del_mc(&pdev->dev);
drivers/edac/i3000_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/i3000_edac.c:	i3000_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
drivers/edac/i3000_edac.c:	mci = edac_mc_del_mc(&pdev->dev);
drivers/edac/i7300_edac.c:		switch (PCI_FUNC(pdev->devfn)) {
drivers/edac/i7300_edac.c:		 pdev->bus->number,
drivers/edac/i7300_edac.c:		 PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
drivers/edac/i7300_edac.c:	if (PCI_FUNC(pdev->devfn) != 0)
drivers/edac/i7300_edac.c:	mci->pdev = &pdev->dev;	/* record ptr  to the generic device */
drivers/edac/i7300_edac.c:	i7300_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
drivers/edac/i7300_edac.c:	mci = edac_mc_del_mc(&pdev->dev);
drivers/edac/r82600_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/r82600_edac.c:	r82600_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
drivers/edac/r82600_edac.c:	if ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)
drivers/edac/amd76x_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/amd76x_edac.c:	amd76x_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
drivers/edac/amd76x_edac.c:	if ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)
drivers/edac/highbank_l2_edac.c:	dci->dev = &pdev->dev;
drivers/edac/highbank_l2_edac.c:	if (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL))
drivers/edac/highbank_l2_edac.c:		dev_err(&pdev->dev, "Unable to get mem resource\n");
drivers/edac/highbank_l2_edac.c:	if (!devm_request_mem_region(&pdev->dev, r->start,
drivers/edac/highbank_l2_edac.c:				     resource_size(r), dev_name(&pdev->dev))) {
drivers/edac/highbank_l2_edac.c:		dev_err(&pdev->dev, "Error while requesting mem region\n");
drivers/edac/highbank_l2_edac.c:	drvdata->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));
drivers/edac/highbank_l2_edac.c:		dev_err(&pdev->dev, "Unable to map regs\n");
drivers/edac/highbank_l2_edac.c:	dci->mod_name = dev_name(&pdev->dev);
drivers/edac/highbank_l2_edac.c:	dci->dev_name = dev_name(&pdev->dev);
drivers/edac/highbank_l2_edac.c:	res = devm_request_irq(&pdev->dev, drvdata->db_irq,
drivers/edac/highbank_l2_edac.c:			       0, dev_name(&pdev->dev), dci);
drivers/edac/highbank_l2_edac.c:	res = devm_request_irq(&pdev->dev, drvdata->sb_irq,
drivers/edac/highbank_l2_edac.c:			       0, dev_name(&pdev->dev), dci);
drivers/edac/highbank_l2_edac.c:	devres_close_group(&pdev->dev, NULL);
drivers/edac/highbank_l2_edac.c:	edac_device_del_device(&pdev->dev);
drivers/edac/highbank_l2_edac.c:	devres_release_group(&pdev->dev, NULL);
drivers/edac/highbank_l2_edac.c:	edac_device_del_device(&pdev->dev);
drivers/edac/pasemi_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/pasemi_edac.c:	struct mem_ctl_info *mci = edac_mc_del_mc(&pdev->dev);
drivers/edac/highbank_mc_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/highbank_mc_edac.c:	if (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL))
drivers/edac/highbank_mc_edac.c:		dev_err(&pdev->dev, "Unable to get mem resource\n");
drivers/edac/highbank_mc_edac.c:	if (!devm_request_mem_region(&pdev->dev, r->start,
drivers/edac/highbank_mc_edac.c:				     resource_size(r), dev_name(&pdev->dev))) {
drivers/edac/highbank_mc_edac.c:		dev_err(&pdev->dev, "Error while requesting mem region\n");
drivers/edac/highbank_mc_edac.c:	drvdata->mc_vbase = devm_ioremap(&pdev->dev,
drivers/edac/highbank_mc_edac.c:		dev_err(&pdev->dev, "Unable to map regs\n");
drivers/edac/highbank_mc_edac.c:		dev_err(&pdev->dev, "No ECC present, or ECC disabled\n");
drivers/edac/highbank_mc_edac.c:	mci->mod_name = dev_name(&pdev->dev);
drivers/edac/highbank_mc_edac.c:	mci->ctl_name = dev_name(&pdev->dev);
drivers/edac/highbank_mc_edac.c:	res = devm_request_irq(&pdev->dev, irq, highbank_mc_err_handler,
drivers/edac/highbank_mc_edac.c:			       0, dev_name(&pdev->dev), mci);
drivers/edac/highbank_mc_edac.c:		dev_err(&pdev->dev, "Unable to request irq %d\n", irq);
drivers/edac/highbank_mc_edac.c:	devres_close_group(&pdev->dev, NULL);
drivers/edac/highbank_mc_edac.c:	edac_mc_del_mc(&pdev->dev);
drivers/edac/highbank_mc_edac.c:	devres_release_group(&pdev->dev, NULL);
drivers/edac/highbank_mc_edac.c:	edac_mc_del_mc(&pdev->dev);
drivers/edac/octeon_edac-lmc.c:	int mc = pdev->id;
drivers/edac/octeon_edac-lmc.c:			dev_info(&pdev->dev, "Disabled (ECC not enabled)\n");
drivers/edac/octeon_edac-lmc.c:		mci->pdev = &pdev->dev;
drivers/edac/octeon_edac-lmc.c:		mci->dev_name = dev_name(&pdev->dev);
drivers/edac/octeon_edac-lmc.c:			dev_err(&pdev->dev, "edac_mc_add_mc() failed\n");
drivers/edac/octeon_edac-lmc.c:			dev_info(&pdev->dev, "Disabled (ECC not enabled)\n");
drivers/edac/octeon_edac-lmc.c:		mci->pdev = &pdev->dev;
drivers/edac/octeon_edac-lmc.c:		mci->dev_name = dev_name(&pdev->dev);
drivers/edac/octeon_edac-lmc.c:			dev_err(&pdev->dev, "edac_mc_add_mc() failed\n");
drivers/edac/octeon_edac-lmc.c:	edac_mc_del_mc(&pdev->dev);
drivers/edac/i82860_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/i82860_edac.c:	i82860_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
drivers/edac/i82860_edac.c:	if ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)
drivers/edac/x38_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/x38_edac.c:	mci = edac_mc_del_mc(&pdev->dev);
drivers/edac/cpc925_edac.c:		dev_info->edac_dev->dev = &dev_info->pdev->dev;
drivers/edac/cpc925_edac.c:		dev_info->edac_dev->dev_name = dev_name(&dev_info->pdev->dev);
drivers/edac/cpc925_edac.c:	edac_dbg(0, "%s platform device found!\n", pdev->name);
drivers/edac/cpc925_edac.c:	if (!devres_open_group(&pdev->dev, cpc925_probe, GFP_KERNEL)) {
drivers/edac/cpc925_edac.c:	if (!devm_request_mem_region(&pdev->dev,
drivers/edac/cpc925_edac.c:				     pdev->name)) {
drivers/edac/cpc925_edac.c:	vbase = devm_ioremap(&pdev->dev, r->start, resource_size(r));
drivers/edac/cpc925_edac.c:	pdata->name = pdev->name;
drivers/edac/cpc925_edac.c:	mci->pdev = &pdev->dev;
drivers/edac/cpc925_edac.c:	mci->dev_name = dev_name(&pdev->dev);
drivers/edac/cpc925_edac.c:	mci->ctl_name = pdev->name;
drivers/edac/cpc925_edac.c:	devm_release_mem_region(&pdev->dev, r->start, resource_size(r));
drivers/edac/cpc925_edac.c:	devres_release_group(&pdev->dev, cpc925_probe);
drivers/edac/cpc925_edac.c:	edac_mc_del_mc(&pdev->dev);
drivers/edac/i7core_edac.c:			 pdev->bus->number,
drivers/edac/i7core_edac.c:			 PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
drivers/edac/i7core_edac.c:	bus = pdev->bus->number;
drivers/edac/i7core_edac.c:	if (unlikely(PCI_SLOT(pdev->devfn) != dev_descr->dev ||
drivers/edac/i7core_edac.c:			PCI_FUNC(pdev->devfn) != dev_descr->func)) {
drivers/edac/i7core_edac.c:			bus, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
drivers/edac/i7core_edac.c:		func = PCI_FUNC(pdev->devfn);
drivers/edac/i7core_edac.c:		slot = PCI_SLOT(pdev->devfn);
drivers/edac/i7core_edac.c:			switch (pdev->device) {
drivers/edac/i7core_edac.c:			 PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
drivers/edac/i7core_edac.c:		if (PCI_SLOT(pdev->devfn) == 3 &&
drivers/edac/i7core_edac.c:			PCI_FUNC(pdev->devfn) == 2)
drivers/edac/edac_mc_sysfs.c:	mci_pdev->bus = edac_subsys;
drivers/edac/edac_mc_sysfs.c:	mci_pdev->type = &mc_attr_type;
drivers/edac/i5000_edac.c:		if (PCI_FUNC(pdev->devfn) == 1)
drivers/edac/i5000_edac.c:		if (PCI_FUNC(pdev->devfn) == 2)
drivers/edac/i5000_edac.c:		 pdev->bus->number,
drivers/edac/i5000_edac.c:		 PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
drivers/edac/i5000_edac.c:	if (PCI_FUNC(pdev->devfn) != 0)
drivers/edac/i5000_edac.c:	mci->pdev = &pdev->dev;	/* record ptr  to the generic device */
drivers/edac/i5000_edac.c:	i5000_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
drivers/edac/i5000_edac.c:	if ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)
drivers/char/scx200_gpio.c:	/* support dev_dbg() with pdev->dev */
drivers/char/scx200_gpio.c:	scx200_gpio_ops.dev = &pdev->dev;
drivers/char/scx200_gpio.c:		dev_err(&pdev->dev, "SCx200 chrdev_region err: %d\n", rc);
drivers/char/sonypi.c:	jog_dev->dev.parent = &pdev->dev;
drivers/char/sonypi.c:	key_dev->dev.parent = &pdev->dev;
drivers/char/xilinx_hwicap/xilinx_hwicap.c:	match = of_match_device(hwicap_of_match, &pdev->dev);
drivers/char/xilinx_hwicap/xilinx_hwicap.c:	family = pdev->dev.platform_data;
drivers/char/xilinx_hwicap/xilinx_hwicap.c:	return hwicap_setup(&pdev->dev, pdev->id, res,
drivers/char/xilinx_hwicap/xilinx_hwicap.c:	return hwicap_remove(&pdev->dev);
drivers/char/hw_random/mxc-rnga.c:	mxc_rng = devm_kzalloc(&pdev->dev, sizeof(struct mxc_rng),
drivers/char/hw_random/mxc-rnga.c:	mxc_rng->dev = &pdev->dev;
drivers/char/hw_random/mxc-rnga.c:	mxc_rng->clk = devm_clk_get(&pdev->dev, NULL);
drivers/char/hw_random/mxc-rnga.c:		dev_err(&pdev->dev, "Could not get rng_clk!\n");
drivers/char/hw_random/mxc-rnga.c:	mxc_rng->mem = devm_ioremap_resource(&pdev->dev, res);
drivers/char/hw_random/mxc-rnga.c:		dev_err(&pdev->dev, "MXC RNGA registering failed (%d)\n", err);
drivers/char/hw_random/mxc-rnga.c:	dev_info(&pdev->dev, "MXC RNGA Registered.\n");
drivers/char/hw_random/meson-rng.c:	meson_rng = devm_kzalloc(&pdev->dev, sizeof(struct meson_rng),
drivers/char/hw_random/meson-rng.c:	meson_rng->dev = &pdev->dev;
drivers/char/hw_random/meson-rng.c:	pm_runtime_set_autosuspend_delay(&pdev->dev, MESON_RNG_AUTOSUSPEND_DELAY);
drivers/char/hw_random/meson-rng.c:	pm_runtime_use_autosuspend(&pdev->dev);
drivers/char/hw_random/meson-rng.c:	pm_runtime_set_active(&pdev->dev);
drivers/char/hw_random/meson-rng.c:	pm_runtime_enable(&pdev->dev);
drivers/char/hw_random/octeon-rng.c:	rng = devm_kzalloc(&pdev->dev, sizeof(*rng), GFP_KERNEL);
drivers/char/hw_random/octeon-rng.c:	rng->control_status = devm_ioremap_nocache(&pdev->dev,
drivers/char/hw_random/octeon-rng.c:	rng->result = devm_ioremap_nocache(&pdev->dev,
drivers/char/hw_random/octeon-rng.c:	dev_set_drvdata(&pdev->dev, &rng->ops);
drivers/char/hw_random/octeon-rng.c:	dev_info(&pdev->dev, "Octeon Random Number Generator\n");
drivers/char/hw_random/octeon-rng.c:	struct hwrng *rng = dev_get_drvdata(&pdev->dev);
drivers/char/hw_random/timeriomem-rng.c:	struct timeriomem_rng_data *pdata = pdev->dev.platform_data;
drivers/char/hw_random/timeriomem-rng.c:	if (!pdev->dev.of_node && !pdata) {
drivers/char/hw_random/timeriomem-rng.c:		dev_err(&pdev->dev, "timeriomem_rng_data is missing\n");
drivers/char/hw_random/timeriomem-rng.c:		dev_err(&pdev->dev,
drivers/char/hw_random/timeriomem-rng.c:		dev_err(&pdev->dev, "failed to allocate device structure.\n");
drivers/char/hw_random/timeriomem-rng.c:	if (pdev->dev.of_node) {
drivers/char/hw_random/timeriomem-rng.c:		if (!of_property_read_u32(pdev->dev.of_node,
drivers/char/hw_random/timeriomem-rng.c:			dev_err(&pdev->dev, "missing period\n");
drivers/char/hw_random/timeriomem-rng.c:		dev_err(&pdev->dev, "period is less than one jiffy\n");
drivers/char/hw_random/timeriomem-rng.c:	priv->timeriomem_rng_ops.name		= dev_name(&pdev->dev);
drivers/char/hw_random/timeriomem-rng.c:				dev_name(&pdev->dev))) {
drivers/char/hw_random/timeriomem-rng.c:		dev_err(&pdev->dev, "request_mem_region failed\n");
drivers/char/hw_random/timeriomem-rng.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/char/hw_random/timeriomem-rng.c:		dev_err(&pdev->dev, "problem registering\n");
drivers/char/hw_random/timeriomem-rng.c:	dev_info(&pdev->dev, "32bits from 0x%p @ %dus\n",
drivers/char/hw_random/amd-rng.c:		dev_err(&pdev->dev, "AMD HWRNG region 0x%x already in use!\n",
drivers/char/hw_random/atmel-rng.c:	trng = devm_kzalloc(&pdev->dev, sizeof(*trng), GFP_KERNEL);
drivers/char/hw_random/atmel-rng.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
drivers/char/hw_random/atmel-rng.c:				     resource_size(res), pdev->name))
drivers/char/hw_random/atmel-rng.c:	trng->base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/char/hw_random/atmel-rng.c:	trng->clk = clk_get(&pdev->dev, NULL);
drivers/char/hw_random/atmel-rng.c:	trng->rng.name = pdev->name;
drivers/char/hw_random/picoxcell-rng.c:		dev_warn(&pdev->dev, "no memory resource\n");
drivers/char/hw_random/picoxcell-rng.c:	if (!devm_request_mem_region(&pdev->dev, mem->start, resource_size(mem),
drivers/char/hw_random/picoxcell-rng.c:		dev_warn(&pdev->dev, "unable to request io mem\n");
drivers/char/hw_random/picoxcell-rng.c:	rng_base = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
drivers/char/hw_random/picoxcell-rng.c:		dev_warn(&pdev->dev, "unable to remap io mem\n");
drivers/char/hw_random/picoxcell-rng.c:	rng_clk = clk_get(&pdev->dev, NULL);
drivers/char/hw_random/picoxcell-rng.c:		dev_warn(&pdev->dev, "no clk\n");
drivers/char/hw_random/picoxcell-rng.c:		dev_warn(&pdev->dev, "unable to enable clk\n");
drivers/char/hw_random/picoxcell-rng.c:	rng_dev = &pdev->dev;
drivers/char/hw_random/picoxcell-rng.c:	dev_info(&pdev->dev, "pixoxcell random number generator active\n");
drivers/char/hw_random/bcm63xx-rng.c:		dev_err(&pdev->dev, "no iomem resource\n");
drivers/char/hw_random/bcm63xx-rng.c:		dev_err(&pdev->dev, "no memory for private structure\n");
drivers/char/hw_random/bcm63xx-rng.c:		dev_err(&pdev->dev, "no memory for rng structure\n");
drivers/char/hw_random/bcm63xx-rng.c:	rng->name = pdev->name;
drivers/char/hw_random/bcm63xx-rng.c:	clk = clk_get(&pdev->dev, "ipsec");
drivers/char/hw_random/bcm63xx-rng.c:		dev_err(&pdev->dev, "no clock for device\n");
drivers/char/hw_random/bcm63xx-rng.c:	if (!devm_request_mem_region(&pdev->dev, r->start,
drivers/char/hw_random/bcm63xx-rng.c:					resource_size(r), pdev->name)) {
drivers/char/hw_random/bcm63xx-rng.c:		dev_err(&pdev->dev, "request mem failed");
drivers/char/hw_random/bcm63xx-rng.c:	priv->regs = devm_ioremap_nocache(&pdev->dev, r->start,
drivers/char/hw_random/bcm63xx-rng.c:		dev_err(&pdev->dev, "ioremap failed");
drivers/char/hw_random/bcm63xx-rng.c:		dev_err(&pdev->dev, "failed to register rng device\n");
drivers/char/hw_random/bcm63xx-rng.c:	dev_info(&pdev->dev, "registered RNG driver\n");
drivers/char/hw_random/omap-rng.c:		dev_err(&pdev->dev, "could not allocate memory\n");
drivers/char/hw_random/omap-rng.c:	dev_set_drvdata(&pdev->dev, priv);
drivers/char/hw_random/omap-rng.c:	priv->base = devm_ioremap_resource(&pdev->dev, priv->mem_res);
drivers/char/hw_random/omap-rng.c:	dev_set_drvdata(&pdev->dev, priv);
drivers/char/hw_random/omap-rng.c:	pm_runtime_enable(&pdev->dev);
drivers/char/hw_random/omap-rng.c:	pm_runtime_get_sync(&pdev->dev);
drivers/char/hw_random/omap-rng.c:	dev_info(&pdev->dev, "OMAP Random Number Generator ver. %02x\n",
drivers/char/hw_random/omap-rng.c:	pm_runtime_disable(&pdev->dev);
drivers/char/hw_random/omap-rng.c:	struct omap_rng_private_data *priv = dev_get_drvdata(&pdev->dev);
drivers/char/hw_random/omap-rng.c:	pm_runtime_put_sync(&pdev->dev);
drivers/char/hw_random/omap-rng.c:	pm_runtime_disable(&pdev->dev);
drivers/char/hw_random/exynos-rng.c:	exynos_rng = devm_kzalloc(&pdev->dev, sizeof(struct exynos_rng),
drivers/char/hw_random/exynos-rng.c:	exynos_rng->dev = &pdev->dev;
drivers/char/hw_random/exynos-rng.c:	exynos_rng->clk = devm_clk_get(&pdev->dev, "secss");
drivers/char/hw_random/exynos-rng.c:		dev_err(&pdev->dev, "Couldn't get clock.\n");
drivers/char/hw_random/exynos-rng.c:	exynos_rng->mem = devm_ioremap_resource(&pdev->dev, res);
drivers/char/hw_random/exynos-rng.c:	pm_runtime_set_autosuspend_delay(&pdev->dev, EXYNOS_AUTOSUSPEND_DELAY);
drivers/char/hw_random/exynos-rng.c:	pm_runtime_use_autosuspend(&pdev->dev);
drivers/char/hw_random/exynos-rng.c:	pm_runtime_enable(&pdev->dev);
drivers/char/hw_random/bcm2835-rng.c:	struct device *dev = &pdev->dev;
drivers/char/tpm/tpm_atmel.c:	struct tpm_chip *chip = dev_get_drvdata(&pdev->dev);
drivers/char/tpm/tpm_atmel.c:	if (!(chip = tpm_register_hardware(&pdev->dev, &tpm_atmel))) {
drivers/char/tpm/tpm_tis.c:	if((rc=tpm_tis_init(&pdev->dev, TIS_MEM_BASE, TIS_MEM_LEN, 0)) != 0) {
drivers/char/tpm/tpm_nsc.c:	pdev->num_resources = 0;
drivers/char/tpm/tpm_nsc.c:	pdev->dev.driver = &nsc_drv.driver;
drivers/char/tpm/tpm_nsc.c:	pdev->dev.release = tpm_nsc_remove;
drivers/char/tpm/tpm_nsc.c:	if (!(chip = tpm_register_hardware(&pdev->dev, &tpm_nsc))) {
drivers/char/tpm/tpm_nsc.c:	dev_dbg(&pdev->dev, "NSC TPM detected\n");
drivers/char/tpm/tpm_nsc.c:	dev_dbg(&pdev->dev,
drivers/char/tpm/tpm_nsc.c:	dev_dbg(&pdev->dev,
drivers/char/tpm/tpm_nsc.c:	dev_dbg(&pdev->dev, "NSC IO Base0 0x%x\n",
drivers/char/tpm/tpm_nsc.c:	dev_dbg(&pdev->dev, "NSC IO Base1 0x%x\n",
drivers/char/tpm/tpm_nsc.c:	dev_dbg(&pdev->dev, "NSC Interrupt number and wakeup 0x%x\n",
drivers/char/tpm/tpm_nsc.c:	dev_dbg(&pdev->dev, "NSC IRQ type select 0x%x\n",
drivers/char/tpm/tpm_nsc.c:	dev_dbg(&pdev->dev,
drivers/char/tpm/tpm_nsc.c:	dev_dbg(&pdev->dev,
drivers/char/tpm/tpm_nsc.c:	dev_info(&pdev->dev,
drivers/char/tpm/tpm_nsc.c:		tpm_nsc_remove(&pdev->dev);
drivers/char/pc8736x_gpio.c:	dev_dbg(&pdev->dev, "_gpio_get(%d from %x bit %d) == val %d\n",
drivers/char/pc8736x_gpio.c:	dev_dbg(&pdev->dev, "addr:%x cur:%x bit-pos:%d cur-bit:%x + new:%d -> bit-new:%d\n",
drivers/char/pc8736x_gpio.c:	dev_dbg(&pdev->dev, "gpio_set(minor:%d port:%d bit:%d)"
drivers/char/pc8736x_gpio.c:	dev_dbg(&pdev->dev, "wrote %x, read: %x\n", curval, val);
drivers/char/pc8736x_gpio.c:	dev_dbg(&pdev->dev, "open %d\n", m);
drivers/char/pc8736x_gpio.c:	dev_info(&pdev->dev, "NatSemi pc8736x GPIO Driver Initializing\n");
drivers/char/pc8736x_gpio.c:		dev_err(&pdev->dev, "no device found\n");
drivers/char/pc8736x_gpio.c:	pc8736x_gpio_ops.dev = &pdev->dev;
drivers/char/pc8736x_gpio.c:		dev_err(&pdev->dev, "device not enabled\n");
drivers/char/pc8736x_gpio.c:		dev_err(&pdev->dev, "GPIO unit not enabled\n");
drivers/char/pc8736x_gpio.c:		dev_err(&pdev->dev, "GPIO ioport %x busy\n",
drivers/char/pc8736x_gpio.c:	dev_info(&pdev->dev, "GPIO ioport %x reserved\n", pc8736x_gpio_base);
drivers/char/pc8736x_gpio.c:		dev_err(&pdev->dev, "register-chrdev failed: %d\n", rc);
drivers/char/pc8736x_gpio.c:		dev_dbg(&pdev->dev, "got dynamic major %d\n", major);
drivers/char/pc8736x_gpio.c:	dev_dbg(&pdev->dev, "cleanup\n");
drivers/char/dsp56k.c:	err = request_firmware(&fw, fw_name, &pdev->dev);
drivers/char/ipmi/ipmi_si_intf.c:	int class_type = pdev->class & PCI_ERMC_CLASSCODE_TYPE_MASK;
drivers/char/ipmi/ipmi_si_intf.c:	dev_info(&pdev->dev, "probing via PCI");
drivers/char/ipmi/ipmi_si_intf.c:		dev_info(&pdev->dev, "Unknown IPMI type: %d\n", class_type);
drivers/char/ipmi/ipmi_si_intf.c:		dev_err(&pdev->dev, "couldn't enable PCI device\n");
drivers/char/ipmi/ipmi_si_intf.c:	info->irq = pdev->irq;
drivers/char/ipmi/ipmi_si_intf.c:	info->dev = &pdev->dev;
drivers/char/ipmi/ipmi_si_intf.c:	dev_info(&pdev->dev, "%pR regsize %d spacing %d irq %d\n",
drivers/char/ipmi/ipmi_si_intf.c:		&pdev->resource[0], info->io.regsize, info->io.regspacing,
drivers/char/ipmi/ipmi_si_intf.c:		new_smi->dev = &new_smi->pdev->dev;
drivers/char/agp/sis-agp.c:	dev_info(&pdev->dev, "SiS chipset [%04x/%04x]\n",
drivers/char/agp/sis-agp.c:		 pdev->vendor, pdev->device);
drivers/char/agp/amd64-agp.c:	switch (pdev->revision) {
drivers/char/agp/amd64-agp.c:	dev_info(&pdev->dev, "AMD 8151 AGP Bridge rev %s\n", revstring);
drivers/char/agp/amd64-agp.c:	if (pdev->revision < 0x13) {
drivers/char/agp/amd64-agp.c:		dev_info(&pdev->dev, "correcting AGP revision (reports 3.5, is really 3.0)\n");
drivers/char/agp/amd64-agp.c:	dev_info(&pdev->dev, "setting up ULi AGP\n");
drivers/char/agp/amd64-agp.c:	dev1 = pci_get_slot (pdev->bus,PCI_DEVFN(0,0));
drivers/char/agp/amd64-agp.c:		dev_info(&pdev->dev, "can't find ULi secondary device\n");
drivers/char/agp/amd64-agp.c:		dev_info(&pdev->dev, "no ULi size found for %d\n", size);
drivers/char/agp/amd64-agp.c:	dev_info(&pdev->dev, "setting up Nforce3 AGP\n");
drivers/char/agp/amd64-agp.c:	dev1 = pci_get_slot(pdev->bus, PCI_DEVFN(11, 0));
drivers/char/agp/amd64-agp.c:		dev_info(&pdev->dev, "can't find Nforce3 secondary device\n");
drivers/char/agp/amd64-agp.c:		dev_info(&pdev->dev, "no NForce3 size found for %d\n", size);
drivers/char/agp/amd64-agp.c:		dev_info(&pdev->dev, "aperture base > 4G\n");
drivers/char/agp/amd64-agp.c:	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
drivers/char/agp/amd64-agp.c:	    pdev->device == PCI_DEVICE_ID_AMD_8151_0) {
drivers/char/agp/amd64-agp.c:		dev_info(&pdev->dev, "AGP bridge [%04x/%04x]\n",
drivers/char/agp/amd64-agp.c:			 pdev->vendor, pdev->device);
drivers/char/agp/amd64-agp.c:	if (pdev->vendor == PCI_VENDOR_ID_NVIDIA) {
drivers/char/agp/amd64-agp.c:	if (pdev->vendor == PCI_VENDOR_ID_AL) {
drivers/char/agp/amd64-agp.c:	if (pdev->vendor == PCI_VENDOR_ID_NVIDIA)
drivers/char/agp/amd-k7-agp.c:	dev_info(&pdev->dev, "AMD %s chipset\n",
drivers/char/agp/amd-k7-agp.c:				dev_info(&pdev->dev, "no AGP VGA controller\n");
drivers/char/agp/amd-k7-agp.c:			dev_info(&pdev->dev, "AMD 751 chipset with NVidia GeForce; forcing 1X due to errata\n");
drivers/char/agp/amd-k7-agp.c:		if (pdev->revision == 0x10 || pdev->revision == 0x11) {
drivers/char/agp/amd-k7-agp.c:			dev_info(&pdev->dev, "AMD 761 chipset with errata; disabling AGP fast writes & SBA and forcing to 1X\n");
drivers/char/agp/nvidia-agp.c:		pci_get_bus_and_slot((unsigned int)pdev->bus->number, PCI_DEVFN(0, 1));
drivers/char/agp/nvidia-agp.c:		pci_get_bus_and_slot((unsigned int)pdev->bus->number, PCI_DEVFN(0, 2));
drivers/char/agp/nvidia-agp.c:		pci_get_bus_and_slot((unsigned int)pdev->bus->number, PCI_DEVFN(30, 0));
drivers/char/agp/nvidia-agp.c:	switch (pdev->device) {
drivers/char/agp/nvidia-agp.c:			    pdev->device);
drivers/char/agp/uninorth-agp.c:		if (device->bus != pdev->bus)
drivers/char/agp/uninorth-agp.c:		dev_info(&pdev->dev, "disabling AGP on device %s\n",
drivers/char/agp/uninorth-agp.c:		dev_info(&pdev->dev, "disabling AGP on bridge\n");
drivers/char/agp/uninorth-agp.c:		if (pdev->device == devs[j].device_id) {
drivers/char/agp/uninorth-agp.c:			dev_info(&pdev->dev, "Apple %s chipset\n",
drivers/char/agp/uninorth-agp.c:	dev_err(&pdev->dev, "unsupported Apple chipset [%04x/%04x]\n",
drivers/char/agp/uninorth-agp.c:		pdev->vendor, pdev->device);
drivers/char/agp/sgi-agp.c:		if (bridge->dev->bus == pdev->bus)
drivers/char/agp/sgi-agp.c:			if (pdev->class != (PCI_CLASS_DISPLAY_VGA << 8))
drivers/char/agp/alpha-agp.c:	pdev->vendor = 0xffff;
drivers/char/agp/alpha-agp.c:	pdev->device = 0xffff;
drivers/char/agp/alpha-agp.c:	pdev->sysdata = agp->hose;
drivers/char/agp/efficeon-agp.c:	if (pdev->device != PCI_DEVICE_ID_EFFICEON) {
drivers/char/agp/efficeon-agp.c:		    pdev->device);
drivers/char/agp/efficeon-agp.c:	r = &pdev->resource[0];
drivers/char/agp/ati-agp.c:		if (pdev->device == devs[j].device_id)
drivers/char/agp/ati-agp.c:	dev_err(&pdev->dev, "unsupported Ati chipset [%04x/%04x])\n",
drivers/char/agp/ati-agp.c:		pdev->vendor, pdev->device);
drivers/char/agp/ati-agp.c:	dev_info(&pdev->dev, "Ati %s chipset\n", devs[j].chipset_name);
drivers/char/agp/intel-agp.c:		if (pdev->device == intel_agp_chipsets[i].chip_id) {
drivers/char/agp/intel-agp.c:			dev_warn(&pdev->dev, "unsupported Intel chipset [%04x/%04x]\n",
drivers/char/agp/intel-agp.c:				 pdev->vendor, pdev->device);
drivers/char/agp/intel-agp.c:	dev_info(&pdev->dev, "Intel %s Chipset\n", intel_agp_chipsets[i].name);
drivers/char/agp/intel-agp.c:	r = &pdev->resource[0];
drivers/char/agp/intel-agp.c:			dev_err(&pdev->dev, "can't assign resource 0\n");
drivers/char/agp/intel-agp.c:		dev_err(&pdev->dev, "can't enable PCI device\n");
drivers/char/agp/ali-agp.c:		if (pdev->device == devs[j].device_id)
drivers/char/agp/ali-agp.c:	dev_err(&pdev->dev, "unsupported ALi chipset [%04x/%04x])\n",
drivers/char/agp/ali-agp.c:		pdev->vendor, pdev->device);
drivers/char/agp/ali-agp.c:	switch (pdev->device) {
drivers/char/agp/ali-agp.c:	dev_info(&pdev->dev, "ALi %s chipset\n", devs[j].chipset_name);
drivers/char/agp/sworks-agp.c:	switch (pdev->device) {
drivers/char/agp/sworks-agp.c:		dev_err(&pdev->dev, "ServerWorks CNB20HE is unsupported due to lack of documentation\n");
drivers/char/agp/sworks-agp.c:			dev_err(&pdev->dev, "unsupported Serverworks chipset "
drivers/char/agp/sworks-agp.c:				"[%04x/%04x]\n", pdev->vendor, pdev->device);
drivers/char/agp/sworks-agp.c:	bridge_dev = pci_get_bus_and_slot((unsigned int)pdev->bus->number,
drivers/char/agp/sworks-agp.c:		dev_info(&pdev->dev, "can't find secondary device\n");
drivers/char/agp/sworks-agp.c:			dev_info(&pdev->dev, "64 bit aperture address, "
drivers/char/agp/sworks-agp.c:			dev_info(&pdev->dev, "64 bit MMIO address, but top "
drivers/char/agp/via-agp.c:	if (pdev->device == PCI_DEVICE_ID_VIA_8367_0) {
drivers/char/agp/via-agp.c:		if (pdev->subsystem_device == PCI_DEVICE_ID_VIA_8377_0) {
drivers/char/agp/intel-gtt.c:			if (gpu_pdev->device ==
drivers/char/agp/intel-gtt.c:	dev_info(&bridge_pdev->dev, "Intel %s Chipset\n", intel_gtt_chipsets[i].name);
drivers/char/ppdev.c:	struct parport *port = pp->pdev->port;
drivers/char/ppdev.c:	pport = pp->pdev->port;
drivers/char/ppdev.c:	pport = pp->pdev->port;
drivers/char/ppdev.c:			wrote = parport_write (pp->pdev->port, kbuffer, n);
drivers/char/ppdev.c:		parport_write_control (pp->pdev->port, pp->irqctl);
drivers/char/ppdev.c:		info = &pp->pdev->port->ieee1284;
drivers/char/ppdev.c:			pp->pdev->port->ieee1284.mode = mode;
drivers/char/ppdev.c:			pp->pdev->port->ieee1284.phase = pp->state.phase;
drivers/char/ppdev.c:			mode = pp->pdev->port->ieee1284.mode;
drivers/char/ppdev.c:			pp->pdev->port->ieee1284.phase = phase;
drivers/char/ppdev.c:			phase = pp->pdev->port->ieee1284.phase;
drivers/char/ppdev.c:	port = pp->pdev->port;
drivers/char/ppdev.c:		info = &pp->pdev->port->ieee1284;
drivers/char/ppdev.c:		/* Convert to jiffies, place in pp->pdev->timeout */
drivers/char/ppdev.c:		pp->pdev->timeout = to_jiffies;
drivers/char/ppdev.c:		to_jiffies = pp->pdev->timeout;
drivers/char/ppdev.c:		info = &pp->pdev->port->ieee1284;
drivers/char/ppdev.c:	    (pp->pdev->port->ieee1284.mode != IEEE1284_MODE_COMPAT)) {
drivers/char/ppdev.c:		parport_negotiate (pp->pdev->port, IEEE1284_MODE_COMPAT);
drivers/char/ppdev.c:		info = &pp->pdev->port->ieee1284;
drivers/char/ppdev.c:		const char *name = pp->pdev->name;
drivers/tty/cyclades.c:	retval = request_firmware(&fw, "cyzfirm.bin", &pdev->dev);
drivers/tty/cyclades.c:		dev_err(&pdev->dev, "can't get firmware\n");
drivers/tty/cyclades.c:			dev_dbg(&pdev->dev, "Cyclades-Z FW already loaded. "
drivers/tty/cyclades.c:			dev_err(&pdev->dev, "fw upload successful, but fw is "
drivers/tty/cyclades.c:			dev_err(&pdev->dev, "you need an external power supply "
drivers/tty/cyclades.c:		dev_warn(&pdev->dev, "fid->signature = 0x%x... Waiting "
drivers/tty/cyclades.c:			dev_err(&pdev->dev, "Board not started in 20 seconds! "
drivers/tty/cyclades.c:			dev_info(&pdev->dev, "*** Warning ***: if you are "
drivers/tty/cyclades.c:		dev_dbg(&pdev->dev, "Firmware started after %d seconds.\n",
drivers/tty/cyclades.c:	dev_dbg(&pdev->dev, "fid=> %p, zfwctrl_addr=> %x, npt_zfwctrl=> %p\n",
drivers/tty/cyclades.c:	dev_info(&pdev->dev, "Cyclades-Z FW loaded: version = %x, ports = %u\n",
drivers/tty/cyclades.c:		dev_warn(&pdev->dev, "no Cyclades-Z ports were found. Please "
drivers/tty/cyclades.c:		dev_info(&pdev->dev, "Null number of ports detected. Board "
drivers/tty/cyclades.c:		dev_err(&pdev->dev, "cannot enable device\n");
drivers/tty/cyclades.c:	irq = pdev->irq;
drivers/tty/cyclades.c:	device_id = pdev->device & ~PCI_DEVICE_ID_MASK;
drivers/tty/cyclades.c:		dev_err(&pdev->dev, "Cyclom-Y/PCI not supported for low "
drivers/tty/cyclades.c:		dev_err(&pdev->dev, "Cyclades-Z/PCI not supported for low "
drivers/tty/cyclades.c:		dev_warn(&pdev->dev, "PCI I/O bit incorrectly set. Ignoring "
drivers/tty/cyclades.c:		pdev->resource[2].flags &= ~IORESOURCE_IO;
drivers/tty/cyclades.c:		dev_err(&pdev->dev, "failed to reserve resources\n");
drivers/tty/cyclades.c:			dev_err(&pdev->dev, "can't remap ctl region\n");
drivers/tty/cyclades.c:			dev_err(&pdev->dev, "can't remap base region\n");
drivers/tty/cyclades.c:			dev_err(&pdev->dev, "Cyclom-Y PCI host card with no "
drivers/tty/cyclades.c:			dev_err(&pdev->dev, "can't remap ctl region\n");
drivers/tty/cyclades.c:			dev_err(&pdev->dev, "can't remap base region\n");
drivers/tty/cyclades.c:				dev_info(&pdev->dev, "Cyclades-8Zo/PCI: FPGA "
drivers/tty/cyclades.c:				dev_info(&pdev->dev, "Cyclades-Z/PCI: New "
drivers/tty/cyclades.c:		dev_err(&pdev->dev, "Cyclades-8Zo/PCI found, but no "
drivers/tty/cyclades.c:		dev_err(&pdev->dev, "Cyclades-8Zo/PCI found, but no "
drivers/tty/cyclades.c:			dev_err(&pdev->dev, "could not allocate IRQ\n");
drivers/tty/cyclades.c:				dev_err(&pdev->dev, "could not allocate IRQ\n");
drivers/tty/cyclades.c:	dev_info(&pdev->dev, "%s/PCI #%d found: %d channels starting from "
drivers/tty/cyclades.c:				cy_serial_driver, i, &pdev->dev);
drivers/tty/isicom.c:	dev_dbg(&pdev->dev, "ISILoad:Resetting Card%d at 0x%lx\n", card + 1,
drivers/tty/isicom.c:		dev_warn(&pdev->dev, "ISILoad:Card%u reset failure (Possible "
drivers/tty/isicom.c:		dev_dbg(&pdev->dev, "Sig=0x%x\n", sig);
drivers/tty/isicom.c:		dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure.\n",
drivers/tty/isicom.c:	dev_info(&pdev->dev, "-Done\n");
drivers/tty/isicom.c:		dev_err(&pdev->dev, "Unknown signature.\n");
drivers/tty/isicom.c:	retval = request_firmware(&fw, name, &pdev->dev);
drivers/tty/isicom.c:			dev_warn(&pdev->dev, "Card%d rejected load header:\n"
drivers/tty/isicom.c:			dev_err(&pdev->dev, "Card%d got out of sync.Card "
drivers/tty/isicom.c:			dev_warn(&pdev->dev, "Card%d rejected verify header:\n"
drivers/tty/isicom.c:			dev_err(&pdev->dev, "Card%d, firmware upload "
drivers/tty/isicom.c:				dev_err(&pdev->dev, "Card%d, firmware upload "
drivers/tty/isicom.c:			dev_err(&pdev->dev, "Card%d verify got out of sync. "
drivers/tty/isicom.c:		dev_err(&pdev->dev, "failed to enable\n");
drivers/tty/isicom.c:	dev_info(&pdev->dev, "ISI PCI Card(Device ID 0x%x)\n", ent->device);
drivers/tty/isicom.c:	board->irq = pdev->irq;
drivers/tty/isicom.c:		dev_err(&pdev->dev, "I/O Region 0x%lx-0x%lx is busy. Card%d "
drivers/tty/isicom.c:		dev_err(&pdev->dev, "Could not install handler at Irq %d. "
drivers/tty/isicom.c:				board->index * 16 + index, &pdev->dev);
drivers/tty/nozomi.c:		dev_err(&dc->pdev->dev, "ConfigTable Bad! 0x%08X != 0x%08X\n",
drivers/tty/nozomi.c:		dev_info(&dc->pdev->dev, "Initialization OK!\n");
drivers/tty/nozomi.c:		dev_info(&dc->pdev->dev, "Version of card: %d\n",
drivers/tty/nozomi.c:		dev_err(&dc->pdev->dev, "Called with wrong port?\n");
drivers/tty/nozomi.c:		dev_err(&dc->pdev->dev, "Called with wrong port?\n");
drivers/tty/nozomi.c:		dev_err(&dc->pdev->dev, "Called with wrong port?\n");
drivers/tty/nozomi.c:		dev_err(&dc->pdev->dev, "Called with wrong port?\n");
drivers/tty/nozomi.c:		dev_err(&dc->pdev->dev, "size == 0?\n");
drivers/tty/nozomi.c:			dev_info(&dc->pdev->dev, "Device READY!\n");
drivers/tty/nozomi.c:		dev_err(&dc->pdev->dev,
drivers/tty/nozomi.c:		dev_err(&dc->pdev->dev,
drivers/tty/nozomi.c:		dev_err(&dc->pdev->dev, "port out of sync!, toggle:%d\n",
drivers/tty/nozomi.c:		dev_err(&dc->pdev->dev, "port out of sync!\n");
drivers/tty/nozomi.c:			dev_err(&dc->pdev->dev, "Could not read status from "
drivers/tty/nozomi.c:			dev_err(&dc->pdev->dev, "MDM_DL out of sync!\n");
drivers/tty/nozomi.c:			dev_err(&dc->pdev->dev, "MDM_UL out of sync!\n");
drivers/tty/nozomi.c:			dev_err(&dc->pdev->dev, "DIAG_DL out of sync!\n");
drivers/tty/nozomi.c:	dev_info(&dc->pdev->dev, "Card type is: %d\n", dc->card_type);
drivers/tty/nozomi.c:	if (device_create_file(&dc->pdev->dev, &dev_attr_card_type))
drivers/tty/nozomi.c:		dev_err(&dc->pdev->dev,
drivers/tty/nozomi.c:	if (device_create_file(&dc->pdev->dev, &dev_attr_open_ttys))
drivers/tty/nozomi.c:		dev_err(&dc->pdev->dev,
drivers/tty/nozomi.c:	device_remove_file(&dc->pdev->dev, &dev_attr_card_type);
drivers/tty/nozomi.c:	device_remove_file(&dc->pdev->dev, &dev_attr_open_ttys);
drivers/tty/nozomi.c:	dev_dbg(&pdev->dev, "Init, new card found\n");
drivers/tty/nozomi.c:		dev_err(&pdev->dev, "no free tty range for this card left\n");
drivers/tty/nozomi.c:		dev_err(&pdev->dev, "Could not allocate memory\n");
drivers/tty/nozomi.c:		dev_err(&pdev->dev, "Failed to enable PCI Device\n");
drivers/tty/nozomi.c:		dev_err(&pdev->dev, "I/O address 0x%04x already in use\n",
drivers/tty/nozomi.c:		dev_err(&pdev->dev, "No I/O address for card detected\n");
drivers/tty/nozomi.c:		dev_err(&pdev->dev, "Unable to map card MMIO\n");
drivers/tty/nozomi.c:		dev_err(&pdev->dev, "Could not allocate send buffer?\n");
drivers/tty/nozomi.c:			dev_err(&pdev->dev,
drivers/tty/nozomi.c:	ret = request_irq(pdev->irq, &interrupt_handler, IRQF_SHARED,
drivers/tty/nozomi.c:		dev_err(&pdev->dev, "can't request irq %d\n", pdev->irq);
drivers/tty/nozomi.c:				dc->index_start + i, &pdev->dev);
drivers/tty/nozomi.c:			dev_err(&pdev->dev, "Could not allocate tty?\n");
drivers/tty/nozomi.c:	free_irq(pdev->irq, dc);
drivers/tty/nozomi.c:			dev_err(&dc->pdev->dev,
drivers/tty/mxser.c:		dev_err(&pdev->dev, "too many boards found (maximum %d), board "
drivers/tty/mxser.c:	dev_info(&pdev->dev, "found MOXA %s board (BusNo=%d, DevNo=%d)\n",
drivers/tty/mxser.c:		pdev->bus->number, PCI_SLOT(pdev->devfn));
drivers/tty/mxser.c:		dev_err(&pdev->dev, "PCI enable failed\n");
drivers/tty/mxser.c:	brd->irq = pdev->irq;
drivers/tty/mxser.c:				mxvar_sdriver, brd->idx + i, &pdev->dev);
drivers/tty/serial/atmel_serial.c:	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
drivers/tty/serial/atmel_serial.c:	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
drivers/tty/serial/atmel_serial.c:	struct atmel_uart_data *pdata = pdev->dev.platform_data;
drivers/tty/serial/atmel_serial.c:	if (pdev->dev.of_node) {
drivers/tty/serial/atmel_serial.c:		atmel_of_init_port(atmel_port, pdev->dev.of_node);
drivers/tty/serial/atmel_serial.c:	port->dev		= &pdev->dev;
drivers/tty/serial/atmel_serial.c:	port->mapbase	= pdev->resource[0].start;
drivers/tty/serial/atmel_serial.c:	port->irq	= pdev->resource[1].start;
drivers/tty/serial/atmel_serial.c:		atmel_port->clk = clk_get(&pdev->dev, "usart");
drivers/tty/serial/atmel_serial.c:	atmel_port->may_wakeup = device_may_wakeup(&pdev->dev);
drivers/tty/serial/atmel_serial.c:		device_set_wakeup_enable(&pdev->dev, 0);
drivers/tty/serial/atmel_serial.c:	device_set_wakeup_enable(&pdev->dev, atmel_port->may_wakeup);
drivers/tty/serial/atmel_serial.c:	struct device_node *np = pdev->dev.of_node;
drivers/tty/serial/atmel_serial.c:	struct atmel_uart_data *pdata = pdev->dev.platform_data;
drivers/tty/serial/atmel_serial.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/tty/serial/atmel_serial.c:	device_init_wakeup(&pdev->dev, 1);
drivers/tty/serial/atmel_serial.c:	device_init_wakeup(&pdev->dev, 0);
drivers/tty/serial/altera_uart.c:	clk = of_get_property(pdev->dev.of_node, "clock-frequency", &len);
drivers/tty/serial/altera_uart.c:	struct altera_uart_platform_uart *platp = pdev->dev.platform_data;
drivers/tty/serial/altera_uart.c:	int i = pdev->id;
drivers/tty/serial/pmac_zilog.c:	uap->port.dev = &pdev->dev;
drivers/tty/serial/bfin_sport_uart.c:	dev_dbg(&pdev->dev, "%s enter\n", __func__);
drivers/tty/serial/bfin_sport_uart.c:	if (pdev->id < 0 || pdev->id >= BFIN_SPORT_UART_MAX_PORTS) {
drivers/tty/serial/bfin_sport_uart.c:		dev_err(&pdev->dev, "Wrong sport uart platform device id.\n");
drivers/tty/serial/bfin_sport_uart.c:	if (bfin_sport_uart_ports[pdev->id] == NULL) {
drivers/tty/serial/bfin_sport_uart.c:		bfin_sport_uart_ports[pdev->id] =
drivers/tty/serial/bfin_sport_uart.c:		sport = bfin_sport_uart_ports[pdev->id];
drivers/tty/serial/bfin_sport_uart.c:			dev_err(&pdev->dev,
drivers/tty/serial/bfin_sport_uart.c:			(unsigned short *)pdev->dev.platform_data, DRV_NAME);
drivers/tty/serial/bfin_sport_uart.c:			dev_err(&pdev->dev,
drivers/tty/serial/bfin_sport_uart.c:		sport->port.line      = pdev->id;
drivers/tty/serial/bfin_sport_uart.c:			dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
drivers/tty/serial/bfin_sport_uart.c:			dev_err(&pdev->dev, "Cannot map sport IO\n");
drivers/tty/serial/bfin_sport_uart.c:			dev_err(&pdev->dev, "No sport RX/TX IRQ specified\n");
drivers/tty/serial/bfin_sport_uart.c:			dev_err(&pdev->dev, "No sport status IRQ specified\n");
drivers/tty/serial/bfin_sport_uart.c:		sport = bfin_sport_uart_ports[pdev->id];
drivers/tty/serial/bfin_sport_uart.c:		sport->port.dev = &pdev->dev;
drivers/tty/serial/bfin_sport_uart.c:		dev_set_drvdata(&pdev->dev, sport);
drivers/tty/serial/bfin_sport_uart.c:			(unsigned short *)pdev->dev.platform_data);
drivers/tty/serial/bfin_sport_uart.c:		bfin_sport_uart_ports[pdev->id] = NULL;
drivers/tty/serial/bfin_sport_uart.c:	dev_dbg(&pdev->dev, "%s enter\n", __func__);
drivers/tty/serial/bfin_sport_uart.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/tty/serial/bfin_sport_uart.c:			(unsigned short *)pdev->dev.platform_data);
drivers/tty/serial/bfin_sport_uart.c:		bfin_sport_uart_ports[pdev->id] = NULL;
drivers/tty/serial/jsm/jsm_driver.c:		dev_err(&pdev->dev, "Device enable FAILED\n");
drivers/tty/serial/jsm/jsm_driver.c:		dev_err(&pdev->dev, "pci_request_region FAILED\n");
drivers/tty/serial/jsm/jsm_driver.c:		dev_err(&pdev->dev,
drivers/tty/serial/jsm/jsm_driver.c:	if (pdev->device == PCIE_DEVICE_ID_NEO_4_IBM)
drivers/tty/serial/jsm/jsm_driver.c:	else if (pdev->device == PCI_DEVICE_ID_DIGI_NEO_8)
drivers/tty/serial/jsm/jsm_driver.c:	brd->rev = pdev->revision;
drivers/tty/serial/jsm/jsm_driver.c:	brd->irq = pdev->irq;
drivers/tty/serial/jsm/jsm_driver.c:		dev_err(&pdev->dev,
drivers/tty/serial/jsm/jsm_driver.c:		dev_err(&pdev->dev, "Can't init tty devices (%d)\n", rc);
drivers/tty/serial/jsm/jsm_driver.c:		dev_err(&pdev->dev, "Can't init uart port (%d)\n", rc);
drivers/tty/serial/jsm/jsm_driver.c:	dev_info(&pdev->dev, "board %d: Digi Neo (rev %d), irq %d\n",
drivers/tty/serial/jsm/jsm.h:		dev_dbg(pdev->dev, fmt, ##__VA_ARGS__);		\
drivers/tty/serial/mxs-auart.c:	struct device_node *np = pdev->dev.of_node;
drivers/tty/serial/mxs-auart.c:		dev_err(&pdev->dev, "failed to get alias id: %d\n", ret);
drivers/tty/serial/mxs-auart.c:			of_match_device(mxs_auart_dt_ids, &pdev->dev);
drivers/tty/serial/mxs-auart.c:		s->port.line = pdev->id < 0 ? 0 : pdev->id;
drivers/tty/serial/mxs-auart.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/tty/serial/mxs-auart.c:		pdev->id_entry = of_id->data;
drivers/tty/serial/mxs-auart.c:		s->devtype = pdev->id_entry->driver_data;
drivers/tty/serial/mxs-auart.c:	s->clk = clk_get(&pdev->dev, NULL);
drivers/tty/serial/mxs-auart.c:	s->port.dev = s->dev = &pdev->dev;
drivers/tty/serial/mxs-auart.c:	ret = request_irq(s->irq, mxs_auart_irq_handle, 0, dev_name(&pdev->dev), s);
drivers/tty/serial/mxs-auart.c:	dev_info(&pdev->dev, "Found APPUART %d.%d.%d\n",
drivers/tty/serial/mxs-auart.c:	auart_port[pdev->id] = NULL;
drivers/tty/serial/mxs-auart.c:	auart_port[pdev->id] = NULL;
drivers/tty/serial/imx.c:	struct device_node *np = pdev->dev.of_node;
drivers/tty/serial/imx.c:			of_match_device(imx_uart_dt_ids, &pdev->dev);
drivers/tty/serial/imx.c:		dev_err(&pdev->dev, "failed to get alias id, errno %d\n", ret);
drivers/tty/serial/imx.c:	struct imxuart_platform_data *pdata = pdev->dev.platform_data;
drivers/tty/serial/imx.c:	sport->port.line = pdev->id;
drivers/tty/serial/imx.c:	sport->devdata = (struct imx_uart_data	*) pdev->id_entry->driver_data;
drivers/tty/serial/imx.c:	sport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);
drivers/tty/serial/imx.c:	base = devm_ioremap(&pdev->dev, res->start, PAGE_SIZE);
drivers/tty/serial/imx.c:	sport->port.dev = &pdev->dev;
drivers/tty/serial/imx.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/tty/serial/imx.c:		dev_err(&pdev->dev, "failed to get default pinctrl: %d\n", ret);
drivers/tty/serial/imx.c:	sport->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
drivers/tty/serial/imx.c:		dev_err(&pdev->dev, "failed to get ipg clk: %d\n", ret);
drivers/tty/serial/imx.c:	sport->clk_per = devm_clk_get(&pdev->dev, "per");
drivers/tty/serial/imx.c:		dev_err(&pdev->dev, "failed to get per clk: %d\n", ret);
drivers/tty/serial/imx.c:	pdata = pdev->dev.platform_data;
drivers/tty/serial/imx.c:	pdata = pdev->dev.platform_data;
drivers/tty/serial/netx-serial.c:	struct uart_port *port = &netx_ports[pdev->id].port;
drivers/tty/serial/netx-serial.c:	dev_info(&pdev->dev, "initialising\n");
drivers/tty/serial/netx-serial.c:	port->dev = &pdev->dev;
drivers/tty/serial/netx-serial.c:	uart_add_one_port(&netx_reg, &netx_ports[pdev->id].port);
drivers/tty/serial/netx-serial.c:	platform_set_drvdata(pdev, &netx_ports[pdev->id]);
drivers/tty/serial/uartlite.c:	int id = pdev->id;
drivers/tty/serial/uartlite.c:	prop = of_get_property(pdev->dev.of_node, "port-number", NULL);
drivers/tty/serial/uartlite.c:	return ulite_assign(&pdev->dev, id, res->start, res2->start);
drivers/tty/serial/uartlite.c:	return ulite_release(&pdev->dev);
drivers/tty/serial/efm32-uart.c:	struct device_node *np = pdev->dev.of_node;
drivers/tty/serial/efm32-uart.c:			dev_err(&pdev->dev, "invalid location\n");
drivers/tty/serial/efm32-uart.c:		dev_err(&pdev->dev, "failed to get alias id: %d\n", ret);
drivers/tty/serial/efm32-uart.c:		dev_dbg(&pdev->dev, "failed to allocate private data\n");
drivers/tty/serial/efm32-uart.c:		dev_dbg(&pdev->dev, "failed to determine base address\n");
drivers/tty/serial/efm32-uart.c:		dev_dbg(&pdev->dev, "memory resource too small\n");
drivers/tty/serial/efm32-uart.c:		dev_dbg(&pdev->dev, "failed to get rx irq\n");
drivers/tty/serial/efm32-uart.c:	efm_port->port.dev = &pdev->dev;
drivers/tty/serial/efm32-uart.c:		const struct efm32_uart_pdata *pdata = dev_get_platdata(&pdev->dev);
drivers/tty/serial/efm32-uart.c:		efm_port->port.line = pdev->id;
drivers/tty/serial/efm32-uart.c:		dev_dbg(&pdev->dev, "failed to add port: %d\n", ret);
drivers/tty/serial/efm32-uart.c:		if (pdev->id >= 0 && pdev->id < ARRAY_SIZE(efm32_uart_ports))
drivers/tty/serial/efm32-uart.c:			efm32_uart_ports[pdev->id] = NULL;
drivers/tty/serial/efm32-uart.c:		dev_dbg(&pdev->dev, "\\o/\n");
drivers/tty/serial/efm32-uart.c:	if (pdev->id >= 0 && pdev->id < ARRAY_SIZE(efm32_uart_ports))
drivers/tty/serial/efm32-uart.c:		efm32_uart_ports[pdev->id] = NULL;
drivers/tty/serial/serial-tegra.c:	struct device_node *np = pdev->dev.of_node;
drivers/tty/serial/serial-tegra.c:		dev_err(&pdev->dev, "missing dma requestor in device tree\n");
drivers/tty/serial/serial-tegra.c:		dev_err(&pdev->dev, "failed to get alias id, errno %d\n", port);
drivers/tty/serial/serial-tegra.c:	match = of_match_device(tegra_uart_of_match, &pdev->dev);
drivers/tty/serial/serial-tegra.c:		dev_err(&pdev->dev, "Error: No device match found\n");
drivers/tty/serial/serial-tegra.c:	tup = devm_kzalloc(&pdev->dev, sizeof(*tup), GFP_KERNEL);
drivers/tty/serial/serial-tegra.c:		dev_err(&pdev->dev, "Failed to allocate memory for tup\n");
drivers/tty/serial/serial-tegra.c:	u->dev = &pdev->dev;
drivers/tty/serial/serial-tegra.c:		dev_err(&pdev->dev, "No IO memory resource\n");
drivers/tty/serial/serial-tegra.c:	u->membase = devm_ioremap_resource(&pdev->dev, resource);
drivers/tty/serial/serial-tegra.c:	tup->uart_clk = devm_clk_get(&pdev->dev, NULL);
drivers/tty/serial/serial-tegra.c:		dev_err(&pdev->dev, "Couldn't get the clock\n");
drivers/tty/serial/serial-tegra.c:		dev_err(&pdev->dev, "Failed to add uart port, err %d\n", ret);
drivers/tty/serial/arc_uart.c:	plat_data = ((unsigned long *)(pdev->dev.platform_data));
drivers/tty/serial/arc_uart.c:		struct device_node *np = pdev->dev.of_node;
drivers/tty/serial/arc_uart.c:			dev_err(&pdev->dev, "clock-frequency property NOTset\n");
drivers/tty/serial/arc_uart.c:			dev_err(&pdev->dev, "current-speed property NOT set\n");
drivers/tty/serial/arc_uart.c:	uart->port.dev = &pdev->dev;
drivers/tty/serial/arc_uart.c:	int dev_id = pdev->id < 0 ? 0 : pdev->id;
drivers/tty/serial/arc_uart.c:	struct device_node *np = pdev->dev.of_node;
drivers/tty/serial/sccnxp.c:	int chiptype = pdev->id_entry->driver_data;
drivers/tty/serial/sccnxp.c:	struct sccnxp_pdata *pdata = dev_get_platdata(&pdev->dev);
drivers/tty/serial/sccnxp.c:		dev_err(&pdev->dev, "Missing memory resource data\n");
drivers/tty/serial/sccnxp.c:	s = devm_kzalloc(&pdev->dev, sizeof(struct sccnxp_port), GFP_KERNEL);
drivers/tty/serial/sccnxp.c:		dev_err(&pdev->dev, "Error allocating port structure\n");
drivers/tty/serial/sccnxp.c:		dev_err(&pdev->dev, "Unsupported chip type %i\n", chiptype);
drivers/tty/serial/sccnxp.c:		dev_warn(&pdev->dev,
drivers/tty/serial/sccnxp.c:		dev_info(&pdev->dev, "Using poll mode, resolution %u usecs\n",
drivers/tty/serial/sccnxp.c:			dev_err(&pdev->dev, "Missing irq resource data\n");
drivers/tty/serial/sccnxp.c:		dev_err(&pdev->dev, "Frequency out of bounds\n");
drivers/tty/serial/sccnxp.c:	s->regulator = devm_regulator_get(&pdev->dev, "VCC");
drivers/tty/serial/sccnxp.c:			dev_err(&pdev->dev,
drivers/tty/serial/sccnxp.c:	membase = devm_ioremap_resource(&pdev->dev, res);
drivers/tty/serial/sccnxp.c:		dev_err(&pdev->dev, "Registering UART driver failed\n");
drivers/tty/serial/sccnxp.c:		s->port[i].dev		= &pdev->dev;
drivers/tty/serial/sccnxp.c:		ret = devm_request_threaded_irq(&pdev->dev, s->irq, NULL,
drivers/tty/serial/sccnxp.c:						dev_name(&pdev->dev), s);
drivers/tty/serial/sccnxp.c:		dev_err(&pdev->dev, "Unable to reguest IRQ %i\n", s->irq);
drivers/tty/serial/sccnxp.c:		devm_free_irq(&pdev->dev, s->irq, s);
drivers/tty/serial/omap-serial.c:	struct omap_uart_port_info *omap_up_info = pdev->dev.platform_data;
drivers/tty/serial/omap-serial.c:	if (pdev->dev.of_node)
drivers/tty/serial/omap-serial.c:		omap_up_info = of_get_uart_port_info(&pdev->dev);
drivers/tty/serial/omap-serial.c:		dev_err(&pdev->dev, "no mem resource?\n");
drivers/tty/serial/omap-serial.c:		dev_err(&pdev->dev, "no irq resource?\n");
drivers/tty/serial/omap-serial.c:	if (!devm_request_mem_region(&pdev->dev, mem->start, resource_size(mem),
drivers/tty/serial/omap-serial.c:				pdev->dev.driver->name)) {
drivers/tty/serial/omap-serial.c:		dev_err(&pdev->dev, "memory region already claimed\n");
drivers/tty/serial/omap-serial.c:	up = devm_kzalloc(&pdev->dev, sizeof(*up), GFP_KERNEL);
drivers/tty/serial/omap-serial.c:	up->dev = &pdev->dev;
drivers/tty/serial/omap-serial.c:	up->port.dev = &pdev->dev;
drivers/tty/serial/omap-serial.c:	if (pdev->dev.of_node)
drivers/tty/serial/omap-serial.c:		up->port.line = of_alias_get_id(pdev->dev.of_node, "serial");
drivers/tty/serial/omap-serial.c:		up->port.line = pdev->id;
drivers/tty/serial/omap-serial.c:		dev_err(&pdev->dev, "failed to get alias/pdev id, errno %d\n",
drivers/tty/serial/omap-serial.c:	up->pins = devm_pinctrl_get_select_default(&pdev->dev);
drivers/tty/serial/omap-serial.c:		dev_warn(&pdev->dev, "did not get pins for uart%i error: %li\n",
drivers/tty/serial/omap-serial.c:	up->port.membase = devm_ioremap(&pdev->dev, mem->start,
drivers/tty/serial/omap-serial.c:		dev_err(&pdev->dev, "can't ioremap UART\n");
drivers/tty/serial/omap-serial.c:		dev_warn(&pdev->dev, "No clock speed specified: using default:"
drivers/tty/serial/omap-serial.c:	pm_runtime_enable(&pdev->dev);
drivers/tty/serial/omap-serial.c:	pm_runtime_use_autosuspend(&pdev->dev);
drivers/tty/serial/omap-serial.c:	pm_runtime_set_autosuspend_delay(&pdev->dev,
drivers/tty/serial/omap-serial.c:	pm_runtime_irq_safe(&pdev->dev);
drivers/tty/serial/omap-serial.c:	pm_runtime_get_sync(&pdev->dev);
drivers/tty/serial/omap-serial.c:	pm_runtime_put(&pdev->dev);
drivers/tty/serial/omap-serial.c:	pm_runtime_disable(&pdev->dev);
drivers/tty/serial/omap-serial.c:	dev_err(&pdev->dev, "[UART%d]: failure [%s]: %d\n",
drivers/tty/serial/omap-serial.c:				pdev->id, __func__, ret);
drivers/tty/serial/8250/8250_dw.c:		dev_err(&pdev->dev, "no registers/irq defined\n");
drivers/tty/serial/8250/8250_dw.c:	uart.port.dev = &pdev->dev;
drivers/tty/serial/8250/8250_dw.c:	uart.port.membase = devm_ioremap(&pdev->dev, regs->start,
drivers/tty/serial/8250/8250_dw.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/tty/serial/8250/8250_dw.c:	data->clk = devm_clk_get(&pdev->dev, NULL);
drivers/tty/serial/8250/8250_dw.c:	if (pdev->dev.of_node) {
drivers/tty/serial/8250/8250_dw.c:	} else if (ACPI_HANDLE(&pdev->dev)) {
drivers/tty/serial/8250/8250_dw.c:	pm_runtime_set_active(&pdev->dev);
drivers/tty/serial/8250/8250_dw.c:	pm_runtime_enable(&pdev->dev);
drivers/tty/serial/8250/8250_dw.c:	pm_runtime_get_sync(&pdev->dev);
drivers/tty/serial/8250/8250_dw.c:	pm_runtime_disable(&pdev->dev);
drivers/tty/serial/8250/8250_dw.c:	pm_runtime_put_noidle(&pdev->dev);
drivers/tty/serial/8250/8250_em.c:		dev_err(&pdev->dev, "missing registers or irq\n");
drivers/tty/serial/8250/8250_em.c:		dev_err(&pdev->dev, "unable to allocate private data\n");
drivers/tty/serial/8250/8250_em.c:	priv->sclk = clk_get(&pdev->dev, "sclk");
drivers/tty/serial/8250/8250_em.c:		dev_err(&pdev->dev, "unable to get clock\n");
drivers/tty/serial/8250/8250_em.c:	up.port.dev = &pdev->dev;
drivers/tty/serial/8250/8250_em.c:		dev_err(&pdev->dev, "unable to register 8250 port\n");
drivers/tty/serial/vt8500_serial.c: * have been allocated as we can't use pdev->id in
drivers/tty/serial/vt8500_serial.c:	struct device_node *np = pdev->dev.of_node;
drivers/tty/serial/vt8500_serial.c:	vt8500_port = devm_kzalloc(&pdev->dev, sizeof(struct vt8500_port),
drivers/tty/serial/vt8500_serial.c:	vt8500_port->uart.membase = devm_ioremap_resource(&pdev->dev, mmres);
drivers/tty/serial/vt8500_serial.c:	vt8500_port->clk = of_clk_get(pdev->dev.of_node, 0);
drivers/tty/serial/vt8500_serial.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/tty/serial/vt8500_serial.c:		dev_err(&pdev->dev, "failed to enable clock\n");
drivers/tty/serial/vt8500_serial.c:	vt8500_port->uart.dev = &pdev->dev;
drivers/tty/serial/vt8500_serial.c:		 "VT8500 UART%d", pdev->id);
drivers/tty/serial/clps711x.c:	s = devm_kzalloc(&pdev->dev, sizeof(struct clps711x_port), GFP_KERNEL);
drivers/tty/serial/clps711x.c:		dev_err(&pdev->dev, "Error allocating port structure\n");
drivers/tty/serial/clps711x.c:	s->uart_clk = devm_clk_get(&pdev->dev, "uart");
drivers/tty/serial/clps711x.c:		dev_err(&pdev->dev, "Can't get UART clocks\n");
drivers/tty/serial/clps711x.c:		dev_err(&pdev->dev, "Registering UART driver failed\n");
drivers/tty/serial/clps711x.c:		devm_clk_put(&pdev->dev, s->uart_clk);
drivers/tty/serial/clps711x.c:		s->port[i].dev		= &pdev->dev;
drivers/tty/serial/clps711x.c:	devm_clk_put(&pdev->dev, s->uart_clk);
drivers/tty/serial/bcm63xx_uart.c:	if (pdev->id < 0 || pdev->id >= BCM63XX_NR_UARTS)
drivers/tty/serial/bcm63xx_uart.c:	if (ports[pdev->id].membase)
drivers/tty/serial/bcm63xx_uart.c:	clk = clk_get(&pdev->dev, "periph");
drivers/tty/serial/bcm63xx_uart.c:	port = &ports[pdev->id];
drivers/tty/serial/bcm63xx_uart.c:	port->dev = &pdev->dev;
drivers/tty/serial/bcm63xx_uart.c:	port->line = pdev->id;
drivers/tty/serial/bcm63xx_uart.c:		ports[pdev->id].membase = 0;
drivers/tty/serial/bcm63xx_uart.c:	ports[pdev->id].membase = 0;
drivers/tty/serial/bfin_uart.c:	if (pdev->id < 0 || pdev->id >= BFIN_UART_NR_PORTS) {
drivers/tty/serial/bfin_uart.c:		dev_err(&pdev->dev, "Wrong bfin uart platform device id.\n");
drivers/tty/serial/bfin_uart.c:	if (bfin_serial_ports[pdev->id] == NULL) {
drivers/tty/serial/bfin_uart.c:			dev_err(&pdev->dev,
drivers/tty/serial/bfin_uart.c:		bfin_serial_ports[pdev->id] = uart;
drivers/tty/serial/bfin_uart.c:			&& bfin_earlyprintk_port.port.line == pdev->id)) {
drivers/tty/serial/bfin_uart.c:			(unsigned short *)pdev->dev.platform_data, DRIVER_NAME);
drivers/tty/serial/bfin_uart.c:			dev_err(&pdev->dev,
drivers/tty/serial/bfin_uart.c:		uart->port.line      = pdev->id;
drivers/tty/serial/bfin_uart.c:			dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
drivers/tty/serial/bfin_uart.c:			dev_err(&pdev->dev, "Cannot map uart IO\n");
drivers/tty/serial/bfin_uart.c:			dev_err(&pdev->dev, "No uart TX IRQ specified\n");
drivers/tty/serial/bfin_uart.c:			dev_err(&pdev->dev, "No uart RX IRQ specified\n");
drivers/tty/serial/bfin_uart.c:			dev_err(&pdev->dev, "No uart status IRQ specified\n");
drivers/tty/serial/bfin_uart.c:			dev_err(&pdev->dev, "No uart TX DMA channel specified\n");
drivers/tty/serial/bfin_uart.c:			dev_err(&pdev->dev, "No uart RX DMA channel specified\n");
drivers/tty/serial/bfin_uart.c:		uart = bfin_serial_ports[pdev->id];
drivers/tty/serial/bfin_uart.c:		uart->port.dev = &pdev->dev;
drivers/tty/serial/bfin_uart.c:		dev_set_drvdata(&pdev->dev, uart);
drivers/tty/serial/bfin_uart.c:			(unsigned short *)pdev->dev.platform_data);
drivers/tty/serial/bfin_uart.c:		bfin_serial_ports[pdev->id] = NULL;
drivers/tty/serial/bfin_uart.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/tty/serial/bfin_uart.c:			(unsigned short *)pdev->dev.platform_data);
drivers/tty/serial/bfin_uart.c:		bfin_serial_ports[pdev->id] = NULL;
drivers/tty/serial/bfin_uart.c:	if (pdev->id < 0 || pdev->id >= BFIN_UART_NR_PORTS) {
drivers/tty/serial/bfin_uart.c:		dev_err(&pdev->dev, "Wrong earlyprintk platform device id.\n");
drivers/tty/serial/bfin_uart.c:		(unsigned short *)pdev->dev.platform_data, DRIVER_NAME);
drivers/tty/serial/bfin_uart.c:		dev_err(&pdev->dev,
drivers/tty/serial/bfin_uart.c:		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
drivers/tty/serial/bfin_uart.c:		dev_err(&pdev->dev, "Cannot map uart IO\n");
drivers/tty/serial/bfin_uart.c:	bfin_earlyprintk_port.port.line = pdev->id;
drivers/tty/serial/bfin_uart.c:		(unsigned short *)pdev->dev.platform_data);
drivers/tty/serial/samsung.c:	if (pdev->dev.of_node) {
drivers/tty/serial/samsung.c:		match = of_match_node(s3c24xx_uart_dt_match, pdev->dev.of_node);
drivers/tty/serial/samsung.c:		dev_err(&pdev->dev, "could not find driver data\n");
drivers/tty/serial/samsung.c:	ourport->cfg = (pdev->dev.platform_data) ?
drivers/tty/serial/samsung.c:			(struct s3c2410_uartcfg *)pdev->dev.platform_data :
drivers/tty/serial/samsung.c:	ret = device_create_file(&pdev->dev, &dev_attr_clock_source);
drivers/tty/serial/samsung.c:		dev_err(&pdev->dev, "failed to add clock source attr.\n");
drivers/tty/serial/samsung.c:		dev_err(&pdev->dev, "failed to add cpufreq notifier\n");
drivers/tty/serial/ioc4_serial.c:		the_port->iobase = (pdev->bus->number << 16) |  port_num;
drivers/tty/serial/ioc4_serial.c:		the_port->dev = &pdev->dev;
drivers/tty/serial/ioc4_serial.c:			       __func__, the_port->line, pdev->bus->number);
drivers/tty/serial/ioc4_serial.c:			       the_port->line, the_port->irq, pdev->bus->number));
drivers/tty/serial/ioc4_serial.c:	if (!request_irq(idd->idd_pdev->irq, ioc4_intr, IRQF_SHARED,
drivers/tty/serial/ioc4_serial.c:		control->ic_irq = idd->idd_pdev->irq;
drivers/tty/serial/ioc4_serial.c:			__func__, idd->idd_pdev->irq);
drivers/tty/serial/lantiq.c:		dev_err(&pdev->dev, "cannot obtain I/O memory region");
drivers/tty/serial/lantiq.c:	res = devm_request_mem_region(&pdev->dev, res->start,
drivers/tty/serial/lantiq.c:		size, dev_name(&pdev->dev));
drivers/tty/serial/lantiq.c:		dev_err(&pdev->dev, "cannot request I/O memory region");
drivers/tty/serial/lantiq.c:		port->membase = devm_ioremap_nocache(&pdev->dev,
drivers/tty/serial/lantiq.c:	struct device_node *node = pdev->dev.of_node;
drivers/tty/serial/lantiq.c:		dev_err(&pdev->dev,
drivers/tty/serial/lantiq.c:		dev_err(&pdev->dev, "port %d already allocated\n", line);
drivers/tty/serial/lantiq.c:	ltq_port = devm_kzalloc(&pdev->dev, sizeof(struct ltq_uart_port),
drivers/tty/serial/lantiq.c:	port->dev	= &pdev->dev;
drivers/tty/serial/lantiq.c:	ltq_port->clk = clk_get(&pdev->dev, NULL);
drivers/tty/serial/ioc3_serial.c:		the_port->iobase = (pdev->bus->number << 16) |  ii;
drivers/tty/serial/ioc3_serial.c:		the_port->dev = &pdev->dev;
drivers/tty/serial/ioc3_serial.c:			       __func__, the_port->line, pdev->bus->number);
drivers/tty/serial/ioc3_serial.c:		          the_port->line, the_port->irq, pdev->bus->number));
drivers/tty/serial/mcf.c:	struct mcf_platform_uart *platp = pdev->dev.platform_data;
drivers/tty/serial/pxa.c:	struct device_node *np = pdev->dev.of_node;
drivers/tty/serial/pxa.c:		dev_err(&pdev->dev, "failed to get alias id, errno %d\n", ret);
drivers/tty/serial/lpc32xx_hs.c:		dev_err(&pdev->dev,
drivers/tty/serial/lpc32xx_hs.c:		dev_err(&pdev->dev,
drivers/tty/serial/lpc32xx_hs.c:		dev_err(&pdev->dev, "Error getting irq for HS UART port %d\n",
drivers/tty/serial/lpc32xx_hs.c:	p->port.dev = &pdev->dev;
drivers/tty/serial/sirfsoc_uart.c:	if (of_property_read_u32(pdev->dev.of_node, "cell-index", &pdev->id)) {
drivers/tty/serial/sirfsoc_uart.c:		dev_err(&pdev->dev,
drivers/tty/serial/sirfsoc_uart.c:	sirfport = &sirfsoc_uart_ports[pdev->id];
drivers/tty/serial/sirfsoc_uart.c:	port->dev = &pdev->dev;
drivers/tty/serial/sirfsoc_uart.c:	if (of_find_property(pdev->dev.of_node, "hw_flow_ctrl", NULL))
drivers/tty/serial/sirfsoc_uart.c:	if (of_property_read_u32(pdev->dev.of_node,
drivers/tty/serial/sirfsoc_uart.c:		dev_err(&pdev->dev,
drivers/tty/serial/sirfsoc_uart.c:		dev_err(&pdev->dev, "Insufficient resources.\n");
drivers/tty/serial/sirfsoc_uart.c:	port->membase = devm_ioremap(&pdev->dev, res->start, resource_size(res));
drivers/tty/serial/sirfsoc_uart.c:		dev_err(&pdev->dev, "Cannot remap resource.\n");
drivers/tty/serial/sirfsoc_uart.c:		dev_err(&pdev->dev, "Insufficient resources.\n");
drivers/tty/serial/sirfsoc_uart.c:		sirfport->p = pinctrl_get_select_default(&pdev->dev);
drivers/tty/serial/sirfsoc_uart.c:	sirfport->clk = clk_get(&pdev->dev, NULL);
drivers/tty/serial/sirfsoc_uart.c:		dev_err(&pdev->dev, "Cannot add UART port(%d).\n", pdev->id);
drivers/tty/serial/mfd.c:	if (priv && (pdev->device != 0x081E)) {
drivers/tty/serial/mfd.c:		dev_warn(&pdev->dev,
drivers/tty/serial/mfd.c:	if (priv && (pdev->device != 0x081E)) {
drivers/tty/serial/mfd.c:		pdev->vendor, pdev->device);
drivers/tty/serial/mfd.c:	switch (pdev->device) {
drivers/tty/serial/mfd.c:		dev_err(&pdev->dev, "HSU: out of index!");
drivers/tty/serial/mfd.c:		ret = request_irq(pdev->irq, dma_irq, 0, "hsu_dma", phsu);
drivers/tty/serial/mfd.c:			dev_err(&pdev->dev, "can not get IRQ\n");
drivers/tty/serial/mfd.c:		uport->port.irq = pdev->irq;
drivers/tty/serial/mfd.c:		uport->port.dev = &pdev->dev;
drivers/tty/serial/mfd.c:		uport->dev = &pdev->dev;
drivers/tty/serial/mfd.c:		ret = request_irq(pdev->irq, port_irq, 0, uport->name, uport);
drivers/tty/serial/mfd.c:			dev_err(&pdev->dev, "can not get IRQ\n");
drivers/tty/serial/mfd.c:	pm_runtime_put_noidle(&pdev->dev);
drivers/tty/serial/mfd.c:	pm_runtime_allow(&pdev->dev);
drivers/tty/serial/mfd.c:	pm_runtime_forbid(&pdev->dev);
drivers/tty/serial/mfd.c:	pm_runtime_get_noresume(&pdev->dev);
drivers/tty/serial/mfd.c:	if (pdev->device != 0x081E) {
drivers/tty/serial/mfd.c:	free_irq(pdev->irq, priv);
drivers/tty/serial/pnx8xxx_uart.c:	struct resource *res = pdev->resource;
drivers/tty/serial/pnx8xxx_uart.c:	for (i = 0; i < pdev->num_resources; i++, res++) {
drivers/tty/serial/pnx8xxx_uart.c:			pnx8xxx_ports[i].port.dev = &pdev->dev;
drivers/tty/serial/vr41xx_siu.c:	int *type = pdev->dev.platform_data;
drivers/tty/serial/sh-sci.c:	struct plat_sci_port *cfg = pdev->dev.platform_data;
drivers/tty/serial/sh-sci.c:	early_serial_console.index = pdev->id;
drivers/tty/serial/sh-sci.c:	sci_init_single(NULL, &sci_ports[pdev->id], pdev->id, cfg);
drivers/tty/serial/rp2.c:		dev_err(&card->pdev->dev, "cannot find '%s' firmware image\n",
drivers/tty/serial/rp2.c:		p->dev = &card->pdev->dev;
drivers/tty/serial/rp2.c:		p->irq = card->pdev->irq;
drivers/tty/serial/rp2.c:			dev_err(&card->pdev->dev,
drivers/tty/serial/rp2.c:		dev_warn(&card->pdev->dev, "driver initialization failed\n");
drivers/tty/serial/rp2.c:	card = devm_kzalloc(&pdev->dev, sizeof(*card), GFP_KERNEL);
drivers/tty/serial/rp2.c:	dev_info(&pdev->dev, "found new card with %d ports\n", card->n_ports);
drivers/tty/serial/rp2.c:		dev_err(&pdev->dev,
drivers/tty/serial/rp2.c:	ports = devm_kzalloc(&pdev->dev, sizeof(*ports) * card->n_ports,
drivers/tty/serial/rp2.c:	rc = devm_request_irq(&pdev->dev, pdev->irq, rp2_uart_interrupt,
drivers/tty/serial/rp2.c:	rc = request_firmware_nowait(THIS_MODULE, 1, RP2_FW_NAME, &pdev->dev,
drivers/tty/serial/rp2.c:	dev_dbg(&pdev->dev, "waiting for firmware blob...\n");
drivers/tty/serial/ar933x_uart.c:	pdata = pdev->dev.platform_data;
drivers/tty/serial/ar933x_uart.c:	id = pdev->id;
drivers/tty/serial/ar933x_uart.c:		dev_err(&pdev->dev, "no MEM resource\n");
drivers/tty/serial/ar933x_uart.c:		dev_err(&pdev->dev, "no IRQ resource\n");
drivers/tty/serial/ar933x_uart.c:	port->dev = &pdev->dev;
drivers/tty/serial/altera_jtaguart.c:	struct altera_jtaguart_platform_uart *platp = pdev->dev.platform_data;
drivers/tty/serial/altera_jtaguart.c:	int i = pdev->id;
drivers/tty/serial/altera_jtaguart.c:	int i = pdev->id;
drivers/tty/serial/msm_serial.c:	if (pdev->id == -1)
drivers/tty/serial/msm_serial.c:		pdev->id = atomic_inc_return(&msm_uart_next_id) - 1;
drivers/tty/serial/msm_serial.c:	if (unlikely(pdev->id < 0 || pdev->id >= UART_NR))
drivers/tty/serial/msm_serial.c:	printk(KERN_INFO "msm_serial: detected port #%d\n", pdev->id);
drivers/tty/serial/msm_serial.c:	port = get_port_from_line(pdev->id);
drivers/tty/serial/msm_serial.c:	port->dev = &pdev->dev;
drivers/tty/serial/msm_serial.c:		msm_port->clk = clk_get(&pdev->dev, "gsbi_uart_clk");
drivers/tty/serial/msm_serial.c:		msm_port->pclk = clk_get(&pdev->dev, "gsbi_pclk");
drivers/tty/serial/msm_serial.c:		msm_port->clk = clk_get(&pdev->dev, "uart_clk");
drivers/tty/serial/pch_uart.c:	dma_dev = pci_get_bus_and_slot(priv->pdev->bus->number,
drivers/tty/serial/pch_uart.c:			dev_err(&priv->pdev->dev, error_msg[i]);
drivers/tty/serial/pch_uart.c:		dev_err(&pdev->dev, "Invalid Port Type(=%d)\n", port_type);
drivers/tty/serial/pch_uart.c:	priv->port.dev = &pdev->dev;
drivers/tty/serial/pch_uart.c:	priv->port.irq = pdev->irq;
drivers/tty/serial/pch_uart.c:		dev_err(&pdev->dev,
drivers/tty/serial/xilinx_uartps.c:	clk = of_clk_get(pdev->dev.of_node, 0);
drivers/tty/serial/xilinx_uartps.c:		dev_err(&pdev->dev, "no clock specified\n");
drivers/tty/serial/xilinx_uartps.c:		dev_err(&pdev->dev, "could not enable clock\n");
drivers/tty/serial/xilinx_uartps.c:		dev_err(&pdev->dev, "Cannot get uart_port structure\n");
drivers/tty/serial/xilinx_uartps.c:		port->dev = &pdev->dev;
drivers/tty/serial/xilinx_uartps.c:		dev_set_drvdata(&pdev->dev, port);
drivers/tty/serial/xilinx_uartps.c:			dev_err(&pdev->dev,
drivers/tty/serial/xilinx_uartps.c:			dev_set_drvdata(&pdev->dev, NULL);
drivers/tty/serial/xilinx_uartps.c:	struct uart_port *port = dev_get_drvdata(&pdev->dev);
drivers/tty/serial/xilinx_uartps.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/tty/serial/xilinx_uartps.c:	uart_suspend_port(&xuartps_uart_driver, &xuartps_port[pdev->id]);
drivers/tty/serial/xilinx_uartps.c:	uart_resume_port(&xuartps_uart_driver, &xuartps_port[pdev->id]);
drivers/tty/serial/msm_serial_hs.c:	if (pdev->id < 0 || pdev->id >= UARTDM_NR) {
drivers/tty/serial/msm_serial_hs.c:		printk(KERN_ERR "Invalid plaform device ID = %d\n", pdev->id);
drivers/tty/serial/msm_serial_hs.c:	msm_uport = &q_uart_port[pdev->id];
drivers/tty/serial/msm_serial_hs.c:						pdev->dev.platform_data;
drivers/tty/serial/msm_serial_hs.c:	if (pdev->id < 0 || pdev->id >= UARTDM_NR) {
drivers/tty/serial/msm_serial_hs.c:		printk(KERN_ERR "Invalid plaform device ID = %d\n", pdev->id);
drivers/tty/serial/msm_serial_hs.c:	msm_uport = &q_uart_port[pdev->id];
drivers/tty/serial/msm_serial_hs.c:	uport->dev = &pdev->dev;
drivers/tty/serial/msm_serial_hs.c:	msm_uport->clk = clk_get(&pdev->dev, "uartdm_clk");
drivers/tty/serial/msm_serial_hs.c:	uport->line = pdev->id;
drivers/tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = &q_uart_port[pdev->id];
drivers/tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = &q_uart_port[pdev->id];
drivers/tty/goldfish.c:	struct goldfish_tty *qtty = &goldfish_ttys[pdev->id];
drivers/tty/goldfish.c:	if(pdev->id >= goldfish_tty_line_count)
drivers/tty/goldfish.c:	qtty = &goldfish_ttys[pdev->id];
drivers/tty/goldfish.c:							pdev->id, &pdev->dev);
drivers/tty/goldfish.c:	qtty->console.index = pdev->id;
drivers/tty/goldfish.c:	qtty = &goldfish_ttys[pdev->id];
drivers/tty/goldfish.c:	tty_unregister_device(goldfish_tty_driver, pdev->id);
drivers/tty/synclink_gt.c:	switch(info->pdev->device) {
drivers/tty/synclink_gt.c:		info->irq_level = pdev->irq;
drivers/tty/synclink_gt.c:	if (pdev->device == SYNCLINK_GT2_DEVICE_ID)
drivers/tty/synclink_gt.c:	else if (pdev->device == SYNCLINK_GT4_DEVICE_ID)
drivers/tty/synclink_gt.c:				&info->pdev->dev);
drivers/tty/ehv_bytechan.c:	struct device_node *np = pdev->dev.of_node;
drivers/tty/ehv_bytechan.c:		dev_err(&pdev->dev, "no 'hv-handle' property in %s node\n",
drivers/tty/ehv_bytechan.c:		dev_err(&pdev->dev, "no 'interrupts' property in %s node\n",
drivers/tty/ehv_bytechan.c:			&pdev->dev);
drivers/tty/ehv_bytechan.c:		dev_err(&pdev->dev, "could not register tty (ret=%i)\n", ret);
drivers/tty/ehv_bytechan.c:	dev_set_drvdata(&pdev->dev, bc);
drivers/tty/ehv_bytechan.c:	dev_info(&pdev->dev, "registered /dev/%s%u for byte channel %u\n",
drivers/tty/ehv_bytechan.c:	struct ehv_bc_data *bc = dev_get_drvdata(&pdev->dev);
drivers/tty/synclinkmp.c:		info->irq_level = pdev->irq;
drivers/tty/moxa.c:		dev_err(&pdev->dev, "can't enable pci device\n");
drivers/tty/moxa.c:		dev_warn(&pdev->dev, "more than %u MOXA Intellio family boards "
drivers/tty/moxa.c:		dev_err(&pdev->dev, "can't request pci region 2\n");
drivers/tty/moxa.c:		dev_err(&pdev->dev, "can't remap io space 2\n");
drivers/tty/moxa.c:	retval = moxa_init_board(board, &pdev->dev);
drivers/tty/moxa.c:	dev_info(&pdev->dev, "board '%s' ready (%u ports, firmware loaded)\n",
drivers/video/wmt_ge_rops.c:		dev_err(&pdev->dev, "no I/O memory resource defined\n");
drivers/video/wmt_ge_rops.c:		dev_err(&pdev->dev, "failed to map I/O memory\n");
drivers/video/ep93xx-fb.c:	struct ep93xxfb_mach_info *mach_info = pdev->dev.platform_data;
drivers/video/ep93xx-fb.c:	info = framebuffer_alloc(sizeof(struct ep93xx_fbi), &pdev->dev);
drivers/video/ep93xx-fb.c:	info->dev = &pdev->dev;
drivers/video/ep93xx-fb.c:	fbi->mmio_base = devm_ioremap(&pdev->dev, res->start,
drivers/video/ep93xx-fb.c:	strcpy(info->fix.id, pdev->name);
drivers/video/ep93xx-fb.c:	fbi->clk = devm_clk_get(&pdev->dev, NULL);
drivers/video/sunxvr2500.c:	info = framebuffer_alloc(sizeof(struct s3d_info), &pdev->dev);
drivers/video/sh_mobile_lcdcfb.c:			pm_runtime_get_sync(&priv->meram_dev->pdev->dev);
drivers/video/sh_mobile_lcdcfb.c:			pm_runtime_put_sync(&priv->meram_dev->pdev->dev);
drivers/video/sh_mobile_lcdcfb.c:			dma_free_coherent(&pdev->dev, ovl->fb_size,
drivers/video/sh_mobile_lcdcfb.c:			dma_free_coherent(&pdev->dev, ch->fb_size,
drivers/video/sh_mobile_lcdcfb.c:		pm_runtime_disable(&pdev->dev);
drivers/video/sh_mobile_lcdcfb.c:	struct sh_mobile_lcdc_info *pdata = pdev->dev.platform_data;
drivers/video/sh_mobile_lcdcfb.c:		dev_err(&pdev->dev, "no platform data defined\n");
drivers/video/sh_mobile_lcdcfb.c:		dev_err(&pdev->dev, "cannot get platform resources\n");
drivers/video/sh_mobile_lcdcfb.c:		dev_err(&pdev->dev, "cannot allocate device data\n");
drivers/video/sh_mobile_lcdcfb.c:	priv->dev = &pdev->dev;
drivers/video/sh_mobile_lcdcfb.c:			    dev_name(&pdev->dev), priv);
drivers/video/sh_mobile_lcdcfb.c:		dev_err(&pdev->dev, "unable to request irq\n");
drivers/video/sh_mobile_lcdcfb.c:			dev_err(&pdev->dev, "unsupported interface type\n");
drivers/video/sh_mobile_lcdcfb.c:			ch->bl = sh_mobile_lcdc_bl_probe(&pdev->dev, ch);
drivers/video/sh_mobile_lcdcfb.c:		dev_err(&pdev->dev, "no channels defined\n");
drivers/video/sh_mobile_lcdcfb.c:		dev_err(&pdev->dev, "unable to setup clocks\n");
drivers/video/sh_mobile_lcdcfb.c:	pm_runtime_enable(&pdev->dev);
drivers/video/sh_mobile_lcdcfb.c:		dev_err(&pdev->dev, "unable to start hardware\n");
drivers/video/imsttfb.c:	info = framebuffer_alloc(sizeof(struct imstt_par), &pdev->dev);
drivers/video/imsttfb.c:	switch (pdev->device) {
drivers/video/imsttfb.c:					 "contact maintainer.\n", pdev->device);
drivers/video/s3c2410fb.c:	mach_info = pdev->dev.platform_data;
drivers/video/s3c2410fb.c:		dev_err(&pdev->dev,
drivers/video/s3c2410fb.c:		dev_err(&pdev->dev, "default is %d but only %d displays\n",
drivers/video/s3c2410fb.c:		dev_err(&pdev->dev, "no irq for device\n");
drivers/video/s3c2410fb.c:	fbinfo = framebuffer_alloc(sizeof(struct s3c2410fb_info), &pdev->dev);
drivers/video/s3c2410fb.c:	info->dev = &pdev->dev;
drivers/video/s3c2410fb.c:		dev_err(&pdev->dev, "failed to get memory registers\n");
drivers/video/s3c2410fb.c:	info->mem = request_mem_region(res->start, size, pdev->name);
drivers/video/s3c2410fb.c:		dev_err(&pdev->dev, "failed to get memory region\n");
drivers/video/s3c2410fb.c:		dev_err(&pdev->dev, "ioremap() of registers failed\n");
drivers/video/s3c2410fb.c:	ret = request_irq(irq, s3c2410fb_irq, 0, pdev->name, info);
drivers/video/s3c2410fb.c:		dev_err(&pdev->dev, "cannot get irq %d - err %d\n", irq, ret);
drivers/video/s3c2410fb.c:		dev_err(&pdev->dev, "failed to get lcd clock source\n");
drivers/video/s3c2410fb.c:		dev_err(&pdev->dev, "Failed to allocate video RAM: %d\n", ret);
drivers/video/s3c2410fb.c:		dev_err(&pdev->dev, "Failed to register cpufreq\n");
drivers/video/s3c2410fb.c:		dev_err(&pdev->dev, "Failed to register framebuffer device: %d\n",
drivers/video/s3c2410fb.c:	ret = device_create_file(&pdev->dev, &dev_attr_debug);
drivers/video/s3c2410fb.c:		dev_err(&pdev->dev, "failed to add debug attribute\n");
drivers/video/s3c2410fb.c:	dev_info(&pdev->dev, "fb%d: %s frame buffer device\n",
drivers/video/mb862xx/mb862xxfbdrv.c:			 par->pdev->revision);
drivers/video/mb862xx/mb862xxfbdrv.c:			 par->pdev->revision);
drivers/video/mb862xx/mb862xxfbdrv.c:	struct device *dev = &pdev->dev;
drivers/video/mb862xx/mb862xxfbdrv.c:	par->irq = pdev->irq;
drivers/video/mb862xx/mb862xxfbdrv.c:	switch (pdev->device) {
drivers/video/mb862xx/mb862xxfbdrv.c:	device_remove_file(&pdev->dev, &dev_attr_dispregs);
drivers/video/auo_k190x.c:	info = framebuffer_alloc(sizeof(struct auok190xfb_par), &pdev->dev);
drivers/video/skeletonfb.c:    struct device *device = &dev->dev; /* or &pdev->dev */
drivers/video/exynos/exynos_mipi_dsi.c:	return pdev->dev.platform_data;
drivers/video/exynos/exynos_mipi_dsi.c:	dsim = devm_kzalloc(&pdev->dev, sizeof(struct mipi_dsim_device),
drivers/video/exynos/exynos_mipi_dsi.c:		dev_err(&pdev->dev, "failed to allocate dsim object.\n");
drivers/video/exynos/exynos_mipi_dsi.c:	dsim->dev = &pdev->dev;
drivers/video/exynos/exynos_mipi_dsi.c:	dsim->id = pdev->id;
drivers/video/exynos/exynos_mipi_dsi.c:		dev_err(&pdev->dev, "failed to get platform data for dsim.\n");
drivers/video/exynos/exynos_mipi_dsi.c:		dev_err(&pdev->dev, "failed to get dsim config data.\n");
drivers/video/exynos/exynos_mipi_dsi.c:	ret = devm_regulator_bulk_get(&pdev->dev, ARRAY_SIZE(supplies),
drivers/video/exynos/exynos_mipi_dsi.c:		dev_err(&pdev->dev, "Failed to get regulators: %d\n", ret);
drivers/video/exynos/exynos_mipi_dsi.c:	dsim->clock = devm_clk_get(&pdev->dev, "dsim0");
drivers/video/exynos/exynos_mipi_dsi.c:		dev_err(&pdev->dev, "failed to get dsim clock source\n");
drivers/video/exynos/exynos_mipi_dsi.c:	dsim->reg_base = devm_ioremap_resource(&pdev->dev, res);
drivers/video/exynos/exynos_mipi_dsi.c:		dev_err(&pdev->dev, "mipi_dsim_ddi object not found.\n");
drivers/video/exynos/exynos_mipi_dsi.c:		dev_err(&pdev->dev, "failed to request dsim irq resource\n");
drivers/video/exynos/exynos_mipi_dsi.c:	ret = devm_request_irq(&pdev->dev, dsim->irq,
drivers/video/exynos/exynos_mipi_dsi.c:			IRQF_SHARED, dev_name(&pdev->dev), dsim);
drivers/video/exynos/exynos_mipi_dsi.c:		dev_err(&pdev->dev, "failed to request dsim irq\n");
drivers/video/exynos/exynos_mipi_dsi.c:	dev_dbg(&pdev->dev, "%s() completed successfully (%s mode)\n", __func__,
drivers/video/exynos/exynos_dp_core.c:	dp = devm_kzalloc(&pdev->dev, sizeof(struct exynos_dp_device),
drivers/video/exynos/exynos_dp_core.c:		dev_err(&pdev->dev, "no memory for device data\n");
drivers/video/exynos/exynos_dp_core.c:	dp->dev = &pdev->dev;
drivers/video/exynos/exynos_dp_core.c:	if (pdev->dev.of_node) {
drivers/video/exynos/exynos_dp_core.c:		pdata = exynos_dp_dt_parse_pdata(&pdev->dev);
drivers/video/exynos/exynos_dp_core.c:		pdata = pdev->dev.platform_data;
drivers/video/exynos/exynos_dp_core.c:			dev_err(&pdev->dev, "no platform data\n");
drivers/video/exynos/exynos_dp_core.c:	dp->clock = devm_clk_get(&pdev->dev, "dp");
drivers/video/exynos/exynos_dp_core.c:		dev_err(&pdev->dev, "failed to get clock\n");
drivers/video/exynos/exynos_dp_core.c:	dp->reg_base = devm_ioremap_resource(&pdev->dev, res);
drivers/video/exynos/exynos_dp_core.c:		dev_err(&pdev->dev, "failed to get irq\n");
drivers/video/exynos/exynos_dp_core.c:	if (pdev->dev.of_node) {
drivers/video/exynos/exynos_dp_core.c:	ret = devm_request_irq(&pdev->dev, dp->irq, exynos_dp_irq_handler, 0,
drivers/video/exynos/exynos_dp_core.c:		dev_err(&pdev->dev, "failed to request irq\n");
drivers/video/exynos/exynos_dp_core.c:	struct exynos_dp_platdata *pdata = pdev->dev.platform_data;
drivers/video/exynos/exynos_dp_core.c:	if (pdev->dev.of_node) {
drivers/video/bf54x-lq043fb.c:	    framebuffer_alloc(sizeof(struct bfin_bf54xfb_info), &pdev->dev);
drivers/video/bf54x-lq043fb.c:	info->dev = &pdev->dev;
drivers/video/bf54x-lq043fb.c:	info->mach_info = pdev->dev.platform_data;
drivers/video/bf54x-lq043fb.c:		dev_err(&pdev->dev,
drivers/video/bf54x-lq043fb.c:	fbinfo->pseudo_palette = devm_kzalloc(&pdev->dev, sizeof(u32) * 16,
drivers/video/bf54x-lq043fb.c:	lcd_dev = lcd_device_register(DRIVER_NAME, &pdev->dev, NULL, &bfin_lcd_ops);
drivers/video/w100fb.c:	info=framebuffer_alloc(sizeof(struct w100fb_par), &pdev->dev);
drivers/video/w100fb.c:	inf = pdev->dev.platform_data;
drivers/video/w100fb.c:	err = device_create_file(&pdev->dev, &dev_attr_fastpllclk);
drivers/video/w100fb.c:	err |= device_create_file(&pdev->dev, &dev_attr_reg_read);
drivers/video/w100fb.c:	err |= device_create_file(&pdev->dev, &dev_attr_reg_write);
drivers/video/w100fb.c:	err |= device_create_file(&pdev->dev, &dev_attr_flip);
drivers/video/w100fb.c:	device_remove_file(&pdev->dev, &dev_attr_fastpllclk);
drivers/video/w100fb.c:	device_remove_file(&pdev->dev, &dev_attr_reg_read);
drivers/video/w100fb.c:	device_remove_file(&pdev->dev, &dev_attr_reg_write);
drivers/video/w100fb.c:	device_remove_file(&pdev->dev, &dev_attr_flip);
drivers/video/sh7760fb.c:		dev_err(&pdev->dev, "invalid resource\n");
drivers/video/sh7760fb.c:	info = framebuffer_alloc(sizeof(struct sh7760fb_par), &pdev->dev);
drivers/video/sh7760fb.c:	par->pd = pdev->dev.platform_data;
drivers/video/sh7760fb.c:					 resource_size(res), pdev->name);
drivers/video/sh7760fb.c:		dev_err(&pdev->dev, "mmio area busy\n");
drivers/video/sh7760fb.c:		dev_err(&pdev->dev, "cannot remap\n");
drivers/video/sh7760fb.c:			dev_err(&pdev->dev, "cannot grab IRQ\n");
drivers/video/sh7760fb.c:	       pdev->name,
drivers/video/sa1100fb.c:	if (!pdev->dev.platform_data) {
drivers/video/sa1100fb.c:		dev_err(&pdev->dev, "no platform LCD data\n");
drivers/video/sa1100fb.c:	fbi = sa1100fb_init_fbinfo(&pdev->dev);
drivers/video/sa1100fb.c:		dev_err(&pdev->dev, "request_irq failed: %d\n", ret);
drivers/video/mxsfb.c:	dev_dbg(&host->pdev->dev, "%s\n", __func__);
drivers/video/mxsfb.c:			dev_err(&host->pdev->dev,
drivers/video/mxsfb.c:	dev_dbg(&host->pdev->dev, "%s\n", __func__);
drivers/video/mxsfb.c:			dev_err(&host->pdev->dev,
drivers/video/mxsfb.c:		dev_dbg(&host->pdev->dev, "Setting up RGB565 mode\n");
drivers/video/mxsfb.c:		dev_dbg(&host->pdev->dev, "Setting up RGB888/666 mode\n");
drivers/video/mxsfb.c:			dev_dbg(&host->pdev->dev,
drivers/video/mxsfb.c:		dev_dbg(&host->pdev->dev, "Unhandled color depth of %u\n",
drivers/video/mxsfb.c:	struct device *dev = &host->pdev->dev;
drivers/video/mxsfb.c:	struct device_node *np = host->pdev->dev.of_node;
drivers/video/mxsfb.c:			of_match_device(mxsfb_dt_ids, &pdev->dev);
drivers/video/mxsfb.c:		pdev->id_entry = of_id->data;
drivers/video/mxsfb.c:		dev_err(&pdev->dev, "Cannot get memory IO resource\n");
drivers/video/mxsfb.c:	fb_info = framebuffer_alloc(sizeof(struct mxsfb_info), &pdev->dev);
drivers/video/mxsfb.c:		dev_err(&pdev->dev, "Failed to allocate fbdev\n");
drivers/video/mxsfb.c:	host->base = devm_ioremap_resource(&pdev->dev, res);
drivers/video/mxsfb.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/video/mxsfb.c:	host->devdata = &mxsfb_devdata[pdev->id_entry->driver_data];
drivers/video/mxsfb.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/video/mxsfb.c:	host->clk = devm_clk_get(&host->pdev->dev, NULL);
drivers/video/mxsfb.c:	host->reg_lcd = devm_regulator_get(&pdev->dev, "lcd");
drivers/video/mxsfb.c:	fb_info->pseudo_palette = devm_kzalloc(&pdev->dev, sizeof(u32) * 16,
drivers/video/mxsfb.c:		dev_err(&pdev->dev,"Failed to register framebuffer\n");
drivers/video/mxsfb.c:	dev_info(&pdev->dev, "initialized\n");
drivers/video/sstfb.c:	info = framebuffer_alloc(sizeof(struct sstfb_par), &pdev->dev);
drivers/video/sstfb.c:	par->revision = pdev->revision;
drivers/video/sstfb.c:	info->device = &pdev->dev;
drivers/video/auo_k1900fb.c:	board = pdev->dev.platform_data;
drivers/video/s3c-fb.c:	struct device *dev = &pdev->dev;
drivers/video/s3c-fb.c:	pd = pdev->dev.platform_data;
drivers/video/pxa168fb.c:	mi = pdev->dev.platform_data;
drivers/video/pxa168fb.c:		dev_err(&pdev->dev, "no platform data defined\n");
drivers/video/pxa168fb.c:	clk = clk_get(&pdev->dev, "LCDCLK");
drivers/video/pxa168fb.c:		dev_err(&pdev->dev, "unable to get LCDCLK");
drivers/video/pxa168fb.c:		dev_err(&pdev->dev, "no IO memory defined\n");
drivers/video/pxa168fb.c:		dev_err(&pdev->dev, "no IRQ defined\n");
drivers/video/pxa168fb.c:	info = framebuffer_alloc(sizeof(struct pxa168fb_info), &pdev->dev);
drivers/video/pxa168fb.c:	fbi->dev = info->dev = &pdev->dev;
drivers/video/pxa168fb.c:	fbi->reg_base = devm_ioremap_nocache(&pdev->dev, res->start,
drivers/video/pxa168fb.c:	ret = devm_request_irq(&pdev->dev, irq, pxa168fb_handle_irq,
drivers/video/pxa168fb.c:		dev_err(&pdev->dev, "unable to request IRQ\n");
drivers/video/pxa168fb.c:		dev_err(&pdev->dev, "Failed to register pxa168-fb: %d\n", ret);
drivers/video/pxa168fb.c:	dev_err(&pdev->dev, "frame buffer device init failed with %d\n", ret);
drivers/video/sis/sis_main.c:		temp = pdev->vendor;
drivers/video/sis/sis_main.c:		dev_warn(&pdev->dev,
drivers/video/sis/sis_main.c:			dev_err(&pdev->dev,
drivers/video/sis/sis_main.c:	sis_fb_info = framebuffer_alloc(sizeof(*ivideo), &pdev->dev);
drivers/video/sis/sis_main.c:	ivideo->chip_id = pdev->device;
drivers/video/sis/sis_main.c:	ivideo->chip_vendor = pdev->vendor;
drivers/video/sis/sis_main.c:	ivideo->revision_id = pdev->revision;
drivers/video/sis/sis_main.c:	ivideo->pcibus = pdev->bus->number;
drivers/video/sis/sis_main.c:	ivideo->pcislot = PCI_SLOT(pdev->devfn);
drivers/video/sis/sis_main.c:	ivideo->pcifunc = PCI_FUNC(pdev->devfn);
drivers/video/sis/sis_main.c:	ivideo->subsysvendor = pdev->subsystem_vendor;
drivers/video/sis/sis_main.c:	ivideo->subsysdevice = pdev->subsystem_device;
drivers/video/sis/sis_main.c:	if(pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW) {
drivers/video/sis/sis_main.c:			dev_info(&pdev->dev, "Z9 detected\n");
drivers/video/bfin-lq035q1-fb.c:		dev_err(&pdev->dev, "requesting peripherals failed\n");
drivers/video/bfin-lq035q1-fb.c:		dev_err(&pdev->dev, "PPI DMA unavailable\n");
drivers/video/bfin-lq035q1-fb.c:	fbinfo = framebuffer_alloc(sizeof(*info), &pdev->dev);
drivers/video/bfin-lq035q1-fb.c:	info->dev = &pdev->dev;
drivers/video/bfin-lq035q1-fb.c:	info->disp_info = pdev->dev.platform_data;
drivers/video/bfin-lq035q1-fb.c:		dev_err(&pdev->dev, "Failed PPI Mode\n");
drivers/video/bfin-lq035q1-fb.c:		dev_err(&pdev->dev, "couldn't allocate dma buffer\n");
drivers/video/bfin-lq035q1-fb.c:		dev_err(&pdev->dev, "failed to allocate colormap (%d entries)\n",
drivers/video/bfin-lq035q1-fb.c:		dev_err(&pdev->dev, "couldn't request gpio port\n");
drivers/video/bfin-lq035q1-fb.c:		dev_err(&pdev->dev, "unable to request PPI ERROR IRQ\n");
drivers/video/bfin-lq035q1-fb.c:		dev_err(&pdev->dev, "couldn't register SPI Interface\n");
drivers/video/bfin-lq035q1-fb.c:			dev_err(&pdev->dev, "failed to request GPIO %d\n",
drivers/video/bfin-lq035q1-fb.c:		dev_err(&pdev->dev, "unable to register framebuffer\n");
drivers/video/bfin-lq035q1-fb.c:	dev_info(&pdev->dev, "%dx%d %d-bit RGB FrameBuffer initialized\n",
drivers/video/bfin-lq035q1-fb.c:	dev_info(&pdev->dev, "unregistered LCD driver\n");
drivers/video/tdfxfb.c:	info = framebuffer_alloc(sizeof(struct tdfx_par), &pdev->dev);
drivers/video/tdfxfb.c:	switch (pdev->device) {
drivers/video/tdfxfb.c:	info->fix.smem_len = do_lfb_size(default_par, pdev->device);
drivers/video/goldfishfb.c:						&pdev->dev, framesize,
drivers/video/goldfishfb.c:							pdev->name, fb);
drivers/video/goldfishfb.c:	dma_free_coherent(&pdev->dev, framesize,
drivers/video/goldfishfb.c:	dma_free_coherent(&pdev->dev, framesize, (void *)fb->fb.screen_base,
drivers/video/tgafb.c:	return tgafb_register(&pdev->dev);
drivers/video/tgafb.c:	tgafb_unregister(&pdev->dev);
drivers/video/nuc900fb.c:	dev_dbg(&pdev->dev, "devinit\n");
drivers/video/nuc900fb.c:	mach_info = pdev->dev.platform_data;
drivers/video/nuc900fb.c:		dev_err(&pdev->dev,
drivers/video/nuc900fb.c:		dev_err(&pdev->dev,
drivers/video/nuc900fb.c:		dev_err(&pdev->dev, "no irq for device\n");
drivers/video/nuc900fb.c:	fbinfo = framebuffer_alloc(sizeof(struct nuc900fb_info), &pdev->dev);
drivers/video/nuc900fb.c:	fbi->dev = &pdev->dev;
drivers/video/nuc900fb.c:	fbi->mem = request_mem_region(res->start, size, pdev->name);
drivers/video/nuc900fb.c:		dev_err(&pdev->dev, "failed to alloc memory region\n");
drivers/video/nuc900fb.c:		dev_err(&pdev->dev, "ioremap() of lcd registers failed\n");
drivers/video/nuc900fb.c:			  pdev->name, fbinfo);
drivers/video/nuc900fb.c:		dev_err(&pdev->dev, "cannot register irq handler %d -err %d\n",
drivers/video/nuc900fb.c:	fbi->clk = clk_get(&pdev->dev, NULL);
drivers/video/nuc900fb.c:	dev_dbg(&pdev->dev, "got and enabled clock\n");
drivers/video/nuc900fb.c:	dev_dbg(&pdev->dev, "got video memory\n");
drivers/video/nuc900fb.c:		dev_err(&pdev->dev, "Failed to register cpufreq\n");
drivers/video/atmel_lcdfb.c:	bl = backlight_device_register("backlight", &sinfo->pdev->dev, sinfo,
drivers/video/atmel_lcdfb.c:		dev_err(&sinfo->pdev->dev, "error %ld on backlight register\n",
drivers/video/atmel_lcdfb.c:	dev_warn(&sinfo->pdev->dev, "backlight control is not available\n");
drivers/video/atmel_lcdfb.c:	struct device *dev = &pdev->dev;
drivers/video/atmel_lcdfb.c:	strcpy(info->fix.id, sinfo->pdev->name);
drivers/video/atmel_lcdfb.c:					info->fix.smem_len, pdev->name)) {
drivers/video/atmel_lcdfb.c:				info->fix.mmio_len, pdev->name)) {
drivers/video/atmel_lcdfb.c:	ret = request_irq(sinfo->irq_base, atmel_lcdfb_interrupt, 0, pdev->name, info);
drivers/video/atmel_lcdfb.c:	struct device *dev = &pdev->dev;
drivers/video/sh_mobile_meram.c:	dev_dbg(&pdev->dev, "registering %dx%d (%s)", xres, yres,
drivers/video/sh_mobile_meram.c:		dev_err(&pdev->dev, "width exceeding the limit (> 8192).");
drivers/video/sh_mobile_meram.c:		dev_err(&pdev->dev, "MERAM allocation failed (%ld).",
drivers/video/sh_mobile_meram.c:	struct sh_mobile_meram_info *pdata = pdev->dev.platform_data;
drivers/video/sh_mobile_meram.c:		dev_err(&pdev->dev, "no platform data defined\n");
drivers/video/sh_mobile_meram.c:		dev_err(&pdev->dev, "cannot get platform resources\n");
drivers/video/sh_mobile_meram.c:		dev_err(&pdev->dev, "cannot allocate device data\n");
drivers/video/sh_mobile_meram.c:	if (!request_mem_region(regs->start, resource_size(regs), pdev->name)) {
drivers/video/sh_mobile_meram.c:		dev_err(&pdev->dev, "MERAM registers region already claimed\n");
drivers/video/sh_mobile_meram.c:				pdev->name)) {
drivers/video/sh_mobile_meram.c:		dev_err(&pdev->dev, "MERAM memory region already claimed\n");
drivers/video/sh_mobile_meram.c:		dev_err(&pdev->dev, "ioremap failed\n");
drivers/video/sh_mobile_meram.c:	pm_runtime_enable(&pdev->dev);
drivers/video/sh_mobile_meram.c:	dev_info(&pdev->dev, "sh_mobile_meram initialized.");
drivers/video/sh_mobile_meram.c:	pm_runtime_disable(&pdev->dev);
drivers/video/msm/mddi_client_toshiba.c:	struct msm_mddi_client_data *client_data = pdev->dev.platform_data;
drivers/video/msm/mddi_client_toshiba.c:		dev_err(&pdev->dev, "mddi_bridge_setup_vsync failed\n");
drivers/video/msm/mddi_client_toshiba.c:	panel->pdev.id = pdev->id;
drivers/video/msm/mdp.c:	clk = clk_get(&pdev->dev, "mdp_clk");
drivers/video/msm/mdp.c:	mdp->mdp_dev.dev.parent = &pdev->dev;
drivers/video/msm/mdp.c:	dev_set_name(&mdp->mdp_dev.dev, "mdp%d", pdev->id);
drivers/video/msm/msm_fb.c:	struct msm_panel_data *panel = pdev->dev.platform_data;
drivers/video/msm/msm_fb.c:	fb = framebuffer_alloc(sizeof(struct msmfb_info), &pdev->dev);
drivers/video/msm/mddi_client_dummy.c:	struct msm_mddi_client_data *client_data = pdev->dev.platform_data;
drivers/video/msm/mddi_client_dummy.c:	panel->pdev.id = pdev->id;
drivers/video/msm/mddi.c:	mddi->clk = clk_get(&pdev->dev, "mddi_clk");
drivers/video/msm/mddi.c:	struct msm_mddi_platform_data *pdata = pdev->dev.platform_data;
drivers/video/msm/mddi.c:	struct mddi_info *mddi = &mddi_info[pdev->id];
drivers/video/msm/mddi.c:	if (pdev->id == 0)
drivers/video/msm/mddi.c:	else if (pdev->id == 1)
drivers/video/msm/mddi.c:		       pdev->id);
drivers/video/msm/mddi_client_nt35399.c:	struct msm_mddi_client_data *client_data = pdev->dev.platform_data;
drivers/video/msm/mddi_client_nt35399.c:	struct panel_info *panel = devm_kzalloc(&pdev->dev,
drivers/video/msm/mddi_client_nt35399.c:		dev_err(&pdev->dev, "mddi_nt35399_setup_vsync failed\n");
drivers/video/msm/mddi_client_nt35399.c:	panel->pdev.id = pdev->id;
drivers/video/bf537-lq035.c:	bfin_lq035_fb.pseudo_palette = devm_kzalloc(&pdev->dev,
drivers/video/bf537-lq035.c:	lcd_dev = lcd_device_register(KBUILD_MODNAME, &pdev->dev, NULL,
drivers/video/pvr2fb.c:	fb_info->device		= &pdev->dev;
drivers/video/backlight/lp8788_bl.c:	struct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);
drivers/video/backlight/lp8788_bl.c:	ret = sysfs_create_group(&pdev->dev.kobj, &lp8788_attr_group);
drivers/video/backlight/lp8788_bl.c:	sysfs_remove_group(&pdev->dev.kobj, &lp8788_attr_group);
drivers/video/backlight/platform_lcd.c:	struct device *dev = &pdev->dev;
drivers/video/backlight/platform_lcd.c:	pdata = pdev->dev.platform_data;
drivers/video/backlight/platform_lcd.c:	plcd = devm_kzalloc(&pdev->dev, sizeof(struct platform_lcd),
drivers/video/backlight/generic_bl.c:	struct generic_bl_info *machinfo = pdev->dev.platform_data;
drivers/video/backlight/generic_bl.c:	bd = backlight_device_register(name, &pdev->dev, NULL, &genericbl_ops,
drivers/video/backlight/generic_bl.c:	dev_info(&pdev->dev, "Generic Backlight Driver Initialized.\n");
drivers/video/backlight/generic_bl.c:	dev_info(&pdev->dev, "Generic Backlight Driver Unloaded\n");
drivers/video/backlight/88pm860x_bl.c:	nproot = of_node_get(pdev->dev.parent->of_node);
drivers/video/backlight/88pm860x_bl.c:		dev_err(&pdev->dev, "failed to find backlights node\n");
drivers/video/backlight/88pm860x_bl.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/video/backlight/88pm860x_bl.c:	struct pm860x_backlight_pdata *pdata = pdev->dev.platform_data;
drivers/video/backlight/88pm860x_bl.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct pm860x_backlight_data),
drivers/video/backlight/88pm860x_bl.c:		dev_err(&pdev->dev, "No REG resource for duty cycle\n");
drivers/video/backlight/88pm860x_bl.c:		dev_err(&pdev->dev, "No REG resorce for always on\n");
drivers/video/backlight/88pm860x_bl.c:		dev_err(&pdev->dev, "No REG resource for current\n");
drivers/video/backlight/88pm860x_bl.c:	sprintf(name, "backlight-%d", pdev->id);
drivers/video/backlight/88pm860x_bl.c:	data->port = pdev->id;
drivers/video/backlight/88pm860x_bl.c:	bl = backlight_device_register(name, &pdev->dev, data,
drivers/video/backlight/88pm860x_bl.c:		dev_err(&pdev->dev, "failed to register backlight\n");
drivers/video/backlight/jornada720_lcd.c:	lcd_device = lcd_device_register(S1D_DEVICENAME, &pdev->dev, NULL, &jornada_lcd_props);
drivers/video/backlight/jornada720_lcd.c:		dev_err(&pdev->dev, "failed to register device\n");
drivers/video/backlight/aat2870_bl.c:			= dev_get_drvdata(aat2870_bl->pdev->dev.parent);
drivers/video/backlight/aat2870_bl.c:			= dev_get_drvdata(aat2870_bl->pdev->dev.parent);
drivers/video/backlight/aat2870_bl.c:			dev_get_drvdata(aat2870_bl->pdev->dev.parent);
drivers/video/backlight/aat2870_bl.c:	struct aat2870_bl_platform_data *pdata = pdev->dev.platform_data;
drivers/video/backlight/aat2870_bl.c:		dev_err(&pdev->dev, "No platform data\n");
drivers/video/backlight/aat2870_bl.c:	if (pdev->id != AAT2870_ID_BL) {
drivers/video/backlight/aat2870_bl.c:		dev_err(&pdev->dev, "Invalid device ID, %d\n", pdev->id);
drivers/video/backlight/aat2870_bl.c:	aat2870_bl = devm_kzalloc(&pdev->dev,
drivers/video/backlight/aat2870_bl.c:		dev_err(&pdev->dev,
drivers/video/backlight/aat2870_bl.c:	bd = backlight_device_register("aat2870-backlight", &pdev->dev,
drivers/video/backlight/aat2870_bl.c:		dev_err(&pdev->dev,
drivers/video/backlight/aat2870_bl.c:		dev_err(&pdev->dev, "Failed to initialize\n");
drivers/video/backlight/tps65217_bl.c:	struct tps65217 *tps = dev_get_drvdata(pdev->dev.parent);
drivers/video/backlight/tps65217_bl.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/video/backlight/tps65217_bl.c:		dev_err(&pdev->dev, "failed to allocate platform data\n");
drivers/video/backlight/tps65217_bl.c:			dev_err(&pdev->dev,
drivers/video/backlight/tps65217_bl.c:			dev_err(&pdev->dev,
drivers/video/backlight/tps65217_bl.c:			dev_err(&pdev->dev,
drivers/video/backlight/tps65217_bl.c:	struct tps65217 *tps = dev_get_drvdata(pdev->dev.parent);
drivers/video/backlight/tps65217_bl.c:		if (!pdev->dev.platform_data) {
drivers/video/backlight/tps65217_bl.c:			dev_err(&pdev->dev, "no platform data provided\n");
drivers/video/backlight/tps65217_bl.c:		pdata = pdev->dev.platform_data;
drivers/video/backlight/tps65217_bl.c:	tps65217_bl = devm_kzalloc(&pdev->dev, sizeof(*tps65217_bl),
drivers/video/backlight/tps65217_bl.c:		dev_err(&pdev->dev, "allocation of struct tps65217_bl failed\n");
drivers/video/backlight/tps65217_bl.c:	tps65217_bl->dev = &pdev->dev;
drivers/video/backlight/tps65217_bl.c:	tps65217_bl->bl = backlight_device_register(pdev->name,
drivers/video/backlight/pwm_bl.c:	struct platform_pwm_backlight_data *data = pdev->dev.platform_data;
drivers/video/backlight/pwm_bl.c:		ret = pwm_backlight_parse_dt(&pdev->dev, &defdata);
drivers/video/backlight/pwm_bl.c:			dev_err(&pdev->dev, "failed to find platform data\n");
drivers/video/backlight/pwm_bl.c:		ret = data->init(&pdev->dev);
drivers/video/backlight/pwm_bl.c:	pb = devm_kzalloc(&pdev->dev, sizeof(*pb), GFP_KERNEL);
drivers/video/backlight/pwm_bl.c:		dev_err(&pdev->dev, "no memory for state\n");
drivers/video/backlight/pwm_bl.c:	pb->dev = &pdev->dev;
drivers/video/backlight/pwm_bl.c:	pb->pwm = devm_pwm_get(&pdev->dev, NULL);
drivers/video/backlight/pwm_bl.c:		dev_err(&pdev->dev, "unable to request PWM, trying legacy API\n");
drivers/video/backlight/pwm_bl.c:			dev_err(&pdev->dev, "unable to request legacy PWM\n");
drivers/video/backlight/pwm_bl.c:	dev_dbg(&pdev->dev, "got pwm for backlight\n");
drivers/video/backlight/pwm_bl.c:	bl = backlight_device_register(dev_name(&pdev->dev), &pdev->dev, pb,
drivers/video/backlight/pwm_bl.c:		dev_err(&pdev->dev, "failed to register backlight\n");
drivers/video/backlight/pwm_bl.c:		dev_warn(&pdev->dev,
drivers/video/backlight/pwm_bl.c:		data->exit(&pdev->dev);
drivers/video/backlight/pwm_bl.c:		pb->exit(&pdev->dev);
drivers/video/backlight/pcf50633-backlight.c:	struct device *parent = pdev->dev.parent;
drivers/video/backlight/pcf50633-backlight.c:	pcf_bl = devm_kzalloc(&pdev->dev, sizeof(*pcf_bl), GFP_KERNEL);
drivers/video/backlight/pcf50633-backlight.c:	pcf_bl->pcf = dev_to_pcf50633(pdev->dev.parent);
drivers/video/backlight/pcf50633-backlight.c:	pcf_bl->bl = backlight_device_register(pdev->name, &pdev->dev, pcf_bl,
drivers/video/backlight/cr_bllcd.c:	bdp = backlight_device_register("cr-backlight", &pdev->dev, NULL,
drivers/video/backlight/cr_bllcd.c:	ldp = lcd_device_register("cr-lcd", &pdev->dev, NULL, &cr_lcd_ops);
drivers/video/backlight/cr_bllcd.c:	crp = devm_kzalloc(&pdev->dev, sizeof(*crp), GFP_KERNEL);
drivers/video/backlight/atmel-pwm-bl.c:	dev_info(&pwmbl->pdev->dev, "Atmel PWM backlight driver (%lu Hz)\n",
drivers/video/backlight/atmel-pwm-bl.c:	pwmbl = devm_kzalloc(&pdev->dev, sizeof(struct atmel_pwm_bl),
drivers/video/backlight/atmel-pwm-bl.c:	pdata = pdev->dev.platform_data;
drivers/video/backlight/atmel-pwm-bl.c:		retval = devm_gpio_request(&pdev->dev, pwmbl->gpio_on,
drivers/video/backlight/atmel-pwm-bl.c:	bldev = backlight_device_register("atmel-pwm-bl", &pdev->dev, pwmbl,
drivers/video/backlight/as3711_bl.c:				       &pdev->dev, su,
drivers/video/backlight/as3711_bl.c:		dev_err(&pdev->dev, "failed to register backlight\n");
drivers/video/backlight/as3711_bl.c:	struct as3711_bl_pdata *pdata = dev_get_platdata(&pdev->dev);
drivers/video/backlight/as3711_bl.c:	struct as3711 *as3711 = dev_get_drvdata(pdev->dev.parent);
drivers/video/backlight/as3711_bl.c:		dev_err(&pdev->dev, "No platform data, exiting...\n");
drivers/video/backlight/as3711_bl.c:	if (pdev->dev.parent->of_node) {
drivers/video/backlight/as3711_bl.c:		ret = as3711_backlight_parse_dt(&pdev->dev);
drivers/video/backlight/as3711_bl.c:			dev_err(&pdev->dev, "DT parsing failed: %d\n", ret);
drivers/video/backlight/as3711_bl.c:		dev_err(&pdev->dev, "No framebuffer specified\n");
drivers/video/backlight/as3711_bl.c:		dev_warn(&pdev->dev,
drivers/video/backlight/as3711_bl.c:	supply = devm_kzalloc(&pdev->dev, sizeof(*supply), GFP_KERNEL);
drivers/video/backlight/max8925_bl.c:	struct device_node *nproot = pdev->dev.parent->of_node, *np;
drivers/video/backlight/max8925_bl.c:		dev_err(&pdev->dev, "failed to find backlight node\n");
drivers/video/backlight/max8925_bl.c:	struct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);
drivers/video/backlight/max8925_bl.c:	struct max8925_backlight_pdata *pdata = pdev->dev.platform_data;
drivers/video/backlight/max8925_bl.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct max8925_backlight_data),
drivers/video/backlight/max8925_bl.c:		dev_err(&pdev->dev, "No REG resource for mode control!\n");
drivers/video/backlight/max8925_bl.c:		dev_err(&pdev->dev, "No REG resource for control!\n");
drivers/video/backlight/max8925_bl.c:	bl = backlight_device_register("max8925-backlight", &pdev->dev, data,
drivers/video/backlight/max8925_bl.c:		dev_err(&pdev->dev, "failed to register backlight\n");
drivers/video/backlight/max8925_bl.c:	if (pdev->dev.parent->of_node && !pdata) {
drivers/video/backlight/max8925_bl.c:		pdata = devm_kzalloc(&pdev->dev,
drivers/video/backlight/jornada720_bl.c:	bd = backlight_device_register(S1D_DEVICENAME, &pdev->dev, NULL,
drivers/video/backlight/jornada720_bl.c:		dev_err(&pdev->dev, "failed to register device, err=%x\n", ret);
drivers/video/backlight/jornada720_bl.c:	dev_info(&pdev->dev, "HP Jornada 700 series backlight driver\n");
drivers/video/backlight/wm831x_bl.c:	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
drivers/video/backlight/wm831x_bl.c:	if (pdev->dev.parent->platform_data) {
drivers/video/backlight/wm831x_bl.c:		wm831x_pdata = pdev->dev.parent->platform_data;
drivers/video/backlight/wm831x_bl.c:		dev_err(&pdev->dev, "No platform data supplied\n");
drivers/video/backlight/wm831x_bl.c:		dev_err(&pdev->dev, "Invalid max_uA: %duA\n", pdata->max_uA);
drivers/video/backlight/wm831x_bl.c:		dev_warn(&pdev->dev,
drivers/video/backlight/wm831x_bl.c:		dev_err(&pdev->dev, "Invalid ISINK %d\n", pdata->isink);
drivers/video/backlight/wm831x_bl.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/video/backlight/wm831x_bl.c:	bl = backlight_device_register("wm831x", &pdev->dev, data,
drivers/video/backlight/wm831x_bl.c:		dev_err(&pdev->dev, "failed to register backlight\n");
drivers/video/backlight/lm3533_bl.c:	dev_dbg(&pdev->dev, "%s\n", __func__);
drivers/video/backlight/lm3533_bl.c:	lm3533 = dev_get_drvdata(pdev->dev.parent);
drivers/video/backlight/lm3533_bl.c:	pdata = pdev->dev.platform_data;
drivers/video/backlight/lm3533_bl.c:		dev_err(&pdev->dev, "no platform data\n");
drivers/video/backlight/lm3533_bl.c:	if (pdev->id < 0 || pdev->id >= LM3533_HVCTRLBANK_COUNT) {
drivers/video/backlight/lm3533_bl.c:		dev_err(&pdev->dev, "illegal backlight id %d\n", pdev->id);
drivers/video/backlight/lm3533_bl.c:	bl = devm_kzalloc(&pdev->dev, sizeof(*bl), GFP_KERNEL);
drivers/video/backlight/lm3533_bl.c:		dev_err(&pdev->dev,
drivers/video/backlight/lm3533_bl.c:	bl->id = pdev->id;
drivers/video/backlight/lm3533_bl.c:	bd = backlight_device_register(pdata->name, pdev->dev.parent, bl,
drivers/video/backlight/lm3533_bl.c:		dev_err(&pdev->dev, "failed to register backlight device\n");
drivers/video/backlight/lm3533_bl.c:		dev_err(&pdev->dev, "failed to create sysfs attributes\n");
drivers/video/backlight/lm3533_bl.c:	dev_dbg(&pdev->dev, "%s\n", __func__);
drivers/video/backlight/ot200_bl.c:	if (devm_gpio_request(&pdev->dev, GPIO_DIMM,
drivers/video/backlight/ot200_bl.c:		dev_err(&pdev->dev, "failed to request GPIO %d\n", GPIO_DIMM);
drivers/video/backlight/ot200_bl.c:		dev_err(&pdev->dev, "MFGPT 7 not available\n");
drivers/video/backlight/ot200_bl.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/video/backlight/ot200_bl.c:	bl = backlight_device_register(dev_name(&pdev->dev), &pdev->dev, data,
drivers/video/backlight/ot200_bl.c:		dev_err(&pdev->dev, "failed to register backlight\n");
drivers/video/backlight/omap1_bl.c:	struct omap_backlight_config *pdata = pdev->dev.platform_data;
drivers/video/backlight/omap1_bl.c:	bl = devm_kzalloc(&pdev->dev, sizeof(struct omap_backlight),
drivers/video/backlight/omap1_bl.c:	dev = backlight_device_register("omap-bl", &pdev->dev, bl, &omapbl_ops,
drivers/video/backlight/omap1_bl.c:	bl->dev = &pdev->dev;
drivers/video/backlight/omap1_bl.c:	dev_info(&pdev->dev, "OMAP LCD backlight initialised\n");
drivers/video/backlight/kb3886_bl.c:	struct kb3886bl_machinfo *machinfo = pdev->dev.platform_data;
drivers/video/backlight/kb3886_bl.c:							    &pdev->dev, NULL,
drivers/video/backlight/hp680_bl.c:	bd = backlight_device_register("hp680-bl", &pdev->dev, NULL,
drivers/video/backlight/pandora_bl.c:	bl = backlight_device_register(pdev->name, &pdev->dev,
drivers/video/backlight/pandora_bl.c:		dev_err(&pdev->dev, "failed to register backlight\n");
drivers/video/backlight/adp5520_bl.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/video/backlight/adp5520_bl.c:	data->master = pdev->dev.parent;
drivers/video/backlight/adp5520_bl.c:	data->pdata = pdev->dev.platform_data;
drivers/video/backlight/adp5520_bl.c:		dev_err(&pdev->dev, "missing platform data\n");
drivers/video/backlight/adp5520_bl.c:	data->id = pdev->id;
drivers/video/backlight/adp5520_bl.c:	bl = backlight_device_register(pdev->name, data->master, data,
drivers/video/backlight/adp5520_bl.c:		dev_err(&pdev->dev, "failed to register backlight\n");
drivers/video/backlight/adp5520_bl.c:		dev_err(&pdev->dev, "failed to register sysfs\n");
drivers/video/backlight/da9052_bl.c:	wleds = devm_kzalloc(&pdev->dev, sizeof(struct da9052_bl), GFP_KERNEL);
drivers/video/backlight/da9052_bl.c:	wleds->da9052 = dev_get_drvdata(pdev->dev.parent);
drivers/video/backlight/da9052_bl.c:	bl = backlight_device_register(pdev->name, wleds->da9052->dev, wleds,
drivers/video/backlight/da9052_bl.c:		dev_err(&pdev->dev, "Failed to register backlight\n");
drivers/video/backlight/da903x_bl.c:	struct da9034_backlight_pdata *pdata = pdev->dev.platform_data;
drivers/video/backlight/da903x_bl.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/video/backlight/da903x_bl.c:	switch (pdev->id) {
drivers/video/backlight/da903x_bl.c:		dev_err(&pdev->dev, "invalid backlight device ID(%d)\n",
drivers/video/backlight/da903x_bl.c:				pdev->id);
drivers/video/backlight/da903x_bl.c:	data->id = pdev->id;
drivers/video/backlight/da903x_bl.c:	data->da903x_dev = pdev->dev.parent;
drivers/video/backlight/da903x_bl.c:	bl = backlight_device_register(pdev->name, data->da903x_dev, data,
drivers/video/backlight/da903x_bl.c:		dev_err(&pdev->dev, "failed to register backlight\n");
drivers/video/matrox/matroxfb_misc.c:			if (ven != pdev->vendor || dev != pdev->device) {
drivers/video/matrox/matroxfb_misc.c:					ven, dev, pdev->vendor, pdev->device);
drivers/video/matrox/matroxfb_base.c:	svid = pdev->subsystem_vendor;
drivers/video/matrox/matroxfb_base.c:	sid = pdev->subsystem_device;
drivers/video/matrox/matroxfb_base.c:		if ((b->vendor != pdev->vendor) || (b->device != pdev->device) || (b->rev < pdev->revision)) continue;
drivers/video/s1d13xxxfb.c:	release_mem_region(pdev->resource[0].start,
drivers/video/s1d13xxxfb.c:			pdev->resource[0].end - pdev->resource[0].start +1);
drivers/video/s1d13xxxfb.c:	release_mem_region(pdev->resource[1].start,
drivers/video/s1d13xxxfb.c:			pdev->resource[1].end - pdev->resource[1].start +1);
drivers/video/s1d13xxxfb.c:	if (pdev->dev.platform_data)
drivers/video/s1d13xxxfb.c:		pdata = pdev->dev.platform_data;
drivers/video/s1d13xxxfb.c:	if (pdev->num_resources != 2) {
drivers/video/s1d13xxxfb.c:		dev_err(&pdev->dev, "invalid num_resources: %i\n",
drivers/video/s1d13xxxfb.c:		       pdev->num_resources);
drivers/video/s1d13xxxfb.c:	if (pdev->resource[0].flags != IORESOURCE_MEM
drivers/video/s1d13xxxfb.c:			|| pdev->resource[1].flags != IORESOURCE_MEM) {
drivers/video/s1d13xxxfb.c:		dev_err(&pdev->dev, "invalid resource type\n");
drivers/video/s1d13xxxfb.c:	if (!request_mem_region(pdev->resource[0].start,
drivers/video/s1d13xxxfb.c:		pdev->resource[0].end - pdev->resource[0].start +1, "s1d13xxxfb mem")) {
drivers/video/s1d13xxxfb.c:		dev_dbg(&pdev->dev, "request_mem_region failed\n");
drivers/video/s1d13xxxfb.c:	if (!request_mem_region(pdev->resource[1].start,
drivers/video/s1d13xxxfb.c:		pdev->resource[1].end - pdev->resource[1].start +1, "s1d13xxxfb regs")) {
drivers/video/s1d13xxxfb.c:		dev_dbg(&pdev->dev, "request_mem_region failed\n");
drivers/video/s1d13xxxfb.c:	info = framebuffer_alloc(sizeof(struct s1d13xxxfb_par) + sizeof(u32) * 256, &pdev->dev);
drivers/video/s1d13xxxfb.c:	default_par->regs = ioremap_nocache(pdev->resource[1].start,
drivers/video/s1d13xxxfb.c:			pdev->resource[1].end - pdev->resource[1].start +1);
drivers/video/s1d13xxxfb.c:	info->screen_base = ioremap_nocache(pdev->resource[0].start,
drivers/video/s1d13xxxfb.c:			pdev->resource[0].end - pdev->resource[0].start +1);
drivers/video/s1d13xxxfb.c:	info->fix.mmio_start = pdev->resource[1].start;
drivers/video/s1d13xxxfb.c:	info->fix.mmio_len = pdev->resource[1].end - pdev->resource[1].start + 1;
drivers/video/s1d13xxxfb.c:	info->fix.smem_start = pdev->resource[0].start;
drivers/video/s1d13xxxfb.c:	info->fix.smem_len = pdev->resource[0].end - pdev->resource[0].start + 1;
drivers/video/fsl-diu-fb.c:	struct device_node *np = pdev->dev.of_node;
drivers/video/fsl-diu-fb.c:	data = dmam_alloc_coherent(&pdev->dev, sizeof(struct fsl_diu_data),
drivers/video/fsl-diu-fb.c:		dev_err(&pdev->dev, "misaligned allocation");
drivers/video/fsl-diu-fb.c:		info->device = &pdev->dev;
drivers/video/fsl-diu-fb.c:		dev_err(&pdev->dev, "cannot map DIU registers\n");
drivers/video/fsl-diu-fb.c:		dev_err(&pdev->dev, "could not get DIU IRQ\n");
drivers/video/fsl-diu-fb.c:		dev_err(&pdev->dev, "could not claim irq\n");
drivers/video/fsl-diu-fb.c:			dev_err(&pdev->dev, "could not register fb %d\n", i);
drivers/video/fsl-diu-fb.c:	ret = device_create_file(&pdev->dev, &data->dev_attr);
drivers/video/fsl-diu-fb.c:		dev_err(&pdev->dev, "could not create sysfs file %s\n",
drivers/video/fsl-diu-fb.c:	dev_set_drvdata(&pdev->dev, data);
drivers/video/fsl-diu-fb.c:	data = dev_get_drvdata(&pdev->dev);
drivers/video/auo_k1901fb.c:	board = pdev->dev.platform_data;
drivers/video/igafb.c:	info = framebuffer_alloc(size, &pdev->dev);
drivers/video/igafb.c:	if ((addr = pdev->resource[0].start) == 0) {
drivers/video/omap/omapfb_main.c:	if (pdev->num_resources != 0) {
drivers/video/omap/omapfb_main.c:		dev_err(&pdev->dev, "probed for an unknown device\n");
drivers/video/omap/omapfb_main.c:	if (pdev->dev.platform_data == NULL) {
drivers/video/omap/omapfb_main.c:		dev_err(&pdev->dev, "missing platform data\n");
drivers/video/omap/omapfb_main.c:		dev_err(&pdev->dev,
drivers/video/omap/omapfb_main.c:	fbdev->dev = &pdev->dev;
drivers/video/omap/omapfb_main.c:		dev_err(&pdev->dev, "can't register omapdss device\n");
drivers/video/omap/lcd_ams_delta.c:	lcd_device = lcd_device_register("omapfb", &pdev->dev, NULL,
drivers/video/omap/lcd_ams_delta.c:		dev_err(&pdev->dev, "failed to register device\n");
drivers/video/kyro/fbdev.c:	info = framebuffer_alloc(sizeof(struct kyrofb_info), &pdev->dev);
drivers/video/bfin-t350mcqb-fb.c:	    framebuffer_alloc(sizeof(struct bfin_t350mcqbfb_info), &pdev->dev);
drivers/video/bfin-t350mcqb-fb.c:	info->dev = &pdev->dev;
drivers/video/sunxvr500.c:	info = framebuffer_alloc(sizeof(struct e3d_info), &pdev->dev);
drivers/video/geode/gxfb_core.c:	info = gxfb_init_fbinfo(&pdev->dev);
drivers/video/geode/gxfb_core.c:		dev_err(&pdev->dev, "failed to map frame buffer or controller registers\n");
drivers/video/geode/gxfb_core.c:		dev_err(&pdev->dev, "could not find valid video mode\n");
drivers/video/geode/lxfb_core.c:	info = lxfb_init_fbinfo(&pdev->dev);
drivers/video/geode/lxfb_core.c:		dev_err(&pdev->dev,
drivers/video/geode/lxfb_core.c:		dev_err(&pdev->dev, "could not find valid video mode\n");
drivers/video/geode/gx1fb_core.c:	info = gx1fb_init_fbinfo(&pdev->dev);
drivers/video/geode/gx1fb_core.c:		dev_err(&pdev->dev, "failed to map frame buffer or controller registers\n");
drivers/video/geode/gx1fb_core.c:		dev_err(&pdev->dev, "could not find valid video mode\n");
drivers/video/mx3fb.c:	struct device *dev = &pdev->dev;
drivers/video/wm8505fb.c:	fbi = devm_kzalloc(&pdev->dev, sizeof(struct wm8505fb_info) +
drivers/video/wm8505fb.c:		dev_err(&pdev->dev, "Failed to initialize framebuffer device\n");
drivers/video/wm8505fb.c:	fbi->regbase = devm_ioremap_resource(&pdev->dev, res);
drivers/video/wm8505fb.c:	disp_timing = of_get_display_timings(pdev->dev.of_node);
drivers/video/wm8505fb.c:	ret = of_get_fb_videomode(pdev->dev.of_node, &mode, OF_USE_NATIVE_MODE);
drivers/video/wm8505fb.c:	ret = of_property_read_u32(pdev->dev.of_node, "bits-per-pixel", &bpp);
drivers/video/wm8505fb.c:	fb_mem_virt = dmam_alloc_coherent(&pdev->dev, fb_mem_len, &fb_mem_phys,
drivers/video/wm8505fb.c:		dev_err(&pdev->dev, "Failed to set parameters\n");
drivers/video/wm8505fb.c:		dev_err(&pdev->dev, "Failed to allocate color map\n");
drivers/video/wm8505fb.c:		dev_err(&pdev->dev,
drivers/video/wm8505fb.c:	ret = device_create_file(&pdev->dev, &dev_attr_contrast);
drivers/video/wm8505fb.c:	device_remove_file(&pdev->dev, &dev_attr_contrast);
drivers/video/chipsfb.c:	if (state.event == pdev->dev.power.power_state.event)
drivers/video/chipsfb.c:	pdev->dev.power.power_state = state;
drivers/video/chipsfb.c:	pdev->dev.power.power_state = PMSG_ON;
drivers/video/via/via-core.c:		ret = request_irq(global_dev.pdev->irq, viafb_dma_irq,
drivers/video/via/via-core.c:		free_irq(global_dev.pdev->irq, &viafb_dma_users);
drivers/video/via/via-core.c:	descrpages = dma_alloc_coherent(&global_dev.pdev->dev,
drivers/video/via/via-core.c:		dev_err(&global_dev.pdev->dev, "Unable to get descr page.\n");
drivers/video/via/via-core.c:	dma_free_coherent(&global_dev.pdev->dev,
drivers/video/via/via-core.c:		DEBUG_MSG(KERN_INFO "Device ID = %x\n", pdev->device);
drivers/video/via/via-core.c:		switch (pdev->device) {
drivers/video/via/via-core.c:		dev_err(&vdev->pdev->dev,
drivers/video/via/via-core.c:		dev_err(&vdev->pdev->dev, "Unable to allocate pdev %s\n",
drivers/video/via/via-core.c:	info->platdev->dev.parent = &vdev->pdev->dev;
drivers/video/via/via-core.c:		dev_err(&vdev->pdev->dev, "Unable to add pdev %s\n",
drivers/video/via/viafbdev.c:		&vdev->pdev->dev);
drivers/video/via/viafbdev.c:				&vdev->pdev->dev);
drivers/video/via/via_i2c.c:		adapter->dev.parent = &pdev->dev;
drivers/video/cirrusfb.c:	info = framebuffer_alloc(sizeof(struct cirrusfb_info), &pdev->dev);
drivers/video/cirrusfb.c:		(unsigned long long)pdev->resource[0].start,  cinfo->btype);
drivers/video/cirrusfb.c:		(unsigned long long)pdev->resource[1].start);
drivers/video/hgafb.c:	info = framebuffer_alloc(0, &pdev->dev);
drivers/video/gxt4500.c:		dev_err(&pdev->dev, "gxt4500: cannot enable PCI device: %d\n",
drivers/video/gxt4500.c:		dev_err(&pdev->dev, "gxt4500: cannot get registers\n");
drivers/video/gxt4500.c:		dev_err(&pdev->dev, "gxt4500: cannot get framebuffer\n");
drivers/video/gxt4500.c:	info = framebuffer_alloc(sizeof(struct gxt4500_par), &pdev->dev);
drivers/video/gxt4500.c:		dev_err(&pdev->dev, "gxt4500: cannot alloc FB info record\n");
drivers/video/gxt4500.c:		dev_err(&pdev->dev, "gxt4500: cannot map registers\n");
drivers/video/gxt4500.c:		dev_err(&pdev->dev, "gxt4500: cannot map framebuffer\n");
drivers/video/gxt4500.c:		dev_err(&pdev->dev, "gxt4500: cannot allocate cmap\n");
drivers/video/gxt4500.c:		dev_err(&pdev->dev, "gxt4500: cannot find valid video mode\n");
drivers/video/gxt4500.c:		dev_err(&pdev->dev, "gxt4500: cannot register framebuffer\n");
drivers/video/aty/radeon_pm.c:		if ((id->subsystem_vendor == rinfo->pdev->subsystem_vendor ) &&
drivers/video/aty/radeon_pm.c:		    (id->subsystem_device == rinfo->pdev->subsystem_device )) {
drivers/video/aty/radeon_pm.c:	rinfo->pdev->current_state = state;
drivers/video/aty/radeon_pm.c:	if (mesg.event == pdev->dev.power.power_state.event)
drivers/video/aty/radeon_pm.c:	pdev->dev.power.power_state = mesg;
drivers/video/aty/radeon_pm.c:	if (pdev->dev.power.power_state.event == PM_EVENT_ON)
drivers/video/aty/radeon_pm.c:	       pci_name(pdev), pdev->dev.power.power_state.event);
drivers/video/aty/radeon_pm.c:	if (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {
drivers/video/aty/radeon_pm.c:	pdev->dev.power.power_state = PMSG_ON;
drivers/video/aty/radeon_base.c:		switch (rinfo->pdev->device) {
drivers/video/aty/radeon_base.c:	info = framebuffer_alloc(sizeof(struct radeonfb_info), &pdev->dev);
drivers/video/aty/radeon_base.c:	rinfo->chipset = pdev->device;
drivers/video/aty/radeon_base.c:		err |= sysfs_create_bin_file(&rinfo->pdev->dev.kobj,
drivers/video/aty/radeon_base.c:		err |= sysfs_create_bin_file(&rinfo->pdev->dev.kobj,
drivers/video/aty/radeon_base.c:		sysfs_remove_bin_file(&rinfo->pdev->dev.kobj, &edid1_attr);
drivers/video/aty/radeon_base.c:		sysfs_remove_bin_file(&rinfo->pdev->dev.kobj, &edid2_attr);
drivers/video/aty/aty128fb.c:	info = framebuffer_alloc(sizeof(struct aty128fb_par), &pdev->dev);
drivers/video/aty/aty128fb.c:	if (state.event == pdev->dev.power.power_state.event)
drivers/video/aty/aty128fb.c:	pdev->dev.power.power_state = state;
drivers/video/aty/aty128fb.c:	if (pdev->dev.power.power_state.event == PM_EVENT_ON)
drivers/video/aty/aty128fb.c:	pdev->dev.power.power_state = PMSG_ON;
drivers/video/aty/radeon_i2c.c:	chan->adapter.dev.parent	= &chan->rinfo->pdev->dev;
drivers/video/aty/radeon_i2c.c:		dev_dbg(&chan->rinfo->pdev->dev, "I2C bus %s registered.\n", name);
drivers/video/aty/radeon_i2c.c:		dev_warn(&chan->rinfo->pdev->dev, "Failed to register I2C bus %s.\n", name);
drivers/video/aty/atyfb_base.c:	if (state.event == pdev->dev.power.power_state.event)
drivers/video/aty/atyfb_base.c:	pdev->dev.power.power_state = state;
drivers/video/aty/atyfb_base.c:	if (pdev->dev.power.power_state.event == PM_EVENT_ON)
drivers/video/aty/atyfb_base.c:	    pdev->dev.power.power_state.event == PM_EVENT_SUSPEND)
drivers/video/aty/atyfb_base.c:	pdev->dev.power.power_state = PMSG_ON;
drivers/video/aty/atyfb_base.c:	for (i = 0; i < 6 && pdev->resource[i].start; i++)
drivers/video/aty/atyfb_base.c:	for (i = 0, j = 2; i < 6 && pdev->resource[i].start; i++) {
drivers/video/aty/atyfb_base.c:		struct resource *rp = &pdev->resource[i];
drivers/video/aty/atyfb_base.c:	if (IS_XL(pdev->device)) {
drivers/video/aty/atyfb_base.c:		if (IS_XL(pdev->device))
drivers/video/aty/atyfb_base.c:	rrp = &pdev->resource[2];
drivers/video/aty/atyfb_base.c:	rp = &pdev->resource[0];
drivers/video/aty/atyfb_base.c:		rp = &pdev->resource[1];
drivers/video/aty/atyfb_base.c:	info = framebuffer_alloc(sizeof(struct atyfb_par), &pdev->dev);
drivers/video/aty/atyfb_base.c:	info->device = &pdev->dev;
drivers/video/aty/atyfb_base.c:	par->pci_id = pdev->device;
drivers/video/aty/atyfb_base.c:	par->irq = pdev->irq;
drivers/video/sh_mobile_hdmi.c:	struct sh_mobile_hdmi_info *pdata = pdev->dev.platform_data;
drivers/video/sh_mobile_hdmi.c:			dev_err(&pdev->dev, "htop1 needs register base\n");
drivers/video/sh_mobile_hdmi.c:		dev_err(&pdev->dev, "Cannot allocate device data\n");
drivers/video/sh_mobile_hdmi.c:	hdmi->dev = &pdev->dev;
drivers/video/sh_mobile_hdmi.c:	hdmi->hdmi_clk = clk_get(&pdev->dev, "ick");
drivers/video/sh_mobile_hdmi.c:		dev_err(&pdev->dev, "Unable to get clock: %d\n", ret);
drivers/video/sh_mobile_hdmi.c:	dev_dbg(&pdev->dev, "Enabled HDMI clock at %luHz\n", rate);
drivers/video/sh_mobile_hdmi.c:	if (!request_mem_region(res->start, resource_size(res), dev_name(&pdev->dev))) {
drivers/video/sh_mobile_hdmi.c:		dev_err(&pdev->dev, "HDMI register region already claimed\n");
drivers/video/sh_mobile_hdmi.c:		dev_err(&pdev->dev, "HDMI register region already claimed\n");
drivers/video/sh_mobile_hdmi.c:	pm_runtime_enable(&pdev->dev);
drivers/video/sh_mobile_hdmi.c:	pm_runtime_get_sync(&pdev->dev);
drivers/video/sh_mobile_hdmi.c:			dev_err(&pdev->dev, "control register region already claimed\n");
drivers/video/sh_mobile_hdmi.c:	dev_info(&pdev->dev, "Detected HDMI controller 0x%x:0x%x\n",
drivers/video/sh_mobile_hdmi.c:			  dev_name(&pdev->dev), hdmi);
drivers/video/sh_mobile_hdmi.c:		dev_err(&pdev->dev, "Unable to request irq: %d\n", ret);
drivers/video/sh_mobile_hdmi.c:	ret = snd_soc_register_codec(&pdev->dev,
drivers/video/sh_mobile_hdmi.c:		dev_err(&pdev->dev, "codec registration failed\n");
drivers/video/sh_mobile_hdmi.c:	pm_runtime_put(&pdev->dev);
drivers/video/sh_mobile_hdmi.c:	pm_runtime_disable(&pdev->dev);
drivers/video/sh_mobile_hdmi.c:	snd_soc_unregister_codec(&pdev->dev);
drivers/video/sh_mobile_hdmi.c:	pm_runtime_put(&pdev->dev);
drivers/video/sh_mobile_hdmi.c:	pm_runtime_disable(&pdev->dev);
drivers/video/intelfb/intelfbhw.c:	switch (pdev->device) {
drivers/video/intelfb/intelfbhw.c:	switch (pdev->device) {
drivers/video/intelfb/intelfbhw.c:	switch(pdev->device) {
drivers/video/intelfb/intelfbhw.c:	if (dinfo->pdev->device == PCI_DEVICE_ID_INTEL_830M) {
drivers/video/intelfb/intelfbhw.c:		if (request_irq(dinfo->pdev->irq, intelfbhw_irq, IRQF_SHARED,
drivers/video/intelfb/intelfbhw.c:		free_irq(dinfo->pdev->irq, dinfo);
drivers/video/intelfb/intelfbdrv.c:	info = framebuffer_alloc(sizeof(struct intelfb_info), &pdev->dev);
drivers/video/intelfb/intelfbdrv.c:	dinfo->pci_chipset = pdev->device;
drivers/video/intelfb/intelfbdrv.c:		pdev->bus->number, PCI_SLOT(pdev->devfn),
drivers/video/intelfb/intelfbdrv.c:		PCI_FUNC(pdev->devfn), dinfo->name,
drivers/video/intelfb/intelfbdrv.c:		const u8 *edid_s = fb_firmware_edid(&dinfo->pdev->dev);
drivers/video/intelfb/intelfb_i2c.c:	chan->adapter.dev.parent	= &chan->dinfo->pdev->dev;
drivers/video/imxfb.c:	bl = backlight_device_register("imxfb-bl", &fbi->pdev->dev, fbi,
drivers/video/imxfb.c:		dev_err(&fbi->pdev->dev, "error %ld on backlight register\n",
drivers/video/imxfb.c:	struct imx_fb_platform_data *pdata = pdev->dev.platform_data;
drivers/video/imxfb.c:	struct fb_info *info = dev_get_drvdata(&pdev->dev);
drivers/video/imxfb.c:	fbi->devtype = pdev->id_entry->driver_data;
drivers/video/imxfb.c:	dev_info(&pdev->dev, "i.MX Framebuffer driver\n");
drivers/video/imxfb.c:	pdata = pdev->dev.platform_data;
drivers/video/imxfb.c:		dev_err(&pdev->dev,"No platform_data available\n");
drivers/video/imxfb.c:	info = framebuffer_alloc(sizeof(struct imxfb_info), &pdev->dev);
drivers/video/imxfb.c:	fbi->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
drivers/video/imxfb.c:	fbi->clk_ahb = devm_clk_get(&pdev->dev, "ahb");
drivers/video/imxfb.c:	fbi->clk_per = devm_clk_get(&pdev->dev, "per");
drivers/video/imxfb.c:		dev_err(&pdev->dev, "Cannot map frame buffer registers\n");
drivers/video/imxfb.c:		fbi->map_cpu = dma_alloc_writecombine(&pdev->dev,
drivers/video/imxfb.c:			dev_err(&pdev->dev, "Failed to allocate video RAM: %d\n", ret);
drivers/video/imxfb.c:		dev_err(&pdev->dev, "failed to register framebuffer\n");
drivers/video/imxfb.c:		dma_free_writecombine(&pdev->dev,fbi->map_size,fbi->map_cpu,
drivers/video/imxfb.c:	pdata = pdev->dev.platform_data;
drivers/video/sm501fb.c:	struct device *dev = &pdev->dev;
drivers/video/sm501fb.c:					    pdev->name);
drivers/video/sm501fb.c:					      pdev->name);
drivers/video/sm501fb.c:					     pdev->name);
drivers/video/sm501fb.c:	struct device *dev = &pdev->dev;
drivers/video/sm501fb.c:	info->dev = dev = &pdev->dev;
drivers/video/sm501fb.c:		struct device_node *np = pdev->dev.parent->of_node;
drivers/video/sm501fb.c:	device_remove_file(&pdev->dev, &dev_attr_fbregs_crt);
drivers/video/sm501fb.c:	device_remove_file(&pdev->dev, &dev_attr_fbregs_pnl);
drivers/video/sm501fb.c:	device_remove_file(&pdev->dev, &dev_attr_crt_src);
drivers/video/sh_mipi_dsi.c:	struct sh_mipi_dsi_info *pdata = mipi->pdev->dev.platform_data;
drivers/video/sh_mipi_dsi.c:	struct sh_mipi_dsi_info *pdata = mipi->pdev->dev.platform_data;
drivers/video/sh_mipi_dsi.c:	pm_runtime_get_sync(&mipi->pdev->dev);
drivers/video/sh_mipi_dsi.c:	pm_runtime_put_sync(&mipi->pdev->dev);
drivers/video/sh_mipi_dsi.c:	struct sh_mipi_dsi_info *pdata = mipi->pdev->dev.platform_data;
drivers/video/sh_mipi_dsi.c:	pm_runtime_put_sync(&mipi->pdev->dev);
drivers/video/sh_mipi_dsi.c:	struct sh_mipi_dsi_info *pdata = pdev->dev.platform_data;
drivers/video/sh_mipi_dsi.c:	int idx = pdev->id, ret;
drivers/video/sh_mipi_dsi.c:	if (!request_mem_region(res->start, resource_size(res), pdev->name)) {
drivers/video/sh_mipi_dsi.c:		dev_err(&pdev->dev, "MIPI register region already claimed\n");
drivers/video/sh_mipi_dsi.c:	if (!request_mem_region(res2->start, resource_size(res2), pdev->name)) {
drivers/video/sh_mipi_dsi.c:		dev_err(&pdev->dev, "MIPI register region 2 already claimed\n");
drivers/video/sh_mipi_dsi.c:	mipi->dsit_clk = clk_get(&pdev->dev, "dsit_clk");
drivers/video/sh_mipi_dsi.c:	dev_dbg(&pdev->dev, "DSI-T clk %lu -> %lu\n", f_current, rate);
drivers/video/sh_mipi_dsi.c:	pm_runtime_enable(&pdev->dev);
drivers/video/sh_mipi_dsi.c:	pm_runtime_resume(&pdev->dev);
drivers/video/sh_mipi_dsi.c:	pm_runtime_disable(&pdev->dev);
drivers/video/vt8500lcdfb.c:	fbi = devm_kzalloc(&pdev->dev, sizeof(struct vt8500lcd_info)
drivers/video/vt8500lcdfb.c:		dev_err(&pdev->dev, "Failed to initialize framebuffer device\n");
drivers/video/vt8500lcdfb.c:		dev_err(&pdev->dev, "no I/O memory resource defined\n");
drivers/video/vt8500lcdfb.c:		dev_err(&pdev->dev, "failed to request I/O memory\n");
drivers/video/vt8500lcdfb.c:		dev_err(&pdev->dev, "failed to map I/O memory\n");
drivers/video/vt8500lcdfb.c:	disp_timing = of_get_display_timings(pdev->dev.of_node);
drivers/video/vt8500lcdfb.c:	ret = of_get_fb_videomode(pdev->dev.of_node, &of_mode,
drivers/video/vt8500lcdfb.c:	ret = of_property_read_u32(pdev->dev.of_node, "bits-per-pixel", &bpp);
drivers/video/vt8500lcdfb.c:	fb_mem_virt = dma_alloc_coherent(&pdev->dev, fb_mem_len, &fb_mem_phys,
drivers/video/vt8500lcdfb.c:	fbi->palette_cpu	= dma_alloc_coherent(&pdev->dev,
drivers/video/vt8500lcdfb.c:		dev_err(&pdev->dev, "Failed to allocate palette buffer\n");
drivers/video/vt8500lcdfb.c:		dev_err(&pdev->dev, "no IRQ defined\n");
drivers/video/vt8500lcdfb.c:		dev_err(&pdev->dev, "request_irq failed: %d\n", ret);
drivers/video/vt8500lcdfb.c:		dev_err(&pdev->dev, "Failed to allocate color map\n");
drivers/video/vt8500lcdfb.c:		dev_err(&pdev->dev, "Failed to set parameters\n");
drivers/video/vt8500lcdfb.c:		dev_err(&pdev->dev,
drivers/video/vt8500lcdfb.c:	dma_free_coherent(&pdev->dev, fbi->palette_size,
drivers/video/vt8500lcdfb.c:	dma_free_coherent(&pdev->dev, fbi->palette_size,
drivers/video/omap2/omapfb/omapfb-main.c:	if (pdev->num_resources != 0) {
drivers/video/omap2/omapfb/omapfb-main.c:		dev_err(&pdev->dev, "probed for an unknown device\n");
drivers/video/omap2/omapfb/omapfb-main.c:	fbdev = devm_kzalloc(&pdev->dev, sizeof(struct omapfb2_device),
drivers/video/omap2/omapfb/omapfb-main.c:		dev_warn(&pdev->dev, "VRFB is not supported on this hardware, "
drivers/video/omap2/omapfb/omapfb-main.c:	fbdev->dev = &pdev->dev;
drivers/video/omap2/omapfb/omapfb-main.c:			dev_warn(&pdev->dev, "no driver for display: %s\n",
drivers/video/omap2/omapfb/omapfb-main.c:		dev_err(&pdev->dev, "no displays\n");
drivers/video/omap2/omapfb/omapfb-main.c:			dev_warn(&pdev->dev, "cannot parse default modes\n");
drivers/video/omap2/omapfb/omapfb-main.c:	dev_err(&pdev->dev, "failed to setup omapfb\n");
drivers/video/omap2/dss/dpi.c:	struct omap_dss_board_info *pdata = pdev->dev.platform_data;
drivers/video/omap2/dss/dpi.c:	dss_unregister_child_devices(&pdev->dev);
drivers/video/omap2/dss/rfbi.c:	r = pm_runtime_get_sync(&rfbi.pdev->dev);
drivers/video/omap2/dss/rfbi.c:	r = pm_runtime_put_sync(&rfbi.pdev->dev);
drivers/video/omap2/dss/rfbi.c:	struct omap_dss_board_info *pdata = pdev->dev.platform_data;
drivers/video/omap2/dss/rfbi.c:	rfbi.base = devm_ioremap(&pdev->dev, rfbi_mem->start,
drivers/video/omap2/dss/rfbi.c:	clk = clk_get(&pdev->dev, "ick");
drivers/video/omap2/dss/rfbi.c:	pm_runtime_enable(&pdev->dev);
drivers/video/omap2/dss/rfbi.c:	dev_dbg(&pdev->dev, "OMAP RFBI rev %d.%d\n",
drivers/video/omap2/dss/rfbi.c:		pm_runtime_disable(&pdev->dev);
drivers/video/omap2/dss/rfbi.c:	pm_runtime_disable(&pdev->dev);
drivers/video/omap2/dss/rfbi.c:	dss_unregister_child_devices(&pdev->dev);
drivers/video/omap2/dss/rfbi.c:	pm_runtime_disable(&pdev->dev);
drivers/video/omap2/dss/display-sysfs.c:	r = sysfs_create_link(&pdev->dev.kobj, &dssdev->dev.kobj,
drivers/video/omap2/dss/display-sysfs.c:	sysfs_remove_link(&pdev->dev.kobj, dev_name(&dssdev->dev));
drivers/video/omap2/dss/dss.c:	struct omap_dss_board_info *board_data = dss.pdev->dev.platform_data;
drivers/video/omap2/dss/dss.c:	cnt = board_data->get_context_loss_count(&dss.pdev->dev);
drivers/video/omap2/dss/dss.c:	clk = devm_clk_get(&dss.pdev->dev, "fck");
drivers/video/omap2/dss/dss.c:	r = pm_runtime_get_sync(&dss.pdev->dev);
drivers/video/omap2/dss/dss.c:	r = pm_runtime_put_sync(&dss.pdev->dev);
drivers/video/omap2/dss/dss.c:	dst = devm_kzalloc(&pdev->dev, sizeof(*dst), GFP_KERNEL);
drivers/video/omap2/dss/dss.c:		dev_err(&pdev->dev, "Failed to allocate local DSS Features\n");
drivers/video/omap2/dss/dss.c:	dss.base = devm_ioremap(&pdev->dev, dss_mem->start,
drivers/video/omap2/dss/dss.c:	pm_runtime_enable(&pdev->dev);
drivers/video/omap2/dss/dss.c:	pm_runtime_disable(&pdev->dev);
drivers/video/omap2/dss/dss.c:	pm_runtime_disable(&pdev->dev);
drivers/video/omap2/dss/hdmi.c:	r = pm_runtime_get_sync(&hdmi.pdev->dev);
drivers/video/omap2/dss/hdmi.c:	r = pm_runtime_put_sync(&hdmi.pdev->dev);
drivers/video/omap2/dss/hdmi.c:		reg = devm_regulator_get(&hdmi.pdev->dev, "vdda_hdmi_dac");
drivers/video/omap2/dss/hdmi.c:			reg = devm_regulator_get(&hdmi.pdev->dev, "VDAC");
drivers/video/omap2/dss/hdmi.c:	clk = devm_clk_get(&pdev->dev, "sys_clk");
drivers/video/omap2/dss/hdmi.c:	struct omap_dss_board_info *pdata = pdev->dev.platform_data;
drivers/video/omap2/dss/hdmi.c:	dssdev = dss_alloc_and_init_device(&pdev->dev);
drivers/video/omap2/dss/hdmi.c:	hdmi.ip_data.base_wp = devm_ioremap_resource(&pdev->dev, res);
drivers/video/omap2/dss/hdmi.c:	pm_runtime_enable(&pdev->dev);
drivers/video/omap2/dss/hdmi.c:		pm_runtime_disable(&pdev->dev);
drivers/video/omap2/dss/hdmi.c:	device_for_each_child(&pdev->dev, NULL, hdmi_remove_child);
drivers/video/omap2/dss/hdmi.c:	dss_unregister_child_devices(&pdev->dev);
drivers/video/omap2/dss/hdmi.c:	pm_runtime_disable(&pdev->dev);
drivers/video/omap2/dss/core.c:	struct omap_dss_board_info *pdata = core.pdev->dev.platform_data;
drivers/video/omap2/dss/core.c:	reg = regulator_get(&core.pdev->dev, "vdds_dsi");
drivers/video/omap2/dss/core.c:	reg = regulator_get(&core.pdev->dev, "vdds_sdi");
drivers/video/omap2/dss/core.c:	struct omap_dss_board_info *board_data = core.pdev->dev.platform_data;
drivers/video/omap2/dss/core.c:	struct omap_dss_board_info *board_data = core.pdev->dev.platform_data;
drivers/video/omap2/dss/core.c:	struct omap_dss_board_info *pdata = core.pdev->dev.platform_data;
drivers/video/omap2/dss/core.c:	struct omap_dss_board_info *pdata = pdev->dev.platform_data;
drivers/video/omap2/dss/venc.c:	r = pm_runtime_get_sync(&venc.pdev->dev);
drivers/video/omap2/dss/venc.c:	r = pm_runtime_put_sync(&venc.pdev->dev);
drivers/video/omap2/dss/venc.c:		vdda_dac = regulator_get(&venc.pdev->dev, "vdda_dac");
drivers/video/omap2/dss/venc.c:		clk = devm_clk_get(&pdev->dev, "tv_dac_clk");
drivers/video/omap2/dss/venc.c:	struct omap_dss_board_info *pdata = pdev->dev.platform_data;
drivers/video/omap2/dss/venc.c:	venc.base = devm_ioremap(&pdev->dev, venc_mem->start,
drivers/video/omap2/dss/venc.c:	pm_runtime_enable(&pdev->dev);
drivers/video/omap2/dss/venc.c:	dev_dbg(&pdev->dev, "OMAP VENC rev %d\n", rev_id);
drivers/video/omap2/dss/venc.c:		pm_runtime_disable(&pdev->dev);
drivers/video/omap2/dss/venc.c:	pm_runtime_disable(&pdev->dev);
drivers/video/omap2/dss/venc.c:	dss_unregister_child_devices(&pdev->dev);
drivers/video/omap2/dss/venc.c:	pm_runtime_disable(&pdev->dev);
drivers/video/omap2/dss/sdi.c:	struct omap_dss_board_info *pdata = pdev->dev.platform_data;
drivers/video/omap2/dss/sdi.c:	dss_unregister_child_devices(&pdev->dev);
drivers/video/omap2/dss/overlay-sysfs.c:			&pdev->dev.kobj, "overlay%d", ovl->id);
drivers/video/omap2/dss/dispc.c:	r = pm_runtime_get_sync(&dispc.pdev->dev);
drivers/video/omap2/dss/dispc.c:	r = pm_runtime_put_sync(&dispc.pdev->dev);
drivers/video/omap2/dss/dispc.c:	dst = devm_kzalloc(&pdev->dev, sizeof(*dst), GFP_KERNEL);
drivers/video/omap2/dss/dispc.c:		dev_err(&pdev->dev, "Failed to allocate DISPC Features\n");
drivers/video/omap2/dss/dispc.c:	return devm_request_irq(&dispc.pdev->dev, dispc.irq, handler,
drivers/video/omap2/dss/dispc.c:	devm_free_irq(&dispc.pdev->dev, dispc.irq, dev_id);
drivers/video/omap2/dss/dispc.c:	dispc.base = devm_ioremap(&pdev->dev, dispc_mem->start,
drivers/video/omap2/dss/dispc.c:	pm_runtime_enable(&pdev->dev);
drivers/video/omap2/dss/dispc.c:	dev_dbg(&pdev->dev, "OMAP DISPC rev %d.%d\n",
drivers/video/omap2/dss/dispc.c:	pm_runtime_disable(&pdev->dev);
drivers/video/omap2/dss/dispc.c:	pm_runtime_disable(&pdev->dev);
drivers/video/omap2/dss/manager-sysfs.c:			&pdev->dev.kobj, "manager%d", mgr->id);
drivers/video/omap2/dss/dsi.c:	r = pm_runtime_get_sync(&dsi->pdev->dev);
drivers/video/omap2/dss/dsi.c:	r = pm_runtime_put_sync(&dsi->pdev->dev);
drivers/video/omap2/dss/dsi.c:		vdds_dsi = regulator_get(&dsi->pdev->dev, "vdds_dsi");
drivers/video/omap2/dss/dsi.c:			vdds_dsi = regulator_get(&dsi->pdev->dev, "VCXIO");
drivers/video/omap2/dss/dsi.c:		vdds_dsi = regulator_get(&dsi->pdev->dev, "vdds_dsi");
drivers/video/omap2/dss/dsi.c:			vdds_dsi = regulator_get(&dsi->pdev->dev, "VCXIO");
drivers/video/omap2/dss/dsi.c:	struct omap_dss_board_info *pdata = pdev->dev.platform_data;
drivers/video/omap2/vrfb.c:	vrfb_base = devm_ioremap_resource(&pdev->dev, mem);
drivers/video/omap2/vrfb.c:	num_ctxs = pdev->num_resources - 1;
drivers/video/omap2/vrfb.c:	ctxs = devm_kzalloc(&pdev->dev,
drivers/video/omap2/vrfb.c:			dev_err(&pdev->dev, "can't get vrfb ctx %d address\n",
drivers/video/riva/rivafb-i2c.c:	chan->adapter.dev.parent	= &chan->par->pdev->dev;
drivers/video/riva/rivafb-i2c.c:		dev_dbg(&chan->par->pdev->dev, "I2C bus %s registered.\n", name);
drivers/video/riva/rivafb-i2c.c:		dev_warn(&chan->par->pdev->dev,
drivers/video/mmp/fb/mmpfb.c:	mi = pdev->dev.platform_data;
drivers/video/mmp/fb/mmpfb.c:		dev_err(&pdev->dev, "no platform data defined\n");
drivers/video/mmp/fb/mmpfb.c:	info = framebuffer_alloc(sizeof(struct mmpfb_info), &pdev->dev);
drivers/video/mmp/fb/mmpfb.c:	fbi->dev = &pdev->dev;
drivers/video/mmp/fb/mmpfb.c:		dev_err(&pdev->dev, "can't get the path %s\n", mi->path_name);
drivers/video/mmp/fb/mmpfb.c:	fbi->fb_start = dma_alloc_coherent(&pdev->dev, PAGE_ALIGN(fbi->fb_size),
drivers/video/mmp/fb/mmpfb.c:		dev_err(&pdev->dev, "can't alloc framebuffer\n");
drivers/video/mmp/fb/mmpfb.c:		dev_err(&pdev->dev, "Failed to register fb: %d\n", ret);
drivers/video/mmp/fb/mmpfb.c:	dma_free_coherent(&pdev->dev, PAGE_ALIGN(fbi->fb_size), fbi->fb_start,
drivers/video/mmp/hw/mmp_ctrl.c:		dev_err(&pdev->dev, "%s: no IO memory defined\n", __func__);
drivers/video/mmp/hw/mmp_ctrl.c:		dev_err(&pdev->dev, "%s: no IRQ defined\n", __func__);
drivers/video/mmp/hw/mmp_ctrl.c:	mi = pdev->dev.platform_data;
drivers/video/mmp/hw/mmp_ctrl.c:		dev_err(&pdev->dev, "%s: no platform data defined\n", __func__);
drivers/video/mmp/hw/mmp_ctrl.c:	ctrl = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
drivers/video/mmp/hw/mmp_ctrl.c:	ctrl->dev = &pdev->dev;
drivers/video/mmp/hw/mmp_ctrl.c:	dev_err(&pdev->dev, "device init failed\n");
drivers/video/simplefb.c:	struct device_node *np = pdev->dev.of_node;
drivers/video/simplefb.c:		dev_err(&pdev->dev, "Can't parse width property\n");
drivers/video/simplefb.c:		dev_err(&pdev->dev, "Can't parse height property\n");
drivers/video/simplefb.c:		dev_err(&pdev->dev, "Can't parse stride property\n");
drivers/video/simplefb.c:		dev_err(&pdev->dev, "Can't parse format property\n");
drivers/video/simplefb.c:		dev_err(&pdev->dev, "Invalid format value\n");
drivers/video/simplefb.c:		dev_err(&pdev->dev, "No memory resource\n");
drivers/video/simplefb.c:	info = framebuffer_alloc(sizeof(u32) * 16, &pdev->dev);
drivers/video/simplefb.c:	info->screen_base = devm_ioremap(&pdev->dev, info->fix.smem_start,
drivers/video/simplefb.c:		dev_err(&pdev->dev, "Unable to register simplefb: %d\n", ret);
drivers/video/simplefb.c:	dev_info(&pdev->dev, "fb%d: simplefb registered!\n", info->node);
drivers/video/jz4740_fb.c:	jzfb->framedesc = dma_alloc_coherent(&jzfb->pdev->dev,
drivers/video/jz4740_fb.c:	jzfb->vidmem = dma_alloc_coherent(&jzfb->pdev->dev,
drivers/video/jz4740_fb.c:	dma_free_coherent(&jzfb->pdev->dev, sizeof(*jzfb->framedesc),
drivers/video/jz4740_fb.c:	dma_free_coherent(&jzfb->pdev->dev, jzfb->vidmem_size,
drivers/video/jz4740_fb.c:	dma_free_coherent(&jzfb->pdev->dev, sizeof(*jzfb->framedesc),
drivers/video/jz4740_fb.c:	struct jz4740_fb_platform_data *pdata = pdev->dev.platform_data;
drivers/video/jz4740_fb.c:		dev_err(&pdev->dev, "Missing platform data\n");
drivers/video/jz4740_fb.c:	fb = framebuffer_alloc(sizeof(struct jzfb), &pdev->dev);
drivers/video/jz4740_fb.c:		dev_err(&pdev->dev, "Failed to allocate framebuffer device\n");
drivers/video/jz4740_fb.c:	jzfb->ldclk = devm_clk_get(&pdev->dev, "lcd");
drivers/video/jz4740_fb.c:		dev_err(&pdev->dev, "Failed to get lcd clock: %d\n", ret);
drivers/video/jz4740_fb.c:	jzfb->lpclk = devm_clk_get(&pdev->dev, "lcd_pclk");
drivers/video/jz4740_fb.c:		dev_err(&pdev->dev, "Failed to get lcd pixel clock: %d\n", ret);
drivers/video/jz4740_fb.c:	jzfb->base = devm_ioremap_resource(&pdev->dev, mem);
drivers/video/jz4740_fb.c:		dev_err(&pdev->dev, "Failed to allocate video memory\n");
drivers/video/jz4740_fb.c:		dev_err(&pdev->dev, "Failed to register framebuffer: %d\n", ret);
drivers/video/pm2fb.c:	info = framebuffer_alloc(sizeof(struct pm2fb_par), &pdev->dev);
drivers/video/pm2fb.c:	switch (pdev->device) {
drivers/video/pm2fb.c:		if (pdev->subsystem_vendor == 0x1048 &&
drivers/video/pm2fb.c:			pdev->subsystem_device == 0x0a31) {
drivers/video/pm2fb.c:				pdev->subsystem_vendor, pdev->subsystem_device);
drivers/video/pm2fb.c:		if (pdev->subsystem_vendor == 0x3d3d &&
drivers/video/pm2fb.c:			pdev->subsystem_device == 0x0100) {
drivers/video/pm2fb.c:				pdev->subsystem_vendor, pdev->subsystem_device);
drivers/video/amifb.c:	info = framebuffer_alloc(sizeof(struct amifb_par), &pdev->dev);
drivers/video/amifb.c:		dev_err(&pdev->dev, "framebuffer_alloc failed\n");
drivers/video/amifb.c:	info->device = &pdev->dev;
drivers/video/amifb.c:		dev_warn(&pdev->dev,
drivers/video/amifb.c:	dev_set_drvdata(&pdev->dev, info);
drivers/video/amifb.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/video/amifb.c:	struct fb_info *info = dev_get_drvdata(&pdev->dev);
drivers/video/amifb.c:	dev_set_drvdata(&pdev->dev, NULL);
drivers/ssb/driver_gige.c:	if (!pdev->resource[0].name)
drivers/ssb/driver_gige.c:	return (strcmp(pdev->resource[0].name, SSB_GIGE_MEM_RES_NAME) == 0);
drivers/ssb/driver_gige.c:	if (pdev->bus->ops != &dev->pci_ops) {
drivers/ssb/driver_gige.c:	res = &(pdev->resource[0]);
drivers/ssb/driver_gige.c:	pdev->irq = ssb_mips_irq(sdev) + 2;
drivers/ssb/driver_gige.c:	pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, pdev->irq);
drivers/ssb/driver_gige.c:	if (pdev->bus->ops != &dev->pci_ops) {
drivers/ssb/driver_pcicore.c:	struct ssb_bus *bus = pdev->bus;
drivers/ssb/driver_pcicore.c:	if (pdev->id.revision < 5) {
drivers/ssb/driver_pcicore.c:	} else if (pdev->id.revision >= 11) {
drivers/ssb/driver_pcicore.c:	struct ssb_bus *bus = pdev->bus;
drivers/ssb/driver_pcicore.c:	bus = pdev->bus;
drivers/ssb/driver_pcicore.c:	might_sleep_if(pdev->id.coreid != SSB_DEV_PCI);
drivers/ssb/driver_pcicore.c:	if ((pdev->id.revision >= 6) || (pdev->id.coreid == SSB_DEV_PCIE)) {
drivers/ssb/driver_pcicore.c:	if (pdev->id.coreid == SSB_DEV_PCI) {
drivers/ssb/driver_pcicore.c:		WARN_ON(pdev->id.coreid != SSB_DEV_PCIE);
drivers/ssb/pci.c:	device_remove_file(&pdev->dev, &dev_attr_ssb_sprom);
drivers/ssb/pci.c:	err = device_create_file(&pdev->dev, &dev_attr_ssb_sprom);
drivers/rapidio/devices/tsi721_dma.c:	mport->dma.dev = &priv->pdev->dev;
drivers/rapidio/devices/tsi721_dma.c:		dev_err(&priv->pdev->dev, "Failed to register DMA device\n");
drivers/rapidio/devices/tsi721.c:			dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_dbg(&priv->pdev->dev, "%s : DMA ABORT ch_stat=%x\n",
drivers/rapidio/devices/tsi721.c:		dev_dbg(&priv->pdev->dev, "OP=%d : destid=%x hc=%x off=%x\n",
drivers/rapidio/devices/tsi721.c:	dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:			dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:				dev_info(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:			dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:			dev_info(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:			dev_err(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		err = request_irq(priv->pdev->irq, tsi721_irqhandler,
drivers/rapidio/devices/tsi721.c:		dev_err(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_err(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_err(&priv->pdev->dev, "PW FIFO allocation failed\n");
drivers/rapidio/devices/tsi721.c:	priv->idb_base = dma_zalloc_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dev_dbg(&priv->pdev->dev, "Allocated IDB buffer @ %p (phys = %llx)\n",
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev, IDB_QSIZE * TSI721_IDB_ENTRY_SIZE,
drivers/rapidio/devices/tsi721.c:	dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	bd_ptr = dma_zalloc_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dev_dbg(&priv->pdev->dev, "DMA descriptors @ %p (phys = %llx)\n",
drivers/rapidio/devices/tsi721.c:	sts_ptr = dma_zalloc_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_info(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_dbg(&priv->pdev->dev, "OB MSG ABORT ch_stat=%x\n",
drivers/rapidio/devices/tsi721.c:				&priv->pdev->dev, TSI721_MSG_BUFFER_SIZE,
drivers/rapidio/devices/tsi721.c:			dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:				&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	priv->omsg_ring[mbox].sts_base = dma_zalloc_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:			dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:			dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:			dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:			dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_info(&priv->pdev->dev, "IB MBOX%d SRIO timeout\n",
drivers/rapidio/devices/tsi721.c:		dev_info(&priv->pdev->dev, "IB MBOX%d PCIe error\n",
drivers/rapidio/devices/tsi721.c:		dev_info(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dma_alloc_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_err(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dma_alloc_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_err(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dma_alloc_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_err(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:			dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:			dev_dbg(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:	dma_free_coherent(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_err(&priv->pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_dbg(&pdev->dev, "Unable to allocate memory for rio_ops\n");
drivers/rapidio/devices/tsi721.c:		dev_dbg(&pdev->dev, "Unable to allocate memory for mport\n");
drivers/rapidio/devices/tsi721.c:		 dev_driver_string(&pdev->dev), dev_name(&pdev->dev));
drivers/rapidio/devices/tsi721.c:		dev_info(&pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_err(&pdev->dev, "Unable to get assigned PCI IRQ "
drivers/rapidio/devices/tsi721.c:			"vector %02X err=0x%x\n", pdev->irq, err);
drivers/rapidio/devices/tsi721.c:		dev_err(&pdev->dev, "Failed to allocate memory for device\n");
drivers/rapidio/devices/tsi721.c:		dev_err(&pdev->dev, "Failed to enable PCI device\n");
drivers/rapidio/devices/tsi721.c:		dev_dbg(&pdev->dev, "res[%d] @ 0x%llx (0x%lx, 0x%lx)\n",
drivers/rapidio/devices/tsi721.c:		dev_err(&pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_err(&pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_info(&pdev->dev, "Outbound BAR2 is not used but enabled.\n");
drivers/rapidio/devices/tsi721.c:		dev_info(&pdev->dev, "Outbound BAR4 is not used but enabled.\n");
drivers/rapidio/devices/tsi721.c:		dev_err(&pdev->dev, "Cannot obtain PCI resources, "
drivers/rapidio/devices/tsi721.c:		dev_err(&pdev->dev,
drivers/rapidio/devices/tsi721.c:		dev_err(&pdev->dev,
drivers/rapidio/devices/tsi721.c:			dev_info(&pdev->dev, "Unable to set DMA mask\n");
drivers/rapidio/devices/tsi721.c:			dev_info(&pdev->dev, "Unable to set consistent DMA mask\n");
drivers/rapidio/devices/tsi721.c:			dev_info(&pdev->dev, "Unable to set consistent DMA mask\n");
drivers/rapidio/devices/tsi721.c:		dev_err(&pdev->dev, "BDMA initialization failed, aborting\n");
drivers/extcon/extcon-adc-jack.c:	struct adc_jack_pdata *pdata = pdev->dev.platform_data;
drivers/extcon/extcon-adc-jack.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
drivers/extcon/extcon-adc-jack.c:		dev_err(&pdev->dev, "error: cable_names not defined.\n");
drivers/extcon/extcon-adc-jack.c:		dev_err(&pdev->dev, "error: pdata->cable_names size = %d\n",
drivers/extcon/extcon-adc-jack.c:		dev_err(&pdev->dev, "error: adc_conditions not defined.\n");
drivers/extcon/extcon-adc-jack.c:	data->chan = iio_channel_get(&pdev->dev, pdata->consumer_channel);
drivers/extcon/extcon-adc-jack.c:	err = extcon_dev_register(&data->edev, &pdev->dev);
drivers/extcon/extcon-adc-jack.c:		dev_err(&pdev->dev, "platform_get_irq failed\n");
drivers/extcon/extcon-adc-jack.c:		dev_err(&pdev->dev, "error: irq %d\n", data->irq);
drivers/extcon/extcon-gpio.c:	struct gpio_extcon_platform_data *pdata = pdev->dev.platform_data;
drivers/extcon/extcon-gpio.c:		dev_err(&pdev->dev, "IRQ flag is not specified.\n");
drivers/extcon/extcon-gpio.c:	extcon_data = devm_kzalloc(&pdev->dev, sizeof(struct gpio_extcon_data),
drivers/extcon/extcon-gpio.c:	ret = extcon_dev_register(&extcon_data->edev, &pdev->dev);
drivers/extcon/extcon-gpio.c:	ret = devm_gpio_request_one(&pdev->dev, extcon_data->gpio, GPIOF_DIR_IN,
drivers/extcon/extcon-gpio.c:				    pdev->name);
drivers/extcon/extcon-gpio.c:				      pdata->irq_flags, pdev->name,
drivers/extcon/extcon-max77693.c:	struct max77693_dev *max77693 = dev_get_drvdata(pdev->dev.parent);
drivers/extcon/extcon-max77693.c:	info = devm_kzalloc(&pdev->dev, sizeof(struct max77693_muic_info),
drivers/extcon/extcon-max77693.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/extcon/extcon-max77693.c:	info->dev = &pdev->dev;
drivers/extcon/extcon-max77693.c:		dev_dbg(&pdev->dev, "allocate register map\n");
drivers/extcon/extcon-max77693.c:	info->dock = devm_input_allocate_device(&pdev->dev);
drivers/extcon/extcon-max77693.c:		dev_err(&pdev->dev, "%s: failed to allocate input\n", __func__);
drivers/extcon/extcon-max77693.c:	info->dock->dev.parent = &pdev->dev;
drivers/extcon/extcon-max77693.c:		dev_err(&pdev->dev, "Cannot register input device error(%d)\n",
drivers/extcon/extcon-max77693.c:			dev_err(&pdev->dev,
drivers/extcon/extcon-max77693.c:	info->edev = devm_kzalloc(&pdev->dev, sizeof(struct extcon_dev),
drivers/extcon/extcon-max77693.c:		dev_err(&pdev->dev, "failed to allocate memory for extcon\n");
drivers/extcon/extcon-max77693.c:		dev_err(&pdev->dev, "failed to register extcon device\n");
drivers/extcon/extcon-max77693.c:		dev_err(&pdev->dev, "failed to read revision number\n");
drivers/extcon/extcon-max8997.c:	struct max8997_dev *max8997 = dev_get_drvdata(pdev->dev.parent);
drivers/extcon/extcon-max8997.c:	info = devm_kzalloc(&pdev->dev, sizeof(struct max8997_muic_info),
drivers/extcon/extcon-max8997.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
drivers/extcon/extcon-max8997.c:	info->dev = &pdev->dev;
drivers/extcon/extcon-max8997.c:			dev_err(&pdev->dev,
drivers/extcon/extcon-max8997.c:	info->edev = devm_kzalloc(&pdev->dev, sizeof(struct extcon_dev),
drivers/extcon/extcon-max8997.c:		dev_err(&pdev->dev, "failed to allocate memory for extcon\n");
drivers/extcon/extcon-max8997.c:		dev_err(&pdev->dev, "failed to register extcon device\n");
drivers/extcon/extcon-arizona.c:	struct arizona *arizona = dev_get_drvdata(pdev->dev.parent);
drivers/extcon/extcon-arizona.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
drivers/extcon/extcon-arizona.c:		dev_err(&pdev->dev, "Failed to allocate memory\n");
drivers/extcon/extcon-arizona.c:	info->dev = &pdev->dev;
drivers/extcon/extcon-arizona.c:	info->input = devm_input_allocate_device(&pdev->dev);
drivers/extcon/extcon-arizona.c:	info->input->dev.parent = &pdev->dev;
drivers/extcon/extcon-arizona.c:		ret = devm_gpio_request_one(&pdev->dev,
drivers/extcon/extcon-arizona.c:		ret = devm_gpio_request_one(&pdev->dev,
drivers/extcon/extcon-arizona.c:	pm_runtime_enable(&pdev->dev);
drivers/extcon/extcon-arizona.c:	pm_runtime_idle(&pdev->dev);
drivers/extcon/extcon-arizona.c:	pm_runtime_get_sync(&pdev->dev);
drivers/extcon/extcon-arizona.c:		dev_err(&pdev->dev, "Failed to get JACKDET rise IRQ: %d\n",
drivers/extcon/extcon-arizona.c:		dev_err(&pdev->dev, "Failed to set JD rise IRQ wake: %d\n",
drivers/extcon/extcon-arizona.c:		dev_err(&pdev->dev, "Failed to get JD fall IRQ: %d\n", ret);
drivers/extcon/extcon-arizona.c:		dev_err(&pdev->dev, "Failed to set JD fall IRQ wake: %d\n",
drivers/extcon/extcon-arizona.c:		dev_err(&pdev->dev, "Failed to get MICDET IRQ: %d\n", ret);
drivers/extcon/extcon-arizona.c:		dev_err(&pdev->dev, "Failed to get HPDET IRQ: %d\n", ret);
drivers/extcon/extcon-arizona.c:	pm_runtime_put(&pdev->dev);
drivers/extcon/extcon-arizona.c:		dev_err(&pdev->dev, "Can't register input device: %d\n", ret);
drivers/extcon/extcon-arizona.c:	pm_runtime_disable(&pdev->dev);
drivers/extcon/extcon-arizona.c:	pm_runtime_disable(&pdev->dev);
drivers/firmware/dcdbas.c:	dev_dbg(&dcdbas_pdev->dev, "%s: phys: %x size: %lu\n",
drivers/firmware/dcdbas.c:	dma_free_coherent(&dcdbas_pdev->dev, smi_data_buf_size, smi_data_buf,
drivers/firmware/dcdbas.c:	buf = dma_alloc_coherent(&dcdbas_pdev->dev, size, &handle, GFP_KERNEL);
drivers/firmware/dcdbas.c:		dev_dbg(&dcdbas_pdev->dev,
drivers/firmware/dcdbas.c:	dev_dbg(&dcdbas_pdev->dev, "%s: phys: %x size: %lu\n",
drivers/firmware/dcdbas.c:		dev_info(&dcdbas_pdev->dev, "%s: invalid magic value\n",
drivers/firmware/dcdbas.c:		dev_dbg(&dcdbas_pdev->dev, "%s: failed to get CPU 0\n",
drivers/firmware/dcdbas.c:		dev_dbg(&dcdbas_pdev->dev, "%s: invalid SMI type %u\n",
drivers/firmware/dcdbas.c:		dev_dbg(&dcdbas_pdev->dev, "%s: no SMI buffer\n", __func__);
drivers/firmware/dcdbas.c:		dev_dbg(&dcdbas_pdev->dev, "%s: SMI buffer too small\n",
drivers/firmware/dcdbas.c:	dcdbas_pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/firmware/dcdbas.c:	dcdbas_pdev->dev.dma_mask = &dcdbas_pdev->dev.coherent_dma_mask;
drivers/firmware/google/gsmi.c:	gsmi_dev.pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/firmware/google/gsmi.c:	gsmi_dev.pdev->dev.dma_mask =
drivers/firmware/google/gsmi.c:		&gsmi_dev.pdev->dev.coherent_dma_mask;
drivers/firmware/google/gsmi.c:	gsmi_dev.dma_pool = dma_pool_create("gsmi", &gsmi_dev.pdev->dev,
drivers/eisa/pci_eisa.c:		dev_err(&pdev->dev, "Could not enable device\n");
drivers/eisa/pci_eisa.c:	pci_bus_for_each_resource(pdev->bus, res, i)
drivers/eisa/pci_eisa.c:		dev_err(&pdev->dev, "No resources available\n");
drivers/eisa/pci_eisa.c:	pci_eisa_root.dev              = &pdev->dev;
drivers/eisa/pci_eisa.c:	pci_eisa_root.dma_mask         = pdev->dma_mask;
drivers/eisa/pci_eisa.c:		dev_err(&pdev->dev, "Could not register EISA root\n");
drivers/devfreq/exynos4_bus.c:	struct device *dev = &pdev->dev;
drivers/devfreq/exynos4_bus.c:	data = devm_kzalloc(&pdev->dev, sizeof(struct busfreq_data), GFP_KERNEL);
drivers/devfreq/exynos4_bus.c:	data->type = pdev->id_entry->driver_data;
drivers/dca/dca-core.c:	struct pci_bus *bus = pdev->bus;
drivers/dca/dca-core.c:	return ((pdev->vendor == PCI_VENDOR_ID_INTEL) &&
drivers/dca/dca-core.c:		((pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG0) ||
drivers/dca/dca-core.c:		(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG1) ||
drivers/dca/dca-core.c:		(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG2) ||
drivers/dca/dca-core.c:		(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG3) ||
drivers/dca/dca-core.c:		(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG4) ||
drivers/dca/dca-core.c:		(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG5) ||
drivers/dca/dca-core.c:		(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG6) ||
drivers/dca/dca-core.c:		(pdev->device == PCI_DEVICE_ID_INTEL_IOAT_TBG7)));
drivers/amlogic/crypto/aml-aes.c:	struct device *dev = &pdev->dev;
drivers/amlogic/crypto/aml-tdes.c:	struct device *dev = &pdev->dev;
drivers/amlogic/thermal/amlogic_thermal.c:    if (!of_property_read_bool(pdev->dev.of_node, "use_virtual_thermal")) {
drivers/amlogic/thermal/amlogic_thermal.c:    ret = of_property_read_u32(pdev->dev.of_node,
drivers/amlogic/thermal/amlogic_thermal.c:    ret = of_property_read_u32_array(pdev->dev.of_node, 
drivers/amlogic/thermal/amlogic_thermal.c:    prop = of_find_property(pdev->dev.of_node, "cpu_virtual", &len);
drivers/amlogic/thermal/amlogic_thermal.c:    ret = of_property_read_u32_array(pdev->dev.of_node, 
drivers/amlogic/thermal/amlogic_thermal.c:    prop = of_find_property(pdev->dev.of_node, "gpu_virtual", &len);
drivers/amlogic/thermal/amlogic_thermal.c:    ret = of_property_read_u32_array(pdev->dev.of_node, 
drivers/amlogic/thermal/amlogic_thermal.c:	if(!of_property_read_u32(pdev->dev.of_node, "trip_point", &val)){
drivers/amlogic/thermal/amlogic_thermal.c:		ret=of_property_read_u32(pdev->dev.of_node, "#thermal-cells", &val);
drivers/amlogic/thermal/amlogic_thermal.c:			dev_err(&pdev->dev, "dt probe #thermal-cells failed: %d\n", ret);
drivers/amlogic/thermal/amlogic_thermal.c:		prop = of_find_property(pdev->dev.of_node, "trip_point", &val);
drivers/amlogic/thermal/amlogic_thermal.c:			dev_err(&pdev->dev, "read %s length error\n","trip_point");
drivers/amlogic/thermal/amlogic_thermal.c:		ret=of_property_read_u32_array(pdev->dev.of_node,"trip_point",(u32 *)tmp_level,val/sizeof(u32));
drivers/amlogic/thermal/amlogic_thermal.c:			dev_err(&pdev->dev, "read %s data error\n","trip_point");
drivers/amlogic/thermal/amlogic_thermal.c:		ret= of_property_read_u32(pdev->dev.of_node, "idle_interval", &val);
drivers/amlogic/thermal/amlogic_thermal.c:			dev_err(&pdev->dev, "read %s  error\n","idle_interval");
drivers/amlogic/thermal/amlogic_thermal.c:		ret=of_property_read_string(pdev->dev.of_node,"dev_name",&pdata->name);
drivers/amlogic/thermal/amlogic_thermal.c:			dev_err(&pdev->dev, "read %s  error\n","dev_name");
drivers/amlogic/thermal/amlogic_thermal.c:	dev_info(&pdev->dev, "amlogic thermal probe start\n");
drivers/amlogic/thermal/amlogic_thermal.c:		dev_err(&pdev->dev, "Failed to initialize thermal\n");
drivers/amlogic/thermal/amlogic_thermal.c:	pdev->dev.platform_data=pdata;
drivers/amlogic/thermal/amlogic_thermal.c:		dev_err(&pdev->dev, "Failed to register thermal interface\n");
drivers/amlogic/thermal/amlogic_thermal.c:	dev_info(&pdev->dev, "amlogic thermal probe done\n");
drivers/amlogic/keymanage/key_manage.c:	if (pdev->dev.of_node) {
drivers/amlogic/keymanage/key_manage.c:		match = of_match_node(meson6_unifykeys_dt_match, pdev->dev.of_node);
drivers/amlogic/keymanage/key_manage.c:	if (pdev->dev.of_node) {
drivers/amlogic/keymanage/key_manage.c:	if (pdev->dev.of_node) {
drivers/amlogic/keymanage/key_dts.c:	struct device_node *np = pdev->dev.of_node;
drivers/amlogic/keymanage/key_dts.c:	if (pdev->dev.of_node) {
drivers/amlogic/keymanage/key_dts.c:		ret = of_property_read_u32(pdev->dev.of_node,"unifykey-num",&key_num);
drivers/amlogic/keymanage/key_dts.c:		of_property_read_u32(pdev->dev.of_node,"efuse-version",&unify_key_info.efuse_version);
drivers/amlogic/keymanage/key_dts.c:	if (pdev->dev.of_node) {
drivers/amlogic/keymanage/key_dts.c:		of_node_put(pdev->dev.of_node);
drivers/amlogic/camera/common/cam_prober.c:		pin_ctrl = pinctrl_get_select((struct device*)(&cam_pdev->dev), "gpio");
drivers/amlogic/camera/common/cam_prober.c:		pin_ctrl = pinctrl_get_select((struct device*)(&cam_pdev->dev), "csi");
drivers/amlogic/camera/common/cam_prober.c:		pin_ctrl = pinctrl_get_select((struct device*)(&cam_pdev->dev), "gpio");
drivers/amlogic/camera/common/cam_prober.c:	p = pinctrl_get(&cam_pdev->dev);
drivers/amlogic/camera/common/cam_prober.c:	struct device_node* cams_node = pdev->dev.of_node;
drivers/amlogic/camera/common/flashlight.c:	pdata = pdev->dev.platform_data;
drivers/amlogic/camera/common/flashlight.c:		dev_err(&pdev->dev, "platform data is required!\n");
drivers/amlogic/camera/common/vm.c:        dma_release_from_contiguous(&vm_device.pdev->dev, vm_pages, vm_buf_size/PAGE_SIZE);
drivers/amlogic/camera/common/vm.c:    vm_pages = dma_alloc_from_contiguous(&vm_device.pdev->dev, size/PAGE_SIZE, 0);
drivers/amlogic/camera/common/vm.c:        dma_release_from_contiguous(&vm_device.pdev->dev, vm_pages, vm_buf_size/PAGE_SIZE);
drivers/amlogic/camera/common/vm.c:        dma_release_from_contiguous(&vm_device.pdev->dev, info->vm_pages, info->vm_buf_size/PAGE_SIZE);
drivers/amlogic/camera/common/vm.c:    info->vm_pages = dma_alloc_from_contiguous(&vm_device.pdev->dev, size/PAGE_SIZE, 0);
drivers/amlogic/camera/common/vm.c:        dma_release_from_contiguous(&vm_device.pdev->dev, info->vm_pages, info->vm_buf_size/PAGE_SIZE);
drivers/amlogic/camera/common/vm.c:     idx = find_reserve_block(pdev->dev.of_node->name,0);
drivers/amlogic/efuse/efuse.c:struct device_node *np = pdev->dev.of_node;
drivers/amlogic/efuse/efuse.c:	if(pdev->dev.of_node){
drivers/amlogic/efuse/efuse.c:	 if(pdev->dev.platform_data)
drivers/amlogic/efuse/efuse.c:		 devp->platform_data = pdev->dev.platform_data;
drivers/amlogic/nfc/common.c:	struct device_node* nfc_node = pdev->dev.of_node;
drivers/amlogic/nfc/common.c:	pdev->dev.platform_data = pdata;
drivers/amlogic/nfc/common.c:    if (pdev->dev.platform_data)
drivers/amlogic/nfc/common.c:	 	kfree (pdev->dev.platform_data);
drivers/amlogic/cardreader/cardreader.c:	if (pdev->dev.of_node) {
drivers/amlogic/cardreader/cardreader.c:		match = of_match_node(card_dt_match, pdev->dev.of_node);
drivers/amlogic/cardreader/cardreader.c:	host = card_alloc_host(sizeof(struct amlogic_card_host), &pdev->dev);
drivers/amlogic/cardreader/cardreader.c:	card_dev=&pdev->dev;
drivers/amlogic/ionvideo/ionvideo.c:            ret += sprintf(buf + ret, "\t buffer number:%d\n", cur_dma_q->pdev->vb_vidq.num_buffers);
drivers/amlogic/ionvideo/ionvideo.c:            ret += sprintf(buf + ret, "\t buffer in driver:%d\n", buf_num_queue(&cur_dma_q->pdev->vb_vidq));
drivers/amlogic/mmc/aml_sdio.c:        mmc = mmc_alloc_host(sizeof(struct amlsd_platform), &pdev->dev);
drivers/amlogic/mmc/aml_sdhc.c:        mmc = mmc_alloc_host(sizeof(struct amlsd_platform), &pdev->dev);
drivers/amlogic/mmc/amlsd.c:	pdev->class = &block_class;
drivers/amlogic/mmc/amlsd.c:	pdev->type = &part_type;
drivers/amlogic/mmc/amlsd.c:	pdev->parent = ddev;
drivers/amlogic/mmc/amlsd.c:	pdev->devt = devt;
drivers/amlogic/mmc/amlsd.c:	p->holder_dir = kobject_create_and_add("holders", &pdev->kobj);
drivers/amlogic/mmc/amlsd.c:		kobject_uevent(&pdev->kobj, KOBJ_ADD);
drivers/amlogic/mmc/amlsd.c:        p = devm_pinctrl_get(&host->pdev->dev);
drivers/amlogic/mmc/amlsd.c:            // ppin = devm_pinctrl_get_select(&pdata->host->pdev->dev, p);
drivers/amlogic/mmc/amlsd.c:                pin = devm_pinctrl_get_select(&pdata->host->pdev->dev, "uartao_default");
drivers/amlogic/mmc/amlsd.c:            pin = devm_pinctrl_get_select(&pdata->host->pdev->dev, "jtag_pin");
drivers/amlogic/mmc/aml_sdhc_m8.c:        mmc = mmc_alloc_host(sizeof(struct amlsd_platform), &pdev->dev);
drivers/amlogic/mmc/amlsd_of.c:	struct device_node* of_node = pdev->dev.of_node;
drivers/amlogic/mmc/amlsd_of.c:		dev_err(&pdev->dev, "of_iomap fail\n");
drivers/amlogic/mmc/amlsd_of.c:    struct device_node* of_node = pdev->dev.of_node;
drivers/amlogic/securitykeys/core.c:    if (pdev->dev.platform_data) ///@todo add some optimize here
drivers/amlogic/securitykeys/core.c:        devp->platform_data = pdev->dev.platform_data;
drivers/amlogic/securitykeys/core.c:	if (pdev->dev.of_node) {
drivers/amlogic/securitykeys/core.c:		match = of_match_node(meson6_keys_dt_match, pdev->dev.of_node);
drivers/amlogic/display/lcd/aml_lcd.c:	if (!pdev->dev.of_node){
drivers/amlogic/display/lcd/aml_lcd.c:	ret = of_property_read_u32_array(pdev->dev.of_node,"basic_setting",&lvds_para[0], 10);
drivers/amlogic/display/lcd/aml_lcd.c:	ret = of_property_read_u32_array(pdev->dev.of_node,"delay_setting",&lvds_para[0], 8);
drivers/amlogic/display/lcd/aml_lcd.c:	if(pdev->dev.of_node) {
drivers/amlogic/display/lcd/aml_lcd.c:		match = of_match_node(lvds_dt_match, pdev->dev.of_node);
drivers/amlogic/display/lcd/aml_lcd.c:	pdata = pdev->dev.platform_data;
drivers/amlogic/display/lcd/aml_lcd_v2.c:	if (!pdev->dev.of_node){
drivers/amlogic/display/lcd/aml_lcd_v2.c:	ret = of_property_read_u32_array(pdev->dev.of_node,"basic_setting",&lvds_para[0], 10);
drivers/amlogic/display/lcd/aml_lcd_v2.c:	ret = of_property_read_u32_array(pdev->dev.of_node,"lcd_timing",&lvds_para[0], 14);
drivers/amlogic/display/lcd/aml_lcd_v2.c:	ret = of_property_read_u32_array(pdev->dev.of_node,"delay_setting",&lvds_para[0], 8);
drivers/amlogic/display/lcd/aml_lcd_v2.c:	if(pdev->dev.of_node) {
drivers/amlogic/display/lcd/aml_lcd_v2.c:		match = of_match_node(lvds_dt_match, pdev->dev.of_node);
drivers/amlogic/display/lcd/aml_lcd_v2.c:	pdata = pdev->dev.platform_data;
drivers/amlogic/display/sys_led/aml_sysled.c:	struct device_node *np = pdev->dev.of_node;
drivers/amlogic/display/sys_led/aml_sysled.c:	ret_dts=of_property_read_string(pdev->dev.of_node,"dev_name",&pdata->name);
drivers/amlogic/display/sys_led/aml_sysled.c:		dev_err(&pdev->dev, "read %s  error\n","dev_name");
drivers/amlogic/display/sys_led/aml_sysled.c:	ret_dts=of_property_read_u32(pdev->dev.of_node,"red_led_mode",&value);
drivers/amlogic/display/sys_led/aml_sysled.c:		dev_err(&pdev->dev, "read %s  error\n","red_led_mode");
drivers/amlogic/display/sys_led/aml_sysled.c:	ret_dts=of_property_read_u32(pdev->dev.of_node,"blue_led_mode",&value);
drivers/amlogic/display/sys_led/aml_sysled.c:		dev_err(&pdev->dev, "read %s  error\n","blue_led_mode");
drivers/amlogic/display/sys_led/aml_sysled.c:	ret_dts = of_property_read_string(pdev->dev.of_node, "red_led_gpio", &str);
drivers/amlogic/display/sys_led/aml_sysled.c:	ret_dts = of_property_read_string(pdev->dev.of_node, "blue_led_gpio", &str);
drivers/amlogic/display/sys_led/aml_sysled.c:	ret = device_create_file(&pdev->dev, &dev_attr_io_val);
drivers/amlogic/display/osd/osd_main.c:		prop = of_get_property(pdev->dev.of_node, "scale_mode", NULL);
drivers/amlogic/display/osd/osd_main.c:		prop = of_get_property(pdev->dev.of_node, "4k2k_fb", NULL);
drivers/amlogic/display/osd/osd_main.c:    		prop = of_get_property(pdev->dev.of_node, "vmode", NULL);
drivers/amlogic/display/osd/osd_main.c:		ret = find_reserve_block(pdev->dev.of_node->name,index);
drivers/amlogic/display/osd/osd_main.c:			amlog_level(LOG_LEVEL_HIGH,"can not find %s%d reserve block\n",pdev->dev.of_node->name,index);
drivers/amlogic/display/osd/osd_main.c:		fbi = framebuffer_alloc(sizeof(struct myfb_dev), &pdev->dev);
drivers/amlogic/display/osd/osd_main.c:				ret = of_property_read_u32_array(pdev->dev.of_node, "display_size_default", &var_screeninfo[0], 5);
drivers/amlogic/display/osd/osd_main.c:			prop = of_get_property(pdev->dev.of_node, "rotation", NULL);
drivers/amlogic/display/osd_ext/osd_main.c:	ret = of_property_read_u32_array(pdev->dev.of_node, "need-memory", &osd_ext_memory, 1);
drivers/amlogic/display/osd_ext/osd_main.c:			ret = find_reserve_block(pdev->dev.of_node->name,index);
drivers/amlogic/display/osd_ext/osd_main.c:				amlog_level(LOG_LEVEL_HIGH,"can not find %s%d reserve block\n",pdev->dev.of_node->name,index);
drivers/amlogic/display/osd_ext/osd_main.c:		fbi = framebuffer_alloc(sizeof(struct myfb_dev), &pdev->dev);
drivers/amlogic/display/osd_ext/osd_main.c:				ret = of_property_read_u32_array(pdev->dev.of_node, "display_size_default", &var_screeninfo[0], 5);
drivers/amlogic/display/backlight/aml_bl.c:	tv_bl_config.p = devm_pinctrl_get_select(&tv_bl_config.amlbl->pdev->dev, buf);
drivers/amlogic/display/backlight/aml_bl.c:	tv_bl_config.p = devm_pinctrl_get_select(&tv_bl_config.amlbl->pdev->dev, bufa);
drivers/amlogic/display/backlight/aml_bl.c:	tv_bl_config.p = devm_pinctrl_get_select(&tv_bl_config.amlbl->pdev->dev, bufvs);
drivers/amlogic/display/backlight/aml_bl.c:	if (pdev->dev.of_node) {
drivers/amlogic/display/backlight/aml_bl.c:		gpio_name = of_get_property(pdev->dev.of_node, "power_pin", NULL);
drivers/amlogic/display/backlight/aml_bl.c:		ret = of_property_read_u32(pdev->dev.of_node, "pwm_hz", &value);
drivers/amlogic/display/backlight/aml_bl.c:	if (pdev->dev.of_node) {
drivers/amlogic/display/backlight/aml_bl.c:    if(pdev->dev.of_node) {
drivers/amlogic/display/backlight/aml_bl.c:        match = of_match_node(backlight_dt_match, pdev->dev.of_node);
drivers/amlogic/display/backlight/aml_bl.c:    if (pdev->dev.of_node) {
drivers/amlogic/display/backlight/aml_bl.c:        ret = of_property_read_u32_array(pdev->dev.of_node,"bl_level_default_uboot_kernel", &bl_para[0], 2);
drivers/amlogic/display/backlight/aml_bl.c:        ret = of_property_read_u32_array(pdev->dev.of_node, "bl_level_middle_mapping", &bl_para[0], 2);
drivers/amlogic/display/backlight/aml_bl.c:        ret = of_property_read_u32_array(pdev->dev.of_node,"bl_level_max_min", &bl_para[0],2);
drivers/amlogic/display/backlight/aml_bl.c:        ret = of_property_read_u32(pdev->dev.of_node, "bl_power_on_delay", &val);
drivers/amlogic/display/backlight/aml_bl.c:        ret = of_property_read_u32(pdev->dev.of_node, "bl_ctrl_method", &val);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 0, &str);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 1, &str);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 2, &str);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_u32_array(pdev->dev.of_node,"bl_gpio_dim_max_min",&bl_para[0],2);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_port_gpio_used", 1, &str);
drivers/amlogic/display/backlight/aml_bl.c:                ret = of_property_read_string(pdev->dev.of_node, "bl_gpio_port_on_off", &str);
drivers/amlogic/display/backlight/aml_bl.c:                          ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 1, &str);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 2, &str);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_port_gpio_used", 0, &str);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_u32(pdev->dev.of_node,"bl_pwm_freq",&val);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_u32_array(pdev->dev.of_node,"bl_pwm_duty_max_min",&bl_para[0],2);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_u32(pdev->dev.of_node,"bl_pwm_combo_high_low_level_switch",&val);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_combo_high_port_method", 0, &str);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_combo_high_port_method", 1, &str);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_combo_low_port_method", 0, &str);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_combo_low_port_method", 1, &str);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_u32_array(pdev->dev.of_node,"bl_pwm_combo_high_freq_duty_max_min",&bl_para[0],3);
drivers/amlogic/display/backlight/aml_bl.c:            ret = of_property_read_u32_array(pdev->dev.of_node,"bl_pwm_combo_low_freq_duty_max_min",&bl_para[0],3);
drivers/amlogic/display/backlight/aml_bl.c:        bl_config.p = devm_pinctrl_get(&pdev->dev);
drivers/amlogic/display/backlight/aml_bl.c:    pdata = pdev->dev.platform_data;
drivers/amlogic/display/backlight/aml_bl.c:    bldev = backlight_device_register("aml-bl", &pdev->dev, amlbl, &aml_bl_ops, &props);
drivers/amlogic/display/backlight/aml_bl_extern/i2c_lp8556.c:    pdev->dev.platform_data = bl_ext_config;
drivers/amlogic/display/backlight/aml_bl_extern/i2c_lp8556.c:    ret = get_bl_extern_config(pdev->dev.of_node, bl_ext_config);
drivers/amlogic/display/backlight/aml_bl_extern/i2c_lp8556.c:    if (pdev->dev.platform_data)
drivers/amlogic/display/backlight/aml_bl_extern/i2c_lp8556.c:        kfree (pdev->dev.platform_data);
drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c:    pdev->dev.platform_data = bl_ext_config;
drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c:    ret = get_bl_extern_config(pdev->dev.of_node, bl_ext_config);
drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c:    if (pdev->dev.platform_data)
drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c:        kfree (pdev->dev.platform_data);
drivers/amlogic/display/backlight/aml_bl_extern/pmu_aml1218.c:    pdev->dev.platform_data = bl_ext_config;
drivers/amlogic/display/backlight/aml_bl_extern/pmu_aml1218.c:    ret = get_bl_extern_config(pdev->dev.of_node, bl_ext_config);
drivers/amlogic/display/backlight/aml_bl_extern/pmu_aml1218.c:    if (pdev->dev.platform_data)
drivers/amlogic/display/backlight/aml_bl_extern/pmu_aml1218.c:        kfree (pdev->dev.platform_data);
drivers/amlogic/display/vout/lcdoutc.c:	if (pdev->dev.of_node) {
drivers/amlogic/display/vout/lcdoutc.c:		ret = of_property_read_u32(pdev->dev.of_node,"lcd_model_config",&fhandle);
drivers/amlogic/display/vout/lcdoutc.c:	//pdev->dev.of_node = of_find_node_by_name(NULL,"lcd");
drivers/amlogic/display/vout/lcdoutc.c:	if (pdev->dev.of_node) {
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32(pdev->dev.of_node,"lcd_bits_user",&val);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32_array(pdev->dev.of_node,"ttl_rb_bit_swap",&lcd_para[0], 2);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32(pdev->dev.of_node,"lvds_channel_pn_swap",&val);
drivers/amlogic/display/vout/lcdoutc.c:		ret = of_property_read_u32_array(pdev->dev.of_node,"valid_hvsync_de",&lcd_para[0], 2);
drivers/amlogic/display/vout/lcdoutc.c:		ret = of_property_read_u32_array(pdev->dev.of_node,"hsign_hoffset_vsign_voffset",&lcd_para[0], 4);
drivers/amlogic/display/vout/lcdoutc.c:		ret = of_property_read_u32_array(pdev->dev.of_node,"dither_user_ctrl",&lcd_para[0], 2);
drivers/amlogic/display/vout/lcdoutc.c:		ret = of_property_read_u32_array(pdev->dev.of_node,"vadj_brightness_contrast_saturation",&lcd_para[0], 3);
drivers/amlogic/display/vout/lcdoutc.c:		ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_en_reverse",&lcd_para[0], 2);
drivers/amlogic/display/vout/lcdoutc.c:		ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_multi_rgb_coeff",&lcd_para[0], 4);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table_r",&gamma_temp[0], 256);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table_g",&gamma_temp[0], 256);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table_b",&gamma_temp[0], 256);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table",&gamma_temp[0], 256);
drivers/amlogic/display/vout/lcdoutc.c:		ret = of_property_read_u32(pdev->dev.of_node,"clock_spread_spectrum",&val);
drivers/amlogic/display/vout/lcdoutc.c:		ret = of_property_read_u32(pdev->dev.of_node,"clock_auto_generation",&val);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32_array(pdev->dev.of_node,"clk_pll_div_clk_ctrl",&lcd_para[0], 3);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32(pdev->dev.of_node,"lvds_vswing",&val);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32_array(pdev->dev.of_node,"lvds_user_repack",&lcd_para[0], 2);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32_array(pdev->dev.of_node,"edp_user_link_rate_lane_count",&lcd_para[0], 3);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32_array(pdev->dev.of_node,"edp_link_adaptive_vswing",&lcd_para[0], 2);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32(pdev->dev.of_node,"edp_sync_clock_mode",&val);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_u32(pdev->dev.of_node,"edp_edid_timing_used",&val);
drivers/amlogic/display/vout/lcdoutc.c:		ret = of_property_read_u32_array(pdev->dev.of_node,"rgb_base_coeff",&lcd_para[0], 2);
drivers/amlogic/display/vout/lcdoutc.c:		// ret = of_property_read_u32_array(pdev->dev.of_node,"video_on_pixel_line",&lcd_para[0], 2);
drivers/amlogic/display/vout/lcdoutc.c:	if (pdev->dev.of_node) {
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_string_index(pdev->dev.of_node, propname, 0, &str);
drivers/amlogic/display/vout/lcdoutc.c:					ret = of_property_read_string_index(pdev->dev.of_node, propname, 1, &str);
drivers/amlogic/display/vout/lcdoutc.c:					ret = of_property_read_string_index(pdev->dev.of_node, propname, 2, &str);
drivers/amlogic/display/vout/lcdoutc.c:		ret = of_property_read_u32_array(pdev->dev.of_node,"power_on_delay",&lcd_para[0],pConf->lcd_power_ctrl.power_on_step);
drivers/amlogic/display/vout/lcdoutc.c:			ret = of_property_read_string_index(pdev->dev.of_node, propname, 0, &str);
drivers/amlogic/display/vout/lcdoutc.c:					ret = of_property_read_string_index(pdev->dev.of_node, propname, 1, &str);
drivers/amlogic/display/vout/lcdoutc.c:					ret = of_property_read_string_index(pdev->dev.of_node, propname, 2, &str);
drivers/amlogic/display/vout/lcdoutc.c:		ret = of_property_read_u32_array(pdev->dev.of_node,"power_off_delay",&lcd_para[0],pConf->lcd_power_ctrl.power_off_step);
drivers/amlogic/display/vout/lcdoutc.c:		pConf->lcd_misc_ctrl.pin = devm_pinctrl_get(&pdev->dev);
drivers/amlogic/display/vout/lcdoutc.c:	pdata = pdev->dev.platform_data;
drivers/amlogic/display/vout/lcd_extern/mipi_KD080D13.c:    pdev->dev.platform_data = lcd_extern_config;
drivers/amlogic/display/vout/lcd_extern/mipi_KD080D13.c:    ret = get_lcd_extern_config(pdev->dev.of_node, lcd_extern_config);
drivers/amlogic/display/vout/lcd_extern/mipi_KD080D13.c:    if (pdev->dev.platform_data)
drivers/amlogic/display/vout/lcd_extern/mipi_KD080D13.c:        kfree (pdev->dev.platform_data);
drivers/amlogic/display/vout/lcd_extern/i2c_tc101.c:    pdev->dev.platform_data = lcd_extern_config;
drivers/amlogic/display/vout/lcd_extern/i2c_tc101.c:    ret = get_lcd_extern_config(pdev->dev.of_node, lcd_extern_config);
drivers/amlogic/display/vout/lcd_extern/i2c_tc101.c:    if (pdev->dev.platform_data)
drivers/amlogic/display/vout/lcd_extern/i2c_tc101.c:        kfree (pdev->dev.platform_data);
drivers/amlogic/display/vout/lcd_extern/spi_LD070WS2.c:    pdev->dev.platform_data = lcd_extern_config;
drivers/amlogic/display/vout/lcd_extern/spi_LD070WS2.c:    ret = get_lcd_extern_config(pdev->dev.of_node, lcd_extern_config);
drivers/amlogic/display/vout/lcd_extern/spi_LD070WS2.c:    if (pdev->dev.platform_data)
drivers/amlogic/display/vout/lcd_extern/spi_LD070WS2.c:        kfree (pdev->dev.platform_data);
drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c:    pdev->dev.platform_data = lcd_extern_config;
drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c:    ret = get_lcd_extern_config(pdev->dev.of_node, lcd_extern_config);
drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c:    if (pdev->dev.platform_data)
drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c:        kfree (pdev->dev.platform_data);
drivers/amlogic/display/vout/lcd_extern/edp_anx6345.c:    pdev->dev.platform_data = lcd_extern_config;
drivers/amlogic/display/vout/lcd_extern/edp_anx6345.c:    ret = get_lcd_extern_config(pdev->dev.of_node, lcd_extern_config);
drivers/amlogic/display/vout/lcd_extern/edp_anx6345.c:    if (pdev->dev.platform_data)
drivers/amlogic/display/vout/lcd_extern/edp_anx6345.c:        kfree (pdev->dev.platform_data);
drivers/amlogic/display/vout/vdac_switch.c:    if(pdev->dev.of_node) {
drivers/amlogic/display/vout/vdac_switch.c:        ret = of_property_read_u32(pdev->dev.of_node,"hw-switch",&val);
drivers/amlogic/display/vout/vdac_switch.c:	vdac_switch_platdata = (struct aml_vdac_switch_platform_data*)pdev->dev.platform_data;
drivers/amlogic/display/vout/vout_serve.c:	if(pdev->dev.of_node != NULL) {
drivers/amlogic/display/vout/vout_serve.c:	    ret = of_property_read_u32(pdev->dev.of_node,"power_level",&power_level);
drivers/amlogic/uart/gps_um220/gps_um220.c:    struct device_node* gps_node = pdev->dev.of_node;
drivers/amlogic/uart/uart/meson_uart.c:	if(of_get_property(mup->pdev->dev.of_node, "pinctrl-names", NULL)){
drivers/amlogic/uart/uart/meson_uart.c:		mup->p=devm_pinctrl_get_select_default(&mup->pdev->dev);
drivers/amlogic/uart/uart/meson_uart.c:	up->dev = &pdev->dev;
drivers/amlogic/uart/uart/meson_uart.c:	if (pdev->dev.of_node) {
drivers/amlogic/uart/uart/meson_uart.c:		match = of_match_node(meson_uart_dt_match, pdev->dev.of_node);
drivers/amlogic/uart/uart/meson_uart.c:			port_name = of_get_property(pdev->dev.of_node, "port_name", NULL);
drivers/amlogic/uart/uart/meson_uart.c:			enable = of_get_property(pdev->dev.of_node, "status", NULL);
drivers/amlogic/smartcard/smartcard.c:	smc->pinctrl = devm_pinctrl_get_select_default(&smc->pdev->dev);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_string(smc->pdev->dev.of_node, buf, &str);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_string(smc->pdev->dev.of_node, buf, &str);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_string(smc->pdev->dev.of_node, buf, &str);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_string(smc->pdev->dev.of_node, buf, &str);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_string(smc->pdev->dev.of_node, buf, &str);
drivers/amlogic/smartcard/smartcard.c:		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
drivers/amlogic/smartcard/smartcard.c:		dev_set_drvdata(&pdev->dev, smc);
drivers/amlogic/smartcard/smartcard.c:	smc_dev_t *smc = (smc_dev_t*)dev_get_drvdata(&pdev->dev);
drivers/amlogic/mipi/vdin/csi.c:	devp->dev = csi_create_device(&pdev->dev, 0);
drivers/amlogic/mipi/vdin/csi.c:	tvin_frontend_init(&devp->frontend, &amcsi_decoder_ops_s, &amcsi_machine_ops, pdev->id);
drivers/amlogic/mipi/vdin/csi.c:	csi_delete_device(pdev->id);
drivers/amlogic/mipi/mem/mipi_mem.c:    ret = request_irq(dev->irq, am_csi2_mem_irq, IRQF_SHARED, dev_name(&(dev->pdev->dev)), (void *)data);
drivers/amlogic/mipi/mem/mipi_mem.c:    data->task = kthread_run(am_csi2_mem_task, (void*)data, dev->pdev->name);
drivers/amlogic/mipi/am_mipi_csi2.c:        pdata = dev->pdev->dev.platform_data;
drivers/amlogic/mipi/am_mipi_csi2.c:            if(strcmp(client_name,pdev->name)==0){
drivers/amlogic/mipi/am_mipi_csi2.c:    if (pdev->dev.of_node){
drivers/amlogic/mipi/am_mipi_csi2.c:            printk("of_node=%p\n", pdev->dev.of_node);
drivers/amlogic/mipi/am_mipi_csi2.c:            match = of_match_node(csi_dt_match, pdev->dev.of_node);
drivers/amlogic/mipi/am_mipi_csi2.c:    pdata = pdev->dev.platform_data;
drivers/amlogic/mipi/am_mipi_csi2.c:    if (pdev->id>=ARRAY_SIZE(am_csi2_para)) {
drivers/amlogic/mipi/am_mipi_csi2.c:    printk("pdev->id=%d\n", pdev->id);
drivers/amlogic/mipi/am_mipi_csi2.c:    dev = (am_csi2_t*)&am_csi2_para[pdev->id];
drivers/amlogic/mipi/am_mipi_csi2.c:    dev->id = pdev->id;
drivers/amlogic/mipi/am_mipi_csi2.c:    pm_runtime_enable(&pdev->dev);
drivers/amlogic/mipi/am_mipi_csi2.c:    pm_runtime_disable(&pdev->dev);
drivers/amlogic/amports/vh264mvc.c:	struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
drivers/amlogic/amports/picdec.c:	struct device_node	*of_node = pdev->dev.of_node;
drivers/amlogic/amports/picdec.c:	idx = find_reserve_block(pdev->dev.of_node->name,0);
drivers/amlogic/amports/vmpeg12.c:    struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
drivers/amlogic/amports/amstream.c:    r = find_reserve_block(pdev->dev.of_node->name,0);
drivers/amlogic/amports/amstream.c:        printk("can not find %s%d reserve block\n",pdev->dev.of_node->name,1);
drivers/amlogic/amports/vdec.c:    r = find_reserve_block(pdev->dev.of_node->name,0);
drivers/amlogic/amports/vdec.c:        name = of_get_property(pdev->dev.of_node,"share-memory-name",NULL);
drivers/amlogic/amports/vdec.c:            name= of_get_property(pdev->dev.of_node,"share-memory-offset",NULL);
drivers/amlogic/amports/vdec.c:            name= of_get_property(pdev->dev.of_node,"share-memory-size",NULL);
drivers/amlogic/amports/vdec.c:    vdec_set_resource(start, end, &pdev->dev);
drivers/amlogic/amports/vreal.c:    struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
drivers/amlogic/amports/vmpeg4.c:    struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
drivers/amlogic/amports/amvideocap.c:    printk("amvideocap_probe,%s\n", pdev->dev.of_node->name);
drivers/amlogic/amports/amvideocap.c:    idx = find_reserve_block(pdev->dev.of_node->name,0);
drivers/amlogic/amports/vh265.c:    struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
drivers/amlogic/amports/jpegenc.c:    idx = find_reserve_block(pdev->dev.of_node->name,0);
drivers/amlogic/amports/vvc1.c:    struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
drivers/amlogic/amports/vh264_4k2k.c:    struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
drivers/amlogic/amports/vmjpeg.c:    struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
drivers/amlogic/amports/encoder.c:        buff[i] = dma_alloc_from_contiguous(&encode_manager.this_pdev->dev, (18 * SZ_1M) >> PAGE_SHIFT, 0);
drivers/amlogic/amports/encoder.c:            dma_release_from_contiguous(&encode_manager.this_pdev->dev, buff[j], (18 * SZ_1M)>>PAGE_SHIFT);
drivers/amlogic/amports/encoder.c:        wq->mem.venc_pages = dma_alloc_from_contiguous(&encode_manager.this_pdev->dev, (18 * SZ_1M) >> PAGE_SHIFT, 0);
drivers/amlogic/amports/encoder.c:            encode_debug_level(LOG_LEVEL_ERROR, "CMA failed to allocate dma buffer for %s, wq:%p.\n", encode_manager.this_pdev->name, (void*)wq);
drivers/amlogic/amports/encoder.c:            dma_release_from_contiguous(&encode_manager.this_pdev->dev, wq->mem.venc_pages, (18 * SZ_1M)>>PAGE_SHIFT);
drivers/amlogic/amports/encoder.c:    idx = find_reserve_block(pdev->dev.of_node->name,0);
drivers/amlogic/amports/vh264.c:    struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
drivers/amlogic/amports/vavs.c:        struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
drivers/amlogic/amports/jpegdec.c:    struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
drivers/amlogic/pinctrl/pinctrl-amlogic.c:	g->pins = devm_kzalloc(&pdev->dev, g->num_pins * sizeof(*g->pins),
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		g->pins = devm_kzalloc(&pdev->dev, g->num_pins * sizeof(*g->pins),
drivers/amlogic/pinctrl/pinctrl-amlogic.c:			dev_err(&pdev->dev, "malloc g->pins error\n");
drivers/amlogic/pinctrl/pinctrl-amlogic.c:				dev_err(&pdev->dev, "read %s error\n",propname);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:				dev_err(&pdev->dev, "%s change name to num  error\n",gpioname);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:			dev_err(&pdev->dev, "read %s length error\n",pinctrl_set);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:			dev_err(&pdev->dev, "num_setmask error must be multiples of 2\n");
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		g->setmask= devm_kzalloc(&pdev->dev, g->num_setmask * sizeof(*g->setmask),
drivers/amlogic/pinctrl/pinctrl-amlogic.c:			dev_err(&pdev->dev, "malloc g->setmask error\n");
drivers/amlogic/pinctrl/pinctrl-amlogic.c:			dev_err(&pdev->dev, "read %s data error\n",pinctrl_set);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:			dev_err(&pdev->dev, "read %s length error\n",pinctrl_clr);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:			dev_err(&pdev->dev, "num_setmask error must be multiples of 2\n");
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		g->clearmask= devm_kzalloc(&pdev->dev, g->num_clearmask * sizeof(*g->clearmask),
drivers/amlogic/pinctrl/pinctrl-amlogic.c:			dev_err(&pdev->dev, "malloc g->clearmask error\n");
drivers/amlogic/pinctrl/pinctrl-amlogic.c:			dev_err(&pdev->dev, "read %s data error\n",pinctrl_clr);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		devm_kfree(&pdev->dev,g->pins);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		devm_kfree(&pdev->dev,g->setmask);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		devm_kfree(&pdev->dev,g->clearmask);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:	struct device_node *np = pdev->dev.of_node;
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		dev_err(&pdev->dev, "no group is defined\n");
drivers/amlogic/pinctrl/pinctrl-amlogic.c:	soc->functions = devm_kzalloc(&pdev->dev, soc->nfunctions *
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		dev_err(&pdev->dev, "malloc soc->functions error\n");
drivers/amlogic/pinctrl/pinctrl-amlogic.c:	soc->groups = devm_kzalloc(&pdev->dev, soc->ngroups *
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		dev_err(&pdev->dev, "malloc soc->functions error\n");
drivers/amlogic/pinctrl/pinctrl-amlogic.c:			f->groups = devm_kzalloc(&pdev->dev, f->num_groups *
drivers/amlogic/pinctrl/pinctrl-amlogic.c:				dev_err(&pdev->dev, "malloc f->groups error\n");
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		devm_kfree(&pdev->dev,soc->groups);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		devm_kfree(&pdev->dev,soc->groups);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		devm_kfree(&pdev->dev,soc->functions);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:	apmx = devm_kzalloc(&pdev->dev, sizeof(*apmx), GFP_KERNEL);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		dev_err(&pdev->dev, "Can't alloc amlogic_pmx\n");
drivers/amlogic/pinctrl/pinctrl-amlogic.c:	apmx->dev = &pdev->dev;
drivers/amlogic/pinctrl/pinctrl-amlogic.c:	ret=of_property_read_u32(pdev->dev.of_node, "#pinmux-cells", &val);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		dev_err(&pdev->dev, "dt probe #pinmux-cells failed: %d\n", ret);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		dev_err(&pdev->dev, "dt probe failed: %d\n", ret);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:	amlogic_pmx_desc.name = dev_name(&pdev->dev);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:	apmx->pctl = pinctrl_register(&amlogic_pmx_desc, &pdev->dev, apmx);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:		dev_err(&pdev->dev, "Couldn't register pinctrl driver\n");
drivers/amlogic/pinctrl/pinctrl-amlogic.c:	pctdev_name=dev_name(&pdev->dev);
drivers/amlogic/pinctrl/pinctrl-amlogic.c:	dev_info(&pdev->dev, "Probed amlogic pinctrl driver\n");
drivers/amlogic/pinctrl/pinctrl-amlogic.c:	devm_kfree(&pdev->dev,apmx);
drivers/amlogic/ion_dev/dev_ion.c:    struct device_node	*of_node = pdev->dev.of_node;
drivers/amlogic/i2c/aml_sw_i2c.c:	struct aml_sw_i2c_platform *plat = pdev->dev.platform_data;
drivers/amlogic/i2c/aml_sw_i2c.c:	printk("pdev_id = %d, plat_udelay = %d, plat_timeout = %d\n", pdev->id, plat->udelay, plat->timeout);
drivers/amlogic/i2c/aml_sw_i2c.c:	snprintf(drv_data->adapter.name, sizeof(drv_data->adapter.name), "aml-sw-i2c%d", pdev->id);
drivers/amlogic/i2c/aml_sw_i2c.c:	drv_data->adapter.dev.parent = &pdev->dev;
drivers/amlogic/i2c/aml_sw_i2c.c:	drv_data->adapter.nr = (pdev->id != -1) ? pdev->id : 0;
drivers/amlogic/i2c/aml_i2c.c:	if (pdev->dev.of_node) {
drivers/amlogic/i2c/aml_i2c.c:		match = of_match_node(meson6_i2c_dt_match, pdev->dev.of_node);
drivers/amlogic/i2c/aml_i2c.c://    struct aml_i2c_platform *plat = (struct aml_i2c_platform *)(pdev->dev.platform_data);
drivers/amlogic/i2c/aml_i2c.c:	if (!pdev->dev.of_node) {
drivers/amlogic/i2c/aml_i2c.c:			dev_err(&pdev->dev, "no platform data\n");
drivers/amlogic/i2c/aml_i2c.c:	ret = of_property_read_u32(pdev->dev.of_node,"device_id",&device_id);
drivers/amlogic/i2c/aml_i2c.c:	pdev->id = device_id;
drivers/amlogic/i2c/aml_i2c.c:			ret = of_property_read_u32(pdev->dev.of_node, "use_pio", &(aml_i2c_property->use_pio));
drivers/amlogic/i2c/aml_i2c.c:			ret = of_property_read_u32(pdev->dev.of_node, "master_i2c_speed", &(aml_i2c_property->master_i2c_speed));
drivers/amlogic/i2c/aml_i2c.c:	ret=of_property_read_string(pdev->dev.of_node,"pinctrl-names",&plat->master_state_name);
drivers/amlogic/i2c/aml_i2c.c:  i2c->dev=&pdev->dev;
drivers/amlogic/i2c/aml_i2c.c:  res_start = of_iomap(pdev->dev.of_node,0);
drivers/amlogic/i2c/aml_i2c.c:  i2c->adap.nr = pdev->id==-1? 0: pdev->id;
drivers/amlogic/i2c/aml_i2c.c:	i2c->adap.dev.of_node = pdev->dev.of_node;
drivers/amlogic/i2c/aml_i2c.c:          dev_err(&pdev->dev, "Adapter %s registration failed\n",
drivers/amlogic/i2c/aml_i2c.c:  dev_info(&pdev->dev, "add adapter %s(%p)\n", i2c->adap.name, &i2c->adap);
drivers/amlogic/i2c/aml_i2c.c:  dev_info(&pdev->dev, "aml i2c bus driver.\n");
drivers/amlogic/i2c/aml_i2c.c:        dev_err(&pdev->dev, "master %d request irq(%d) failed!\n", device_id, i2c->irq);
drivers/amlogic/i2c/aml_i2c.c:	adapter = i2c_get_adapter(pdev->id==-1? 0: pdev->id);
drivers/amlogic/i2c/aml_i2c.c:	adapter = i2c_get_adapter(pdev->id==-1? 0: pdev->id);
drivers/amlogic/watchdog/aml_wdt.c:	aml_wdt = devm_kzalloc(&pdev->dev, sizeof(*aml_wdt), GFP_KERNEL);
drivers/amlogic/watchdog/aml_wdt.c:	wdev = devm_kzalloc(&pdev->dev, sizeof(*wdev), GFP_KERNEL);
drivers/amlogic/watchdog/aml_wdt.c:	wdev->dev		= &pdev->dev;
drivers/amlogic/rtc/aml_rtc.c:	rtc_set_alarm_aml(&pdev->dev, &alarm_data);
drivers/amlogic/rtc/aml_rtc.c:	struct device_node* aml_rtc_node = pdev->dev.of_node;
drivers/amlogic/rtc/aml_rtc.c:	if (!device_can_wakeup(&pdev->dev))
drivers/amlogic/rtc/aml_rtc.c:		device_init_wakeup(&pdev->dev, 1);
drivers/amlogic/rtc/aml_rtc.c:	priv->rtc = rtc_device_register("aml_rtc", &pdev->dev, &
drivers/amlogic/input/gpio_key/aml_gpiokey.c:	  if (!pdev->dev.of_node) {
drivers/amlogic/input/gpio_key/aml_gpiokey.c:				printk("gpio_key: pdev->dev.of_node == NULL!\n");
drivers/amlogic/input/gpio_key/aml_gpiokey.c:		ret = of_property_read_u32(pdev->dev.of_node,"key_num",&key_size);
drivers/amlogic/input/gpio_key/aml_gpiokey.c:        dev_err(&pdev->dev, "platform data is required!\n");
drivers/amlogic/input/gpio_key/aml_gpiokey.c:    ret = of_property_read_bool(pdev->dev.of_node, "gpio_high_z");
drivers/amlogic/input/gpio_key/aml_gpiokey.c:			dev_err(&pdev->dev, "platform key is required!\n");
drivers/amlogic/input/gpio_key/aml_gpiokey.c:				ret = of_property_read_string_index(pdev->dev.of_node, "key_name", i, &(pdata->key[i].name));
drivers/amlogic/input/gpio_key/aml_gpiokey.c:    ret = of_property_read_u32_array(pdev->dev.of_node,"key_code",key_param, pdata->key_num);
drivers/amlogic/input/gpio_key/aml_gpiokey.c:    ret = of_property_read_u32(pdev->dev.of_node,"irq_keyup",&irq_keyup);
drivers/amlogic/input/gpio_key/aml_gpiokey.c:    ret |= of_property_read_u32(pdev->dev.of_node,"irq_keydown",&irq_keydown);
drivers/amlogic/input/gpio_key/aml_gpiokey.c:				ret = of_property_read_string_index(pdev->dev.of_node, "key_pin", i, &str);
drivers/amlogic/input/gpio_key/aml_gpiokey.c:    input_dev->dev.parent = &pdev->dev;
drivers/amlogic/input/sensor/common.c:	struct device_node* node = pdev->dev.of_node;
drivers/amlogic/input/keyboard/key_input.c:		if (!pdev->dev.of_node) {
drivers/amlogic/input/keyboard/key_input.c:			printk("key_input: pdev->dev.of_node == NULL!\n");
drivers/amlogic/input/keyboard/key_input.c:		ret = of_property_read_u32(pdev->dev.of_node,"scan_period",&(pdata->scan_period));
drivers/amlogic/input/keyboard/key_input.c:		ret = of_property_read_u32(pdev->dev.of_node,"fuzz_time",&(pdata->fuzz_time));
drivers/amlogic/input/keyboard/key_input.c:		ret = of_property_read_u32(pdev->dev.of_node,"key_num",&(pdata->key_num));
drivers/amlogic/input/keyboard/key_input.c:		ret = of_property_read_u32(pdev->dev.of_node,"config",&(pdata->config));
drivers/amlogic/input/keyboard/key_input.c:    ret = of_property_read_u32_array(pdev->dev.of_node,"key_code_list",key_code_list_t,pdata->key_num);
drivers/amlogic/input/keyboard/key_input.c:		pdata = pdev->dev.platform_data;
drivers/amlogic/input/keyboard/key_input.c:        dev_err(&pdev->dev, "platform data is required!\n");
drivers/amlogic/input/keyboard/key_input.c:    input_dev->dev.parent = &pdev->dev;
drivers/amlogic/input/keyboard/so340010.c://		input->dev.parent = &pdev->dev;
drivers/amlogic/input/keyboard/ha2605.c://		input->dev.parent = &pdev->dev;
drivers/amlogic/input/keyboard/adc_keypad.c:	 if (!pdev->dev.of_node) {
drivers/amlogic/input/keyboard/adc_keypad.c:				printk("adc_key: pdev->dev.of_node == NULL!\n");
drivers/amlogic/input/keyboard/adc_keypad.c:		ret = of_property_read_u32(pdev->dev.of_node,"key_num",&key_size);
drivers/amlogic/input/keyboard/adc_keypad.c:	  ret = of_property_read_u32(pdev->dev.of_node,"name_len",&name_len);
drivers/amlogic/input/keyboard/adc_keypad.c:        dev_err(&pdev->dev, "platform data is required!\n");
drivers/amlogic/input/keyboard/adc_keypad.c:			dev_err(&pdev->dev, "platform key is required!\n");
drivers/amlogic/input/keyboard/adc_keypad.c:				ret = of_property_read_string_index(pdev->dev.of_node, "key_name", i, &(pdata->key[i].name));
drivers/amlogic/input/keyboard/adc_keypad.c:    ret = of_property_read_u32_array(pdev->dev.of_node,"key_code",key_param, pdata->key_num);
drivers/amlogic/input/keyboard/adc_keypad.c:    ret = of_property_read_u32_array(pdev->dev.of_node,"key_chan",key_param+pdata->key_num, pdata->key_num);
drivers/amlogic/input/keyboard/adc_keypad.c:	  ret = of_property_read_u32_array(pdev->dev.of_node,"key_val",key_param+pdata->key_num*2, pdata->key_num);
drivers/amlogic/input/keyboard/adc_keypad.c:	  ret = of_property_read_u32_array(pdev->dev.of_node,"key_tolerance",key_param+pdata->key_num*3, pdata->key_num);
drivers/amlogic/input/keyboard/adc_keypad.c:		pdata = pdev->dev.platform_data;
drivers/amlogic/input/keyboard/adc_keypad.c:    input_dev->dev.parent = &pdev->dev;
drivers/amlogic/input/simcard_detect/simcard_detect.c:    struct simdetect_platform_data *pdata = pdev->dev.platform_data;
drivers/amlogic/input/simcard_detect/simcard_detect.c:        dev_err(&pdev->dev, "platform data is required!\n");
drivers/amlogic/input/simcard_detect/simcard_detect.c:    register_simdetect_dev(gp_sim_detect, pdev->id);
drivers/amlogic/input/new_remote/remote_main.c:	p=devm_pinctrl_get_select_default(&pdev->dev);
drivers/amlogic/input/new_remote/remote_main.c:	if (!pdev->dev.of_node) {
drivers/amlogic/input/new_remote/remote_main.c:		printk("aml_remote: pdev->dev.of_node == NULL!\n");
drivers/amlogic/input/new_remote/remote_main.c:	ret = of_property_read_u32(pdev->dev.of_node,"ao_baseaddr",&ao_baseaddr);
drivers/amlogic/input/new_remote/remote_main.c:	ret = device_create_file(&pdev->dev, &dev_attr_enable);
drivers/amlogic/input/new_remote/remote_main.c:	ret = device_create_file(&pdev->dev, &dev_attr_log_buffer);
drivers/amlogic/input/new_remote/remote_main.c:		device_remove_file(&pdev->dev, &dev_attr_enable);
drivers/amlogic/input/new_remote/remote_main.c:	input_dev->dev.parent = &pdev->dev;
drivers/amlogic/input/new_remote/remote_main.c:	device_remove_file(&pdev->dev, &dev_attr_enable);
drivers/amlogic/input/new_remote/remote_main.c:	device_remove_file(&pdev->dev, &dev_attr_log_buffer);
drivers/amlogic/input/new_remote/remote_main.c:	device_remove_file(&pdev->dev, &dev_attr_enable);
drivers/amlogic/input/new_remote/remote_main.c:	device_remove_file(&pdev->dev, &dev_attr_log_buffer);
drivers/amlogic/input/call_key/aml_callkey.c:    struct call_key_platform_data *pdata = pdev->dev.platform_data;
drivers/amlogic/input/call_key/aml_callkey.c:        dev_err(&pdev->dev, "platform data is required!\n");
drivers/amlogic/input/call_key/aml_callkey.c:    input->dev.parent = &pdev->dev;
drivers/amlogic/input/remote/virtual_remote.c:	input_dev->dev.parent = &pdev->dev;
drivers/amlogic/input/remote/am_remote.c:	//remote_pdata = (struct aml_remote_platdata *)pdev->dev.platform_data;
drivers/amlogic/input/remote/am_remote.c:	p=devm_pinctrl_get_select_default(&pdev->dev);
drivers/amlogic/input/remote/am_remote.c:	 if (!pdev->dev.of_node) {
drivers/amlogic/input/remote/am_remote.c:		printk("aml_remote: pdev->dev.of_node == NULL!\n");
drivers/amlogic/input/remote/am_remote.c:	ret = of_property_read_u32(pdev->dev.of_node,"ao_baseaddr",&ao_baseaddr);
drivers/amlogic/input/remote/am_remote.c:	ret = device_create_file(&pdev->dev, &dev_attr_enable);
drivers/amlogic/input/remote/am_remote.c:	ret = device_create_file(&pdev->dev, &dev_attr_log_buffer);
drivers/amlogic/input/remote/am_remote.c:		device_remove_file(&pdev->dev, &dev_attr_enable);
drivers/amlogic/input/remote/am_remote.c:	//input_dev->cdev.dev = &pdev->dev;
drivers/amlogic/input/remote/am_remote.c:	input_dev->dev.parent = &pdev->dev;
drivers/amlogic/input/remote/am_remote.c:	device_remove_file(&pdev->dev, &dev_attr_enable);
drivers/amlogic/input/remote/am_remote.c:	device_remove_file(&pdev->dev, &dev_attr_log_buffer);
drivers/amlogic/input/remote/am_remote.c:	device_remove_file(&pdev->dev, &dev_attr_enable);
drivers/amlogic/input/remote/am_remote.c:	device_remove_file(&pdev->dev, &dev_attr_log_buffer);
drivers/amlogic/input/holdkey/aml_holdkey.c:    struct hold_key_platform_data *pdata = pdev->dev.platform_data;
drivers/amlogic/input/holdkey/aml_holdkey.c:        dev_err(&pdev->dev, "platform data is required!\n");
drivers/amlogic/input/touchscreen/common.c:	struct device_node* touch_node = pdev->dev.of_node;
drivers/amlogic/input/touchscreen/common.c:	pdev->dev.platform_data = pdata;
drivers/amlogic/input/touchscreen/common.c:	if (pdev->dev.platform_data)
drivers/amlogic/input/touchscreen/common.c:	 	kfree (pdev->dev.platform_data);
drivers/amlogic/input/touchscreen/adc_ts.c:	struct adc_ts_platform_data *pdata = pdev->dev.platform_data;
drivers/amlogic/input/touchscreen/adc_ts.c:		dev_err(&pdev->dev, "platform data is required!\n");
drivers/amlogic/input/touchscreen/adc_ts.c:		 "%s/input0", dev_name(&pdev->dev));
drivers/amlogic/input/touchscreen/adc_ts.c:	input_dev->dev.parent = &pdev->dev;
drivers/amlogic/input/touchscreen/adc_ts.c:	struct device *dev = &pdev->dev;
drivers/amlogic/input/irblaster/am_irblaster.c:	if (pdev->dev.of_node) {
drivers/amlogic/input/irblaster/am_irblaster.c:		printk("aml_irblaster: pdev->dev.of_node == NULL!\n");
drivers/amlogic/video_dev/amlvideo2.c:	vid_dev->node_num = pdev->num_resources;
drivers/amlogic/video_dev/amlvideo2.c:    		ret = find_reserve_block(pdev->dev.of_node->name,i);
drivers/amlogic/video_dev/amlvideo2.c:	if(of_get_property(pdev->dev.of_node, "reserve-memory", NULL))
drivers/amlogic/video_dev/amlvideo2.c:		pdev->num_resources = MAX_SUB_DEV_NODE;
drivers/amlogic/video_dev/amlvideo2.c:	if (pdev->num_resources == 0) {
drivers/amlogic/video_dev/amlvideo2.c:		dev_err(&pdev->dev, "probed for an unknown device\n");
drivers/amlogic/video_dev/amlvideo2.c:	if (v4l2_device_register(&pdev->dev, &dev->v4l2_dev) < 0) {
drivers/amlogic/video_dev/amlvideo2.c:		dev_err(&pdev->dev, "v4l2_device_register failed\n");
drivers/amlogic/bluetooth/bt_wake_control.c:	if (!(pdev->dev.of_node)) {
drivers/amlogic/bluetooth/bt_wake_control.c:        printk("btwake_control: pdev->dev.of_node == NULL!\n");
drivers/amlogic/bluetooth/bt_wake_control.c:	ret = of_property_read_string(pdev->dev.of_node,"gpio_host_wake",&str);
drivers/amlogic/bluetooth/bt_wake_control.c:	ret = of_property_read_string(pdev->dev.of_node,"gpio_ext_wake",&str);
drivers/amlogic/bluetooth/bt_wake_control.c:    ret = of_property_read_u32(pdev->dev.of_node, "host_wake_irq_high", &bsi->host_wake_irq_high);	
drivers/amlogic/bluetooth/bt_wake_control.c:    ret = of_property_read_u32(pdev->dev.of_node, "host_wake_irq_low", &bsi->host_wake_irq_low);	
drivers/amlogic/bluetooth/bt_device.c:	if (pdev->dev.of_node) {
drivers/amlogic/bluetooth/bt_device.c:		ret = of_property_read_string(pdev->dev.of_node,"gpio_reset",&str);
drivers/amlogic/bluetooth/bt_device.c:        ret = of_property_read_string(pdev->dev.of_node,"gpio_en",&str);
drivers/amlogic/bluetooth/bt_device.c:		ret = of_property_read_string(pdev->dev.of_node,"gpio_wake",&str);
drivers/amlogic/bluetooth/bt_device.c:    pdata = (struct bt_dev_data *)(pdev->dev.platform_data);
drivers/amlogic/bluetooth/bt_device.c:	bt_rfk = rfkill_alloc("bt-dev", &pdev->dev, RFKILL_TYPE_BLUETOOTH,
drivers/amlogic/deinterlace/deinterlace.c:    di_device.dev = device_create(di_class, &pdev->dev, di_device.devt, &di_device, "di%d", 0); //kernel>=2.6.27
drivers/amlogic/deinterlace/deinterlace.c:    r = find_reserve_block(pdev->dev.of_node->name,0);
drivers/amlogic/deinterlace/deinterlace.c:        name = of_get_property(pdev->dev.of_node,"share-memory-name",NULL);
drivers/amlogic/deinterlace/deinterlace.c:            name= of_get_property(pdev->dev.of_node,"share-memory-offset",NULL);
drivers/amlogic/deinterlace/deinterlace.c:            name= of_get_property(pdev->dev.of_node,"share-memory-size",NULL);
drivers/amlogic/cpufreq/meson-cpufreq.c:    if (pdev->dev.of_node) {
drivers/amlogic/cpufreq/meson-cpufreq.c:        err = of_property_read_bool(pdev->dev.of_node, "syspll_fixed");
drivers/amlogic/cpufreq/meson-cpufreq.c:		if (pdev->dev.of_node) {
drivers/amlogic/cpufreq/meson-cpufreq.c:			prop = of_get_property(pdev->dev.of_node, "voltage_control", NULL);
drivers/amlogic/cpufreq/meson-cpufreq.c:    cpufreq.dev = &pdev->dev;
drivers/amlogic/d2d3/d2d3_drv.c:        devp->dev = d2d3_create_device(&pdev->dev,0);
drivers/amlogic/d2d3/d2d3_drv.c:       	ret = find_reserve_block(pdev->dev.of_node->name,0);
drivers/amlogic/d2d3/d2d3_drv.c:     	if (pdev->dev.of_node) {
drivers/amlogic/d2d3/d2d3_drv.c:               	ret = of_property_read_u32(pdev->dev.of_node,"irq",&(res->start));
drivers/amlogic/d2d3/d2d3_drv.c:        device_remove_file(&pdev->dev,&dev_attr_debug);
drivers/amlogic/d2d3/d2d3_drv.c:        device_del(&pdev->dev);
drivers/amlogic/spi_nor/apollo_spi_nor.c:	master = spi_alloc_master(&pdev->dev, sizeof *amlogic_spi);
drivers/amlogic/spi_nor/apollo_spi_nor.c:		dev_dbg(&pdev->dev, "master allocation failed\n");
drivers/amlogic/spi_nor/apollo_spi_nor.c:	if (pdev->id != -1)
drivers/amlogic/spi_nor/apollo_spi_nor.c:		master->bus_num = pdev->id;
drivers/amlogic/spi_nor/apollo_spi_nor.c:	dev_set_drvdata(&pdev->dev, master);
drivers/amlogic/spi_nor/apollo_spi_nor.c:		of_property_read_string(pdev->dev.of_node,"pinctrl-names",(const char **)&amlogic_spi->spi_state_name);
drivers/amlogic/spi_nor/apollo_spi_nor.c:	amlogic_spi->dev = &pdev->dev;
drivers/amlogic/spi_nor/apollo_spi_nor.c:	amlogic_spi->spi_dev.dev.platform_data = pdev->dev.platform_data;
drivers/amlogic/spi_nor/apollo_spi_nor.c:	master = dev_get_drvdata(&pdev->dev);
drivers/amlogic/wifi/wifi_power.c:    if(pdev->dev.of_node)
drivers/amlogic/wifi/wifi_power.c:    	ret = of_property_read_string(pdev->dev.of_node, "valid", &str);
drivers/amlogic/wifi/wifi_power.c:			ret = of_property_read_string(pdev->dev.of_node, "suspend_pull_power", &str);
drivers/amlogic/wifi/wifi_power.c:      ret = of_property_read_string(pdev->dev.of_node, "power_gpio", &str);
drivers/amlogic/wifi/wifi_power.c:	  	if(!(ret = of_property_read_string(pdev->dev.of_node, "power_gpio2", &str)))
drivers/amlogic/wifi/wifi_power.c:    pdev->dev.platform_data = pdata;
drivers/amlogic/wifi/wifi_dt.c:	match = of_match_node(wifi_match, pdev->dev.of_node);
drivers/amlogic/wifi/wifi_dt.c:    struct wifi_plat_info *plat = (struct wifi_plat_info *)(pdev->dev.platform_data);
drivers/amlogic/wifi/wifi_dt.c:	if (pdev->dev.of_node) {
drivers/amlogic/wifi/wifi_dt.c:		ret = of_property_read_string(pdev->dev.of_node, "interrupt_pin", &value);
drivers/amlogic/wifi/wifi_dt.c:		ret = of_property_read_u32(pdev->dev.of_node, "irq_num", &plat->irq_num);
drivers/amlogic/wifi/wifi_dt.c:		ret = of_property_read_string(pdev->dev.of_node, "irq_trigger_type", &value);
drivers/amlogic/wifi/wifi_dt.c:		ret = of_property_read_string(pdev->dev.of_node, "power_on_pin", &value);
drivers/amlogic/wifi/wifi_dt.c:		ret = of_property_read_u32(pdev->dev.of_node, "power_on_pin_level", &plat->power_on_pin_level);
drivers/amlogic/wifi/wifi_dt.c:		ret = of_property_read_string(pdev->dev.of_node, "power_on_pin2", &value);
drivers/amlogic/wifi/wifi_dt.c:		ret = of_property_read_string(pdev->dev.of_node, "clock_32k_pin", &value);
drivers/amlogic/canvas/canvas.c:				&pdev->dev.kobj, "%d", i);
drivers/amlogic/spi/spicc.c:	BUG_ON(!pdev->dev.of_node);
drivers/amlogic/spi/spicc.c:	ret = of_property_read_u32(pdev->dev.of_node,"device_id",&pdata->device_id);
drivers/amlogic/spi/spicc.c:		dev_err(&pdev->dev, "match device_id failed!\n");
drivers/amlogic/spi/spicc.c:	dev_info(&pdev->dev, "device_id = %d \n", pdata->device_id);
drivers/amlogic/spi/spicc.c:	ret = of_property_read_string(pdev->dev.of_node, "pinctrl-names", &prop_name);
drivers/amlogic/spi/spicc.c:		dev_err(&pdev->dev, "match pinctrl-names failed!\n");
drivers/amlogic/spi/spicc.c:	pdata->pinctrl = devm_pinctrl_get_select(&pdev->dev, prop_name);
drivers/amlogic/spi/spicc.c:		dev_err(&pdev->dev, "pinmux error\n");
drivers/amlogic/spi/spicc.c:	dev_info(&pdev->dev, "pinctrl_name = %s\n", prop_name);
drivers/amlogic/spi/spicc.c:	ret = of_property_read_u32(pdev->dev.of_node,"num_chipselect",&pdata->num_chipselect);
drivers/amlogic/spi/spicc.c:		dev_err(&pdev->dev, "match num_chipselect failed!\n");
drivers/amlogic/spi/spicc.c: 	dev_info(&pdev->dev, "num_chipselect = %d\n", pdata->num_chipselect);
drivers/amlogic/spi/spicc.c:		ret = of_property_read_string_index(pdev->dev.of_node, "cs_gpios", i, &prop_name);
drivers/amlogic/spi/spicc.c:			dev_err(&pdev->dev, "match cs_gpios[%d](%s) failed!\n", i, prop_name);
drivers/amlogic/spi/spicc.c: 			dev_info(&pdev->dev, "cs_gpios[%d] = %s(%d)\n", i, prop_name, gpio);
drivers/amlogic/spi/spicc.c:  pdata->regs = (struct spicc_regs __iomem *)of_iomap(pdev->dev.of_node, 0);
drivers/amlogic/spi/spicc.c:	dev_info(&pdev->dev, "regs = %x\n", pdata->regs);
drivers/amlogic/spi/spicc.c:	pdata = (struct spicc_platform_data *)pdev->dev.platform_data
drivers/amlogic/spi/spicc.c:			dev_err(&pdev->dev, "request chipselect gpio(%d) failed!\n", i);
drivers/amlogic/spi/spicc.c:	master = spi_alloc_master(&pdev->dev, sizeof *spicc);
drivers/amlogic/spi/spicc.c:		dev_err(&pdev->dev, "allocate spi master failed!\n");
drivers/amlogic/spi/spicc.c:			dev_err(&pdev->dev, "register spi master failed! (%d)\n", ret);
drivers/amlogic/spi/spicc.c:	dev_set_drvdata(&pdev->dev, spicc);
drivers/amlogic/spi/spicc.c:		dev_err(&pdev->dev, "register class failed! (%d)\n", ret);
drivers/amlogic/spi/spicc.c:	dev_info(&pdev->dev, "SPICC init ok \n");
drivers/amlogic/spi/spicc.c:	spicc = (struct spicc *)dev_get_drvdata(&pdev->dev);
drivers/amlogic/ext_hdmiin/sii9233/sii9233_drv.c:	sii9233a_get_of_data(pdev->dev.of_node);
drivers/amlogic/ext_hdmiin/sii9233/sii9233_drv.c:	hdmirx_pdata = pdev->dev.platform_data;
drivers/amlogic/ext_hdmiin/sii9293/linux_driver/application/mhl_linuxdrv_main.c:	sii5293_get_of_data(pdev->dev.of_node);
drivers/amlogic/ethernet/am_net8218.c:	if (!pdev->dev.of_node) {
drivers/amlogic/ethernet/am_net8218.c:		printk("eth: pdev->dev.of_node == NULL!\n");
drivers/amlogic/ethernet/am_net8218.c:	ret = of_property_read_u32(pdev->dev.of_node,"ethbaseaddr",&ethbaseaddr);
drivers/amlogic/ethernet/am_net8218.c:	ret = of_property_read_u32(pdev->dev.of_node,"interruptnum",&interruptnum);
drivers/amlogic/ethernet/am_net8218.c:	ret = of_property_read_u32(pdev->dev.of_node,"phy_interface",&phy_interface); // 0 rgmii 1: RMII
drivers/amlogic/ethernet/am_net8218.c:	ret = of_property_read_u32(pdev->dev.of_node,"savepowermode",&savepowermode);
drivers/amlogic/ethernet/am_net8218.c:	ret = of_property_read_u32(pdev->dev.of_node,"reset_pin_enable",&reset_pin_enable);
drivers/amlogic/ethernet/am_net8218.c:	ret = of_property_read_u32(pdev->dev.of_node,"reset_delay",&reset_delay);
drivers/amlogic/ethernet/am_net8218.c:	ret = of_property_read_string(pdev->dev.of_node,"reset_pin",&reset_pin);
drivers/amlogic/ethernet/am_net8218.c:	ret = of_property_read_u32(pdev->dev.of_node,"new_maclogic",&new_maclogic);
drivers/amlogic/ethernet/am_net8218.c:	ret = of_property_read_u32(pdev->dev.of_node,"used_pmu4_phy",&used_pmu4_phy);
drivers/amlogic/ethernet/am_net8218.c:	SET_NETDEV_DEV(my_ndev, &pdev->dev);
drivers/amlogic/ethernet/am_net8218.c:	eth_pdata = (struct aml_eth_platdata *)pdev->dev.platform_data;
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:	struct meson_cs_pdata_t *meson_cs_pdata  = pdev->dev.platform_data;
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:	struct device_node *np = pdev->dev.of_node;
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:	if (pdev->dev.of_node) {
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:		if(of_find_property(pdev->dev.of_node,"vcck_pwm_table",NULL))
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:			vcck_pwm_init(&(pdev->dev));
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:		pdev->dev.platform_data = vcck_pdata;	
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:	meson_regulator_config = devm_kzalloc(&pdev->dev, sizeof(*meson_regulator_config), GFP_KERNEL);
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:	meson_regulator_config->dev=&pdev->dev;
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:	meson_regulator_config->of_node=pdev->dev.of_node;
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:			dev_err(&pdev->dev,
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:				pdev->name);
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:			dev_err(&pdev->dev,
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:				pdev->name);
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:		error = device_create_file(&pdev->dev, attributes_virtual[i]);
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:	struct device_node *np = pdev->dev.of_node;
drivers/amlogic/power/meson_cs_dcdc_regulator/meson_cs_dcdc_regulator.c:        dvfs_vcck_pwm_init(&pdev->dev);
Binary file drivers/amlogic/power/meson_cs_dcdc_regulator/.meson_cs_dcdc_regulator.c.kate-swp matches
drivers/amlogic/power/aml_dvfs/aml_dvfs.c:    struct device_node     *dvfs_node = pdev->dev.of_node;
drivers/amlogic/power/axp_power/axp18-regu.c:		ret = device_create_file(&pdev->dev,&axp_regu_attrs[j]);
drivers/amlogic/power/axp_power/axp18-regu.c:		device_remove_file(&pdev->dev,&axp_regu_attrs[j]);
drivers/amlogic/power/axp_power/axp18-regu.c:	ri = find_regulator_info(pdev->id);
drivers/amlogic/power/axp_power/axp18-regu.c:		dev_err(&pdev->dev, "invalid regulator ID specified\n");
drivers/amlogic/power/axp_power/axp18-regu.c:	rdev = regulator_register(&ri->desc, &pdev->dev,
drivers/amlogic/power/axp_power/axp18-regu.c:				  pdev->dev.platform_data, ri);
drivers/amlogic/power/axp_power/axp18-regu.c:		dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/amlogic/power/axp_power/axp19-gpio.c:	//struct axp_mfd_chip *axp_chip = dev_get_drvdata(pdev->dev.parent);
drivers/amlogic/power/axp_power/axp19-gpio.c:		ret = device_create_file(&pdev->dev, attributes[i]);
drivers/amlogic/power/axp_power/axp19-gpio.c:		device_remove_file(&pdev->dev, attributes[i]);
drivers/amlogic/power/axp_power/axp20-regu.c:		ret = device_create_file(&pdev->dev,&axp_regu_attrs[j]);
drivers/amlogic/power/axp_power/axp20-regu.c:		device_remove_file(&pdev->dev,&axp_regu_attrs[j]);
drivers/amlogic/power/axp_power/axp20-regu.c:            dev_err(&pdev->dev, "alloc device list failed\n");
drivers/amlogic/power/axp_power/axp20-regu.c:            dev_err(&pdev->dev, "alloc device list failed\n");
drivers/amlogic/power/axp_power/axp20-regu.c:	ri = find_regulator_info(pdev->id);
drivers/amlogic/power/axp_power/axp20-regu.c:		dev_err(&pdev->dev, "invalid regulator ID specified\n");
drivers/amlogic/power/axp_power/axp20-regu.c:    tmplist->config.dev = &pdev->dev;
drivers/amlogic/power/axp_power/axp20-regu.c:    tmplist->config.init_data = pdev->dev.platform_data;
drivers/amlogic/power/axp_power/axp20-regu.c:		dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/amlogic/power/axp_power/axp-mfd.c:		pdev->dev.parent = chip->dev;
drivers/amlogic/power/axp_power/axp-mfd.c:		pdev->dev.platform_data = regl_dev->platform_data;
drivers/amlogic/power/axp_power/axp-mfd.c:		pdev->dev.parent = chip->dev;
drivers/amlogic/power/axp_power/axp-mfd.c:		pdev->dev.platform_data = sply_dev->platform_data;
drivers/amlogic/power/axp_power/axp-mfd.c:		pdev->dev.parent = chip->dev;
drivers/amlogic/power/axp_power/axp-mfd.c:		pdev->dev.platform_data = gpio_dev->platform_data;
drivers/amlogic/power/axp_power/axp20-sply.c:	struct axp_supply_init_data *pdata = pdev->dev.platform_data;
drivers/amlogic/power/axp_power/axp20-sply.c:	powerkeydev->name       = pdev->name;
drivers/amlogic/power/axp_power/axp20-sply.c:	powerkeydev->dev.parent = &pdev->dev;
drivers/amlogic/power/axp_power/axp20-sply.c:	supply->master = pdev->dev.parent;
drivers/amlogic/power/axp_power/axp20-sply.c:    ret = power_supply_register(&pdev->dev, &supply->batt);
drivers/amlogic/power/axp_power/axp20-sply.c:    ret = power_supply_register(&pdev->dev, &supply->ac);
drivers/amlogic/power/axp_power/axp20-sply.c:    ret = power_supply_register(&pdev->dev, &supply->usb);
drivers/amlogic/power/axp_power/axp19-regu.c:		ret = device_create_file(&pdev->dev,&axp_regu_attrs[j]);
drivers/amlogic/power/axp_power/axp19-regu.c:		device_remove_file(&pdev->dev,&axp_regu_attrs[j]);
drivers/amlogic/power/axp_power/axp19-regu.c:	ri = find_regulator_info(pdev->id);
drivers/amlogic/power/axp_power/axp19-regu.c:		dev_err(&pdev->dev, "invalid regulator ID specified\n");
drivers/amlogic/power/axp_power/axp19-regu.c:	rdev = regulator_register(&ri->desc, &pdev->dev,
drivers/amlogic/power/axp_power/axp19-regu.c:				  pdev->dev.platform_data, ri);
drivers/amlogic/power/axp_power/axp19-regu.c:		dev_err(&pdev->dev, "failed to register regulator %s\n",
drivers/amlogic/power/axp_power/axp19-sply.c:	struct axp_supply_init_data *pdata = pdev->dev.platform_data;
drivers/amlogic/power/axp_power/axp19-sply.c:	powerkeydev->name = pdev->name;
drivers/amlogic/power/axp_power/axp19-sply.c:	powerkeydev->dev.parent = &pdev->dev;
drivers/amlogic/power/axp_power/axp19-sply.c:	charger->master = pdev->dev.parent;
drivers/amlogic/power/axp_power/axp19-sply.c:	ret = power_supply_register(&pdev->dev, &charger->batt);
drivers/amlogic/power/axp_power/axp19-sply.c:	ret = power_supply_register(&pdev->dev, &charger->ac);
drivers/amlogic/power/axp_power/axp19-sply.c:	ret = power_supply_register(&pdev->dev, &charger->usb);
drivers/amlogic/power/axp_power/axp18-sply.c:	struct axp_supply_init_data *pdata = pdev->dev.platform_data;
drivers/amlogic/power/axp_power/axp18-sply.c:	powerkeydev->name = pdev->name;
drivers/amlogic/power/axp_power/axp18-sply.c:	powerkeydev->dev.parent = &pdev->dev;
drivers/amlogic/power/axp_power/axp18-sply.c:	charger->master = pdev->dev.parent;
drivers/amlogic/power/axp_power/axp18-sply.c:	ret = power_supply_register(&pdev->dev, &charger->batt);
drivers/amlogic/power/axp_power/axp18-sply.c:	ret = power_supply_register(&pdev->dev, &charger->ac);
drivers/amlogic/power/axp_power/axp18-sply.c:	ret = power_supply_register(&pdev->dev, &charger->usb);
drivers/amlogic/power/axp_power/axp20-gpio.c:	//struct axp_mfd_chip *axp_chip = dev_get_drvdata(pdev->dev.parent);
drivers/amlogic/power/axp_power/axp20-gpio.c:	axp_gpio_cfg_t *init_gpio_cfg = pdev->dev.platform_data;
drivers/amlogic/power/axp_power/axp20-gpio.c:		ret = device_create_file(&pdev->dev, attributes[i]);
drivers/amlogic/power/axp_power/axp20-gpio.c:		device_remove_file(&pdev->dev, attributes[i]);
drivers/amlogic/power/axp_power/virtual19.c:	char *reg_id = pdev->dev.platform_data;
drivers/amlogic/power/axp_power/virtual19.c:	//drvdata->regulator = regulator_get(&pdev->dev, reg_id);
drivers/amlogic/power/axp_power/virtual19.c:		ret = device_create_file(&pdev->dev, attributes_virtual[i]);
drivers/amlogic/power/axp_power/virtual19.c:		device_remove_file(&pdev->dev, attributes_virtual[i]);
drivers/amlogic/power/axp_power/virtual19.c:		device_remove_file(&pdev->dev, attributes_virtual[i]);
drivers/amlogic/power/axp_power/virtual18.c:	char *reg_id = pdev->dev.platform_data;
drivers/amlogic/power/axp_power/virtual18.c:	//drvdata->regulator = regulator_get(&pdev->dev, reg_id);
drivers/amlogic/power/axp_power/virtual18.c:		ret = device_create_file(&pdev->dev, attributes_virtual[i]);
drivers/amlogic/power/axp_power/virtual18.c:		device_remove_file(&pdev->dev, attributes_virtual[i]);
drivers/amlogic/power/axp_power/virtual18.c:		device_remove_file(&pdev->dev, attributes_virtual[i]);
drivers/amlogic/power/axp_power/virtual20.c:	char *reg_id = pdev->dev.platform_data;
drivers/amlogic/power/axp_power/virtual20.c:	//drvdata->regulator = regulator_get(&pdev->dev, reg_id);
drivers/amlogic/power/axp_power/virtual20.c:		ret = device_create_file(&pdev->dev, attributes_virtual[i]);
drivers/amlogic/power/axp_power/virtual20.c:		device_remove_file(&pdev->dev, attributes_virtual[i]);
drivers/amlogic/power/axp_power/virtual20.c:		device_remove_file(&pdev->dev, attributes_virtual[i]);
drivers/amlogic/power/aml_pmu_of_common.c:	struct device_node	*pmu_node = pdev->dev.of_node;
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    aml1212_init = pdev->dev.platform_data;
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    aml_pmu_power_key->name       = pdev->name;
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    aml_pmu_power_key->dev.parent = &pdev->dev;
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    supply->master = pdev->dev.parent;
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    ret = power_supply_register(&pdev->dev, &supply->batt);
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    ret = power_supply_register(&pdev->dev, &supply->ac);
drivers/amlogic/power/aml_pmu/aml1212-sply.c:    ret = power_supply_register(&pdev->dev, &supply->usb);
drivers/amlogic/power/aml_pmu/aml1218-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/aml_pmu/aml1218-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/aml_pmu/aml1218-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/aml_pmu/aml1218-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/aml_pmu/aml1218-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/aml_pmu/aml1218-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/aml_pmu/aml1216-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/aml_pmu/aml1216-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/aml_pmu/aml1216-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/aml_pmu/aml1216-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/aml_pmu/aml1216-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/aml_pmu/aml1216-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/aml_pmu/aml1220_pmu4.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/aml_pmu/aml1220_pmu4.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/aml_pmu/aml1220_pmu4.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/aml_pmu/aml1220_pmu4.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/aml_pmu/aml1216-sply.c:    g_aml1216_init = pdev->dev.platform_data;
drivers/amlogic/power/aml_pmu/aml1216-sply.c:    aml1216_power_key->name       = pdev->name;
drivers/amlogic/power/aml_pmu/aml1216-sply.c:    aml1216_power_key->dev.parent = &pdev->dev;
drivers/amlogic/power/aml_pmu/aml1216-sply.c:    supply->master = pdev->dev.parent;
drivers/amlogic/power/aml_pmu/aml1216-sply.c:    ret = power_supply_register(&pdev->dev, &supply->batt);
drivers/amlogic/power/aml_pmu/aml1216-sply.c:    ret = power_supply_register(&pdev->dev, &supply->ac);
drivers/amlogic/power/aml_pmu/aml1216-sply.c:    ret = power_supply_register(&pdev->dev, &supply->usb);
drivers/amlogic/power/aml_pmu/aml1218-sply.c:    g_aml1218_init = pdev->dev.platform_data;
drivers/amlogic/power/aml_pmu/aml1218-sply.c:    aml1218_power_key->name       = pdev->name;
drivers/amlogic/power/aml_pmu/aml1218-sply.c:    aml1218_power_key->dev.parent = &pdev->dev;
drivers/amlogic/power/aml_pmu/aml1218-sply.c:    supply->master = pdev->dev.parent;
drivers/amlogic/power/aml_pmu/aml1218-sply.c:    ret = power_supply_register(&pdev->dev, &supply->batt);
drivers/amlogic/power/aml_pmu/aml1218-sply.c:    ret = power_supply_register(&pdev->dev, &supply->ac);
drivers/amlogic/power/aml_pmu/aml1218-sply.c:    ret = power_supply_register(&pdev->dev, &supply->usb);
drivers/amlogic/power/aml_pmu/aml_pmu.c:	pdev->dev.parent		= &client->dev;
drivers/amlogic/power/aml_pmu/aml_pmu.c:	pdev->dev.platform_data =  init_data;
drivers/amlogic/power/ricoh/rn5t618-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/ricoh/rn5t618-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 1);
drivers/amlogic/power/ricoh/rn5t618-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/ricoh/rn5t618-rw.c:    ret = i2c_transfer(pdev->adapter, msg, 2);
drivers/amlogic/power/ricoh/ricoh_pmu.c:	pdev->dev.parent		= &client->dev;
drivers/amlogic/power/ricoh/ricoh_pmu.c:	pdev->dev.platform_data =  init_data;
drivers/amlogic/power/ricoh/rn5t618-sply.c:    g_rn5t618_init = pdev->dev.platform_data;
drivers/amlogic/power/ricoh/rn5t618-sply.c:    rn5t618_power_key->name       = pdev->name;
drivers/amlogic/power/ricoh/rn5t618-sply.c:    rn5t618_power_key->dev.parent = &pdev->dev;
drivers/amlogic/power/ricoh/rn5t618-sply.c:    supply->master = pdev->dev.parent;
drivers/amlogic/power/ricoh/rn5t618-sply.c:    ret = power_supply_register(&pdev->dev, &supply->batt);
drivers/amlogic/power/ricoh/rn5t618-sply.c:    ret = power_supply_register(&pdev->dev, &supply->ac);
drivers/amlogic/power/ricoh/rn5t618-sply.c:    ret = power_supply_register(&pdev->dev, &supply->usb);
drivers/amlogic/mhl/it6681/it6681.c:	struct device_node* node = pdev->dev.of_node;
drivers/amlogic/early_init/early_init.c:	ret = of_property_read_string(pdev->dev.of_node,"gpio-1",&str);
drivers/amlogic/early_init/early_init.c:	ret = of_property_read_string(pdev->dev.of_node,"gpio-2",&str);
drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c:    if(pdev->dev.of_node){
drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c:        ret = of_property_read_u32(pdev->dev.of_node, "phy-size", &psize);
drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c:                ret = of_property_read_u32_array(pdev->dev.of_node, "phy-data", (unsigned int *)(hdmitx_device.config_data.phy_data), (sizeof(struct hdmi_phy_set_data))*psize/sizeof(struct hdmi_phy_set_data*));
drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c:        ret = of_property_read_u32(pdev->dev.of_node,"vend-data",&val);
drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c:        ret = of_property_read_u32(pdev->dev.of_node,"pwr-ctrl", &val);
drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c:    hdmi_pdata = pdev->dev.platform_data;
drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c:    if(pdev->dev.of_node){
drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c:        ret = of_property_read_u32(pdev->dev.of_node, "phy-size", &psize);
drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c:                ret = of_property_read_u32_array(pdev->dev.of_node, "phy-data", (unsigned int *)(hdmitx_device.config_data.phy_data), (sizeof(struct hdmi_phy_set_data))*psize/sizeof(struct hdmi_phy_set_data*));
drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c:        ret = of_property_read_u32(pdev->dev.of_node,"vend-data",&val);
drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c:        ret = of_property_read_u32(pdev->dev.of_node,"pwr-ctrl", &val);
drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c:    hdmi_pdata = pdev->dev.platform_data;
drivers/amlogic/ppmgr/ppmgr_drv.c:    idx = find_reserve_block(pdev->dev.of_node->name,0);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
drivers/amlogic/dvb_tv/aml_fe.c:		ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
drivers/amlogic/dvb_tv/aml_fe.c:			ret = find_reserve_block(pdev->dev.of_node->name,0);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
drivers/amlogic/dvb_tv/aml_fe.c:	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
drivers/amlogic/dvb_tv/aml_fe.c:	fe_man.pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/amlogic/dvb_tv/aml_dvb.c:		ts->pinctrl  = devm_pinctrl_get_select(&dvb->pdev->dev, pname);
drivers/amlogic/dvb_tv/aml_dvb.c:	advb->dev  = &pdev->dev;
drivers/amlogic/dvb_tv/aml_dvb.c:	if(pdev->dev.of_node){
drivers/amlogic/dvb_tv/aml_dvb.c:			ret = of_property_read_string(pdev->dev.of_node, buf, &str);
drivers/amlogic/dvb_tv/aml_dvb.c:						advb->ts[i].pinctrl = devm_pinctrl_get_select(&pdev->dev, buf);
drivers/amlogic/dvb_tv/aml_dvb.c:					advb->ts[i].pinctrl = devm_pinctrl_get_select(&pdev->dev, buf);
drivers/amlogic/dvb_tv/aml_dvb.c:			ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
drivers/amlogic/dvb_tv/aml_dvb.c:				ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
drivers/amlogic/dvb_tv/aml_dvb.c:	struct aml_dvb *advb = (struct aml_dvb*)dev_get_drvdata(&pdev->dev);
drivers/amlogic/defendkey/defendkey.c:	if (pdev->dev.of_node) {
drivers/amlogic/defendkey/defendkey.c:		match = of_match_node(meson6_defendkey_dt_match, pdev->dev.of_node);
drivers/amlogic/defendkey/defendkey.c:    if (pdev->dev.platform_data)
drivers/amlogic/defendkey/defendkey.c:        devp->platform_data = pdev->dev.platform_data;
drivers/amlogic/defendkey/defendkey.c:	//if (pdev->dev.of_node) {
drivers/memory/tegra30-mc.c:	mc = devm_kzalloc(&pdev->dev, bytes, GFP_KERNEL);
drivers/memory/tegra30-mc.c:	mc->dev = &pdev->dev;
drivers/memory/tegra30-mc.c:		mc->regs[i] = devm_ioremap_resource(&pdev->dev, res);
drivers/memory/tegra30-mc.c:	err = devm_request_irq(&pdev->dev, irq->start, tegra30_mc_isr,
drivers/memory/tegra30-mc.c:			       IRQF_SHARED, dev_name(&pdev->dev), mc);
drivers/memory/tegra20-mc.c:	mc = devm_kzalloc(&pdev->dev, sizeof(*mc), GFP_KERNEL);
drivers/memory/tegra20-mc.c:	mc->dev = &pdev->dev;
drivers/memory/tegra20-mc.c:		mc->regs[i] = devm_ioremap_resource(&pdev->dev, res);
drivers/memory/tegra20-mc.c:	err = devm_request_irq(&pdev->dev, irq->start, tegra20_mc_isr,
drivers/memory/tegra20-mc.c:			       IRQF_SHARED, dev_name(&pdev->dev), mc);
drivers/memory/emif.c:	pd = pdev->dev.platform_data;
drivers/memory/emif.c:	dev = &pdev->dev;
drivers/memory/emif.c:	if (pdev->dev.of_node)
drivers/memory/emif.c:		emif = of_get_memory_device_details(pdev->dev.of_node, &pdev->dev);
drivers/memory/emif.c:	emif->dev = &pdev->dev;
drivers/memory/emif.c:	dev_info(&pdev->dev, "%s: device configured with addr = %p and IRQ%d\n",
drivers/dma/iop-adma.c:	struct device *dev = &iop_chan->device->pdev->dev;
drivers/dma/iop-adma.c:	struct device *dev = &iop_chan->device->pdev->dev;
drivers/dma/iop-adma.c:		iop_chan->device->pdev->dev.platform_data;
drivers/dma/iop-adma.c:	dma_sync_single_for_cpu(&iop_chan->device->pdev->dev, dest_dma,
drivers/dma/iop-adma.c:	dma_sync_single_for_cpu(&iop_chan->device->pdev->dev, dest_dma,
drivers/dma/iop-adma.c:	dma_sync_single_for_device(&iop_chan->device->pdev->dev, dest_dma,
drivers/dma/iop-adma.c:	struct iop_adma_platform_data *plat_data = pdev->dev.platform_data;
drivers/dma/iop-adma.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
drivers/dma/iop-adma.c:				resource_size(res), pdev->name))
drivers/dma/iop-adma.c:	if ((adev->dma_desc_pool_virt = dma_alloc_writecombine(&pdev->dev,
drivers/dma/iop-adma.c:	dev_dbg(&pdev->dev, "%s: allocated descriptor pool virt %p phys %p\n",
drivers/dma/iop-adma.c:	dma_dev->dev = &pdev->dev;
drivers/dma/iop-adma.c:	iop_chan->mmr_base = devm_ioremap(&pdev->dev, res->start,
drivers/dma/iop-adma.c:			ret = devm_request_irq(&pdev->dev, irq,
drivers/dma/iop-adma.c:					handler[i], 0, pdev->name, iop_chan);
drivers/dma/iop-adma.c:		dev_dbg(&pdev->dev, "memcpy self test returned %d\n", ret);
drivers/dma/iop-adma.c:		dev_dbg(&pdev->dev, "xor self test returned %d\n", ret);
drivers/dma/iop-adma.c:		dev_dbg(&pdev->dev, "pq self test returned %d\n", ret);
drivers/dma/iop-adma.c:	dev_info(&pdev->dev, "Intel(R) IOP: ( %s%s%s%s%s%s%s)\n",
drivers/dma/iop-adma.c:	dma_free_coherent(&adev->pdev->dev, plat_data->pool_size,
drivers/dma/mxs-dma.c:	struct device_node *np = pdev->dev.of_node;
drivers/dma/mxs-dma.c:	mxs_dma = devm_kzalloc(&pdev->dev, sizeof(*mxs_dma), GFP_KERNEL);
drivers/dma/mxs-dma.c:		dev_err(&pdev->dev, "failed to read dma-channels\n");
drivers/dma/mxs-dma.c:	of_id = of_match_device(mxs_dma_dt_ids, &pdev->dev);
drivers/dma/mxs-dma.c:	mxs_dma->base = devm_ioremap_resource(&pdev->dev, iores);
drivers/dma/mxs-dma.c:	mxs_dma->clk = devm_clk_get(&pdev->dev, NULL);
drivers/dma/mxs-dma.c:	mxs_dma->dma_device.dev = &pdev->dev;
drivers/dma/edma.c:	ecc = devm_kzalloc(&pdev->dev, sizeof(*ecc), GFP_KERNEL);
drivers/dma/edma.c:		dev_err(&pdev->dev, "Can't allocate controller\n");
drivers/dma/edma.c:	ecc->ctlr = pdev->id;
drivers/dma/edma.c:		dev_err(&pdev->dev, "Can't allocate PaRAM dummy slot\n");
drivers/dma/edma.c:	edma_dma_init(ecc, &ecc->dma_slave, &pdev->dev);
drivers/dma/edma.c:	dev_info(&pdev->dev, "TI EDMA DMA engine driver\n");
drivers/dma/edma.c:	struct device *dev = &pdev->dev;
drivers/dma/mmp_pdma.c:	u32 dint = readl(pdev->base + DINT);
drivers/dma/mmp_pdma.c:		phy = &pdev->phy[i];
drivers/dma/mmp_pdma.c:	for (prio = 0; prio <= (((pdev->dma_channels - 1) & 0xf) >> 2); prio++) {
drivers/dma/mmp_pdma.c:		for (i = 0; i < pdev->dma_channels; i++) {
drivers/dma/mmp_pdma.c:			phy = &pdev->phy[i];
drivers/dma/mmp_pdma.c:	dma_async_device_unregister(&pdev->device);
drivers/dma/mmp_pdma.c:	struct mmp_pdma_phy *phy  = &pdev->phy[idx];
drivers/dma/mmp_pdma.c:	chan = devm_kzalloc(pdev->dev,
drivers/dma/mmp_pdma.c:	phy->base = pdev->base;
drivers/dma/mmp_pdma.c:		ret = devm_request_irq(pdev->dev, irq,
drivers/dma/mmp_pdma.c:			dev_err(pdev->dev, "channel request irq fail!\n");
drivers/dma/mmp_pdma.c:	chan->dev = pdev->dev;
drivers/dma/mmp_pdma.c:	chan->chan.device = &pdev->device;
drivers/dma/mmp_pdma.c:			&pdev->device.channels);
drivers/dma/mmp_pdma.c:	pdev->dev = &op->dev;
drivers/dma/mmp_pdma.c:	pdev->base = devm_ioremap_resource(pdev->dev, iores);
drivers/dma/mmp_pdma.c:	if (IS_ERR(pdev->base))
drivers/dma/mmp_pdma.c:		return PTR_ERR(pdev->base);
drivers/dma/mmp_pdma.c:	of_id = of_match_device(mmp_pdma_dt_ids, pdev->dev);
drivers/dma/mmp_pdma.c:		of_property_read_u32(pdev->dev->of_node,
drivers/dma/mmp_pdma.c:	pdev->dma_channels = dma_channels;
drivers/dma/mmp_pdma.c:	pdev->phy = devm_kzalloc(pdev->dev,
drivers/dma/mmp_pdma.c:	if (pdev->phy == NULL)
drivers/dma/mmp_pdma.c:	INIT_LIST_HEAD(&pdev->device.channels);
drivers/dma/mmp_pdma.c:		ret = devm_request_irq(pdev->dev, irq,
drivers/dma/mmp_pdma.c:	dma_cap_set(DMA_SLAVE, pdev->device.cap_mask);
drivers/dma/mmp_pdma.c:	dma_cap_set(DMA_MEMCPY, pdev->device.cap_mask);
drivers/dma/mmp_pdma.c:	dma_cap_set(DMA_SLAVE, pdev->device.cap_mask);
drivers/dma/mmp_pdma.c:	pdev->device.dev = &op->dev;
drivers/dma/mmp_pdma.c:	pdev->device.device_alloc_chan_resources = mmp_pdma_alloc_chan_resources;
drivers/dma/mmp_pdma.c:	pdev->device.device_free_chan_resources = mmp_pdma_free_chan_resources;
drivers/dma/mmp_pdma.c:	pdev->device.device_tx_status = mmp_pdma_tx_status;
drivers/dma/mmp_pdma.c:	pdev->device.device_prep_dma_memcpy = mmp_pdma_prep_memcpy;
drivers/dma/mmp_pdma.c:	pdev->device.device_prep_slave_sg = mmp_pdma_prep_slave_sg;
drivers/dma/mmp_pdma.c:	pdev->device.device_issue_pending = mmp_pdma_issue_pending;
drivers/dma/mmp_pdma.c:	pdev->device.device_control = mmp_pdma_control;
drivers/dma/mmp_pdma.c:	pdev->device.copy_align = PDMA_ALIGNMENT;
drivers/dma/mmp_pdma.c:	if (pdev->dev->coherent_dma_mask)
drivers/dma/mmp_pdma.c:		dma_set_mask(pdev->dev, pdev->dev->coherent_dma_mask);
drivers/dma/mmp_pdma.c:		dma_set_mask(pdev->dev, DMA_BIT_MASK(64));
drivers/dma/mmp_pdma.c:	ret = dma_async_device_register(&pdev->device);
drivers/dma/mmp_pdma.c:		dev_err(pdev->device.dev, "unable to register\n");
drivers/dma/mmp_pdma.c:	dev_info(pdev->device.dev, "initialized\n");
drivers/dma/txx9dmac.c:	struct txx9dmac_chan_platform_data *cpdata = pdev->dev.platform_data;
drivers/dma/txx9dmac.c:	int ch = pdev->id % TXX9_DMA_MAX_NR_CHANNELS;
drivers/dma/txx9dmac.c:	dc = devm_kzalloc(&pdev->dev, sizeof(*dc), GFP_KERNEL);
drivers/dma/txx9dmac.c:	dc->dma.dev = &pdev->dev;
drivers/dma/txx9dmac.c:		err = devm_request_irq(&pdev->dev, dc->irq,
drivers/dma/txx9dmac.c:			txx9dmac_chan_interrupt, 0, dev_name(&pdev->dev), dc);
drivers/dma/txx9dmac.c:	dev_dbg(&pdev->dev, "TXx9 DMA Channel (dma%d%s%s)\n",
drivers/dma/txx9dmac.c:	dc->ddev->chan[pdev->id % TXX9_DMA_MAX_NR_CHANNELS] = NULL;
drivers/dma/txx9dmac.c:	struct txx9dmac_platform_data *pdata = pdev->dev.platform_data;
drivers/dma/txx9dmac.c:	ddev = devm_kzalloc(&pdev->dev, sizeof(*ddev), GFP_KERNEL);
drivers/dma/txx9dmac.c:	if (!devm_request_mem_region(&pdev->dev, io->start, resource_size(io),
drivers/dma/txx9dmac.c:				     dev_name(&pdev->dev)))
drivers/dma/txx9dmac.c:	ddev->regs = devm_ioremap(&pdev->dev, io->start, resource_size(io));
drivers/dma/txx9dmac.c:		err = devm_request_irq(&pdev->dev, ddev->irq,
drivers/dma/txx9dmac.c:			txx9dmac_interrupt, 0, dev_name(&pdev->dev), ddev);
drivers/dma/txx9dmac.c:	struct txx9dmac_platform_data *pdata = pdev->dev.platform_data;
drivers/dma/coh901318.c:	if (devm_request_mem_region(&pdev->dev,
drivers/dma/coh901318.c:				    pdev->dev.driver->name) == NULL)
drivers/dma/coh901318.c:	base = devm_kzalloc(&pdev->dev,
drivers/dma/coh901318.c:	base->virtbase = devm_ioremap(&pdev->dev, io->start, resource_size(io));
drivers/dma/coh901318.c:	base->dev = &pdev->dev;
drivers/dma/coh901318.c:	err = devm_request_irq(&pdev->dev, irq, dma_irq_handler, IRQF_DISABLED,
drivers/dma/coh901318.c:	err = coh901318_pool_create(&base->pool, &pdev->dev,
drivers/dma/coh901318.c:	base->dma_slave.dev = &pdev->dev;
drivers/dma/coh901318.c:	base->dma_memcpy.dev = &pdev->dev;
drivers/dma/coh901318.c:	dev_info(&pdev->dev, "Initialized COH901318 DMA on virtual base 0x%08x\n",
drivers/dma/mmp_tdma.c:	of_id = of_match_device(mmp_tdma_dt_ids, &pdev->dev);
drivers/dma/mmp_tdma.c:	tdev = devm_kzalloc(&pdev->dev, sizeof(*tdev), GFP_KERNEL);
drivers/dma/mmp_tdma.c:	tdev->dev = &pdev->dev;
drivers/dma/mmp_tdma.c:	tdev->base = devm_ioremap_resource(&pdev->dev, iores);
drivers/dma/mmp_tdma.c:		ret = devm_request_irq(&pdev->dev, irq,
drivers/dma/mmp_tdma.c:	tdev->device.dev = &pdev->dev;
drivers/dma/mmp_tdma.c:	dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));
drivers/dma/imx-sdma.c:			of_match_device(sdma_dt_ids, &pdev->dev);
drivers/dma/imx-sdma.c:	struct device_node *np = pdev->dev.of_node;
drivers/dma/imx-sdma.c:	struct sdma_platform_data *pdata = pdev->dev.platform_data;
drivers/dma/imx-sdma.c:	sdma->dev = &pdev->dev;
drivers/dma/imx-sdma.c:	if (!request_mem_region(iores->start, resource_size(iores), pdev->name)) {
drivers/dma/imx-sdma.c:	sdma->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
drivers/dma/imx-sdma.c:	sdma->clk_ahb = devm_clk_get(&pdev->dev, "ahb");
drivers/dma/imx-sdma.c:		pdev->id_entry = of_id->data;
drivers/dma/imx-sdma.c:	sdma->devtype = pdev->id_entry->driver_data;
drivers/dma/imx-sdma.c:			dev_warn(&pdev->dev, "failed to get firmware from platform data\n");
drivers/dma/imx-sdma.c:			dev_warn(&pdev->dev, "failed to get firmware name\n");
drivers/dma/imx-sdma.c:				dev_warn(&pdev->dev, "failed to get firmware from device tree\n");
drivers/dma/imx-sdma.c:	sdma->dma_device.dev = &pdev->dev;
drivers/dma/imx-sdma.c:		dev_err(&pdev->dev, "unable to register\n");
drivers/dma/ipu/ipu_idmac.c:	ipu_data.dev = &pdev->dev;
drivers/dma/ipu/ipu_idmac.c:	dev_dbg(&pdev->dev, "fn irq %u, err irq %u\n",
drivers/dma/ipu/ipu_idmac.c:	ipu_data.ipu_clk = clk_get(&pdev->dev, NULL);
drivers/dma/ipu/ipu_idmac.c:	dev_dbg(&pdev->dev, "%s @ 0x%08lx, fn irq %u, err irq %u\n", pdev->name,
drivers/dma/ipu/ipu_idmac.c:	ipu_data.dev = &pdev->dev;
drivers/dma/ipu/ipu_idmac.c:	dev_err(&pdev->dev, "Failed to probe IPU: %d\n", ret);
drivers/dma/timb_dma.c:	struct timb_dma_platform_data *pdata = pdev->dev.platform_data;
drivers/dma/timb_dma.c:		dev_err(&pdev->dev, "No platform data\n");
drivers/dma/timb_dma.c:	dev_dbg(&pdev->dev, "Allocated TD: %p\n", td);
drivers/dma/timb_dma.c:		dev_err(&pdev->dev, "Failed to remap I/O memory\n");
drivers/dma/timb_dma.c:		dev_err(&pdev->dev, "Failed to request IRQ\n");
drivers/dma/timb_dma.c:	td->dma.dev = &pdev->dev;
drivers/dma/timb_dma.c:			dev_err(&pdev->dev, "Wrong channel configuration\n");
drivers/dma/timb_dma.c:		dev_dbg(&pdev->dev, "Chan: %d, membase: %p\n",
drivers/dma/timb_dma.c:		dev_err(&pdev->dev, "Failed to register async device\n");
drivers/dma/timb_dma.c:	dev_dbg(&pdev->dev, "Probe result: %d\n", err);
drivers/dma/timb_dma.c:	dev_dbg(&pdev->dev, "Removed...\n");
drivers/dma/omap-dma.c:	od->ddev.dev = &pdev->dev;
drivers/dma/omap-dma.c:	if (pdev->dev.of_node) {
drivers/dma/omap-dma.c:		rc = of_dma_controller_register(pdev->dev.of_node,
drivers/dma/omap-dma.c:	dev_info(&pdev->dev, "OMAP DMA engine driver\n");
drivers/dma/omap-dma.c:	if (pdev->dev.of_node)
drivers/dma/omap-dma.c:		of_dma_controller_free(pdev->dev.of_node);
drivers/dma/dw_dmac.c:	struct device_node *np = pdev->dev.of_node;
drivers/dma/dw_dmac.c:		dev_err(&pdev->dev, "Missing DT data\n");
drivers/dma/dw_dmac.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/dma/dw_dmac.c:	regs = devm_ioremap_resource(&pdev->dev, io);
drivers/dma/dw_dmac.c:	if (!pdev->dev.dma_mask) {
drivers/dma/dw_dmac.c:		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
drivers/dma/dw_dmac.c:		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
drivers/dma/dw_dmac.c:	dev_dbg(&pdev->dev, "DW_PARAMS: 0x%08x\n", dw_params);
drivers/dma/dw_dmac.c:	pdata = dev_get_platdata(&pdev->dev);
drivers/dma/dw_dmac.c:		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
drivers/dma/dw_dmac.c:	dw = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
drivers/dma/dw_dmac.c:	dw->clk = devm_clk_get(&pdev->dev, "hclk");
drivers/dma/dw_dmac.c:	err = devm_request_irq(&pdev->dev, irq, dw_dma_interrupt, 0,
drivers/dma/dw_dmac.c:	dw->desc_pool = dmam_pool_create("dw_dmac_desc_pool", &pdev->dev,
drivers/dma/dw_dmac.c:		dev_err(&pdev->dev, "No memory for descriptors dma pool\n");
drivers/dma/dw_dmac.c:			dev_dbg(&pdev->dev, "DWC_PARAMS[%d]: 0x%08x\n", i,
drivers/dma/dw_dmac.c:	dw->dma.dev = &pdev->dev;
drivers/dma/dw_dmac.c:	dev_info(&pdev->dev, "DesignWare DMA Controller, %d channels\n",
drivers/dma/dw_dmac.c:	if (pdev->dev.of_node) {
drivers/dma/dw_dmac.c:		err = of_dma_controller_register(pdev->dev.of_node,
drivers/dma/dw_dmac.c:			dev_err(&pdev->dev,
drivers/dma/dw_dmac.c:	if (ACPI_HANDLE(&pdev->dev))
drivers/dma/dw_dmac.c:	if (pdev->dev.of_node)
drivers/dma/dw_dmac.c:		of_dma_controller_free(pdev->dev.of_node);
drivers/dma/mv_xor.c:	mv_chan = devm_kzalloc(&pdev->dev, sizeof(*mv_chan), GFP_KERNEL);
drivers/dma/mv_xor.c:	  dma_alloc_writecombine(&pdev->dev, MV_XOR_POOL_SIZE,
drivers/dma/mv_xor.c:	dma_dev->dev = &pdev->dev;
drivers/dma/mv_xor.c:			  0, dev_name(&pdev->dev), mv_chan);
drivers/dma/mv_xor.c:		dev_dbg(&pdev->dev, "memcpy self test returned %d\n", ret);
drivers/dma/mv_xor.c:		dev_dbg(&pdev->dev, "xor self test returned %d\n", ret);
drivers/dma/mv_xor.c:	dev_info(&pdev->dev, "Marvell XOR: ( %s%s%s%s)\n",
drivers/dma/mv_xor.c:	dma_free_coherent(&pdev->dev, MV_XOR_POOL_SIZE,
drivers/dma/mv_xor.c:	struct mv_xor_platform_data *pdata = pdev->dev.platform_data;
drivers/dma/mv_xor.c:	dev_notice(&pdev->dev, "Marvell shared XOR driver\n");
drivers/dma/mv_xor.c:	xordev = devm_kzalloc(&pdev->dev, sizeof(*xordev), GFP_KERNEL);
drivers/dma/mv_xor.c:	xordev->xor_base = devm_ioremap(&pdev->dev, res->start,
drivers/dma/mv_xor.c:	xordev->xor_high_base = devm_ioremap(&pdev->dev, res->start,
drivers/dma/mv_xor.c:	xordev->clk = clk_get(&pdev->dev, NULL);
drivers/dma/mv_xor.c:	if (pdev->dev.of_node) {
drivers/dma/mv_xor.c:		for_each_child_of_node(pdev->dev.of_node, np) {
drivers/dma/mv_xor.c:			if (pdev->dev.of_node)
drivers/dma/sa11x0-dma.c:	return request_irq(irq, sa11x0_dma_irq, 0, dev_name(&pdev->dev), data);
drivers/dma/sa11x0-dma.c:	ret = sa11x0_dma_init_dmadev(&d->slave, &pdev->dev);
drivers/dma/at_hdmac.c:	atslave = devm_kzalloc(&dmac_pdev->dev, sizeof(*atslave), GFP_KERNEL);
drivers/dma/at_hdmac.c:	atslave->dma_dev = &dmac_pdev->dev;
drivers/dma/at_hdmac.c:	if (pdev->dev.of_node) {
drivers/dma/at_hdmac.c:		match = of_match_node(atmel_dma_dt_ids, pdev->dev.of_node);
drivers/dma/at_hdmac.c:	if (!request_mem_region(io->start, size, pdev->dev.driver->name)) {
drivers/dma/at_hdmac.c:	atdma->clk = clk_get(&pdev->dev, "dma_clk");
drivers/dma/at_hdmac.c:			&pdev->dev, sizeof(struct at_desc),
drivers/dma/at_hdmac.c:		dev_err(&pdev->dev, "No memory for descriptors dma pool\n");
drivers/dma/at_hdmac.c:	atdma->dma_common.dev = &pdev->dev;
drivers/dma/at_hdmac.c:	dev_info(&pdev->dev, "Atmel AHB DMA Controller ( %s%s), %d channels\n",
drivers/dma/at_hdmac.c:	if (pdev->dev.of_node) {
drivers/dma/at_hdmac.c:		err = of_dma_controller_register(pdev->dev.of_node,
drivers/dma/at_hdmac.c:			dev_err(&pdev->dev, "could not register of_dma_controller\n");
drivers/dma/ep93xx_dma.c:	struct ep93xx_dma_platform_data *pdata = dev_get_platdata(&pdev->dev);
drivers/dma/ep93xx_dma.c:			dev_warn(&pdev->dev, "failed to get clock for %s\n",
drivers/dma/ep93xx_dma.c:	dma_dev->dev = &pdev->dev;
drivers/dma/sh/sudmac.c:	sc = devm_kzalloc(&pdev->dev, sizeof(struct sudmac_chan), GFP_KERNEL);
drivers/dma/sh/sudmac.c:	if (pdev->id >= 0)
drivers/dma/sh/sudmac.c:			 pdev->id, id);
drivers/dma/sh/sudmac.c:	struct sudmac_pdata *pdata = pdev->dev.platform_data;
drivers/dma/sh/sudmac.c:	su_dev = devm_kzalloc(&pdev->dev, sizeof(struct sudmac_device),
drivers/dma/sh/sudmac.c:		dev_err(&pdev->dev, "Not enough memory\n");
drivers/dma/sh/sudmac.c:	su_dev->chan_reg = devm_request_and_ioremap(&pdev->dev, chan);
drivers/dma/sh/sudmac.c:	err = shdma_init(&pdev->dev, &su_dev->shdma_dev, pdata->channel_num);
drivers/dma/sh/sudmac.c:	su_dev->pdata = pdev->dev.platform_data;
drivers/dma/sh/shdma.c:	if (pdev->id >= 0)
drivers/dma/sh/shdma.c:			 "sh-dmae%d.%d", pdev->id, id);
drivers/dma/sh/shdma.c:	struct sh_dmae_pdata *pdata = pdev->dev.platform_data;
drivers/dma/sh/shdma.c:	if (!request_mem_region(chan->start, resource_size(chan), pdev->name)) {
drivers/dma/sh/shdma.c:		dev_err(&pdev->dev, "DMAC register region already claimed\n");
drivers/dma/sh/shdma.c:	if (dmars && !request_mem_region(dmars->start, resource_size(dmars), pdev->name)) {
drivers/dma/sh/shdma.c:		dev_err(&pdev->dev, "DMAC DMARS region already claimed\n");
drivers/dma/sh/shdma.c:		dev_err(&pdev->dev, "Not enough memory\n");
drivers/dma/sh/shdma.c:	err = shdma_init(&pdev->dev, &shdev->shdma_dev,
drivers/dma/sh/shdma.c:	shdev->pdata = pdev->dev.platform_data;
drivers/dma/sh/shdma.c:	pm_runtime_enable(&pdev->dev);
drivers/dma/sh/shdma.c:	err = pm_runtime_get_sync(&pdev->dev);
drivers/dma/sh/shdma.c:		dev_err(&pdev->dev, "%s(): GET = %d\n", __func__, err);
drivers/dma/sh/shdma.c:		dev_err(&pdev->dev,
drivers/dma/sh/shdma.c:				dev_dbg(&pdev->dev,
drivers/dma/sh/shdma.c:		dev_notice(&pdev->dev, "Attempting to register %d DMA "
drivers/dma/sh/shdma.c:	pm_runtime_put(&pdev->dev);
drivers/dma/sh/shdma.c:	pm_runtime_get(&pdev->dev);
drivers/dma/sh/shdma.c:	pm_runtime_put(&pdev->dev);
drivers/dma/sh/shdma.c:	pm_runtime_disable(&pdev->dev);
drivers/dma/sh/shdma.c:	pm_runtime_disable(&pdev->dev);
drivers/dma/pch_dma.c:		dev_dbg(&pdev->dev, "failed to enable device\n");
drivers/dma/pch_dma.c:		dev_err(&pdev->dev, "Cannot enable PCI device\n");
drivers/dma/pch_dma.c:		dev_err(&pdev->dev, "Cannot find proper base address\n");
drivers/dma/pch_dma.c:		dev_err(&pdev->dev, "Cannot obtain PCI resources\n");
drivers/dma/pch_dma.c:		dev_err(&pdev->dev, "Cannot set proper DMA config\n");
drivers/dma/pch_dma.c:		dev_err(&pdev->dev, "Cannot map MMIO registers\n");
drivers/dma/pch_dma.c:	err = request_irq(pdev->irq, pd_irq, IRQF_SHARED, DRV_NAME, pd);
drivers/dma/pch_dma.c:		dev_err(&pdev->dev, "Failed to request IRQ\n");
drivers/dma/pch_dma.c:		dev_err(&pdev->dev, "Failed to alloc DMA descriptors\n");
drivers/dma/pch_dma.c:	pd->dma.dev = &pdev->dev;
drivers/dma/pch_dma.c:		dev_err(&pdev->dev, "Failed to register DMA device\n");
drivers/dma/pch_dma.c:	free_irq(pdev->irq, pd);
drivers/dma/pch_dma.c:		free_irq(pdev->irq, pd);
drivers/dma/imx-dma.c:	imxdma = devm_kzalloc(&pdev->dev, sizeof(*imxdma), GFP_KERNEL);
drivers/dma/imx-dma.c:	imxdma->devtype = pdev->id_entry->driver_data;
drivers/dma/imx-dma.c:	imxdma->base = devm_ioremap_resource(&pdev->dev, res);
drivers/dma/imx-dma.c:	imxdma->dma_ipg = devm_clk_get(&pdev->dev, "ipg");
drivers/dma/imx-dma.c:	imxdma->dma_ahb = devm_clk_get(&pdev->dev, "ahb");
drivers/dma/imx-dma.c:		ret = devm_request_irq(&pdev->dev, irq,
drivers/dma/imx-dma.c:		ret = devm_request_irq(&pdev->dev, irq_err,
drivers/dma/imx-dma.c:			ret = devm_request_irq(&pdev->dev, irq + i,
drivers/dma/imx-dma.c:	imxdma->dev = &pdev->dev;
drivers/dma/imx-dma.c:	imxdma->dma_device.dev = &pdev->dev;
drivers/dma/imx-dma.c:		dev_err(&pdev->dev, "unable to register\n");
drivers/dma/tegra20-apb-dma.c:	match = of_match_device(tegra_dma_of_match, &pdev->dev);
drivers/dma/tegra20-apb-dma.c:		dev_err(&pdev->dev, "Error: No device match found\n");
drivers/dma/tegra20-apb-dma.c:	tdma = devm_kzalloc(&pdev->dev, sizeof(*tdma) + cdata->nr_channels *
drivers/dma/tegra20-apb-dma.c:		dev_err(&pdev->dev, "Error: memory allocation failed\n");
drivers/dma/tegra20-apb-dma.c:	tdma->dev = &pdev->dev;
drivers/dma/tegra20-apb-dma.c:	tdma->base_addr = devm_ioremap_resource(&pdev->dev, res);
drivers/dma/tegra20-apb-dma.c:	tdma->dma_clk = devm_clk_get(&pdev->dev, NULL);
drivers/dma/tegra20-apb-dma.c:		dev_err(&pdev->dev, "Error: Missing controller clock\n");
drivers/dma/tegra20-apb-dma.c:	pm_runtime_enable(&pdev->dev);
drivers/dma/tegra20-apb-dma.c:	if (!pm_runtime_enabled(&pdev->dev)) {
drivers/dma/tegra20-apb-dma.c:		ret = tegra_dma_runtime_resume(&pdev->dev);
drivers/dma/tegra20-apb-dma.c:			dev_err(&pdev->dev, "dma_runtime_resume failed %d\n",
drivers/dma/tegra20-apb-dma.c:		dev_err(&pdev->dev, "clk_prepare_enable failed: %d\n", ret);
drivers/dma/tegra20-apb-dma.c:			dev_err(&pdev->dev, "No irq resource for chan %d\n", i);
drivers/dma/tegra20-apb-dma.c:		ret = devm_request_irq(&pdev->dev, tdc->irq,
drivers/dma/tegra20-apb-dma.c:			dev_err(&pdev->dev,
drivers/dma/tegra20-apb-dma.c:	tdma->dma_dev.dev = &pdev->dev;
drivers/dma/tegra20-apb-dma.c:		dev_err(&pdev->dev,
drivers/dma/tegra20-apb-dma.c:	dev_info(&pdev->dev, "Tegra20 APB DMA driver register %d channels\n",
drivers/dma/tegra20-apb-dma.c:	pm_runtime_disable(&pdev->dev);
drivers/dma/tegra20-apb-dma.c:	if (!pm_runtime_status_suspended(&pdev->dev))
drivers/dma/tegra20-apb-dma.c:		tegra_dma_runtime_suspend(&pdev->dev);
drivers/dma/tegra20-apb-dma.c:	pm_runtime_disable(&pdev->dev);
drivers/dma/tegra20-apb-dma.c:	if (!pm_runtime_status_suspended(&pdev->dev))
drivers/dma/tegra20-apb-dma.c:		tegra_dma_runtime_suspend(&pdev->dev);
drivers/dma/intel_mid_dma.c:	pm_runtime_put(&mid->pdev->dev);
drivers/dma/intel_mid_dma.c:	pm_runtime_get_sync(&mid->pdev->dev);
drivers/dma/intel_mid_dma.c:		if (dma_resume(&mid->pdev->dev)) {
drivers/dma/intel_mid_dma.c:		pm_runtime_put(&mid->pdev->dev);
drivers/dma/intel_mid_dma.c:			pm_runtime_put(&mid->pdev->dev);
drivers/dma/intel_mid_dma.c:	dma->pci_id = pdev->device;
drivers/dma/intel_mid_dma.c:	dma->common.dev = &pdev->dev;
drivers/dma/intel_mid_dma.c:		err = request_irq(pdev->irq, intel_mid_dma_interrupt1,
drivers/dma/intel_mid_dma.c:		err = request_irq(pdev->irq, intel_mid_dma_interrupt2,
drivers/dma/intel_mid_dma.c:	free_irq(pdev->irq, dma);
drivers/dma/intel_mid_dma.c:	free_irq(pdev->irq, device);
drivers/dma/intel_mid_dma.c:	pr_debug("MDMA: probe for %x\n", pdev->device);
drivers/dma/intel_mid_dma.c:	pm_runtime_put_noidle(&pdev->dev);
drivers/dma/intel_mid_dma.c:	pm_runtime_allow(&pdev->dev);
drivers/dma/intel_mid_dma.c:	pm_runtime_get_noresume(&pdev->dev);
drivers/dma/intel_mid_dma.c:	pm_runtime_forbid(&pdev->dev);
drivers/dma/ste_dma40.c:	clk = clk_get(&pdev->dev, NULL);
drivers/dma/ste_dma40.c:		d40_err(&pdev->dev, "No matching clock found\n");
drivers/dma/ste_dma40.c:		d40_err(&pdev->dev, "Failed to prepare/enable clock\n");
drivers/dma/ste_dma40.c:		d40_err(&pdev->dev, "Unknown hardware! No PrimeCell ID\n");
drivers/dma/ste_dma40.c:		d40_err(&pdev->dev, "Unknown designer! Got %x wanted %x\n",
drivers/dma/ste_dma40.c:	plat_data = pdev->dev.platform_data;
drivers/dma/ste_dma40.c:	dev_info(&pdev->dev, "hardware revision: %d @ 0x%x with %d physical channels\n",
drivers/dma/ste_dma40.c:		d40_err(&pdev->dev, "hardware revision: %d is not supported",
drivers/dma/ste_dma40.c:		d40_err(&pdev->dev, "Out of memory\n");
drivers/dma/ste_dma40.c:	base->dev = &pdev->dev;
drivers/dma/ste_dma40.c:		d40_err(&pdev->dev, "No \"lcpa\" memory resource\n");
drivers/dma/ste_dma40.c:		d40_err(&pdev->dev,
drivers/dma/ste_dma40.c:		dev_warn(&pdev->dev,
drivers/dma/ste_dma40.c:		d40_err(&pdev->dev, "Failed to ioremap LCPA region\n");
drivers/dma/ste_dma40.c:			d40_err(&pdev->dev,
drivers/dma/ste_dma40.c:			d40_err(&pdev->dev, "Failed to ioremap LCLA region\n");
drivers/dma/ste_dma40.c:			d40_err(&pdev->dev, "Failed to allocate LCLA area\n");
drivers/dma/ste_dma40.c:		d40_err(&pdev->dev, "No IRQ defined\n");
drivers/dma/ste_dma40.c:			d40_err(&pdev->dev, "Failed to get lcpa_regulator\n");
drivers/dma/ste_dma40.c:			d40_err(&pdev->dev,
drivers/dma/ste_dma40.c:		d40_err(&pdev->dev, "Failed to set dma max seg size\n");
drivers/dma/ste_dma40.c:	d40_err(&pdev->dev, "probe failed\n");
drivers/dma/ioat/dma.c:	struct device *dev = &device->pdev->dev;
drivers/dma/ioat/dma.c:		synchronize_irq(pdev->irq);
drivers/dma/ioat/dma.c:	struct device *dev = &device->pdev->dev;
drivers/dma/ioat/dma.c:	struct device *dev = &pdev->dev;
drivers/dma/ioat/dma.c:	err = devm_request_irq(dev, pdev->irq, ioat_dma_do_interrupt, 0,
drivers/dma/ioat/dma.c:	err = devm_request_irq(dev, pdev->irq, ioat_dma_do_interrupt,
drivers/dma/ioat/dma.c:	struct device *dev = &pdev->dev;
drivers/dma/ioat/dma.c:	dma->dev = &pdev->dev;
drivers/dma/ioat/dma.c:	if (pdev->msi_enabled)
drivers/dma/ioat/dma_v2.c:	struct device *dev = &device->pdev->dev;
drivers/dma/ioat/pci.c:	struct device *dev = &pdev->dev;
drivers/dma/ioat/pci.c:	struct device *dev = &pdev->dev;
drivers/dma/ioat/pci.c:	dev_err(&pdev->dev, "Removing dma and dca services\n");
drivers/dma/ioat/pci.c:		unregister_dca_provider(device->dca, &pdev->dev);
drivers/dma/ioat/dma.h:#define to_dev(ioat_chan) (&(ioat_chan)->device->pdev->dev)
drivers/dma/ioat/dca.c:		dev_dbg(&pdev->dev, "DCA is disabled in BIOS\n");
drivers/dma/ioat/dca.c:	dev_dbg(&pdev->dev, "boot cpu doesn't have X86_FEATURE_DCA\n");
drivers/dma/ioat/dca.c:	switch (pdev->vendor) {
drivers/dma/ioat/dca.c:		switch (pdev->device) {
drivers/dma/ioat/dca.c:		switch (pdev->device) {
drivers/dma/ioat/dca.c:	err = register_dca_provider(dca, &pdev->dev);
drivers/dma/ioat/dca.c:				dev_driver_string(&pdev->dev),
drivers/dma/ioat/dca.c:				dev_name(&pdev->dev));
drivers/dma/ioat/dca.c:	err = register_dca_provider(dca, &pdev->dev);
drivers/dma/ioat/dca.c:				dev_driver_string(&pdev->dev),
drivers/dma/ioat/dca.c:				dev_name(&pdev->dev));
drivers/dma/ioat/dca.c:	err = register_dca_provider(dca, &pdev->dev);
drivers/dma/ioat/dma_v3.c:	switch (pdev->device) {
drivers/dma/ioat/dma_v3.c:	switch (pdev->device) {
drivers/dma/ioat/dma_v3.c:	switch (pdev->device) {
drivers/dma/ioat/dma_v3.c:	switch (pdev->device) {
drivers/dma/ioat/dma_v3.c:	switch (pdev->device) {
drivers/dma/ioat/dma_v3.c:	switch (pdev->device) {
drivers/dma/ioat/dma_v3.c:		dev_err(&pdev->dev, "%s: unknown op type: %#x\n",
drivers/dma/ioat/dma_v3.c:	struct device *dev = &device->pdev->dev;
drivers/dma/ioat/dma_v3.c:			devm_free_irq(&pdev->dev, msix->vector, chan);
drivers/dma/ioat/dma_v3.c:		devm_free_irq(&pdev->dev, msix->vector, chan);
drivers/dma/ioat/dma_v3.c:		devm_free_irq(&pdev->dev, pdev->irq, chan);
drivers/dma/ioat/dma_v3.c:		devm_free_irq(&pdev->dev, pdev->irq, chan);
drivers/dma/ioat/dma_v3.c:			dev_err(&pdev->dev,
drivers/dma/ioat/dma_v3.c:		dev_err(&pdev->dev, "Failed to reset!\n");
drivers/dma/ioat/dma_v3.c:					&pdev->dev,
drivers/misc/ep93xx_pwm.c:	res = request_mem_region(res->start, resource_size(res), pdev->name);
drivers/misc/ep93xx_pwm.c:	err = sysfs_create_group(&pdev->dev.kobj, &ep93xx_pwm_sysfs_files);
drivers/misc/ep93xx_pwm.c:	pwm->clk = clk_get(&pdev->dev, "pwm_clk");
drivers/misc/ep93xx_pwm.c:	sysfs_remove_group(&pdev->dev.kobj, &ep93xx_pwm_sysfs_files);
drivers/misc/ep93xx_pwm.c:	sysfs_remove_group(&pdev->dev.kobj, &ep93xx_pwm_sysfs_files);
drivers/misc/pch_phub.c:	dev_dbg(&pdev->dev, "%s : "
drivers/misc/pch_phub.c:		dev_dbg(&pdev->dev, "%s : "
drivers/misc/pch_phub.c:	dev_dbg(&pdev->dev, "%s : "
drivers/misc/pch_phub.c:		dev_dbg(&pdev->dev, "%s : "
drivers/misc/pch_phub.c:		dev_err(&pdev->dev,
drivers/misc/pch_phub.c:	dev_dbg(&pdev->dev, "%s : pci_enable_device returns %d\n", __func__,
drivers/misc/pch_phub.c:		dev_err(&pdev->dev,
drivers/misc/pch_phub.c:	dev_dbg(&pdev->dev, "%s : "
drivers/misc/pch_phub.c:		dev_err(&pdev->dev, "%s : pci_iomap FAILED", __func__);
drivers/misc/pch_phub.c:	dev_dbg(&pdev->dev, "%s : pci_iomap SUCCESS and value "
drivers/misc/pch_phub.c:		retval = sysfs_create_file(&pdev->dev.kobj,
drivers/misc/pch_phub.c:		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pch_bin_attr);
drivers/misc/pch_phub.c:		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pch_bin_attr);
drivers/misc/pch_phub.c:		retval = sysfs_create_file(&pdev->dev.kobj,
drivers/misc/pch_phub.c:		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pch_bin_attr);
drivers/misc/pch_phub.c:		retval = sysfs_create_file(&pdev->dev.kobj,
drivers/misc/pch_phub.c:		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pch_bin_attr);
drivers/misc/pch_phub.c:	sysfs_remove_file(&pdev->dev.kobj, &dev_attr_pch_mac.attr);
drivers/misc/pch_phub.c:	dev_err(&pdev->dev, "%s returns %d\n", __func__, ret);
drivers/misc/pch_phub.c:	sysfs_remove_file(&pdev->dev.kobj, &dev_attr_pch_mac.attr);
drivers/misc/pch_phub.c:	sysfs_remove_bin_file(&pdev->dev.kobj, &pch_bin_attr);
drivers/misc/pch_phub.c:		dev_err(&pdev->dev,
drivers/misc/pch_phub.c:		dev_err(&pdev->dev,
drivers/misc/pti.c: * @pdev- pci_dev struct values for pti.
drivers/misc/pti.c:	dev_dbg(&pdev->dev, "%s %s(%d): PTI PCI ID %04x:%04x\n", __FILE__,
drivers/misc/pti.c:			__func__, __LINE__, pdev->vendor, pdev->device);
drivers/misc/pti.c:		dev_err(&pdev->dev,
drivers/misc/pti.c:		dev_err(&pdev->dev,
drivers/misc/pti.c:	retval = pci_request_region(pdev, pci_bar, dev_name(&pdev->dev));
drivers/misc/pti.c:		dev_err(&pdev->dev,
drivers/misc/pti.c:		tty_port_register_device(port, pti_tty_driver, a, &pdev->dev);
drivers/misc/mei/init.c:	dev_dbg(&dev->pdev->dev, "reset in start the mei device.\n");
drivers/misc/mei/init.c:		dev_err(&dev->pdev->dev, "HBM haven't started");
drivers/misc/mei/init.c:		dev_err(&dev->pdev->dev, "host is not ready.\n");
drivers/misc/mei/init.c:		dev_err(&dev->pdev->dev, "ME is not ready.\n");
drivers/misc/mei/init.c:		dev_dbg(&dev->pdev->dev, "MEI start failed.\n");
drivers/misc/mei/init.c:	dev_dbg(&dev->pdev->dev, "link layer has been established.\n");
drivers/misc/mei/init.c:	dev_err(&dev->pdev->dev, "link layer initialization failed.\n");
drivers/misc/mei/init.c:		dev_dbg(&dev->pdev->dev, "remove iamthif and wd from the file list.\n");
drivers/misc/mei/init.c:		dev_warn(&dev->pdev->dev, "unexpected reset: dev_state = %s\n",
drivers/misc/mei/init.c:		dev_dbg(&dev->pdev->dev, "intr not enabled end of reset\n");
drivers/misc/mei/init.c:	dev_dbg(&dev->pdev->dev, "link is established start sending messages.\n");
drivers/misc/mei/init.c:	dev_dbg(&dev->pdev->dev, "stopping the device.\n");
drivers/misc/mei/client.c:	dev_dbg(&cl->dev->pdev->dev, "remove list entry belonging to cl\n");
drivers/misc/mei/client.c:		dev_err(&dev->pdev->dev, "id exceded %d", MEI_CLIENTS_MAX) ;
drivers/misc/mei/client.c:	dev_dbg(&dev->pdev->dev, "link cl host id = %d\n", cl->host_client_id);
drivers/misc/mei/client.c:			dev_dbg(&dev->pdev->dev, "remove host client = %d, ME client = %d\n",
drivers/misc/mei/client.c:			dev_err(&dev->pdev->dev, "failed to disconnect.\n");
drivers/misc/mei/client.c:		dev_dbg(&dev->pdev->dev, "add disconnect cb to control write list\n");
drivers/misc/mei/client.c:		dev_dbg(&dev->pdev->dev, "successfully disconnected from FW client.\n");
drivers/misc/mei/client.c:			dev_dbg(&dev->pdev->dev, "wrong status client disconnect.\n");
drivers/misc/mei/client.c:			dev_dbg(&dev->pdev->dev,
drivers/misc/mei/client.c:		dev_dbg(&dev->pdev->dev, "failed to disconnect from FW client.\n");
drivers/misc/mei/client.c:		dev_dbg(&dev->pdev->dev, "read is pending.\n");
drivers/misc/mei/client.c:		dev_err(&dev->pdev->dev, "no such me client %d\n",
drivers/misc/mei/client.c:	dev_dbg(&dev->pdev->dev, "mei_cl_write %d\n", buf->size);
drivers/misc/mei/client.c:	dev_dbg(&dev->pdev->dev, "write " MEI_HDR_FMT "\n",
drivers/misc/mei/client.c:			dev_dbg(&dev->pdev->dev, "Waking up client!\n");
drivers/misc/mei/amthif.c:		dev_info(&dev->pdev->dev, "amthif: failed to find the client\n");
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "IAMTHIF_MTU = %d\n",
drivers/misc/mei/amthif.c:		dev_err(&dev->pdev->dev, "amthif: memory allocation for ME message buffer failed.\n");
drivers/misc/mei/amthif.c:		dev_err(&dev->pdev->dev, "amthif: failed link client\n");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "amthif: Failed to connect to ME client\n");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "bad file ext.\n");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "amthif client not found.\n");
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "checking amthif data\n");
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "waiting for amthif data\n");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "woke up from sleep\n");
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "Got amthif data\n");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "amthif timeout = %lud\n",
drivers/misc/mei/amthif.c:			dev_dbg(&dev->pdev->dev, "amthif Time out\n");
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "amthif cb->response_buffer size - %d\n",
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "amthif cb->buf_idx - %lu\n", cb->buf_idx);
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "free amthif cb memory.\n");
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "write data to amthif client.\n");
drivers/misc/mei/amthif.c:			dev_dbg(&dev->pdev->dev, "add amthif cb to write waiting list\n");
drivers/misc/mei/amthif.c:			dev_dbg(&dev->pdev->dev, "message does not complete, so add amthif cb to write list.\n");
drivers/misc/mei/amthif.c:			dev_dbg(&dev->pdev->dev, "host buffer is not empty");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "No flow control credentials, so add iamthif cb to write list.\n");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev,
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "AMTHIF: add cb to the wait list\n");
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "complete amthif cmd_list cb.\n");
drivers/misc/mei/amthif.c:				dev_dbg(&dev->pdev->dev,
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "run next amthif cb\n");
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, MEI_HDR_FMT,  MEI_HDR_PRM(&mei_hdr));
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "amthif_message_buffer_index =%d\n",
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "completed amthif read.\n ");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "complete the amthif read cb.\n ");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "add the amthif read cb to complete.\n ");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "iamthif flow control failed\n");
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "iamthif flow control success\n");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "amthif read completed\n");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "dev->iamthif_timer = %ld\n",
drivers/misc/mei/amthif.c:	dev_dbg(&dev->pdev->dev, "completing amthif call back.\n");
drivers/misc/mei/amthif.c:		dev_dbg(&dev->pdev->dev, "amthif canceled iamthif state %d\n",
drivers/misc/mei/amthif.c:			dev_dbg(&dev->pdev->dev, "run next amthif iamthif cb\n");
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "completing call back.\n");
drivers/misc/mei/interrupt.c:			dev_err(&dev->pdev->dev, "response buffer is not allocated.\n");
drivers/misc/mei/interrupt.c:			dev_dbg(&dev->pdev->dev, "message overflow. size %d len %d idx %ld\n",
drivers/misc/mei/interrupt.c:				dev_err(&dev->pdev->dev, "allocation failed.\n");
drivers/misc/mei/interrupt.c:			dev_dbg(&dev->pdev->dev, "completed read H cl = %d, ME cl = %d, length = %lu\n",
drivers/misc/mei/interrupt.c:	dev_dbg(&dev->pdev->dev, "message read\n");
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "discarding message " MEI_HDR_FMT "\n",
drivers/misc/mei/interrupt.c:	dev_dbg(&dev->pdev->dev, "buf: size = %d idx = %lu\n",
drivers/misc/mei/interrupt.c:	dev_dbg(&dev->pdev->dev, MEI_HDR_FMT, MEI_HDR_PRM(&mei_hdr));
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "slots =%08x.\n", *slots);
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "slots =%08x.\n", *slots);
drivers/misc/mei/interrupt.c:	dev_dbg(&dev->pdev->dev, MEI_HDR_FMT, MEI_HDR_PRM(mei_hdr));
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "corrupted message header.\n");
drivers/misc/mei/interrupt.c:			dev_dbg(&dev->pdev->dev,
drivers/misc/mei/interrupt.c:			dev_dbg(&dev->pdev->dev, "corrupted message header\n");
drivers/misc/mei/interrupt.c:		dev_err(&dev->pdev->dev,
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "call mei_irq_thread_read_bus_message.\n");
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "end mei_irq_thread_read_bus_message.\n");
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "call mei_irq_thread_read_iamthif_message.\n");
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, MEI_HDR_FMT, MEI_HDR_PRM(mei_hdr));
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "call mei_cl_irq_read_msg.\n");
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, MEI_HDR_FMT, MEI_HDR_PRM(mei_hdr));
drivers/misc/mei/interrupt.c:		dev_err(&dev->pdev->dev, "resetting due to slots overflow.\n");
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "host buffer is not empty.\n");
drivers/misc/mei/interrupt.c:	dev_dbg(&dev->pdev->dev, "complete all waiting for write cb.\n");
drivers/misc/mei/interrupt.c:			dev_dbg(&dev->pdev->dev, "MEI WRITE COMPLETE\n");
drivers/misc/mei/interrupt.c:			dev_dbg(&dev->pdev->dev, "check iamthif flow control.\n");
drivers/misc/mei/interrupt.c:				dev_dbg(&dev->pdev->dev, "wd send failed.\n");
drivers/misc/mei/interrupt.c:	dev_dbg(&dev->pdev->dev, "complete control write list cb.\n");
drivers/misc/mei/interrupt.c:	dev_dbg(&dev->pdev->dev, "complete write list cb.\n");
drivers/misc/mei/interrupt.c:			dev_dbg(&dev->pdev->dev,
drivers/misc/mei/interrupt.c:					dev_err(&dev->pdev->dev, "reset: init clients timeout hbm_state = %d.\n",
drivers/misc/mei/interrupt.c:				dev_err(&dev->pdev->dev, "reset: connect/disconnect timeout.\n");
drivers/misc/mei/interrupt.c:			dev_err(&dev->pdev->dev, "reset: amthif  hanged.\n");
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "dev->iamthif_timer = %ld\n",
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "timeout = %ld\n", timeout);
drivers/misc/mei/interrupt.c:		dev_dbg(&dev->pdev->dev, "jiffies = %ld\n", jiffies);
drivers/misc/mei/interrupt.c:			dev_dbg(&dev->pdev->dev, "freeing AMTHI for other requests\n");
drivers/misc/mei/hbm.c:	dev_dbg(&dev->pdev->dev, "memory allocation for ME clients size=%zd.\n",
drivers/misc/mei/hbm.c:		dev_err(&dev->pdev->dev, "memory allocation for ME clients failed.\n");
drivers/misc/mei/hbm.c:		dev_err(&dev->pdev->dev, "wating for mei start failed\n");
drivers/misc/mei/hbm.c:		dev_err(&dev->pdev->dev, "version message writet failed\n");
drivers/misc/mei/hbm.c:		dev_err(&dev->pdev->dev, "enumeration request write failed.\n");
drivers/misc/mei/hbm.c:		dev_err(&dev->pdev->dev, "properties request write failed\n");
drivers/misc/mei/hbm.c:	dev_dbg(&dev->pdev->dev, "sending flow control host client = %d, ME client = %d\n",
drivers/misc/mei/hbm.c:				dev_dbg(&dev->pdev->dev, "recv flow ctrl msg ME %d (single).\n",
drivers/misc/mei/hbm.c:				dev_dbg(&dev->pdev->dev, "flow control credentials =%d.\n",
drivers/misc/mei/hbm.c:			dev_dbg(&dev->pdev->dev, "flow ctrl msg for host %d ME %d.\n",
drivers/misc/mei/hbm.c:			dev_dbg(&dev->pdev->dev, "flow control credentials = %d.\n",
drivers/misc/mei/hbm.c:	dev_dbg(&dev->pdev->dev,
drivers/misc/mei/hbm.c:		dev_dbg(&dev->pdev->dev, "list_for_each_entry_safe in ctrl_rd_list.\n");
drivers/misc/mei/hbm.c:	dev_dbg(&dev->pdev->dev,
drivers/misc/mei/hbm.c:		dev_dbg(&dev->pdev->dev, "successfully connected to WD client.\n");
drivers/misc/mei/hbm.c:			dev_dbg(&dev->pdev->dev, "disconnect request host client %d ME client %d.\n",
drivers/misc/mei/hbm.c:			dev_dbg(&dev->pdev->dev, "version mismatch.\n");
drivers/misc/mei/hbm.c:			dev_err(&dev->pdev->dev, "reset: wrong host start response\n");
drivers/misc/mei/hbm.c:		dev_dbg(&dev->pdev->dev, "host start response message received.\n");
drivers/misc/mei/hbm.c:		dev_dbg(&dev->pdev->dev, "client connect response message received.\n");
drivers/misc/mei/hbm.c:		dev_dbg(&dev->pdev->dev, "client disconnect response message received.\n");
drivers/misc/mei/hbm.c:		dev_dbg(&dev->pdev->dev, "client flow control response message received.\n");
drivers/misc/mei/hbm.c:			dev_err(&dev->pdev->dev, "reset: properties response hbm wrong status.\n");
drivers/misc/mei/hbm.c:			dev_err(&dev->pdev->dev, "reset: host properties response address mismatch\n");
drivers/misc/mei/hbm.c:			dev_err(&dev->pdev->dev, "reset: unexpected properties response\n");
drivers/misc/mei/hbm.c:			dev_err(&dev->pdev->dev, "reset: unexpected enumeration response hbm.\n");
drivers/misc/mei/hbm.c:			dev_err(&dev->pdev->dev, "unexpected stop response hbm.\n");
drivers/misc/mei/hbm.c:		dev_info(&dev->pdev->dev, "reset: FW stop response.\n");
drivers/misc/mei/debugfs.c:		dev_err(&dev->pdev->dev, "meclients: registration failed\n");
drivers/misc/mei/debugfs.c:		dev_err(&dev->pdev->dev, "devstate: registration failed\n");
drivers/misc/mei/pci-me.c:			dev_info(&pdev->dev, "Device doesn't have valid ME Interface\n");
drivers/misc/mei/pci-me.c:		dev_err(&pdev->dev, "failed to enable pci device.\n");
drivers/misc/mei/pci-me.c:		dev_err(&pdev->dev, "failed to get pci regions.\n");
drivers/misc/mei/pci-me.c:		dev_err(&pdev->dev, "mapping I/O device memory failure.\n");
drivers/misc/mei/pci-me.c:		err = request_threaded_irq(pdev->irq,
drivers/misc/mei/pci-me.c:		err = request_threaded_irq(pdev->irq,
drivers/misc/mei/pci-me.c:		dev_err(&pdev->dev, "request_threaded_irq failure. irq = %d\n",
drivers/misc/mei/pci-me.c:		       pdev->irq);
drivers/misc/mei/pci-me.c:		dev_err(&pdev->dev, "init hw failure.\n");
drivers/misc/mei/pci-me.c:	free_irq(pdev->irq, dev);
drivers/misc/mei/pci-me.c:	dev_err(&pdev->dev, "initialization failed.\n");
drivers/misc/mei/pci-me.c:	dev_err(&pdev->dev, "stop\n");
drivers/misc/mei/pci-me.c:	free_irq(pdev->irq, dev);
drivers/misc/mei/pci-me.c:	dev_err(&pdev->dev, "suspend\n");
drivers/misc/mei/pci-me.c:	free_irq(pdev->irq, dev);
drivers/misc/mei/pci-me.c:		err = request_threaded_irq(pdev->irq,
drivers/misc/mei/pci-me.c:		err = request_threaded_irq(pdev->irq,
drivers/misc/mei/pci-me.c:		dev_err(&pdev->dev, "request_threaded_irq failed: irq = %d.\n",
drivers/misc/mei/pci-me.c:				pdev->irq);
drivers/misc/mei/hw-me.c:	dev_dbg(&dev->pdev->dev, "current HCSR = 0x%08x.\n", mei_hcsr_read(hw));
drivers/misc/mei/hw-me.c:		dev_err(&dev->pdev->dev,
drivers/misc/mei/hw-me.c:	dev_dbg(&dev->pdev->dev, "hw is ready\n");
drivers/misc/mei/hw-me.c:	dev_dbg(&dev->pdev->dev, MEI_HDR_FMT, MEI_HDR_PRM(header));
drivers/misc/mei/hw-me.c:	dev_dbg(&dev->pdev->dev, "empty slots = %hu.\n", empty_slots);
drivers/misc/mei/hw-me.c:	dev_dbg(&dev->pdev->dev, "filled_slots =%08x\n", filled_slots);
drivers/misc/mei/hw-me.c:	dev_dbg(&dev->pdev->dev, "function called after ISR to handle the interrupt processing.\n");
drivers/misc/mei/hw-me.c:		dev_dbg(&dev->pdev->dev, "FW not ready.\n");
drivers/misc/mei/hw-me.c:			dev_dbg(&dev->pdev->dev, "we need to start the dev.\n");
drivers/misc/mei/hw-me.c:			dev_dbg(&dev->pdev->dev, "Reset Completed.\n");
drivers/misc/mei/hw-me.c:		dev_dbg(&dev->pdev->dev, "slots =%08x\n", slots);
drivers/misc/mei/hw-me.c:		dev_dbg(&dev->pdev->dev, "call mei_irq_read_handler.\n");
drivers/misc/mei/hw-me.c:	dev_dbg(&dev->pdev->dev, "end of bottom half function.\n");
drivers/misc/mei/wd.c:	dev_dbg(&dev->pdev->dev, "wd: set timeout=%d.\n", timeout);
drivers/misc/mei/wd.c:		dev_info(&dev->pdev->dev, "wd: failed to find the client\n");
drivers/misc/mei/wd.c:		dev_info(&dev->pdev->dev, "wd: failed link client\n");
drivers/misc/mei/wd.c:		dev_err(&dev->pdev->dev, "wd: failed to connect to the client\n");
drivers/misc/mei/wd.c:			dev_err(&dev->pdev->dev, "wd: send stop failed\n");
drivers/misc/mei/wd.c:		dev_dbg(&dev->pdev->dev, "wd: stop completed ret=%d.\n", ret);
drivers/misc/mei/wd.c:		dev_warn(&dev->pdev->dev,
drivers/misc/mei/wd.c:		dev_dbg(&dev->pdev->dev,
drivers/misc/mei/wd.c:		dev_dbg(&dev->pdev->dev,
drivers/misc/mei/wd.c:		dev_err(&dev->pdev->dev, "wd: not connected.\n");
drivers/misc/mei/wd.c:		dev_dbg(&dev->pdev->dev, "wd: sending ping\n");
drivers/misc/mei/wd.c:			dev_err(&dev->pdev->dev, "wd: send failed.\n");
drivers/misc/mei/wd.c:			dev_err(&dev->pdev->dev,
drivers/misc/mei/wd.c:		dev_err(&dev->pdev->dev,
drivers/misc/mei/wd.c:	dev_dbg(&dev->pdev->dev,
drivers/misc/mei/nfc.c:			dev_err(&dev->pdev->dev, "Unknow radio type 0x%x\n",
drivers/misc/mei/nfc.c:			dev_err(&dev->pdev->dev, "Unknow radio type 0x%x\n",
drivers/misc/mei/nfc.c:		dev_err(&dev->pdev->dev, "Unknow vendor ID 0x%x\n",
drivers/misc/mei/nfc.c:		dev_err(&dev->pdev->dev, "Could not send connect cmd\n");
drivers/misc/mei/nfc.c:		dev_err(&dev->pdev->dev, "Could not read connect response\n");
drivers/misc/mei/nfc.c:	dev_info(&dev->pdev->dev, "IVN 0x%x Vendor ID 0x%x\n",
drivers/misc/mei/nfc.c:	dev_info(&dev->pdev->dev, "ME FW %d.%d.%d.%d\n",
drivers/misc/mei/nfc.c:		dev_err(&dev->pdev->dev, "Could not send IF version cmd\n");
drivers/misc/mei/nfc.c:		dev_err(&dev->pdev->dev, "Could not read IF version\n");
drivers/misc/mei/nfc.c:		dev_err(&dev->pdev->dev, "Could not connect to NFC");
drivers/misc/mei/nfc.c:		dev_err(&dev->pdev->dev, "NFC MEI command timeout\n");
drivers/misc/mei/nfc.c:		dev_err(&dev->pdev->dev,
drivers/misc/mei/nfc.c:		dev_err(&dev->pdev->dev, "Could not get the NFC interfave version");
drivers/misc/mei/nfc.c:	dev_info(&dev->pdev->dev,
drivers/misc/mei/nfc.c:		dev_err(&dev->pdev->dev,
drivers/misc/mei/nfc.c:		dev_err(&dev->pdev->dev,
drivers/misc/mei/nfc.c:		dev_err(&dev->pdev->dev,
drivers/misc/mei/nfc.c:		dev_info(&dev->pdev->dev, "nfc: failed to find the client\n");
drivers/misc/mei/nfc.c:		dev_info(&dev->pdev->dev, "nfc: failed to find the client\n");
drivers/misc/mei/bus.c:	device->dev.parent = &dev->pdev->dev;
drivers/misc/mei/bus.c:		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
drivers/misc/mei/bus.c:		dev_err(&dev->pdev->dev, "Could not connect to the ME client");
drivers/misc/mei/bus.c:		dev_err(&dev->pdev->dev, "Already disconnected");
drivers/misc/mei/bus.c:		dev_err(&dev->pdev->dev,
drivers/misc/mei/main.c:		dev_dbg(&dev->pdev->dev, "dev_state != MEI_ENABLED  dev_state = %s\n",
drivers/misc/mei/main.c:		dev_err(&dev->pdev->dev, "open_handle_count exceded %d",
drivers/misc/mei/main.c:		dev_dbg(&dev->pdev->dev,
drivers/misc/mei/main.c:	dev_dbg(&dev->pdev->dev, "remove client host client = %d, ME client = %d\n",
drivers/misc/mei/main.c:		dev_dbg(&dev->pdev->dev,
drivers/misc/mei/main.c:	dev_dbg(&dev->pdev->dev, "buf.size = %d buf.idx= %ld\n",
drivers/misc/mei/main.c:	dev_dbg(&dev->pdev->dev, "end mei read rets= %d\n", rets);
drivers/misc/mei/main.c:		dev_err(&dev->pdev->dev, "host client = %d,  is not connected to ME client = %d",
drivers/misc/mei/main.c:		dev_err(&dev->pdev->dev, "write cb allocation failed\n");
drivers/misc/mei/main.c:			dev_err(&dev->pdev->dev,
drivers/misc/mei/main.c:		dev_dbg(&dev->pdev->dev, "Cannot connect to FW Client UUID = %pUl\n",
drivers/misc/mei/main.c:	dev_dbg(&dev->pdev->dev, "Connect to FW Client ID = %d\n",
drivers/misc/mei/main.c:	dev_dbg(&dev->pdev->dev, "FW Client - Protocol Version = %d\n",
drivers/misc/mei/main.c:	dev_dbg(&dev->pdev->dev, "FW Client - Max Msg Len = %d\n",
drivers/misc/mei/main.c:		dev_dbg(&dev->pdev->dev, "FW Client is amthi\n");
drivers/misc/mei/main.c:	dev_dbg(&dev->pdev->dev, "Can connect?\n");
drivers/misc/mei/main.c:	dev_dbg(&dev->pdev->dev, "IOCTL cmd = 0x%x", cmd);
drivers/misc/mei/main.c:	dev_dbg(&dev->pdev->dev, ": IOCTL_MEI_CONNECT_CLIENT.\n");
drivers/misc/mei/main.c:	dev_dbg(&dev->pdev->dev, "copy connect data from user\n");
drivers/misc/mei/main.c:		dev_dbg(&dev->pdev->dev, "failed to copy data from userland\n");
drivers/misc/mei/main.c:	dev_dbg(&dev->pdev->dev, "copy connect data to user\n");
drivers/misc/mei/main.c:		dev_dbg(&dev->pdev->dev, "failed to copy data to userland\n");
drivers/misc/mei/main.c:	mei_misc_device.parent = &dev->pdev->dev;
drivers/misc/mei/main.c:		dev_err(&dev->pdev->dev, "cannot register debugfs\n");
drivers/misc/hpilo.c:		dev_err(&pdev->dev, "Closing, but controller still active\n");
drivers/misc/hpilo.c:		dev_err(&pdev->dev, "Error mapping mmio\n");
drivers/misc/hpilo.c:		dev_err(&pdev->dev, "Error mapping shared mem\n");
drivers/misc/hpilo.c:		dev_err(&pdev->dev, "Error mapping doorbell\n");
drivers/misc/hpilo.c:	free_irq(pdev->irq, ilo_hw);
drivers/misc/hpilo.c:	if (pdev->subsystem_device == 0x1979)
drivers/misc/hpilo.c:		dev_err(&pdev->dev, "Error finding free device\n");
drivers/misc/hpilo.c:	error = request_irq(pdev->irq, ilo_isr, IRQF_SHARED, "hpilo", ilo_hw);
drivers/misc/hpilo.c:		dev_err(&pdev->dev, "Could not add cdev\n");
drivers/misc/hpilo.c:		dev = device_create(ilo_class, &pdev->dev,
drivers/misc/hpilo.c:			dev_err(&pdev->dev, "Could not create files\n");
drivers/misc/hpilo.c:	free_irq(pdev->irq, ilo_hw);
drivers/misc/cs5535-mfgpt.c:	dev_info(&mfgpt->pdev->dev, "registered timer %d\n", timer_nr);
drivers/misc/cs5535-mfgpt.c:		dev_err(&pdev->dev, "Bad mfgpt_reset_timers value: %i\n",
drivers/misc/cs5535-mfgpt.c:		dev_err(&pdev->dev, "can't fetch device resource info\n");
drivers/misc/cs5535-mfgpt.c:	if (!request_region(res->start, resource_size(res), pdev->name)) {
drivers/misc/cs5535-mfgpt.c:		dev_err(&pdev->dev, "can't request region\n");
drivers/misc/cs5535-mfgpt.c:	dev_info(&pdev->dev, "reserved resource region %pR\n", res);
drivers/misc/cs5535-mfgpt.c:	dev_info(&pdev->dev, "%d MFGPT timers available\n", t);
drivers/misc/atmel-ssc.c:		if (ssc->pdev->dev.of_node) {
drivers/misc/atmel-ssc.c:			if (of_alias_get_id(ssc->pdev->dev.of_node, "ssc")
drivers/misc/atmel-ssc.c:		} else if (ssc->pdev->id == ssc_num) {
drivers/misc/atmel-ssc.c:		dev_dbg(&ssc->pdev->dev, "module busy\n");
drivers/misc/atmel-ssc.c:		dev_dbg(&ssc->pdev->dev, "device already free\n");
drivers/misc/atmel-ssc.c:	if (pdev->dev.of_node) {
drivers/misc/atmel-ssc.c:		match = of_match_node(atmel_ssc_dt_ids, pdev->dev.of_node);
drivers/misc/atmel-ssc.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
drivers/misc/atmel-ssc.c:		dev_err(&pdev->dev, "Failed to request pinctrl\n");
drivers/misc/atmel-ssc.c:	ssc = devm_kzalloc(&pdev->dev, sizeof(struct ssc_device), GFP_KERNEL);
drivers/misc/atmel-ssc.c:		dev_dbg(&pdev->dev, "out of memory\n");
drivers/misc/atmel-ssc.c:	ssc->regs = devm_ioremap_resource(&pdev->dev, regs);
drivers/misc/atmel-ssc.c:	ssc->clk = devm_clk_get(&pdev->dev, "pclk");
drivers/misc/atmel-ssc.c:		dev_dbg(&pdev->dev, "no pclk clock defined\n");
drivers/misc/atmel-ssc.c:		dev_dbg(&pdev->dev, "could not get irq\n");
drivers/misc/atmel-ssc.c:	dev_info(&pdev->dev, "Atmel SSC device at 0x%p (irq %d)\n",
drivers/misc/arm-charlcd.c:	lcd->dev = &pdev->dev;
drivers/misc/arm-charlcd.c:	dev_info(&pdev->dev, "initialized ARM character LCD at %08x\n",
drivers/misc/ti-st/st_kim.c:			     &kim_gdata->kim_pdev->dev);
drivers/misc/ti-st/st_kim.c:	pdata = kim_gdata->kim_pdev->dev.platform_data;
drivers/misc/ti-st/st_kim.c:		sysfs_notify(&kim_gdata->kim_pdev->dev.kobj,
drivers/misc/ti-st/st_kim.c:		kim_gdata->kim_pdev->dev.platform_data;
drivers/misc/ti-st/st_kim.c:	sysfs_notify(&kim_gdata->kim_pdev->dev.kobj, NULL, "install");
drivers/misc/ti-st/st_kim.c:	kim_gdata = dev_get_drvdata(&pdev->dev);
drivers/misc/ti-st/st_kim.c:	struct ti_st_plat_data	*pdata = pdev->dev.platform_data;
drivers/misc/ti-st/st_kim.c:	if ((pdev->id != -1) && (pdev->id < MAX_ST_DEVICES)) {
drivers/misc/ti-st/st_kim.c:		st_kim_devices[pdev->id] = pdev;
drivers/misc/ti-st/st_kim.c:	dev_set_drvdata(&pdev->dev, kim_gdata);
drivers/misc/ti-st/st_kim.c:	err = sysfs_create_group(&pdev->dev.kobj, &uim_attr_grp);
drivers/misc/ti-st/st_kim.c:	sysfs_remove_group(&pdev->dev.kobj, &uim_attr_grp);
drivers/misc/ti-st/st_kim.c:	struct ti_st_plat_data	*pdata = pdev->dev.platform_data;
drivers/misc/ti-st/st_kim.c:	kim_gdata = dev_get_drvdata(&pdev->dev);
drivers/misc/ti-st/st_kim.c:	sysfs_remove_group(&pdev->dev.kobj, &uim_attr_grp);
drivers/misc/ti-st/st_kim.c:	struct ti_st_plat_data	*pdata = pdev->dev.platform_data;
drivers/misc/ti-st/st_kim.c:	struct ti_st_plat_data	*pdata = pdev->dev.platform_data;
drivers/misc/ti-st/st_ll.c:	pdata = kim_data->kim_pdev->dev.platform_data;
drivers/misc/ti-st/st_ll.c:	pdata = kim_data->kim_pdev->dev.platform_data;
drivers/misc/ibmasm/module.c:		dev_err(&pdev->dev, "Failed to enable PCI device\n");
drivers/misc/ibmasm/module.c:		dev_err(&pdev->dev, "Failed to allocate PCI resources\n");
drivers/misc/ibmasm/module.c:		dev_err(&pdev->dev, "Failed to allocate memory\n");
drivers/misc/ibmasm/module.c:	sp->dev = &pdev->dev;
drivers/misc/ibmasm/module.c:	sp->number = pdev->bus->number;
drivers/misc/ibmasm/module.c:	sp->irq = pdev->irq;
drivers/misc/ibmasm/remote.c:	mouse_dev->id.vendor = pdev->vendor;
drivers/misc/ibmasm/remote.c:	mouse_dev->id.product = pdev->device;
drivers/misc/ibmasm/remote.c:	keybd_dev->id.vendor = pdev->vendor;
drivers/misc/ibmasm/remote.c:	keybd_dev->id.product = pdev->device;
drivers/misc/cb710/core.c:	unsigned int devfn = PCI_DEVFN(PCI_SLOT(pdev->devfn), 0);
drivers/misc/cb710/core.c:	pdev0 = pci_get_slot(pdev->bus, devfn);
drivers/misc/cb710/core.c:	slot->pdev.dev.parent = &chip->pdev->dev;
drivers/misc/cb710/core.c:	free_irq(pdev->irq, chip);
drivers/misc/cb710/core.c:	return devm_request_irq(&pdev->dev, pdev->irq,
drivers/misc/cb710/core.c:	dev_dbg(&pdev->dev, "PCI config[0x48] = 0x%08X\n", val);
drivers/misc/cb710/core.c:	chip = devm_kzalloc(&pdev->dev,
drivers/misc/cb710/core.c:	err = devm_request_irq(&pdev->dev, pdev->irq,
drivers/misc/cb710/core.c:	dev_info(&pdev->dev, "id %d, IO 0x%p, IRQ %d\n",
drivers/misc/cb710/core.c:		chip->platform_id, chip->iobase, pdev->irq);
drivers/misc/vmw_vmci/vmci_guest.c:		dev_err(&pdev->dev, "%s: Insufficient memory\n", __func__);
drivers/misc/vmw_vmci/vmci_guest.c:	dev_dbg(&pdev->dev, "%s: Host capability check: %s\n",
drivers/misc/vmw_vmci/vmci_guest.c:	dev_dbg(&pdev->dev, "Probing for vmci/PCI guest device\n");
drivers/misc/vmw_vmci/vmci_guest.c:		dev_err(&pdev->dev,
drivers/misc/vmw_vmci/vmci_guest.c:		dev_err(&pdev->dev, "Failed to reserve/map IO regions\n");
drivers/misc/vmw_vmci/vmci_guest.c:	dev_info(&pdev->dev, "Found VMCI PCI device at %#lx, irq %u\n",
drivers/misc/vmw_vmci/vmci_guest.c:		 (unsigned long)iobase, pdev->irq);
drivers/misc/vmw_vmci/vmci_guest.c:	vmci_dev = devm_kzalloc(&pdev->dev, sizeof(*vmci_dev), GFP_KERNEL);
drivers/misc/vmw_vmci/vmci_guest.c:		dev_err(&pdev->dev,
drivers/misc/vmw_vmci/vmci_guest.c:	vmci_dev->dev = &pdev->dev;
drivers/misc/vmw_vmci/vmci_guest.c:		dev_err(&pdev->dev,
drivers/misc/vmw_vmci/vmci_guest.c:		dev_err(&pdev->dev, "Device does not support datagrams\n");
drivers/misc/vmw_vmci/vmci_guest.c:			dev_warn(&pdev->dev,
drivers/misc/vmw_vmci/vmci_guest.c:	dev_info(&pdev->dev, "Using capabilities 0x%x\n", capabilities);
drivers/misc/vmw_vmci/vmci_guest.c:			dev_warn(&pdev->dev,
drivers/misc/vmw_vmci/vmci_guest.c:		dev_warn(&pdev->dev,
drivers/misc/vmw_vmci/vmci_guest.c:		vmci_dev->irq = pdev->irq;
drivers/misc/vmw_vmci/vmci_guest.c:		vmci_dev->irq = pdev->irq;
drivers/misc/vmw_vmci/vmci_guest.c:		dev_err(&pdev->dev, "Irq %u in use: %d\n",
drivers/misc/vmw_vmci/vmci_guest.c:			dev_err(&pdev->dev,
drivers/misc/vmw_vmci/vmci_guest.c:	dev_dbg(&pdev->dev, "Registered device\n");
drivers/misc/vmw_vmci/vmci_guest.c:		dev_warn(&pdev->dev,
drivers/misc/vmw_vmci/vmci_guest.c:	dev_dbg(&pdev->dev, "Removing device\n");
drivers/misc/vmw_vmci/vmci_guest.c:		dev_warn(&pdev->dev,
drivers/misc/vmw_vmci/vmci_guest.c:	dev_dbg(&pdev->dev, "Resetting vmci device\n");
drivers/misc/spear13xx_pcie_gadget.c:		dev_err(&pdev->dev, "no resource defined\n");
drivers/misc/spear13xx_pcie_gadget.c:				pdev->name)) {
drivers/misc/spear13xx_pcie_gadget.c:		dev_err(&pdev->dev, "pcie gadget region already	claimed\n");
drivers/misc/spear13xx_pcie_gadget.c:		dev_err(&pdev->dev, "no resource defined\n");
drivers/misc/spear13xx_pcie_gadget.c:				pdev->name)) {
drivers/misc/spear13xx_pcie_gadget.c:		dev_err(&pdev->dev, "pcie gadget region already	claimed\n");
drivers/misc/spear13xx_pcie_gadget.c:		dev_err(&pdev->dev, "out of memory\n");
drivers/misc/spear13xx_pcie_gadget.c:	sprintf(cg_item->ci_namebuf, "pcie_gadget.%d", pdev->id);
drivers/misc/spear13xx_pcie_gadget.c:		dev_err(&pdev->dev, "ioremap fail\n");
drivers/misc/spear13xx_pcie_gadget.c:		dev_err(&pdev->dev, "ioremap fail\n");
drivers/misc/spear13xx_pcie_gadget.c:	dev_set_drvdata(&pdev->dev, target);
drivers/misc/spear13xx_pcie_gadget.c:		dev_err(&pdev->dev, "no update irq?\n");
drivers/misc/spear13xx_pcie_gadget.c:	status = request_irq(irq, spear_pcie_gadget_irq, 0, pdev->name, NULL);
drivers/misc/spear13xx_pcie_gadget.c:		dev_err(&pdev->dev,
drivers/misc/spear13xx_pcie_gadget.c:	if (pdev->id == 1) {
drivers/misc/spear13xx_pcie_gadget.c:	} else if (pdev->id == 2) {
drivers/misc/spear13xx_pcie_gadget.c:	target = dev_get_drvdata(&pdev->dev);
drivers/misc/atmel_tclib.c:		if (tc->pdev->dev.of_node) {
drivers/misc/atmel_tclib.c:			if (of_alias_get_id(tc->pdev->dev.of_node, "tcb")
drivers/misc/atmel_tclib.c:		} else if (tc->pdev->id == block) {
drivers/misc/atmel_tclib.c:	clk = clk_get(&pdev->dev, "t0_clk");
drivers/misc/atmel_tclib.c:	if (pdev->dev.of_node) {
drivers/misc/atmel_tclib.c:		match = of_match_node(atmel_tcb_dt_ids, pdev->dev.of_node);
drivers/misc/atmel_tclib.c:	tc->clk[1] = clk_get(&pdev->dev, "t1_clk");
drivers/misc/atmel_tclib.c:	tc->clk[2] = clk_get(&pdev->dev, "t2_clk");
drivers/misc/sram.c:	virt_base = devm_request_and_ioremap(&pdev->dev, res);
drivers/misc/sram.c:	sram = devm_kzalloc(&pdev->dev, sizeof(*sram), GFP_KERNEL);
drivers/misc/sram.c:	sram->clk = devm_clk_get(&pdev->dev, NULL);
drivers/misc/sram.c:	sram->pool = devm_gen_pool_create(&pdev->dev, ilog2(SRAM_GRANULARITY), -1);
drivers/misc/sram.c:	dev_dbg(&pdev->dev, "SRAM pool: %ld KiB @ 0x%p\n", size / 1024, virt_base);
drivers/misc/sram.c:		dev_dbg(&pdev->dev, "removed while SRAM allocated\n");
drivers/misc/phantom.c:		dev_err(&pdev->dev, "pci_enable_device failed!\n");
drivers/misc/phantom.c:		dev_err(&pdev->dev, "too many devices found!\n");
drivers/misc/phantom.c:		dev_err(&pdev->dev, "pci_request_regions failed!\n");
drivers/misc/phantom.c:		dev_err(&pdev->dev, "unable to allocate device\n");
drivers/misc/phantom.c:		dev_err(&pdev->dev, "can't remap conf space\n");
drivers/misc/phantom.c:		dev_err(&pdev->dev, "can't remap input space\n");
drivers/misc/phantom.c:		dev_err(&pdev->dev, "can't remap output space\n");
drivers/misc/phantom.c:	retval = request_irq(pdev->irq, phantom_isr,
drivers/misc/phantom.c:		dev_err(&pdev->dev, "can't establish ISR\n");
drivers/misc/phantom.c:		dev_err(&pdev->dev, "chardev registration failed\n");
drivers/misc/phantom.c:	if (IS_ERR(device_create(phantom_class, &pdev->dev,
drivers/misc/phantom.c:		dev_err(&pdev->dev, "can't create device\n");
drivers/misc/phantom.c:	free_irq(pdev->irq, pht);
drivers/misc/phantom.c:	free_irq(pdev->irq, pht);
drivers/misc/phantom.c:	synchronize_irq(pdev->irq);
drivers/misc/atmel_pwm.c:	struct device	*dev = &pwm->pdev->dev;
drivers/misc/atmel_pwm.c:	u32 *mp = pdev->dev.platform_data;
drivers/misc/atmel_pwm.c:		dev_warn(&pdev->dev, "mask 0x%x ... more than %d channels\n",
drivers/misc/atmel_pwm.c:	p->clk = clk_get(&pdev->dev, "pwm_clk");
drivers/misc/atmel_pwm.c:	status = request_irq(irq, pwm_irq, 0, pdev->name, p);
drivers/misc/lis3lv02d/lis3lv02d.c:	input_dev->dev.parent = &lis3->pdev->dev;
drivers/misc/lis3lv02d/lis3lv02d.c:	return sysfs_create_group(&lis3->pdev->dev.kobj, &lis3lv02d_attribute_group);
drivers/misc/lis3lv02d/lis3lv02d.c:	sysfs_remove_group(&lis3->pdev->dev.kobj, &lis3lv02d_attribute_group);
drivers/misc/ioc4.c:		    idd->idd_pdev->bus->number == pdev->bus->number &&
drivers/misc/ioc4.c:		    3 == PCI_SLOT(pdev->devfn))
drivers/misc/ioc4.c:		    idd->idd_pdev->bus->number == pdev->bus->number &&
drivers/misc/ioc4.c:		    3 == PCI_SLOT(pdev->devfn))
drivers/acpi/acpi_lpss.c:	id = acpi_match_device(acpi_lpss_device_ids, &pdev->dev);
drivers/acpi/acpi_lpss.c:	if (acpi_bus_get_device(ACPI_HANDLE(&pdev->dev), &adev))
drivers/acpi/acpi_lpss.c:		dev_err(&pdev->dev, "MMIO size insufficient to access LTR\n");
drivers/acpi/acpi_lpss.c:		ret = sysfs_create_group(&pdev->dev.kobj, &lpss_attr_group);
drivers/acpi/acpi_lpss.c:		sysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);
drivers/acpi/acpi_platform.c:			dev_name(&pdev->dev));
drivers/acpi/pci_root.c:		pbus = pdev->subordinate;
drivers/acpi/pci_root.c:		 * case pdev->subordinate will be NULL for the parent.
drivers/acpi/pci_root.c:			dev_dbg(&pdev->dev, "Not a PCI-to-PCI bridge\n");
drivers/acpi/video.c:			parent = &pdev->dev;
samples/rpmsg/rpmsg_client_sample.c:	dev_info(&rpdev->dev, "incoming msg %d (src: 0x%x)\n", ++rx_count, src);
samples/rpmsg/rpmsg_client_sample.c:		dev_info(&rpdev->dev, "goodbye!\n");
samples/rpmsg/rpmsg_client_sample.c:		dev_err(&rpdev->dev, "rpmsg_send failed: %d\n", ret);
samples/rpmsg/rpmsg_client_sample.c:	dev_info(&rpdev->dev, "new channel: 0x%x -> 0x%x!\n",
samples/rpmsg/rpmsg_client_sample.c:					rpdev->src, rpdev->dst);
samples/rpmsg/rpmsg_client_sample.c:		dev_err(&rpdev->dev, "rpmsg_send failed: %d\n", ret);
samples/rpmsg/rpmsg_client_sample.c:	dev_info(&rpdev->dev, "rpmsg sample client driver is removed\n");
sound/soc/jz4740/qi_lb60.c:	card->dev = &pdev->dev;
sound/soc/jz4740/qi_lb60.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/jz4740/jz4740-i2s.c:				pdev->name);
sound/soc/jz4740/jz4740-i2s.c:	i2s->clk_aic = clk_get(&pdev->dev, "aic");
sound/soc/jz4740/jz4740-i2s.c:	i2s->clk_i2s = clk_get(&pdev->dev, "i2s");
sound/soc/jz4740/jz4740-i2s.c:	ret = snd_soc_register_component(&pdev->dev, &jz4740_i2s_component,
sound/soc/jz4740/jz4740-i2s.c:		dev_err(&pdev->dev, "Failed to register DAI\n");
sound/soc/jz4740/jz4740-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/jz4740/jz4740-pcm.c:	return snd_soc_register_platform(&pdev->dev, &jz4740_soc_platform);
sound/soc/jz4740/jz4740-pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/txx9/txx9aclc-ac97.c:	if (!devm_request_mem_region(&pdev->dev, r->start, resource_size(r),
sound/soc/txx9/txx9aclc-ac97.c:				     dev_name(&pdev->dev)))
sound/soc/txx9/txx9aclc-ac97.c:	drvdata = devm_kzalloc(&pdev->dev, sizeof(*drvdata), GFP_KERNEL);
sound/soc/txx9/txx9aclc-ac97.c:	drvdata->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));
sound/soc/txx9/txx9aclc-ac97.c:	err = devm_request_irq(&pdev->dev, irq, txx9aclc_ac97_irq,
sound/soc/txx9/txx9aclc-ac97.c:			       0, dev_name(&pdev->dev), drvdata);
sound/soc/txx9/txx9aclc-ac97.c:	return snd_soc_register_component(&pdev->dev, &txx9aclc_ac97_component,
sound/soc/txx9/txx9aclc-ac97.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/txx9/txx9aclc.c:	return snd_soc_register_platform(&pdev->dev, &txx9aclc_soc_platform);
sound/soc/txx9/txx9aclc.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/samsung/pcm.c:	if ((pdev->id < 0) || pdev->id >= ARRAY_SIZE(s3c_pcm)) {
sound/soc/samsung/pcm.c:		dev_err(&pdev->dev, "id %d out of range\n", pdev->id);
sound/soc/samsung/pcm.c:	pcm_pdata = pdev->dev.platform_data;
sound/soc/samsung/pcm.c:		dev_err(&pdev->dev, "Unable to get PCM-TX dma resource\n");
sound/soc/samsung/pcm.c:		dev_err(&pdev->dev, "Unable to get PCM-RX dma resource\n");
sound/soc/samsung/pcm.c:		dev_err(&pdev->dev, "Unable to get register resource\n");
sound/soc/samsung/pcm.c:		dev_err(&pdev->dev, "Unable to configure gpio\n");
sound/soc/samsung/pcm.c:	pcm = &s3c_pcm[pdev->id];
sound/soc/samsung/pcm.c:	pcm->dev = &pdev->dev;
sound/soc/samsung/pcm.c:	pcm->cclk = clk_get(&pdev->dev, "audio-bus");
sound/soc/samsung/pcm.c:		dev_err(&pdev->dev, "failed to get audio-bus\n");
sound/soc/samsung/pcm.c:	dev_set_drvdata(&pdev->dev, pcm);
sound/soc/samsung/pcm.c:		dev_err(&pdev->dev, "Unable to request register region\n");
sound/soc/samsung/pcm.c:		dev_err(&pdev->dev, "cannot ioremap registers\n");
sound/soc/samsung/pcm.c:	pcm->pclk = clk_get(&pdev->dev, "pcm");
sound/soc/samsung/pcm.c:		dev_err(&pdev->dev, "failed to get pcm_clock\n");
sound/soc/samsung/pcm.c:	s3c_pcm_stereo_in[pdev->id].dma_addr = mem_res->start
sound/soc/samsung/pcm.c:	s3c_pcm_stereo_out[pdev->id].dma_addr = mem_res->start
sound/soc/samsung/pcm.c:	s3c_pcm_stereo_in[pdev->id].channel = dmarx_res->start;
sound/soc/samsung/pcm.c:	s3c_pcm_stereo_out[pdev->id].channel = dmatx_res->start;
sound/soc/samsung/pcm.c:	pcm->dma_capture = &s3c_pcm_stereo_in[pdev->id];
sound/soc/samsung/pcm.c:	pcm->dma_playback = &s3c_pcm_stereo_out[pdev->id];
sound/soc/samsung/pcm.c:	pm_runtime_enable(&pdev->dev);
sound/soc/samsung/pcm.c:	ret = snd_soc_register_component(&pdev->dev, &s3c_pcm_component,
sound/soc/samsung/pcm.c:					 &s3c_pcm_dai[pdev->id], 1);
sound/soc/samsung/pcm.c:		dev_err(&pdev->dev, "failed to get register DAI: %d\n", ret);
sound/soc/samsung/pcm.c:	ret = asoc_dma_platform_register(&pdev->dev);
sound/soc/samsung/pcm.c:		dev_err(&pdev->dev, "failed to get register DMA: %d\n", ret);
sound/soc/samsung/pcm.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/samsung/pcm.c:	struct s3c_pcm_info *pcm = &s3c_pcm[pdev->id];
sound/soc/samsung/pcm.c:	asoc_dma_platform_unregister(&pdev->dev);
sound/soc/samsung/pcm.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/samsung/pcm.c:	pm_runtime_disable(&pdev->dev);
sound/soc/samsung/s3c24xx_uda134x.c:	s3c24xx_uda134x_l3_pins = pdev->dev.platform_data;
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev, "Wrong BCLK Divider!\n");
sound/soc/samsung/i2s.c:			dev_err(&i2s->pdev->dev,
sound/soc/samsung/i2s.c:				i2s->op_clk = clk_get(&i2s->pdev->dev,
sound/soc/samsung/i2s.c:				i2s->op_clk = clk_get(&i2s->pdev->dev,
sound/soc/samsung/i2s.c:			dev_err(&i2s->pdev->dev,
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev, "We don't serve that!\n");
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev, "Format not supported\n");
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev, "Polarity not supported\n");
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev, "master/slave format not supported\n");
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev,
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev, "%d channels not supported\n",
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev, "Format(%d) not supported\n",
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev,
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev,
sound/soc/samsung/i2s.c:		dev_dbg(&i2s->pdev->dev,
sound/soc/samsung/i2s.c:			dev_err(&i2s->pdev->dev,
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev,
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev, "cannot ioremap registers\n");
sound/soc/samsung/i2s.c:	i2s->clk = clk_get(&i2s->pdev->dev, "iis");
sound/soc/samsung/i2s.c:		dev_err(&i2s->pdev->dev, "failed to get i2s_clock\n");
sound/soc/samsung/i2s.c:	i2s = devm_kzalloc(&pdev->dev, sizeof(struct i2s_dai), GFP_KERNEL);
sound/soc/samsung/i2s.c:		dev_set_drvdata(&i2s->pdev->dev, i2s);
sound/soc/samsung/i2s.c:	struct device *dev = &i2s->pdev->dev;
sound/soc/samsung/i2s.c:	if (pdev->dev.of_node) {
sound/soc/samsung/i2s.c:		match = of_match_node(exynos_i2s_match, pdev->dev.of_node);
sound/soc/samsung/i2s.c:	struct s3c_audio_pdata *i2s_pdata = pdev->dev.platform_data;
sound/soc/samsung/i2s.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/samsung/i2s.c:		sec_dai = dev_get_drvdata(&pdev->dev);
sound/soc/samsung/i2s.c:			dev_err(&pdev->dev, "Unable to get drvdata\n");
sound/soc/samsung/i2s.c:		snd_soc_register_component(&sec_dai->pdev->dev,
sound/soc/samsung/i2s.c:		asoc_dma_platform_register(&pdev->dev);
sound/soc/samsung/i2s.c:		dev_err(&pdev->dev, "Unable to alloc I2S_pri\n");
sound/soc/samsung/i2s.c:			dev_err(&pdev->dev,
sound/soc/samsung/i2s.c:			dev_err(&pdev->dev,
sound/soc/samsung/i2s.c:			dev_err(&pdev->dev, "Can't work without s3c_audio_pdata\n");
sound/soc/samsung/i2s.c:				dev_err(&pdev->dev, "idma address is not"\
sound/soc/samsung/i2s.c:		dev_err(&pdev->dev, "Unable to get I2S SFR address\n");
sound/soc/samsung/i2s.c:		dev_err(&pdev->dev, "Unable to request SFR region\n");
sound/soc/samsung/i2s.c:			dev_err(&pdev->dev, "Unable to alloc I2S_sec\n");
sound/soc/samsung/i2s.c:			dev_err(&pdev->dev, "Unable to configure gpio\n");
sound/soc/samsung/i2s.c:			dev_err(&pdev->dev, "Unable to configure gpio\n");
sound/soc/samsung/i2s.c:	snd_soc_register_component(&pri_dai->pdev->dev, &samsung_i2s_component,
sound/soc/samsung/i2s.c:	pm_runtime_enable(&pdev->dev);
sound/soc/samsung/i2s.c:	asoc_dma_platform_register(&pdev->dev);
sound/soc/samsung/i2s.c:	struct s3c_audio_pdata *i2s_pdata = pdev->dev.platform_data;
sound/soc/samsung/i2s.c:	i2s = dev_get_drvdata(&pdev->dev);
sound/soc/samsung/i2s.c:	if (!i2s_pdata->cfg_gpio && pdev->dev.of_node)
sound/soc/samsung/i2s.c:		pm_runtime_disable(&pdev->dev);
sound/soc/samsung/i2s.c:	asoc_dma_platform_unregister(&pdev->dev);
sound/soc/samsung/i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/samsung/idma.c:	return snd_soc_register_platform(&pdev->dev, &asoc_idma_platform);
sound/soc/samsung/idma.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/samsung/s3c24xx_simtec.c:	pdata = pdev->dev.platform_data;
sound/soc/samsung/s3c24xx_simtec.c:		dev_err(&pdev->dev, "no platform data supplied\n");
sound/soc/samsung/s3c24xx_simtec.c:	xtal_clk = clk_get(&pdev->dev, "xtal");
sound/soc/samsung/s3c24xx_simtec.c:		dev_err(&pdev->dev, "could not get clkout0\n");
sound/soc/samsung/s3c24xx_simtec.c:	dev_info(&pdev->dev, "xtal rate is %ld\n", clk_get_rate(xtal_clk));
sound/soc/samsung/s3c24xx_simtec.c:	ret = attach_gpio_amp(&pdev->dev, pdata);
sound/soc/samsung/s3c24xx_simtec.c:		dev_err(&pdev->dev, "failed to alloc soc-audio devicec\n");
sound/soc/samsung/s3c24xx_simtec.c:		dev_err(&pdev->dev, "failed to add soc-audio dev\n");
sound/soc/samsung/speyside.c:	card->dev = &pdev->dev;
sound/soc/samsung/speyside.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/samsung/smdk_wm8994.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/samsung/smdk_wm8994.c:	card->dev = &pdev->dev;
sound/soc/samsung/smdk_wm8994.c:			dev_err(&pdev->dev,
sound/soc/samsung/smdk_wm8994.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed:%d\n", ret);
sound/soc/samsung/ac97.c:	ac97_pdata = pdev->dev.platform_data;
sound/soc/samsung/ac97.c:		dev_err(&pdev->dev, "cfg_gpio callback not provided!\n");
sound/soc/samsung/ac97.c:		dev_err(&pdev->dev, "Unable to get AC97-TX dma resource\n");
sound/soc/samsung/ac97.c:		dev_err(&pdev->dev, "Unable to get AC97-RX dma resource\n");
sound/soc/samsung/ac97.c:		dev_err(&pdev->dev, "Unable to get AC97-MIC dma resource\n");
sound/soc/samsung/ac97.c:		dev_err(&pdev->dev, "Unable to get register resource\n");
sound/soc/samsung/ac97.c:		dev_err(&pdev->dev, "AC97 IRQ not provided!\n");
sound/soc/samsung/ac97.c:		dev_err(&pdev->dev, "Unable to request register region\n");
sound/soc/samsung/ac97.c:		dev_err(&pdev->dev, "Unable to ioremap register region\n");
sound/soc/samsung/ac97.c:	s3c_ac97.ac97_clk = clk_get(&pdev->dev, "ac97");
sound/soc/samsung/ac97.c:		dev_err(&pdev->dev, "ac97 failed to get ac97_clock\n");
sound/soc/samsung/ac97.c:		dev_err(&pdev->dev, "Unable to configure gpio\n");
sound/soc/samsung/ac97.c:		dev_err(&pdev->dev, "ac97: interrupt request failed.\n");
sound/soc/samsung/ac97.c:	ret = snd_soc_register_component(&pdev->dev, &s3c_ac97_component,
sound/soc/samsung/ac97.c:	ret = asoc_dma_platform_register(&pdev->dev);
sound/soc/samsung/ac97.c:		dev_err(&pdev->dev, "failed to get register DMA: %d\n", ret);
sound/soc/samsung/ac97.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/samsung/ac97.c:	asoc_dma_platform_unregister(&pdev->dev);
sound/soc/samsung/ac97.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/samsung/s3c2412-i2s.c:	ret = s3c_i2sv2_register_component(&pdev->dev, -1,
sound/soc/samsung/s3c2412-i2s.c:	ret = asoc_dma_platform_register(&pdev->dev);
sound/soc/samsung/s3c2412-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/samsung/s3c2412-i2s.c:	asoc_dma_platform_unregister(&pdev->dev);
sound/soc/samsung/s3c2412-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/samsung/littlemill.c:	card->dev = &pdev->dev;
sound/soc/samsung/littlemill.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/samsung/bells.c:	bells_cards[pdev->id].dev = &pdev->dev;
sound/soc/samsung/bells.c:	ret = snd_soc_register_card(&bells_cards[pdev->id]);
sound/soc/samsung/bells.c:		dev_err(&pdev->dev,
sound/soc/samsung/bells.c:			bells_cards[pdev->id].name, ret);
sound/soc/samsung/bells.c:	snd_soc_unregister_card(&bells_cards[pdev->id]);
sound/soc/samsung/lowland.c:	card->dev = &pdev->dev;
sound/soc/samsung/lowland.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/samsung/smdk_wm8994pcm.c:	smdk_pcm.dev = &pdev->dev;
sound/soc/samsung/smdk_wm8994pcm.c:		dev_err(&pdev->dev, "snd_soc_register_card failed %d\n", ret);
sound/soc/samsung/smdk_wm8580pcm.c:	smdk_pcm.dev = &pdev->dev;
sound/soc/samsung/smdk_wm8580pcm.c:		dev_err(&pdev->dev, "snd_soc_register_card failed %d\n", ret);
sound/soc/samsung/spdif.c:	spdif_pdata = pdev->dev.platform_data;
sound/soc/samsung/spdif.c:	dev_dbg(&pdev->dev, "Entered %s\n", __func__);
sound/soc/samsung/spdif.c:		dev_err(&pdev->dev, "Unable to get dma resource.\n");
sound/soc/samsung/spdif.c:		dev_err(&pdev->dev, "Unable to get register resource.\n");
sound/soc/samsung/spdif.c:		dev_err(&pdev->dev, "Unable to configure GPIO pins\n");
sound/soc/samsung/spdif.c:	spdif->dev = &pdev->dev;
sound/soc/samsung/spdif.c:	spdif->pclk = clk_get(&pdev->dev, "spdif");
sound/soc/samsung/spdif.c:		dev_err(&pdev->dev, "failed to get peri-clock\n");
sound/soc/samsung/spdif.c:	spdif->sclk = clk_get(&pdev->dev, "sclk_spdif");
sound/soc/samsung/spdif.c:		dev_err(&pdev->dev, "failed to get internal source clock\n");
sound/soc/samsung/spdif.c:		dev_err(&pdev->dev, "Unable to request register region\n");
sound/soc/samsung/spdif.c:		dev_err(&pdev->dev, "Cannot ioremap registers\n");
sound/soc/samsung/spdif.c:	dev_set_drvdata(&pdev->dev, spdif);
sound/soc/samsung/spdif.c:	ret = snd_soc_register_component(&pdev->dev, &samsung_spdif_component,
sound/soc/samsung/spdif.c:		dev_err(&pdev->dev, "fail to register dai\n");
sound/soc/samsung/spdif.c:	ret = asoc_dma_platform_register(&pdev->dev);
sound/soc/samsung/spdif.c:		dev_err(&pdev->dev, "failed to register DMA: %d\n", ret);
sound/soc/samsung/spdif.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/samsung/spdif.c:	asoc_dma_platform_unregister(&pdev->dev);
sound/soc/samsung/spdif.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/samsung/smdk_spdif.c:	sclk_audio0 = clk_get(&pdev->dev, "sclk_audio");
sound/soc/samsung/tobermory.c:	card->dev = &pdev->dev;
sound/soc/samsung/tobermory.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/samsung/s3c24xx-i2s.c:	ret = snd_soc_register_component(&pdev->dev, &s3c24xx_i2s_component,
sound/soc/samsung/s3c24xx-i2s.c:	ret = asoc_dma_platform_register(&pdev->dev);
sound/soc/samsung/s3c24xx-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/samsung/s3c24xx-i2s.c:	asoc_dma_platform_unregister(&pdev->dev);
sound/soc/samsung/s3c24xx-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/tegra/trimslice.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/tegra/trimslice.c:	trimslice = devm_kzalloc(&pdev->dev, sizeof(struct tegra_trimslice),
sound/soc/tegra/trimslice.c:		dev_err(&pdev->dev, "Can't allocate tegra_trimslice\n");
sound/soc/tegra/trimslice.c:	card->dev = &pdev->dev;
sound/soc/tegra/trimslice.c:		dev_err(&pdev->dev,
sound/soc/tegra/trimslice.c:		dev_err(&pdev->dev,
sound/soc/tegra/trimslice.c:	ret = tegra_asoc_utils_init(&trimslice->util_data, &pdev->dev);
sound/soc/tegra/trimslice.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/tegra/tegra_wm8753.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/tegra/tegra_wm8753.c:	machine = devm_kzalloc(&pdev->dev, sizeof(struct tegra_wm8753),
sound/soc/tegra/tegra_wm8753.c:		dev_err(&pdev->dev, "Can't allocate tegra_wm8753 struct\n");
sound/soc/tegra/tegra_wm8753.c:	card->dev = &pdev->dev;
sound/soc/tegra/tegra_wm8753.c:		dev_err(&pdev->dev,
sound/soc/tegra/tegra_wm8753.c:		dev_err(&pdev->dev,
sound/soc/tegra/tegra_wm8753.c:	ret = tegra_asoc_utils_init(&machine->util_data, &pdev->dev);
sound/soc/tegra/tegra_wm8753.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/tegra/tegra20_ac97.c:	ac97 = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_ac97),
sound/soc/tegra/tegra20_ac97.c:		dev_err(&pdev->dev, "Can't allocate tegra20_ac97\n");
sound/soc/tegra/tegra20_ac97.c:	dev_set_drvdata(&pdev->dev, ac97);
sound/soc/tegra/tegra20_ac97.c:	ac97->clk_ac97 = clk_get(&pdev->dev, NULL);
sound/soc/tegra/tegra20_ac97.c:		dev_err(&pdev->dev, "Can't retrieve ac97 clock\n");
sound/soc/tegra/tegra20_ac97.c:		dev_err(&pdev->dev, "No memory resource\n");
sound/soc/tegra/tegra20_ac97.c:	memregion = devm_request_mem_region(&pdev->dev, mem->start,
sound/soc/tegra/tegra20_ac97.c:		dev_err(&pdev->dev, "Memory region already claimed\n");
sound/soc/tegra/tegra20_ac97.c:	regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
sound/soc/tegra/tegra20_ac97.c:		dev_err(&pdev->dev, "ioremap failed\n");
sound/soc/tegra/tegra20_ac97.c:	ac97->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
sound/soc/tegra/tegra20_ac97.c:		dev_err(&pdev->dev, "regmap init failed\n");
sound/soc/tegra/tegra20_ac97.c:	if (of_property_read_u32_array(pdev->dev.of_node,
sound/soc/tegra/tegra20_ac97.c:		dev_err(&pdev->dev, "No DMA resource\n");
sound/soc/tegra/tegra20_ac97.c:	ac97->reset_gpio = of_get_named_gpio(pdev->dev.of_node,
sound/soc/tegra/tegra20_ac97.c:		ret = devm_gpio_request_one(&pdev->dev, ac97->reset_gpio,
sound/soc/tegra/tegra20_ac97.c:			dev_err(&pdev->dev, "could not get codec-reset GPIO\n");
sound/soc/tegra/tegra20_ac97.c:		dev_err(&pdev->dev, "no codec-reset GPIO supplied\n");
sound/soc/tegra/tegra20_ac97.c:	ac97->sync_gpio = of_get_named_gpio(pdev->dev.of_node,
sound/soc/tegra/tegra20_ac97.c:		dev_err(&pdev->dev, "no codec-sync GPIO supplied\n");
sound/soc/tegra/tegra20_ac97.c:	ret = snd_soc_register_component(&pdev->dev, &tegra20_ac97_component,
sound/soc/tegra/tegra20_ac97.c:		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
sound/soc/tegra/tegra20_ac97.c:	ret = tegra_pcm_platform_register(&pdev->dev);
sound/soc/tegra/tegra20_ac97.c:		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
sound/soc/tegra/tegra20_ac97.c:	ret = tegra_asoc_utils_init(&ac97->util_data, &pdev->dev);
sound/soc/tegra/tegra20_ac97.c:		dev_err(&pdev->dev, "clk_enable failed: %d\n", ret);
sound/soc/tegra/tegra20_ac97.c:	tegra_pcm_platform_unregister(&pdev->dev);
sound/soc/tegra/tegra20_ac97.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/tegra/tegra20_ac97.c:	struct tegra20_ac97 *ac97 = dev_get_drvdata(&pdev->dev);
sound/soc/tegra/tegra20_ac97.c:	tegra_pcm_platform_unregister(&pdev->dev);
sound/soc/tegra/tegra20_ac97.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/tegra/tegra20_das.c:	das = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_das), GFP_KERNEL);
sound/soc/tegra/tegra20_das.c:		dev_err(&pdev->dev, "Can't allocate tegra20_das\n");
sound/soc/tegra/tegra20_das.c:	das->dev = &pdev->dev;
sound/soc/tegra/tegra20_das.c:		dev_err(&pdev->dev, "No memory resource\n");
sound/soc/tegra/tegra20_das.c:	region = devm_request_mem_region(&pdev->dev, res->start,
sound/soc/tegra/tegra20_das.c:					 resource_size(res), pdev->name);
sound/soc/tegra/tegra20_das.c:		dev_err(&pdev->dev, "Memory region already claimed\n");
sound/soc/tegra/tegra20_das.c:	regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));
sound/soc/tegra/tegra20_das.c:		dev_err(&pdev->dev, "ioremap failed\n");
sound/soc/tegra/tegra20_das.c:	das->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
sound/soc/tegra/tegra20_das.c:		dev_err(&pdev->dev, "regmap init failed\n");
sound/soc/tegra/tegra20_das.c:		dev_err(&pdev->dev, "Can't set up DAS DAP connection\n");
sound/soc/tegra/tegra20_das.c:		dev_err(&pdev->dev, "Can't set up DAS DAC connection\n");
sound/soc/tegra/tegra20_das.c:		dev_err(&pdev->dev, "Can't set up DAS DAP connection\n");
sound/soc/tegra/tegra20_das.c:		dev_err(&pdev->dev, "Can't set up DAS DAC connection\n");
sound/soc/tegra/tegra30_i2s.c:	i2s = devm_kzalloc(&pdev->dev, sizeof(struct tegra30_i2s), GFP_KERNEL);
sound/soc/tegra/tegra30_i2s.c:		dev_err(&pdev->dev, "Can't allocate tegra30_i2s\n");
sound/soc/tegra/tegra30_i2s.c:	dev_set_drvdata(&pdev->dev, i2s);
sound/soc/tegra/tegra30_i2s.c:	i2s->dai.name = dev_name(&pdev->dev);
sound/soc/tegra/tegra30_i2s.c:	ret = of_property_read_u32_array(pdev->dev.of_node,
sound/soc/tegra/tegra30_i2s.c:	i2s->clk_i2s = clk_get(&pdev->dev, NULL);
sound/soc/tegra/tegra30_i2s.c:		dev_err(&pdev->dev, "Can't retrieve i2s clock\n");
sound/soc/tegra/tegra30_i2s.c:		dev_err(&pdev->dev, "No memory resource\n");
sound/soc/tegra/tegra30_i2s.c:	memregion = devm_request_mem_region(&pdev->dev, mem->start,
sound/soc/tegra/tegra30_i2s.c:		dev_err(&pdev->dev, "Memory region already claimed\n");
sound/soc/tegra/tegra30_i2s.c:	regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
sound/soc/tegra/tegra30_i2s.c:		dev_err(&pdev->dev, "ioremap failed\n");
sound/soc/tegra/tegra30_i2s.c:	i2s->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
sound/soc/tegra/tegra30_i2s.c:		dev_err(&pdev->dev, "regmap init failed\n");
sound/soc/tegra/tegra30_i2s.c:	pm_runtime_enable(&pdev->dev);
sound/soc/tegra/tegra30_i2s.c:	if (!pm_runtime_enabled(&pdev->dev)) {
sound/soc/tegra/tegra30_i2s.c:		ret = tegra30_i2s_runtime_resume(&pdev->dev);
sound/soc/tegra/tegra30_i2s.c:	ret = snd_soc_register_component(&pdev->dev, &tegra30_i2s_component,
sound/soc/tegra/tegra30_i2s.c:		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
sound/soc/tegra/tegra30_i2s.c:	ret = tegra_pcm_platform_register(&pdev->dev);
sound/soc/tegra/tegra30_i2s.c:		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
sound/soc/tegra/tegra30_i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/tegra/tegra30_i2s.c:	if (!pm_runtime_status_suspended(&pdev->dev))
sound/soc/tegra/tegra30_i2s.c:		tegra30_i2s_runtime_suspend(&pdev->dev);
sound/soc/tegra/tegra30_i2s.c:	pm_runtime_disable(&pdev->dev);
sound/soc/tegra/tegra30_i2s.c:	struct tegra30_i2s *i2s = dev_get_drvdata(&pdev->dev);
sound/soc/tegra/tegra30_i2s.c:	pm_runtime_disable(&pdev->dev);
sound/soc/tegra/tegra30_i2s.c:	if (!pm_runtime_status_suspended(&pdev->dev))
sound/soc/tegra/tegra30_i2s.c:		tegra30_i2s_runtime_suspend(&pdev->dev);
sound/soc/tegra/tegra30_i2s.c:	tegra_pcm_platform_unregister(&pdev->dev);
sound/soc/tegra/tegra30_i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/tegra/tegra_wm9712.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/tegra/tegra_wm9712.c:	machine = devm_kzalloc(&pdev->dev, sizeof(struct tegra_wm9712),
sound/soc/tegra/tegra_wm9712.c:		dev_err(&pdev->dev, "Can't allocate tegra_wm9712 struct\n");
sound/soc/tegra/tegra_wm9712.c:	card->dev = &pdev->dev;
sound/soc/tegra/tegra_wm9712.c:		dev_err(&pdev->dev, "Can't allocate wm9712 platform device\n");
sound/soc/tegra/tegra_wm9712.c:		dev_err(&pdev->dev,
sound/soc/tegra/tegra_wm9712.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/tegra/tegra20_i2s.c:	i2s = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_i2s), GFP_KERNEL);
sound/soc/tegra/tegra20_i2s.c:		dev_err(&pdev->dev, "Can't allocate tegra20_i2s\n");
sound/soc/tegra/tegra20_i2s.c:	dev_set_drvdata(&pdev->dev, i2s);
sound/soc/tegra/tegra20_i2s.c:	i2s->dai.name = dev_name(&pdev->dev);
sound/soc/tegra/tegra20_i2s.c:	i2s->clk_i2s = clk_get(&pdev->dev, NULL);
sound/soc/tegra/tegra20_i2s.c:		dev_err(&pdev->dev, "Can't retrieve i2s clock\n");
sound/soc/tegra/tegra20_i2s.c:		dev_err(&pdev->dev, "No memory resource\n");
sound/soc/tegra/tegra20_i2s.c:		if (of_property_read_u32_array(pdev->dev.of_node,
sound/soc/tegra/tegra20_i2s.c:			dev_err(&pdev->dev, "No DMA resource\n");
sound/soc/tegra/tegra20_i2s.c:	memregion = devm_request_mem_region(&pdev->dev, mem->start,
sound/soc/tegra/tegra20_i2s.c:		dev_err(&pdev->dev, "Memory region already claimed\n");
sound/soc/tegra/tegra20_i2s.c:	regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
sound/soc/tegra/tegra20_i2s.c:		dev_err(&pdev->dev, "ioremap failed\n");
sound/soc/tegra/tegra20_i2s.c:	i2s->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
sound/soc/tegra/tegra20_i2s.c:		dev_err(&pdev->dev, "regmap init failed\n");
sound/soc/tegra/tegra20_i2s.c:	pm_runtime_enable(&pdev->dev);
sound/soc/tegra/tegra20_i2s.c:	if (!pm_runtime_enabled(&pdev->dev)) {
sound/soc/tegra/tegra20_i2s.c:		ret = tegra20_i2s_runtime_resume(&pdev->dev);
sound/soc/tegra/tegra20_i2s.c:	ret = snd_soc_register_component(&pdev->dev, &tegra20_i2s_component,
sound/soc/tegra/tegra20_i2s.c:		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
sound/soc/tegra/tegra20_i2s.c:	ret = tegra_pcm_platform_register(&pdev->dev);
sound/soc/tegra/tegra20_i2s.c:		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
sound/soc/tegra/tegra20_i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/tegra/tegra20_i2s.c:	if (!pm_runtime_status_suspended(&pdev->dev))
sound/soc/tegra/tegra20_i2s.c:		tegra20_i2s_runtime_suspend(&pdev->dev);
sound/soc/tegra/tegra20_i2s.c:	pm_runtime_disable(&pdev->dev);
sound/soc/tegra/tegra20_i2s.c:	struct tegra20_i2s *i2s = dev_get_drvdata(&pdev->dev);
sound/soc/tegra/tegra20_i2s.c:	pm_runtime_disable(&pdev->dev);
sound/soc/tegra/tegra20_i2s.c:	if (!pm_runtime_status_suspended(&pdev->dev))
sound/soc/tegra/tegra20_i2s.c:		tegra20_i2s_runtime_suspend(&pdev->dev);
sound/soc/tegra/tegra20_i2s.c:	tegra_pcm_platform_unregister(&pdev->dev);
sound/soc/tegra/tegra20_i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/tegra/tegra20_spdif.c:	spdif = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_spdif),
sound/soc/tegra/tegra20_spdif.c:		dev_err(&pdev->dev, "Can't allocate tegra20_spdif\n");
sound/soc/tegra/tegra20_spdif.c:	dev_set_drvdata(&pdev->dev, spdif);
sound/soc/tegra/tegra20_spdif.c:	spdif->clk_spdif_out = clk_get(&pdev->dev, "spdif_out");
sound/soc/tegra/tegra20_spdif.c:		dev_err(&pdev->dev, "No memory resource\n");
sound/soc/tegra/tegra20_spdif.c:		dev_err(&pdev->dev, "No DMA resource\n");
sound/soc/tegra/tegra20_spdif.c:	memregion = devm_request_mem_region(&pdev->dev, mem->start,
sound/soc/tegra/tegra20_spdif.c:		dev_err(&pdev->dev, "Memory region already claimed\n");
sound/soc/tegra/tegra20_spdif.c:	regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
sound/soc/tegra/tegra20_spdif.c:		dev_err(&pdev->dev, "ioremap failed\n");
sound/soc/tegra/tegra20_spdif.c:	spdif->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
sound/soc/tegra/tegra20_spdif.c:		dev_err(&pdev->dev, "regmap init failed\n");
sound/soc/tegra/tegra20_spdif.c:	pm_runtime_enable(&pdev->dev);
sound/soc/tegra/tegra20_spdif.c:	if (!pm_runtime_enabled(&pdev->dev)) {
sound/soc/tegra/tegra20_spdif.c:		ret = tegra20_spdif_runtime_resume(&pdev->dev);
sound/soc/tegra/tegra20_spdif.c:	ret = snd_soc_register_component(&pdev->dev, &tegra20_spdif_component,
sound/soc/tegra/tegra20_spdif.c:		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
sound/soc/tegra/tegra20_spdif.c:	ret = tegra_pcm_platform_register(&pdev->dev);
sound/soc/tegra/tegra20_spdif.c:		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
sound/soc/tegra/tegra20_spdif.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/tegra/tegra20_spdif.c:	if (!pm_runtime_status_suspended(&pdev->dev))
sound/soc/tegra/tegra20_spdif.c:		tegra20_spdif_runtime_suspend(&pdev->dev);
sound/soc/tegra/tegra20_spdif.c:	pm_runtime_disable(&pdev->dev);
sound/soc/tegra/tegra20_spdif.c:	struct tegra20_spdif *spdif = dev_get_drvdata(&pdev->dev);
sound/soc/tegra/tegra20_spdif.c:	pm_runtime_disable(&pdev->dev);
sound/soc/tegra/tegra20_spdif.c:	if (!pm_runtime_status_suspended(&pdev->dev))
sound/soc/tegra/tegra20_spdif.c:		tegra20_spdif_runtime_suspend(&pdev->dev);
sound/soc/tegra/tegra20_spdif.c:	tegra_pcm_platform_unregister(&pdev->dev);
sound/soc/tegra/tegra20_spdif.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/tegra/tegra30_ahub.c:	match = of_match_device(tegra30_ahub_of_match, &pdev->dev);
sound/soc/tegra/tegra30_ahub.c:		clk = clk_get(&pdev->dev, configlink_clocks[i].clk_name);
sound/soc/tegra/tegra30_ahub.c:			dev_err(&pdev->dev, "Can't get clock %s\n",
sound/soc/tegra/tegra30_ahub.c:	ahub = devm_kzalloc(&pdev->dev, sizeof(struct tegra30_ahub),
sound/soc/tegra/tegra30_ahub.c:		dev_err(&pdev->dev, "Can't allocate tegra30_ahub\n");
sound/soc/tegra/tegra30_ahub.c:	dev_set_drvdata(&pdev->dev, ahub);
sound/soc/tegra/tegra30_ahub.c:	ahub->dev = &pdev->dev;
sound/soc/tegra/tegra30_ahub.c:	ahub->clk_d_audio = clk_get(&pdev->dev, "d_audio");
sound/soc/tegra/tegra30_ahub.c:		dev_err(&pdev->dev, "Can't retrieve ahub d_audio clock\n");
sound/soc/tegra/tegra30_ahub.c:	ahub->clk_apbif = clk_get(&pdev->dev, "apbif");
sound/soc/tegra/tegra30_ahub.c:		dev_err(&pdev->dev, "Can't retrieve ahub apbif clock\n");
sound/soc/tegra/tegra30_ahub.c:	if (of_property_read_u32_array(pdev->dev.of_node,
sound/soc/tegra/tegra30_ahub.c:		dev_err(&pdev->dev,
sound/soc/tegra/tegra30_ahub.c:		dev_err(&pdev->dev, "No apbif memory resource\n");
sound/soc/tegra/tegra30_ahub.c:	region = devm_request_mem_region(&pdev->dev, res0->start,
sound/soc/tegra/tegra30_ahub.c:		dev_err(&pdev->dev, "request region apbif failed\n");
sound/soc/tegra/tegra30_ahub.c:	regs_apbif = devm_ioremap(&pdev->dev, res0->start,
sound/soc/tegra/tegra30_ahub.c:		dev_err(&pdev->dev, "ioremap apbif failed\n");
sound/soc/tegra/tegra30_ahub.c:	ahub->regmap_apbif = devm_regmap_init_mmio(&pdev->dev, regs_apbif,
sound/soc/tegra/tegra30_ahub.c:		dev_err(&pdev->dev, "apbif regmap init failed\n");
sound/soc/tegra/tegra30_ahub.c:		dev_err(&pdev->dev, "No ahub memory resource\n");
sound/soc/tegra/tegra30_ahub.c:	region = devm_request_mem_region(&pdev->dev, res1->start,
sound/soc/tegra/tegra30_ahub.c:		dev_err(&pdev->dev, "request region ahub failed\n");
sound/soc/tegra/tegra30_ahub.c:	regs_ahub = devm_ioremap(&pdev->dev, res1->start,
sound/soc/tegra/tegra30_ahub.c:		dev_err(&pdev->dev, "ioremap ahub failed\n");
sound/soc/tegra/tegra30_ahub.c:	ahub->regmap_ahub = devm_regmap_init_mmio(&pdev->dev, regs_ahub,
sound/soc/tegra/tegra30_ahub.c:		dev_err(&pdev->dev, "ahub regmap init failed\n");
sound/soc/tegra/tegra30_ahub.c:	pm_runtime_enable(&pdev->dev);
sound/soc/tegra/tegra30_ahub.c:	if (!pm_runtime_enabled(&pdev->dev)) {
sound/soc/tegra/tegra30_ahub.c:		ret = tegra30_ahub_runtime_resume(&pdev->dev);
sound/soc/tegra/tegra30_ahub.c:	of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);
sound/soc/tegra/tegra30_ahub.c:	pm_runtime_disable(&pdev->dev);
sound/soc/tegra/tegra30_ahub.c:	pm_runtime_disable(&pdev->dev);
sound/soc/tegra/tegra30_ahub.c:	if (!pm_runtime_status_suspended(&pdev->dev))
sound/soc/tegra/tegra30_ahub.c:		tegra30_ahub_runtime_suspend(&pdev->dev);
sound/soc/tegra/tegra_wm8903.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/tegra/tegra_wm8903.c:	machine = devm_kzalloc(&pdev->dev, sizeof(struct tegra_wm8903),
sound/soc/tegra/tegra_wm8903.c:		dev_err(&pdev->dev, "Can't allocate tegra_wm8903 struct\n");
sound/soc/tegra/tegra_wm8903.c:	card->dev = &pdev->dev;
sound/soc/tegra/tegra_wm8903.c:		ret = devm_gpio_request_one(&pdev->dev, machine->gpio_spkr_en,
sound/soc/tegra/tegra_wm8903.c:		ret = devm_gpio_request_one(&pdev->dev, machine->gpio_hp_mute,
sound/soc/tegra/tegra_wm8903.c:		ret = devm_gpio_request_one(&pdev->dev,
sound/soc/tegra/tegra_wm8903.c:		ret = devm_gpio_request_one(&pdev->dev,
sound/soc/tegra/tegra_wm8903.c:		dev_err(&pdev->dev,
sound/soc/tegra/tegra_wm8903.c:		dev_err(&pdev->dev,
sound/soc/tegra/tegra_wm8903.c:	ret = tegra_asoc_utils_init(&machine->util_data, &pdev->dev);
sound/soc/tegra/tegra_wm8903.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/tegra/tegra_alc5632.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/tegra/tegra_alc5632.c:	alc5632 = devm_kzalloc(&pdev->dev,
sound/soc/tegra/tegra_alc5632.c:		dev_err(&pdev->dev, "Can't allocate tegra_alc5632\n");
sound/soc/tegra/tegra_alc5632.c:	card->dev = &pdev->dev;
sound/soc/tegra/tegra_alc5632.c:			pdev->dev.of_node, "nvidia,audio-codec", 0);
sound/soc/tegra/tegra_alc5632.c:		dev_err(&pdev->dev,
sound/soc/tegra/tegra_alc5632.c:		dev_err(&pdev->dev,
sound/soc/tegra/tegra_alc5632.c:	ret = tegra_asoc_utils_init(&alc5632->util_data, &pdev->dev);
sound/soc/tegra/tegra_alc5632.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/soc-core.c:	dev_warn(&pdev->dev,
sound/soc/soc-core.c:	card->dev = &pdev->dev;
sound/soc/cirrus/simone.c:	card->dev = &pdev->dev;
sound/soc/cirrus/simone.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/cirrus/ep93xx-ac97.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
sound/soc/cirrus/ep93xx-ac97.c:	info->regs = devm_ioremap_resource(&pdev->dev, res);
sound/soc/cirrus/ep93xx-ac97.c:	ret = devm_request_irq(&pdev->dev, irq, ep93xx_ac97_interrupt,
sound/soc/cirrus/ep93xx-ac97.c:			       IRQF_TRIGGER_HIGH, pdev->name, info);
sound/soc/cirrus/ep93xx-ac97.c:	dev_set_drvdata(&pdev->dev, info);
sound/soc/cirrus/ep93xx-ac97.c:	info->dev = &pdev->dev;
sound/soc/cirrus/ep93xx-ac97.c:	ret = snd_soc_register_component(&pdev->dev, &ep93xx_ac97_component,
sound/soc/cirrus/ep93xx-ac97.c:	dev_set_drvdata(&pdev->dev, NULL);
sound/soc/cirrus/ep93xx-ac97.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/cirrus/ep93xx-ac97.c:	dev_set_drvdata(&pdev->dev, NULL);
sound/soc/cirrus/ep93xx-i2s.c:	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
sound/soc/cirrus/ep93xx-i2s.c:	info->regs = devm_ioremap_resource(&pdev->dev, res);
sound/soc/cirrus/ep93xx-i2s.c:	info->mclk = clk_get(&pdev->dev, "mclk");
sound/soc/cirrus/ep93xx-i2s.c:	info->sclk = clk_get(&pdev->dev, "sclk");
sound/soc/cirrus/ep93xx-i2s.c:	info->lrclk = clk_get(&pdev->dev, "lrclk");
sound/soc/cirrus/ep93xx-i2s.c:	dev_set_drvdata(&pdev->dev, info);
sound/soc/cirrus/ep93xx-i2s.c:	err = snd_soc_register_component(&pdev->dev, &ep93xx_i2s_component,
sound/soc/cirrus/ep93xx-i2s.c:	dev_set_drvdata(&pdev->dev, NULL);
sound/soc/cirrus/ep93xx-i2s.c:	struct ep93xx_i2s_info *info = dev_get_drvdata(&pdev->dev);
sound/soc/cirrus/ep93xx-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/cirrus/ep93xx-i2s.c:	dev_set_drvdata(&pdev->dev, NULL);
sound/soc/cirrus/ep93xx-pcm.c:	return snd_soc_register_platform(&pdev->dev, &ep93xx_soc_platform);
sound/soc/cirrus/ep93xx-pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/cirrus/edb93xx.c:	card->dev = &pdev->dev;
sound/soc/cirrus/edb93xx.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/cirrus/snappercl15.c:	card->dev = &pdev->dev;
sound/soc/cirrus/snappercl15.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/fsl/mpc8610_hpcd.c:	struct device *dev = pdev->dev.parent;
sound/soc/fsl/mpc8610_hpcd.c:	struct device_node *np = ssi_pdev->dev.of_node;
sound/soc/fsl/mpc8610_hpcd.c:	machine_data->dai[0].cpu_dai_name = dev_name(&ssi_pdev->dev);
sound/soc/fsl/mpc8610_hpcd.c:		dev_err(&pdev->dev, "cell-index property not found\n");
sound/soc/fsl/mpc8610_hpcd.c:		dev_err(&pdev->dev, "fsl,mode property not found\n");
sound/soc/fsl/mpc8610_hpcd.c:			dev_err(&pdev->dev, "codec bus-frequency "
sound/soc/fsl/mpc8610_hpcd.c:		dev_err(&pdev->dev,
sound/soc/fsl/mpc8610_hpcd.c:		dev_err(&pdev->dev, "unknown clock frequency\n");
sound/soc/fsl/mpc8610_hpcd.c:		dev_err(&pdev->dev, "missing/invalid playback DMA phandle\n");
sound/soc/fsl/mpc8610_hpcd.c:		dev_err(&pdev->dev, "missing/invalid capture DMA phandle\n");
sound/soc/fsl/mpc8610_hpcd.c:	machine_data->card.name = pdev->name; /* The platform driver name */
sound/soc/fsl/mpc8610_hpcd.c:	machine_data->card.dev = &pdev->dev;
sound/soc/fsl/mpc8610_hpcd.c:		dev_err(&pdev->dev, "could not register card\n");
sound/soc/fsl/imx-pcm-fiq.c:		dev_err(&pdev->dev, "failed to claim fiq: %d", ret);
sound/soc/fsl/imx-pcm-fiq.c:	ret = snd_soc_register_platform(&pdev->dev, &imx_soc_platform_fiq);
sound/soc/fsl/imx-mc13783.c:	imx_mc13783.dev = &pdev->dev;
sound/soc/fsl/imx-mc13783.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/fsl/imx-audmux.c:			of_match_device(imx_audmux_dt_ids, &pdev->dev);
sound/soc/fsl/imx-audmux.c:	audmux_base = devm_ioremap_resource(&pdev->dev, res);
sound/soc/fsl/imx-audmux.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
sound/soc/fsl/imx-audmux.c:		dev_err(&pdev->dev, "setup pinctrl failed!");
sound/soc/fsl/imx-audmux.c:	audmux_clk = devm_clk_get(&pdev->dev, "audmux");
sound/soc/fsl/imx-audmux.c:		dev_dbg(&pdev->dev, "cannot get clock: %ld\n",
sound/soc/fsl/imx-audmux.c:		pdev->id_entry = of_id->data;
sound/soc/fsl/imx-audmux.c:	audmux_type = pdev->id_entry->driver_data;
sound/soc/fsl/fsl_ssi.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/fsl/fsl_ssi.c:		dev_notice(&pdev->dev, "mode %s is unsupported\n", sprop);
sound/soc/fsl/fsl_ssi.c:		dev_err(&pdev->dev, "could not allocate DAI object\n");
sound/soc/fsl/fsl_ssi.c:		dev_err(&pdev->dev, "could not determine device resources\n");
sound/soc/fsl/fsl_ssi.c:		dev_err(&pdev->dev, "could not map device resources\n");
sound/soc/fsl/fsl_ssi.c:		dev_err(&pdev->dev, "no irq for node %s\n", np->full_name);
sound/soc/fsl/fsl_ssi.c:		dev_err(&pdev->dev, "could not claim irq %u\n", ssi_private->irq);
sound/soc/fsl/fsl_ssi.c:	if (of_device_is_compatible(pdev->dev.of_node, "fsl,imx21-ssi")) {
sound/soc/fsl/fsl_ssi.c:		ssi_private->clk = clk_get(&pdev->dev, NULL);
sound/soc/fsl/fsl_ssi.c:			dev_err(&pdev->dev, "could not get clock: %d\n", ret);
sound/soc/fsl/fsl_ssi.c:		ret = of_property_read_u32_array(pdev->dev.of_node,
sound/soc/fsl/fsl_ssi.c:			dev_err(&pdev->dev, "could not get dma events\n");
sound/soc/fsl/fsl_ssi.c:	ret = device_create_file(&pdev->dev, dev_attr);
sound/soc/fsl/fsl_ssi.c:		dev_err(&pdev->dev, "could not create sysfs %s file\n",
sound/soc/fsl/fsl_ssi.c:	dev_set_drvdata(&pdev->dev, ssi_private);
sound/soc/fsl/fsl_ssi.c:	ret = snd_soc_register_component(&pdev->dev, &fsl_ssi_component,
sound/soc/fsl/fsl_ssi.c:		dev_err(&pdev->dev, "failed to register DAI: %d\n", ret);
sound/soc/fsl/fsl_ssi.c:		platform_device_register_data(&pdev->dev, name, 0, NULL, 0);
sound/soc/fsl/fsl_ssi.c:		dev_err(&pdev->dev, "failed to register platform: %d\n", ret);
sound/soc/fsl/fsl_ssi.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/fsl/fsl_ssi.c:	dev_set_drvdata(&pdev->dev, NULL);
sound/soc/fsl/fsl_ssi.c:	device_remove_file(&pdev->dev, dev_attr);
sound/soc/fsl/fsl_ssi.c:	struct fsl_ssi_private *ssi_private = dev_get_drvdata(&pdev->dev);
sound/soc/fsl/fsl_ssi.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/fsl/fsl_ssi.c:	device_remove_file(&pdev->dev, &ssi_private->dev_attr);
sound/soc/fsl/fsl_ssi.c:	dev_set_drvdata(&pdev->dev, NULL);
sound/soc/fsl/p1022_rdk.c:	struct device *dev = pdev->dev.parent;
sound/soc/fsl/p1022_rdk.c:	struct device_node *np = ssi_pdev->dev.of_node;
sound/soc/fsl/p1022_rdk.c:	mdata->dai[0].cpu_dai_name = dev_name(&ssi_pdev->dev);
sound/soc/fsl/p1022_rdk.c:		dev_err(&pdev->dev, "codec bus-frequency property is missing or invalid\n");
sound/soc/fsl/p1022_rdk.c:		dev_err(&pdev->dev, "unknown clock frequency\n");
sound/soc/fsl/p1022_rdk.c:		dev_err(&pdev->dev, "missing/invalid playback DMA phandle (ret=%i)\n",
sound/soc/fsl/p1022_rdk.c:		dev_err(&pdev->dev, "missing/invalid capture DMA phandle (ret=%i)\n",
sound/soc/fsl/p1022_rdk.c:	mdata->card.name = pdev->name; /* The platform driver name */
sound/soc/fsl/p1022_rdk.c:	mdata->card.dev = &pdev->dev;
sound/soc/fsl/p1022_rdk.c:		dev_err(&pdev->dev, "could not register card (ret=%i)\n", ret);
sound/soc/fsl/eukrea-tlv320.c:	eukrea_tlv320.dev = &pdev->dev;
sound/soc/fsl/eukrea-tlv320.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
sound/soc/fsl/imx-sgtl5000.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/fsl/imx-sgtl5000.c:		dev_err(&pdev->dev, "mux-int-port missing or invalid\n");
sound/soc/fsl/imx-sgtl5000.c:		dev_err(&pdev->dev, "mux-ext-port missing or invalid\n");
sound/soc/fsl/imx-sgtl5000.c:		dev_err(&pdev->dev, "audmux internal port setup failed\n");
sound/soc/fsl/imx-sgtl5000.c:		dev_err(&pdev->dev, "audmux external port setup failed\n");
sound/soc/fsl/imx-sgtl5000.c:	ssi_np = of_parse_phandle(pdev->dev.of_node, "ssi-controller", 0);
sound/soc/fsl/imx-sgtl5000.c:	codec_np = of_parse_phandle(pdev->dev.of_node, "audio-codec", 0);
sound/soc/fsl/imx-sgtl5000.c:		dev_err(&pdev->dev, "phandle missing or invalid\n");
sound/soc/fsl/imx-sgtl5000.c:		dev_err(&pdev->dev, "failed to find SSI platform device\n");
sound/soc/fsl/imx-sgtl5000.c:		dev_err(&pdev->dev, "failed to find codec platform device\n");
sound/soc/fsl/imx-sgtl5000.c:	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
sound/soc/fsl/imx-sgtl5000.c:	data->card.dev = &pdev->dev;
sound/soc/fsl/imx-sgtl5000.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
sound/soc/fsl/imx-ssi.c:	struct imx_ssi_platform_data *pdata = pdev->dev.platform_data;
sound/soc/fsl/imx-ssi.c:	ssi = devm_kzalloc(&pdev->dev, sizeof(*ssi), GFP_KERNEL);
sound/soc/fsl/imx-ssi.c:	dev_set_drvdata(&pdev->dev, ssi);
sound/soc/fsl/imx-ssi.c:	ssi->clk = devm_clk_get(&pdev->dev, NULL);
sound/soc/fsl/imx-ssi.c:		dev_err(&pdev->dev, "Cannot get the clock: %d\n",
sound/soc/fsl/imx-ssi.c:	ssi->base = devm_ioremap_resource(&pdev->dev, res);
sound/soc/fsl/imx-ssi.c:			dev_err(&pdev->dev, "AC'97 SSI already registered\n");
sound/soc/fsl/imx-ssi.c:	ret = snd_soc_register_component(&pdev->dev, &imx_component,
sound/soc/fsl/imx-ssi.c:		dev_err(&pdev->dev, "register DAI failed\n");
sound/soc/fsl/imx-ssi.c:	ssi->soc_platform_pdev_fiq = platform_device_alloc("imx-fiq-pcm-audio", pdev->id);
sound/soc/fsl/imx-ssi.c:		dev_err(&pdev->dev, "failed to add platform device\n");
sound/soc/fsl/imx-ssi.c:	ssi->soc_platform_pdev = platform_device_alloc("imx-pcm-audio", pdev->id);
sound/soc/fsl/imx-ssi.c:		dev_err(&pdev->dev, "failed to add platform device\n");
sound/soc/fsl/imx-ssi.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/fsl/imx-ssi.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/fsl/p1022_ds.c:	struct device *dev = pdev->dev.parent;
sound/soc/fsl/p1022_ds.c:	struct device_node *np = ssi_pdev->dev.of_node;
sound/soc/fsl/p1022_ds.c:	mdata->dai[0].cpu_dai_name = dev_name(&ssi_pdev->dev);
sound/soc/fsl/p1022_ds.c:		dev_err(&pdev->dev, "cell-index property not found\n");
sound/soc/fsl/p1022_ds.c:		dev_err(&pdev->dev, "fsl,mode property not found\n");
sound/soc/fsl/p1022_ds.c:			dev_err(&pdev->dev, "codec bus-frequency "
sound/soc/fsl/p1022_ds.c:		dev_err(&pdev->dev,
sound/soc/fsl/p1022_ds.c:		dev_err(&pdev->dev, "unknown clock frequency\n");
sound/soc/fsl/p1022_ds.c:		dev_err(&pdev->dev, "missing/invalid playback DMA phandle\n");
sound/soc/fsl/p1022_ds.c:		dev_err(&pdev->dev, "missing/invalid capture DMA phandle\n");
sound/soc/fsl/p1022_ds.c:	mdata->card.name = pdev->name; /* The platform driver name */
sound/soc/fsl/p1022_ds.c:	mdata->card.dev = &pdev->dev;
sound/soc/fsl/p1022_ds.c:		dev_err(&pdev->dev, "could not register card\n");
sound/soc/fsl/mx27vis-aic32x4.c:	struct snd_mx27vis_platform_data *pdata = pdev->dev.platform_data;
sound/soc/fsl/mx27vis-aic32x4.c:		dev_err(&pdev->dev, "No platform data supplied\n");
sound/soc/fsl/mx27vis-aic32x4.c:	mx27vis_aic32x4.dev = &pdev->dev;
sound/soc/fsl/mx27vis-aic32x4.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/fsl/fsl_dma.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/fsl/fsl_dma.c:		dev_err(&pdev->dev, "cannot find parent SSI node\n");
sound/soc/fsl/fsl_dma.c:		dev_err(&pdev->dev, "could not determine resources for %s\n",
sound/soc/fsl/fsl_dma.c:		dev_err(&pdev->dev, "could not allocate dma object\n");
sound/soc/fsl/fsl_dma.c:	ret = snd_soc_register_platform(&pdev->dev, &dma->dai);
sound/soc/fsl/fsl_dma.c:		dev_err(&pdev->dev, "could not register platform\n");
sound/soc/fsl/fsl_dma.c:	dev_set_drvdata(&pdev->dev, dma);
sound/soc/fsl/fsl_dma.c:	struct dma_object *dma = dev_get_drvdata(&pdev->dev);
sound/soc/fsl/fsl_dma.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/fsl/imx-pcm-dma.c:	return snd_dmaengine_pcm_register(&pdev->dev, &imx_dmaengine_pcm_config,
sound/soc/fsl/imx-pcm-dma.c:	snd_dmaengine_pcm_unregister(&pdev->dev);
sound/soc/fsl/imx-pcm.c:	if (strcmp(pdev->id_entry->name, "imx-fiq-pcm-audio") == 0)
sound/soc/fsl/imx-pcm.c:	if (strcmp(pdev->id_entry->name, "imx-fiq-pcm-audio") == 0)
sound/soc/fsl/imx-pcm.c:		snd_soc_unregister_platform(&pdev->dev);
sound/soc/ux500/ux500_msp_dai.c:	dev_dbg(&pdev->dev, "%s: Enter (pdev->name = %s).\n", __func__,
sound/soc/ux500/ux500_msp_dai.c:		pdev->name);
sound/soc/ux500/ux500_msp_dai.c:	drvdata = devm_kzalloc(&pdev->dev,
sound/soc/ux500/ux500_msp_dai.c:	drvdata->reg_vape = devm_regulator_get(&pdev->dev, "v-ape");
sound/soc/ux500/ux500_msp_dai.c:		dev_err(&pdev->dev,
sound/soc/ux500/ux500_msp_dai.c:	prcmu_qos_add_requirement(PRCMU_QOS_APE_OPP, (char *)pdev->name, 50);
sound/soc/ux500/ux500_msp_dai.c:	drvdata->pclk = clk_get(&pdev->dev, "apb_pclk");
sound/soc/ux500/ux500_msp_dai.c:		dev_err(&pdev->dev, "%s: ERROR: clk_get of pclk failed (%d)!\n",
sound/soc/ux500/ux500_msp_dai.c:	drvdata->clk = clk_get(&pdev->dev, NULL);
sound/soc/ux500/ux500_msp_dai.c:		dev_err(&pdev->dev, "%s: ERROR: clk_get failed (%d)!\n",
sound/soc/ux500/ux500_msp_dai.c:				pdev->dev.platform_data);
sound/soc/ux500/ux500_msp_dai.c:		dev_err(&pdev->dev,
sound/soc/ux500/ux500_msp_dai.c:	dev_set_drvdata(&pdev->dev, drvdata);
sound/soc/ux500/ux500_msp_dai.c:	ret = snd_soc_register_component(&pdev->dev, &ux500_msp_component,
sound/soc/ux500/ux500_msp_dai.c:		dev_err(&pdev->dev, "Error: %s: Failed to register MSP%d!\n",
sound/soc/ux500/ux500_msp_dai.c:		dev_err(&pdev->dev,
sound/soc/ux500/ux500_msp_dai.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/ux500/ux500_msp_dai.c:	struct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(&pdev->dev);
sound/soc/ux500/ux500_msp_dai.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/ux500/ux500_msp_i2s.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/ux500/ux500_msp_i2s.c:	*msp_p = devm_kzalloc(&pdev->dev, sizeof(struct ux500_msp), GFP_KERNEL);
sound/soc/ux500/ux500_msp_i2s.c:			platform_data = devm_kzalloc(&pdev->dev,
sound/soc/ux500/ux500_msp_i2s.c:	dev_dbg(&pdev->dev, "%s: Enter (name: %s, id: %d).\n", __func__,
sound/soc/ux500/ux500_msp_i2s.c:		pdev->name, platform_data->id);
sound/soc/ux500/ux500_msp_i2s.c:	msp->dev = &pdev->dev;
sound/soc/ux500/ux500_msp_i2s.c:		dev_err(&pdev->dev, "%s: ERROR: Unable to get resource!\n",
sound/soc/ux500/ux500_msp_i2s.c:	msp->registers = devm_ioremap(&pdev->dev, res->start,
sound/soc/ux500/ux500_msp_i2s.c:		dev_err(&pdev->dev, "%s: ERROR: ioremap failed!\n", __func__);
sound/soc/ux500/ux500_msp_i2s.c:	i2s_cont = devm_kzalloc(&pdev->dev, sizeof(*i2s_cont), GFP_KERNEL);
sound/soc/ux500/ux500_msp_i2s.c:		dev_err(&pdev->dev,
sound/soc/ux500/ux500_msp_i2s.c:	i2s_cont->dev.parent = &pdev->dev;
sound/soc/ux500/ux500_msp_i2s.c:	dev_dbg(&pdev->dev, "I2S device-name: '%s'\n", i2s_cont->name);
sound/soc/ux500/ux500_msp_i2s.c:		dev_err(&pdev->dev, "could not get MSP pinctrl\n");
sound/soc/ux500/ux500_msp_i2s.c:			dev_err(&pdev->dev,
sound/soc/ux500/ux500_msp_i2s.c:			dev_err(&pdev->dev,
sound/soc/ux500/mop500.c:		dev_err(&pdev->dev, "Phandle missing or invalid\n");
sound/soc/ux500/mop500.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/ux500/mop500.c:	dev_dbg(&pdev->dev, "%s: Enter.\n", __func__);
sound/soc/ux500/mop500.c:	mop500_card.dev = &pdev->dev;
sound/soc/ux500/mop500.c:	dev_dbg(&pdev->dev, "%s: Card %s: Set platform drvdata.\n",
sound/soc/ux500/mop500.c:	dev_dbg(&pdev->dev, "%s: Card %s: num_links = %d\n",
sound/soc/ux500/mop500.c:	dev_dbg(&pdev->dev, "%s: Card %s: DAI-link 0: name = %s\n",
sound/soc/ux500/mop500.c:	dev_dbg(&pdev->dev, "%s: Card %s: DAI-link 0: stream_name = %s\n",
sound/soc/ux500/mop500.c:		dev_err(&pdev->dev,
sound/soc/ux500/ux500_pcm.c:	ret = snd_dmaengine_pcm_register(&pdev->dev,
sound/soc/ux500/ux500_pcm.c:		dev_err(&pdev->dev,
sound/soc/ux500/ux500_pcm.c:			__func__, pdev->name, ret);
sound/soc/ux500/ux500_pcm.c:	snd_dmaengine_pcm_unregister(&pdev->dev);
sound/soc/nuc900/nuc900-pcm.c:	return snd_soc_register_platform(&pdev->dev, &nuc900_soc_platform);
sound/soc/nuc900/nuc900-pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/nuc900/nuc900-ac97.c:			resource_size(nuc900_audio->res), pdev->name)) {
sound/soc/nuc900/nuc900-ac97.c:	nuc900_audio->clk = clk_get(&pdev->dev, NULL);
sound/soc/nuc900/nuc900-ac97.c:	ret = snd_soc_register_component(&pdev->dev, &nuc900_ac97_component,
sound/soc/nuc900/nuc900-ac97.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/soc-utils.c:	ret = snd_soc_register_codec(&pdev->dev, &dummy_codec, &dummy_dai, 1);
sound/soc/soc-utils.c:	ret = snd_soc_register_platform(&pdev->dev, &dummy_platform);
sound/soc/soc-utils.c:		snd_soc_unregister_codec(&pdev->dev);
sound/soc/soc-utils.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/soc-utils.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/pxa/palm27x.c:	if (!pdev->dev.platform_data) {
sound/soc/pxa/palm27x.c:		dev_err(&pdev->dev, "please supply platform_data\n");
sound/soc/pxa/palm27x.c:			(pdev->dev.platform_data))->jack_gpio;
sound/soc/pxa/palm27x.c:	palm27x_asoc.dev = &pdev->dev;
sound/soc/pxa/palm27x.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/pxa/poodle.c:	card->dev = &pdev->dev;
sound/soc/pxa/poodle.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/pxa/ttc-dkb.c:	card->dev = &pdev->dev;
sound/soc/pxa/ttc-dkb.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/pxa/e740_wm9705.c:	card->dev = &pdev->dev;
sound/soc/pxa/e740_wm9705.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/pxa/mmp-pcm.c:	struct mmp_audio_platdata *pdata = pdev->dev.platform_data;
sound/soc/pxa/mmp-pcm.c:	return snd_soc_register_platform(&pdev->dev, &mmp_soc_platform);
sound/soc/pxa/mmp-pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/pxa/pxa-ssp.c:	dev_dbg(&ssp->pdev->dev, "SSCR0 0x%08x SSCR1 0x%08x SSTO 0x%08x\n",
sound/soc/pxa/pxa-ssp.c:	dev_dbg(&ssp->pdev->dev, "SSPSP 0x%08x SSSR 0x%08x SSACD 0x%08x\n",
sound/soc/pxa/pxa-ssp.c:	dev_dbg(&ssp->pdev->dev,
sound/soc/pxa/pxa-ssp.c:			dev_dbg(&ssp->pdev->dev,
sound/soc/pxa/pxa-ssp.c:		dev_err(&ssp->pdev->dev,
sound/soc/pxa/pxa-ssp.c:		dev_err(&ssp->pdev->dev, "No TDM timeslot configured\n");
sound/soc/pxa/pxa-ssp.c:	return snd_soc_register_component(&pdev->dev, &pxa_ssp_component,
sound/soc/pxa/pxa-ssp.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/pxa/brownstone.c:	brownstone.dev = &pdev->dev;
sound/soc/pxa/brownstone.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/pxa/pxa2xx-pcm.c:	return snd_soc_register_platform(&pdev->dev, &pxa2xx_soc_platform);
sound/soc/pxa/pxa2xx-pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/pxa/hx4700.c:	snd_soc_card_hx4700.dev = &pdev->dev;
sound/soc/pxa/tosa.c:	card->dev = &pdev->dev;
sound/soc/pxa/tosa.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/pxa/e750_wm9705.c:	card->dev = &pdev->dev;
sound/soc/pxa/e750_wm9705.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/pxa/imote2.c:	card->dev = &pdev->dev;
sound/soc/pxa/imote2.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/pxa/corgi.c:	card->dev = &pdev->dev;
sound/soc/pxa/corgi.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/pxa/pxa2xx-ac97.c:	if (pdev->id != -1) {
sound/soc/pxa/pxa2xx-ac97.c:		dev_err(&pdev->dev, "PXA2xx has only one AC97 port.\n");
sound/soc/pxa/pxa2xx-ac97.c:	return snd_soc_register_component(&pdev->dev, &pxa_ac97_component,
sound/soc/pxa/pxa2xx-ac97.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/pxa/pxa2xx-i2s.c:	return snd_soc_register_component(&pdev->dev, &pxa_i2s_component,
sound/soc/pxa/pxa2xx-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/pxa/e800_wm9712.c:	card->dev = &pdev->dev;
sound/soc/pxa/e800_wm9712.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/pxa/mmp-sspa.c:		dev_err(&sspa->pdev->dev,
sound/soc/pxa/mmp-sspa.c:	priv = devm_kzalloc(&pdev->dev,
sound/soc/pxa/mmp-sspa.c:	priv->sspa = devm_kzalloc(&pdev->dev,
sound/soc/pxa/mmp-sspa.c:	priv->dma_params = devm_kzalloc(&pdev->dev,
sound/soc/pxa/mmp-sspa.c:	priv->sspa->mmio_base = devm_ioremap_resource(&pdev->dev, res);
sound/soc/pxa/mmp-sspa.c:	priv->sspa->clk = devm_clk_get(&pdev->dev, NULL);
sound/soc/pxa/mmp-sspa.c:	return snd_soc_register_component(&pdev->dev, &mmp_sspa_component,
sound/soc/pxa/mmp-sspa.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/pxa/mioa701_wm9713.c:	mioa701.dev = &pdev->dev;
sound/soc/pxa/mioa701_wm9713.c:		dev_warn(&pdev->dev, "Be warned that incorrect mixers/muxes setup will"
sound/soc/atmel/atmel-pcm-dma.c:		sdata = ssc->pdev->dev.platform_data;
sound/soc/atmel/sam9g20_wm8731.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/atmel/sam9g20_wm8731.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
sound/soc/atmel/sam9g20_wm8731.c:		dev_err(&pdev->dev, "Failed to request pinctrl for mck\n");
sound/soc/atmel/sam9g20_wm8731.c:		dev_err(&pdev->dev, "ssc channel is not valid\n");
sound/soc/atmel/sam9g20_wm8731.c:	card->dev = &pdev->dev;
sound/soc/atmel/sam9g20_wm8731.c:			dev_err(&pdev->dev, "codec info missing\n");
sound/soc/atmel/sam9g20_wm8731.c:			dev_err(&pdev->dev, "dai and pcm info missing\n");
sound/soc/atmel/atmel_ssc_dai.c:	ret = asoc_ssc_init(&ssc->pdev->dev);
sound/soc/atmel/atmel_ssc_dai.c:	asoc_ssc_exit(&ssc->pdev->dev);
sound/soc/codecs/wm8994.c:	wm8994 = devm_kzalloc(&pdev->dev, sizeof(struct wm8994_priv),
sound/soc/codecs/wm8994.c:	wm8994->wm8994 = dev_get_drvdata(pdev->dev.parent);
sound/soc/codecs/wm8994.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_wm8994,
sound/soc/codecs/wm8994.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/ad1980.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/ad1980.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/88pm860x-codec.c:	struct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);
sound/soc/codecs/88pm860x-codec.c:	pm860x = devm_kzalloc(&pdev->dev, sizeof(struct pm860x_priv),
sound/soc/codecs/88pm860x-codec.c:			dev_err(&pdev->dev, "Failed to get IRQ resources\n");
sound/soc/codecs/88pm860x-codec.c:	ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_pm860x,
sound/soc/codecs/88pm860x-codec.c:		dev_err(&pdev->dev, "Failed to register codec\n");
sound/soc/codecs/88pm860x-codec.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/aml_pmu3.c:    int ret = snd_soc_register_codec(&pdev->dev, 
sound/soc/codecs/aml_pmu3.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/si476x.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_si476x,
sound/soc/codecs/si476x.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/aml_pmu4_codec.c:	ret = snd_soc_register_codec(&pdev->dev, 
sound/soc/codecs/aml_pmu4_codec.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/ad73311.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/ad73311.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/twl6040.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_twl6040,
sound/soc/codecs/twl6040.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/wm8350.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_wm8350,
sound/soc/codecs/wm8350.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/wm8400.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_wm8400,
sound/soc/codecs/wm8400.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/wm9712.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/wm9712.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/wm5110.c:	struct arizona *arizona = dev_get_drvdata(pdev->dev.parent);
sound/soc/codecs/wm5110.c:	wm5110 = devm_kzalloc(&pdev->dev, sizeof(struct wm5110_priv),
sound/soc/codecs/wm5110.c:	pm_runtime_enable(&pdev->dev);
sound/soc/codecs/wm5110.c:	pm_runtime_idle(&pdev->dev);
sound/soc/codecs/wm5110.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_wm5110,
sound/soc/codecs/wm5110.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/wm5110.c:	pm_runtime_disable(&pdev->dev);
sound/soc/codecs/cx20442.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/cx20442.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/pcm3008.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/pcm3008.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/jz4740.c:	jz4740_codec = devm_kzalloc(&pdev->dev, sizeof(*jz4740_codec),
sound/soc/codecs/jz4740.c:	base = devm_ioremap_resource(&pdev->dev, mem);
sound/soc/codecs/jz4740.c:	jz4740_codec->regmap = devm_regmap_init_mmio(&pdev->dev, base,
sound/soc/codecs/jz4740.c:	ret = snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/jz4740.c:		dev_err(&pdev->dev, "Failed to register codec\n");
sound/soc/codecs/jz4740.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/stac9766.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/stac9766.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/wm8727.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/wm8727.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/spdif_receiver.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_spdif_dir,
sound/soc/codecs/spdif_receiver.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/mc13783.c:	struct mc13xxx_codec_platform_data *pdata = pdev->dev.platform_data;
sound/soc/codecs/mc13783.c:	mc13xxx = dev_get_drvdata(pdev->dev.parent);
sound/soc/codecs/mc13783.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
sound/soc/codecs/mc13783.c:	dev_set_drvdata(&pdev->dev, priv);
sound/soc/codecs/mc13783.c:		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_mc13783,
sound/soc/codecs/mc13783.c:		ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_mc13783,
sound/soc/codecs/mc13783.c:	dev_err(&pdev->dev, "register codec failed with %d\n", ret);
sound/soc/codecs/mc13783.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/dmic.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/dmic.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/pcm2bt.c:    ret = snd_soc_register_codec(&pdev->dev, 
sound/soc/codecs/pcm2bt.c:    snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/ac97.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/ac97.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/cq93vc.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/cq93vc.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/twl4030.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_twl4030,
sound/soc/codecs/twl4030.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/wm8782.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/wm8782.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/spdif_transciever.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_spdif_dit,
sound/soc/codecs/spdif_transciever.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/wm5102.c:	struct arizona *arizona = dev_get_drvdata(pdev->dev.parent);
sound/soc/codecs/wm5102.c:	wm5102 = devm_kzalloc(&pdev->dev, sizeof(struct wm5102_priv),
sound/soc/codecs/wm5102.c:	pm_runtime_enable(&pdev->dev);
sound/soc/codecs/wm5102.c:	pm_runtime_idle(&pdev->dev);
sound/soc/codecs/wm5102.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_wm5102,
sound/soc/codecs/wm5102.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/wm5102.c:	pm_runtime_disable(&pdev->dev);
sound/soc/codecs/ads117x.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/ads117x.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/uda134x.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/uda134x.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/dfbmcs320.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_dfbmcs320,
sound/soc/codecs/dfbmcs320.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/omap-hdmi.c:	return snd_soc_register_codec(&pdev->dev, &omap_hdmi_codec,
sound/soc/codecs/omap-hdmi.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/wm9713.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/wm9713.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/aml_m8_codec.c:	return snd_soc_register_codec(&pdev->dev, 
sound/soc/codecs/aml_m8_codec.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/wm9705.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/codecs/wm9705.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/dummy_codec.c:    ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_dummy_codec,
sound/soc/codecs/dummy_codec.c:    snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/ak5386.c:	struct device *dev = &pdev->dev;
sound/soc/codecs/ak5386.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/ab8500-codec.c:	dev_dbg(&pdev->dev, "%s: Enter.\n", __func__);
sound/soc/codecs/ab8500-codec.c:	drvdata = devm_kzalloc(&pdev->dev, sizeof(struct ab8500_codec_drvdata),
sound/soc/codecs/ab8500-codec.c:	dev_set_drvdata(&pdev->dev, drvdata);
sound/soc/codecs/ab8500-codec.c:	dev_dbg(&pdev->dev, "%s: Register codec.\n", __func__);
sound/soc/codecs/ab8500-codec.c:	status = snd_soc_register_codec(&pdev->dev, &ab8500_codec_driver,
sound/soc/codecs/ab8500-codec.c:		dev_err(&pdev->dev,
sound/soc/codecs/ab8500-codec.c:	dev_info(&pdev->dev, "%s Enter.\n", __func__);
sound/soc/codecs/ab8500-codec.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/sn95031.c:	pr_debug("codec device probe called for %s\n", dev_name(&pdev->dev));
sound/soc/codecs/sn95031.c:	return snd_soc_register_codec(&pdev->dev, &sn95031_codec,
sound/soc/codecs/sn95031.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/codecs/wl1273.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_wl1273,
sound/soc/codecs/wl1273.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/generic/simple-card.c:	struct asoc_simple_card_info *cinfo = pdev->dev.platform_data;
sound/soc/generic/simple-card.c:	struct device *dev = &pdev->dev;
sound/soc/generic/simple-card.c:	cinfo->snd_card.dev		= &pdev->dev;
sound/soc/generic/simple-card.c:	struct asoc_simple_card_info *cinfo = pdev->dev.platform_data;
sound/soc/dwc/designware_i2s.c:	const struct i2s_platform_data *pdata = pdev->dev.platform_data;
sound/soc/dwc/designware_i2s.c:		dev_err(&pdev->dev, "Invalid platform data\n");
sound/soc/dwc/designware_i2s.c:		dev_err(&pdev->dev, "no i2s resource defined\n");
sound/soc/dwc/designware_i2s.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
sound/soc/dwc/designware_i2s.c:				resource_size(res), pdev->name)) {
sound/soc/dwc/designware_i2s.c:		dev_err(&pdev->dev, "i2s region already claimed\n");
sound/soc/dwc/designware_i2s.c:	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
sound/soc/dwc/designware_i2s.c:		dev_warn(&pdev->dev, "kzalloc fail\n");
sound/soc/dwc/designware_i2s.c:	dev->i2s_base = devm_ioremap(&pdev->dev, res->start,
sound/soc/dwc/designware_i2s.c:		dev_err(&pdev->dev, "ioremap fail for i2s_region\n");
sound/soc/dwc/designware_i2s.c:	dev->clk = clk_get(&pdev->dev, NULL);
sound/soc/dwc/designware_i2s.c:	dw_i2s_dai = devm_kzalloc(&pdev->dev, sizeof(*dw_i2s_dai), GFP_KERNEL);
sound/soc/dwc/designware_i2s.c:		dev_err(&pdev->dev, "mem allocation failed for dai driver\n");
sound/soc/dwc/designware_i2s.c:		dev_dbg(&pdev->dev, " SPEAr: play supported\n");
sound/soc/dwc/designware_i2s.c:		dev_dbg(&pdev->dev, "SPEAr: record supported\n");
sound/soc/dwc/designware_i2s.c:	dev->dev = &pdev->dev;
sound/soc/dwc/designware_i2s.c:	dev_set_drvdata(&pdev->dev, dev);
sound/soc/dwc/designware_i2s.c:	ret = snd_soc_register_component(&pdev->dev, &dw_i2s_component,
sound/soc/dwc/designware_i2s.c:		dev_err(&pdev->dev, "not able to register dai\n");
sound/soc/dwc/designware_i2s.c:	dev_set_drvdata(&pdev->dev, NULL);
sound/soc/dwc/designware_i2s.c:	struct dw_i2s_dev *dev = dev_get_drvdata(&pdev->dev);
sound/soc/dwc/designware_i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/dwc/designware_i2s.c:	dev_set_drvdata(&pdev->dev, NULL);
sound/soc/mid-x86/mfld_machine.c:			IRQF_SHARED, pdev->dev.driver->name, mc_drv_ctx);
sound/soc/mid-x86/mfld_machine.c:	snd_soc_card_mfld.dev = &pdev->dev;
sound/soc/mid-x86/sst_platform.c:	ret = snd_soc_register_platform(&pdev->dev, &sst_soc_platform_drv);
sound/soc/mid-x86/sst_platform.c:	ret = snd_soc_register_component(&pdev->dev, &sst_component,
sound/soc/mid-x86/sst_platform.c:		snd_soc_unregister_platform(&pdev->dev);
sound/soc/mid-x86/sst_platform.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/mid-x86/sst_platform.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/omap/ams-delta.c:	card->dev = &pdev->dev;
sound/soc/omap/ams-delta.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
sound/soc/omap/ams-delta.c:		dev_warn(&pdev->dev,
sound/soc/omap/omap-mcbsp.c:	struct omap_mcbsp_platform_data *pdata = dev_get_platdata(&pdev->dev);
sound/soc/omap/omap-mcbsp.c:	match = of_match_device(omap_mcbsp_of_match, &pdev->dev);
sound/soc/omap/omap-mcbsp.c:		struct device_node *node = pdev->dev.of_node;
sound/soc/omap/omap-mcbsp.c:		pdata = devm_kzalloc(&pdev->dev,
sound/soc/omap/omap-mcbsp.c:		dev_err(&pdev->dev, "missing platform data.\n");
sound/soc/omap/omap-mcbsp.c:	mcbsp = devm_kzalloc(&pdev->dev, sizeof(struct omap_mcbsp), GFP_KERNEL);
sound/soc/omap/omap-mcbsp.c:	mcbsp->id = pdev->id;
sound/soc/omap/omap-mcbsp.c:	mcbsp->dev = &pdev->dev;
sound/soc/omap/omap-mcbsp.c:		return snd_soc_register_component(&pdev->dev, &omap_mcbsp_component,
sound/soc/omap/omap-mcbsp.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/omap/omap-mcpdm.c:	mcpdm = devm_kzalloc(&pdev->dev, sizeof(struct omap_mcpdm), GFP_KERNEL);
sound/soc/omap/omap-mcpdm.c:	mcpdm->io_base = devm_ioremap_resource(&pdev->dev, res);
sound/soc/omap/omap-mcpdm.c:	mcpdm->dev = &pdev->dev;
sound/soc/omap/omap-mcpdm.c:	return snd_soc_register_component(&pdev->dev, &omap_mcpdm_component,
sound/soc/omap/omap-mcpdm.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/omap/mcbsp.c:	if (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),
sound/soc/omap/mcbsp.c:				     dev_name(&pdev->dev))) {
sound/soc/omap/mcbsp.c:	mcbsp->io_base = devm_ioremap(&pdev->dev, res->start,
sound/soc/omap/mcbsp.c:		dev_err(&pdev->dev, "invalid rx DMA channel\n");
sound/soc/omap/mcbsp.c:		dev_err(&pdev->dev, "invalid tx DMA channel\n");
sound/soc/omap/mcbsp.c:	mcbsp->fclk = clk_get(&pdev->dev, "fck");
sound/soc/omap/omap-pcm.c:	return snd_soc_register_platform(&pdev->dev,
sound/soc/omap/omap-pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/omap/omap-hdmi.c:	hdmi_data = devm_kzalloc(&pdev->dev, sizeof(*hdmi_data), GFP_KERNEL);
sound/soc/omap/omap-hdmi.c:		dev_err(&pdev->dev, "Cannot allocate memory for HDMI data\n");
sound/soc/omap/omap-hdmi.c:		dev_err(&pdev->dev, "Cannot obtain IORESOURCE_MEM HDMI\n");
sound/soc/omap/omap-hdmi.c:		dev_err(&pdev->dev, "Cannot obtain IORESOURCE_DMA HDMI\n");
sound/soc/omap/omap-hdmi.c:		dev_err(&pdev->dev, "no driver for HDMI display found\n");
sound/soc/omap/omap-hdmi.c:	dev_set_drvdata(&pdev->dev, hdmi_data);
sound/soc/omap/omap-hdmi.c:	ret = snd_soc_register_component(&pdev->dev, &omap_hdmi_component,
sound/soc/omap/omap-hdmi.c:	struct hdmi_priv *hdmi_data = dev_get_drvdata(&pdev->dev);
sound/soc/omap/omap-hdmi.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/omap/omap-hdmi.c:		dev_err(&pdev->dev, "cannot obtain HDMi data\n");
sound/soc/omap/omap-abe-twl6040.c:	struct omap_abe_twl6040_data *pdata = dev_get_platdata(&pdev->dev);
sound/soc/omap/omap-abe-twl6040.c:	struct device_node *node = pdev->dev.of_node;
sound/soc/omap/omap-abe-twl6040.c:	card->dev = &pdev->dev;
sound/soc/omap/omap-abe-twl6040.c:	priv = devm_kzalloc(&pdev->dev, sizeof(struct abe_twl6040), GFP_KERNEL);
sound/soc/omap/omap-abe-twl6040.c:			dev_err(&pdev->dev, "Card name is not provided\n");
sound/soc/omap/omap-abe-twl6040.c:			dev_err(&pdev->dev,
sound/soc/omap/omap-abe-twl6040.c:			dev_err(&pdev->dev, "McPDM node is not provided\n");
sound/soc/omap/omap-abe-twl6040.c:				dev_err(&pdev->dev,
sound/soc/omap/omap-abe-twl6040.c:			dev_err(&pdev->dev, "MCLK frequency not provided\n");
sound/soc/omap/omap-abe-twl6040.c:			dev_err(&pdev->dev, "Card name is not provided\n");
sound/soc/omap/omap-abe-twl6040.c:		dev_err(&pdev->dev, "Missing pdata\n");
sound/soc/omap/omap-abe-twl6040.c:		dev_err(&pdev->dev, "MCLK frequency missing\n");
sound/soc/omap/omap-abe-twl6040.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/omap/omap-dmic.c:	dmic = devm_kzalloc(&pdev->dev, sizeof(struct omap_dmic), GFP_KERNEL);
sound/soc/omap/omap-dmic.c:	dmic->dev = &pdev->dev;
sound/soc/omap/omap-dmic.c:	dmic->io_base = devm_ioremap_resource(&pdev->dev, res);
sound/soc/omap/omap-dmic.c:	ret = snd_soc_register_component(&pdev->dev, &omap_dmic_component,
sound/soc/omap/omap-dmic.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/omap/omap-hdmi-card.c:	card->dev = &pdev->dev;
sound/soc/omap/omap-hdmi-card.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
sound/soc/omap/omap-twl4030.c:	struct omap_tw4030_pdata *pdata = dev_get_platdata(&pdev->dev);
sound/soc/omap/omap-twl4030.c:	struct device_node *node = pdev->dev.of_node;
sound/soc/omap/omap-twl4030.c:	card->dev = &pdev->dev;
sound/soc/omap/omap-twl4030.c:	priv = devm_kzalloc(&pdev->dev, sizeof(struct omap_twl4030), GFP_KERNEL);
sound/soc/omap/omap-twl4030.c:			dev_err(&pdev->dev, "Card name is not provided\n");
sound/soc/omap/omap-twl4030.c:			dev_err(&pdev->dev, "McBSP node is not provided\n");
sound/soc/omap/omap-twl4030.c:			dev_err(&pdev->dev, "Card name is not provided\n");
sound/soc/omap/omap-twl4030.c:		dev_err(&pdev->dev, "Missing pdata\n");
sound/soc/omap/omap-twl4030.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/blackfin/bfin-eval-adau1373.c:	card->dev = &pdev->dev;
sound/soc/blackfin/bf5xx-ac97-pcm.c:	return snd_soc_register_platform(&pdev->dev, &bf5xx_ac97_soc_platform);
sound/soc/blackfin/bf5xx-ac97-pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/blackfin/bf5xx-ad1836.c:	link_name = pdev->dev.platform_data;
sound/soc/blackfin/bf5xx-ad1836.c:		dev_err(&pdev->dev, "No platform data supplied\n");
sound/soc/blackfin/bf5xx-ad1836.c:	card->dev = &pdev->dev;
sound/soc/blackfin/bf5xx-ad1836.c:		dev_err(&pdev->dev, "Failed to register card\n");
sound/soc/blackfin/bf5xx-i2s.c:	ret = snd_soc_register_component(&pdev->dev, &bf5xx_i2s_component,
sound/soc/blackfin/bf5xx-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/blackfin/bf5xx-sport.c:	struct device *dev = &pdev->dev;
sound/soc/blackfin/bf5xx-sport.c:	param->num = pdev->id;
sound/soc/blackfin/bf5xx-sport.c:	struct device *dev = &pdev->dev;
sound/soc/blackfin/bf5xx-tdm.c:	ret = snd_soc_register_component(&pdev->dev, &bf5xx_tdm_component,
sound/soc/blackfin/bf5xx-tdm.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/blackfin/bf5xx-tdm-pcm.c:	return snd_soc_register_platform(&pdev->dev, &bf5xx_tdm_soc_platform);
sound/soc/blackfin/bf5xx-tdm-pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/blackfin/bf5xx-i2s-pcm.c:	return snd_soc_register_platform(&pdev->dev, &bf5xx_i2s_soc_platform);
sound/soc/blackfin/bf5xx-i2s-pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/blackfin/bfin-eval-adau1701.c:	card->dev = &pdev->dev;
sound/soc/blackfin/bf5xx-ac97.c:	ret = snd_soc_register_component(&pdev->dev, &bfin_ac97_component,
sound/soc/blackfin/bf5xx-ac97.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/blackfin/bfin-eval-adav80x.c:	card->dev = &pdev->dev;
sound/soc/blackfin/bf6xx-sport.c:	struct device *dev = &sport->pdev->dev;
sound/soc/blackfin/bf6xx-sport.c:	struct device *dev = &pdev->dev;
sound/soc/blackfin/bf6xx-sport.c:	struct device *dev = &sport->pdev->dev;
sound/soc/blackfin/bf6xx-sport.c:	struct device *dev = &pdev->dev;
sound/soc/blackfin/bf6xx-i2s.c:	struct device *dev = &sport->pdev->dev;
sound/soc/blackfin/bf6xx-i2s.c:	struct device *dev = &sport->pdev->dev;
sound/soc/blackfin/bf6xx-i2s.c:	struct device *dev = &sport->pdev->dev;
sound/soc/blackfin/bf6xx-i2s.c:	struct device *dev = &pdev->dev;
sound/soc/blackfin/bf6xx-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/sh/siu_pcm.c:	/* pdev->id selects between SIUA and SIUB */
sound/soc/sh/siu_pcm.c:	if (pdev->id < 0 || pdev->id >= SIU_PORT_NUM)
sound/soc/sh/siu_pcm.c:	info->port_id = pdev->id;
sound/soc/sh/siu_pcm.c:	for (i = pdev->id; i < pdev->id + 1; i++) {
sound/soc/sh/siu_pcm.c:	siu_free_port(siu_ports[pdev->id]);
sound/soc/sh/siu_pcm.c:	struct siu_port *port_info = siu_ports[pdev->id];
sound/soc/sh/ssi.c:	return snd_soc_register_component(&pdev->dev, &sh4_ssi_component,
sound/soc/sh/ssi.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/sh/siu_dai.c:	info->dev = &pdev->dev;
sound/soc/sh/siu_dai.c:	ret = request_firmware(&fw_entry, "siu_spb.bin", &pdev->dev);
sound/soc/sh/siu_dai.c:				    pdev->name);
sound/soc/sh/siu_dai.c:		dev_err(&pdev->dev, "SIU region already claimed\n");
sound/soc/sh/siu_dai.c:	dev_set_drvdata(&pdev->dev, info);
sound/soc/sh/siu_dai.c:	ret = snd_soc_register_component(&pdev->dev, &siu_i2s_component,
sound/soc/sh/siu_dai.c:	ret = snd_soc_register_platform(&pdev->dev, &siu_platform);
sound/soc/sh/siu_dai.c:	pm_runtime_enable(&pdev->dev);
sound/soc/sh/siu_dai.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/sh/siu_dai.c:	struct siu_info *info = dev_get_drvdata(&pdev->dev);
sound/soc/sh/siu_dai.c:	pm_runtime_disable(&pdev->dev);
sound/soc/sh/siu_dai.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/sh/siu_dai.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/sh/siu.h:	return siu_ports[pdev->id];
sound/soc/sh/dma-sh7760.c:	return snd_soc_register_platform(&pdev->dev, &sh7760_soc_platform);
sound/soc/sh/dma-sh7760.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/sh/hac.c:	return snd_soc_register_component(&pdev->dev, &sh4_hac_component,
sound/soc/sh/hac.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/sh/fsi.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/sh/fsi.c:		of_id = of_match_device(fsi_of_match, &pdev->dev);
sound/soc/sh/fsi.c:			fsi_of_parse("fsia", np, &info.port_a, &pdev->dev);
sound/soc/sh/fsi.c:			fsi_of_parse("fsib", np, &info.port_b, &pdev->dev);
sound/soc/sh/fsi.c:		const struct platform_device_id	*id_entry = pdev->id_entry;
sound/soc/sh/fsi.c:		if (pdev->dev.platform_data)
sound/soc/sh/fsi.c:			memcpy(&info, pdev->dev.platform_data, sizeof(info));
sound/soc/sh/fsi.c:		dev_err(&pdev->dev, "unknown fsi device\n");
sound/soc/sh/fsi.c:		dev_err(&pdev->dev, "Not enough FSI platform resources.\n");
sound/soc/sh/fsi.c:	master = devm_kzalloc(&pdev->dev, sizeof(*master), GFP_KERNEL);
sound/soc/sh/fsi.c:		dev_err(&pdev->dev, "Could not allocate master\n");
sound/soc/sh/fsi.c:	master->base = devm_ioremap_nocache(&pdev->dev,
sound/soc/sh/fsi.c:		dev_err(&pdev->dev, "Unable to ioremap FSI registers.\n");
sound/soc/sh/fsi.c:	ret = fsi_stream_probe(fsi, &pdev->dev);
sound/soc/sh/fsi.c:		dev_err(&pdev->dev, "FSIA stream probe failed\n");
sound/soc/sh/fsi.c:	ret = fsi_stream_probe(fsi, &pdev->dev);
sound/soc/sh/fsi.c:		dev_err(&pdev->dev, "FSIB stream probe failed\n");
sound/soc/sh/fsi.c:	pm_runtime_enable(&pdev->dev);
sound/soc/sh/fsi.c:	dev_set_drvdata(&pdev->dev, master);
sound/soc/sh/fsi.c:	ret = devm_request_irq(&pdev->dev, irq, &fsi_interrupt, 0,
sound/soc/sh/fsi.c:			       dev_name(&pdev->dev), master);
sound/soc/sh/fsi.c:		dev_err(&pdev->dev, "irq request err\n");
sound/soc/sh/fsi.c:	ret = snd_soc_register_platform(&pdev->dev, &fsi_soc_platform);
sound/soc/sh/fsi.c:		dev_err(&pdev->dev, "cannot snd soc register\n");
sound/soc/sh/fsi.c:	ret = snd_soc_register_component(&pdev->dev, &fsi_soc_component,
sound/soc/sh/fsi.c:		dev_err(&pdev->dev, "cannot snd component register\n");
sound/soc/sh/fsi.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/sh/fsi.c:	pm_runtime_disable(&pdev->dev);
sound/soc/sh/fsi.c:	master = dev_get_drvdata(&pdev->dev);
sound/soc/sh/fsi.c:	pm_runtime_disable(&pdev->dev);
sound/soc/sh/fsi.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/sh/fsi.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/spear/spear_pcm.c:	return snd_soc_register_platform(&pdev->dev, &spear_soc_platform);
sound/soc/spear/spear_pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/spear/spdif_in.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
sound/soc/spear/spdif_in.c:				resource_size(res), pdev->name)) {
sound/soc/spear/spdif_in.c:		dev_warn(&pdev->dev, "Failed to get memory resourse\n");
sound/soc/spear/spdif_in.c:	host = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);
sound/soc/spear/spdif_in.c:		dev_warn(&pdev->dev, "kzalloc fail\n");
sound/soc/spear/spdif_in.c:	host->io_base = devm_ioremap(&pdev->dev, res->start,
sound/soc/spear/spdif_in.c:		dev_warn(&pdev->dev, "ioremap failed\n");
sound/soc/spear/spdif_in.c:	host->clk = clk_get(&pdev->dev, NULL);
sound/soc/spear/spdif_in.c:	pdata = dev_get_platdata(&pdev->dev);
sound/soc/spear/spdif_in.c:	host->dev = &pdev->dev;
sound/soc/spear/spdif_in.c:	dev_set_drvdata(&pdev->dev, host);
sound/soc/spear/spdif_in.c:	ret = devm_request_irq(&pdev->dev, host->irq, spdif_in_irq, 0,
sound/soc/spear/spdif_in.c:		dev_warn(&pdev->dev, "request_irq failed\n");
sound/soc/spear/spdif_in.c:	ret = snd_soc_register_component(&pdev->dev, &spdif_in_component,
sound/soc/spear/spdif_in.c:	struct spdif_in_dev *host = dev_get_drvdata(&pdev->dev);
sound/soc/spear/spdif_in.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/spear/spdif_in.c:	dev_set_drvdata(&pdev->dev, NULL);
sound/soc/spear/spdif_out.c:	if (!devm_request_mem_region(&pdev->dev, res->start,
sound/soc/spear/spdif_out.c:				resource_size(res), pdev->name)) {
sound/soc/spear/spdif_out.c:		dev_warn(&pdev->dev, "Failed to get memory resourse\n");
sound/soc/spear/spdif_out.c:	host = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);
sound/soc/spear/spdif_out.c:		dev_warn(&pdev->dev, "kzalloc fail\n");
sound/soc/spear/spdif_out.c:	host->io_base = devm_ioremap(&pdev->dev, res->start,
sound/soc/spear/spdif_out.c:		dev_warn(&pdev->dev, "ioremap failed\n");
sound/soc/spear/spdif_out.c:	host->clk = clk_get(&pdev->dev, NULL);
sound/soc/spear/spdif_out.c:	pdata = dev_get_platdata(&pdev->dev);
sound/soc/spear/spdif_out.c:	dev_set_drvdata(&pdev->dev, host);
sound/soc/spear/spdif_out.c:	ret = snd_soc_register_component(&pdev->dev, &spdif_out_component,
sound/soc/spear/spdif_out.c:	struct spdif_out_dev *host = dev_get_drvdata(&pdev->dev);
sound/soc/spear/spdif_out.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/spear/spdif_out.c:	dev_set_drvdata(&pdev->dev, NULL);
sound/soc/spear/spdif_out.c:	struct spdif_out_dev *host = dev_get_drvdata(&pdev->dev);
sound/soc/spear/spdif_out.c:	struct spdif_out_dev *host = dev_get_drvdata(&pdev->dev);
sound/soc/s6000/s6000-pcm.c:	return snd_soc_register_platform(&pdev->dev, &s6000_soc_platform);
sound/soc/s6000/s6000-pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/s6000/s6000-i2s.c:		dev_err(&pdev->dev, "no mem resource?\n");
sound/soc/s6000/s6000-i2s.c:								pdev->name);
sound/soc/s6000/s6000-i2s.c:		dev_err(&pdev->dev, "I2S SCB region already claimed\n");
sound/soc/s6000/s6000-i2s.c:		dev_err(&pdev->dev, "can't ioremap SCB region\n");
sound/soc/s6000/s6000-i2s.c:		dev_err(&pdev->dev, "no second mem resource?\n");
sound/soc/s6000/s6000-i2s.c:								pdev->name);
sound/soc/s6000/s6000-i2s.c:		dev_err(&pdev->dev, "I2S SIF region already claimed\n");
sound/soc/s6000/s6000-i2s.c:		dev_err(&pdev->dev, "no dma resource?\n");
sound/soc/s6000/s6000-i2s.c:								pdev->name);
sound/soc/s6000/s6000-i2s.c:		dev_err(&pdev->dev, "I2S DMA region already claimed\n");
sound/soc/s6000/s6000-i2s.c:								pdev->name);
sound/soc/s6000/s6000-i2s.c:			dev_err(&pdev->dev,
sound/soc/s6000/s6000-i2s.c:	dev_set_drvdata(&pdev->dev, dev);
sound/soc/s6000/s6000-i2s.c:		dev_err(&pdev->dev, "no irq resource?\n");
sound/soc/s6000/s6000-i2s.c:	ret = snd_soc_register_component(&pdev->dev, &s6000_i2s_component,
sound/soc/s6000/s6000-i2s.c:	struct s6000_i2s_dev *dev = dev_get_drvdata(&pdev->dev);
sound/soc/s6000/s6000-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/au1x/psc-ac97.c:	wd = devm_kzalloc(&pdev->dev, sizeof(struct au1xpsc_audio_data),
sound/soc/au1x/psc-ac97.c:	if (!devm_request_mem_region(&pdev->dev, iores->start,
sound/soc/au1x/psc-ac97.c:				     pdev->name))
sound/soc/au1x/psc-ac97.c:	wd->mmio = devm_ioremap(&pdev->dev, iores->start,
sound/soc/au1x/psc-ac97.c:	wd->dai_drv.name = dev_name(&pdev->dev);
sound/soc/au1x/psc-ac97.c:	ret = snd_soc_register_component(&pdev->dev, &au1xpsc_ac97_component,
sound/soc/au1x/psc-ac97.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/au1x/dma.c:	ctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);
sound/soc/au1x/dma.c:	return snd_soc_register_platform(&pdev->dev, &alchemy_pcm_soc_platform);
sound/soc/au1x/dma.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/au1x/i2sc.c:	ctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);
sound/soc/au1x/i2sc.c:	if (!devm_request_mem_region(&pdev->dev, iores->start,
sound/soc/au1x/i2sc.c:				     pdev->name))
sound/soc/au1x/i2sc.c:	ctx->mmio = devm_ioremap_nocache(&pdev->dev, iores->start,
sound/soc/au1x/i2sc.c:	return snd_soc_register_component(&pdev->dev, &au1xi2s_component,
sound/soc/au1x/i2sc.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/au1x/dbdma2.c:	dmadata = devm_kzalloc(&pdev->dev,
sound/soc/au1x/dbdma2.c:	return snd_soc_register_platform(&pdev->dev, &au1xpsc_soc_platform);
sound/soc/au1x/dbdma2.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/au1x/psc-i2s.c:	wd = devm_kzalloc(&pdev->dev, sizeof(struct au1xpsc_audio_data),
sound/soc/au1x/psc-i2s.c:	if (!devm_request_mem_region(&pdev->dev, iores->start,
sound/soc/au1x/psc-i2s.c:				     pdev->name))
sound/soc/au1x/psc-i2s.c:	wd->mmio = devm_ioremap(&pdev->dev, iores->start,
sound/soc/au1x/psc-i2s.c:	wd->dai_drv.name = dev_name(&pdev->dev);
sound/soc/au1x/psc-i2s.c:	return snd_soc_register_component(&pdev->dev, &au1xpsc_i2s_component,
sound/soc/au1x/psc-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/au1x/db1000.c:	card->dev = &pdev->dev;
sound/soc/au1x/ac97c.c:	ctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);
sound/soc/au1x/ac97c.c:	if (!devm_request_mem_region(&pdev->dev, iores->start,
sound/soc/au1x/ac97c.c:				     pdev->name))
sound/soc/au1x/ac97c.c:	ctx->mmio = devm_ioremap_nocache(&pdev->dev, iores->start,
sound/soc/au1x/ac97c.c:	ret = snd_soc_register_component(&pdev->dev, &au1xac97c_component,
sound/soc/au1x/ac97c.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/au1x/db1200.c:	card->dev = &pdev->dev;
sound/soc/aml/m8/aml_i2s.c:    return snd_soc_register_platform(&pdev->dev, &aml_soc_platform);
sound/soc/aml/m8/aml_i2s.c:    snd_soc_unregister_platform(&pdev->dev);
sound/soc/aml/m8/aml_g9tv.c:    struct device_node* audio_codec_node = pdev->dev.of_node;
sound/soc/aml/m8/aml_g9tv.c:    p_aml_audio = devm_kzalloc(&pdev->dev,
sound/soc/aml/m8/aml_g9tv.c:        dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
sound/soc/aml/m8/aml_g9tv.c:    card->dev = &pdev->dev;
sound/soc/aml/m8/aml_g9tv.c:    if (!(pdev->dev.of_node)) {
sound/soc/aml/m8/aml_g9tv.c:        dev_err(&pdev->dev, "Must be instantiated using device tree\n");
sound/soc/aml/m8/aml_g9tv.c:    ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
sound/soc/aml/m8/aml_g9tv.c:        dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/aml/m8/aml_audio_codec_probe.c:	struct device_node* audio_codec_node = pdev->dev.of_node;
sound/soc/aml/m8/aml_audio_codec_probe.c:        dev_err(&pdev->dev, "register_codec_device failed (%d)\n", ret);
sound/soc/aml/m8/aml_m8_rt5616.c:    //struct device_node *np = pdev->dev.of_node;
sound/soc/aml/m8/aml_m8_rt5616.c:    p_aml_audio = devm_kzalloc(&pdev->dev,
sound/soc/aml/m8/aml_m8_rt5616.c:        dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
sound/soc/aml/m8/aml_m8_rt5616.c:    card->dev = &pdev->dev;
sound/soc/aml/m8/aml_m8_rt5616.c:    if (!(pdev->dev.of_node)) {
sound/soc/aml/m8/aml_m8_rt5616.c:        dev_err(&pdev->dev, "Must be instantiated using device tree\n");
sound/soc/aml/m8/aml_m8_rt5616.c:    ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
sound/soc/aml/m8/aml_m8_rt5616.c://          pdev->dev.of_node, "aml,audio-codec", 0);
sound/soc/aml/m8/aml_m8_rt5616.c:        dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/aml/m8/aml_pcm.c:	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform_pcm2bt);
sound/soc/aml/m8/aml_pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/aml/m8/aml_m8.c:    p_aml_audio = devm_kzalloc(&pdev->dev,
sound/soc/aml/m8/aml_m8.c:        dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
sound/soc/aml/m8/aml_m8.c:    card->dev = &pdev->dev;
sound/soc/aml/m8/aml_m8.c:    if (!(pdev->dev.of_node)) {
sound/soc/aml/m8/aml_m8.c:        dev_err(&pdev->dev, "Must be instantiated using device tree\n");
sound/soc/aml/m8/aml_m8.c:    ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
sound/soc/aml/m8/aml_m8.c:    //ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_name",
sound/soc/aml/m8/aml_m8.c:	//		 pdev->dev.of_node, "aml,audio-codec", 0);
sound/soc/aml/m8/aml_m8.c:        dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/aml/m8/aml_spdif_codec.c:    int ret = device_create_file(&pdev->dev, &dev_attr_spdif_mute);
sound/soc/aml/m8/aml_spdif_codec.c:    spdif_dev = &pdev->dev;
sound/soc/aml/m8/aml_spdif_codec.c:    aml_spdif_pinmux_init(&pdev->dev);
sound/soc/aml/m8/aml_spdif_codec.c:	return snd_soc_register_codec(&pdev->dev, &soc_codec_spdif_dit,
sound/soc/aml/m8/aml_spdif_codec.c:    aml_spdif_pinmux_deinit(&pdev->dev);
sound/soc/aml/m8/aml_spdif_codec.c:    device_remove_file(&pdev->dev, &dev_attr_spdif_mute);
sound/soc/aml/m8/aml_spdif_codec.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/aml/m8/aml_pcm_dai.c:	BUG_ON(pdev->id < 0);
sound/soc/aml/m8/aml_pcm_dai.c:	BUG_ON(pdev->id >= ARRAY_SIZE(aml_dai));
sound/soc/aml/m8/aml_pcm_dai.c:	return snd_soc_register_dai(&pdev->dev, &aml_dai[pdev->id]);
sound/soc/aml/m8/aml_pcm_dai.c:	return snd_soc_register_component(&pdev->dev, &aml_component,
sound/soc/aml/m8/aml_pcm_dai.c://    return snd_soc_register_dais(&pdev->dev, aml_dai, ARRAY_SIZE(aml_dai));
sound/soc/aml/m8/aml_pcm_dai.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/aml/m8/aml_m_dummy.c:		if (pdev->dev.of_node) {
sound/soc/aml/m8/aml_m_dummy.c:            np = pdev->dev.of_node;
sound/soc/aml/m8/aml_m_dummy.c:		dummy_codec_dev=&pdev->dev;
sound/soc/aml/m8/aml_m_dummy.c:		pdev->dev.platform_data = dummy_codec_pdata;
sound/soc/aml/m8/aml_m_dummy.c:		dummy_codec_snd_pdata = pdev->dev.platform_data;
sound/soc/aml/m8/aml_m_dummy.c:    card->dev = &pdev->dev;
sound/soc/aml/m8/aml_m_dummy.c:		if (!(pdev->dev.of_node)) {
sound/soc/aml/m8/aml_m_dummy.c:			dev_err(&pdev->dev, "Must be instantiated using device tree\n");
sound/soc/aml/m8/aml_m_dummy.c:			dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/aml/m8/aml_m_dummy.c:    dummy_codec_snd_pdata = pdev->dev.platform_data;
sound/soc/aml/m8/aml_spdif_dai.c:	return snd_soc_register_component(&pdev->dev, &aml_component,
sound/soc/aml/m8/aml_spdif_dai.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/aml/m8/aml_i2s_dai.c:		dev_err(&pdev->dev, "Can't allocate aml_i2s\n");
sound/soc/aml/m8/aml_i2s_dai.c:	dev_set_drvdata(&pdev->dev, i2s);
sound/soc/aml/m8/aml_i2s_dai.c:	if(of_property_read_u32(pdev->dev.of_node, "clk_src_mpll", &i2s->mpll)){
sound/soc/aml/m8/aml_i2s_dai.c:	return snd_soc_register_component(&pdev->dev, &aml_component,
sound/soc/aml/m8/aml_i2s_dai.c:	struct aml_i2s *i2s = dev_get_drvdata(&pdev->dev);
sound/soc/aml/m8/aml_i2s_dai.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/aml/m6/aml_dai.c:	BUG_ON(pdev->id < 0);
sound/soc/aml/m6/aml_dai.c:	BUG_ON(pdev->id >= ARRAY_SIZE(aml_dai));
sound/soc/aml/m6/aml_dai.c:	return snd_soc_register_dai(&pdev->dev, &aml_dai[pdev->id]);
sound/soc/aml/m6/aml_dai.c:	//return snd_soc_register_dais(&pdev->dev, aml_dai, ARRAY_SIZE(aml_dai));
sound/soc/aml/m6/aml_dai.c:	return snd_soc_register_component(&pdev->dev, &aml_component,
sound/soc/aml/m6/aml_dai.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/aml/m6/aml_m6_rt5631.c:	//struct device_node *np = pdev->dev.of_node;
sound/soc/aml/m6/aml_m6_rt5631.c:	p_aml_audio = devm_kzalloc(&pdev->dev,
sound/soc/aml/m6/aml_m6_rt5631.c:		dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
sound/soc/aml/m6/aml_m6_rt5631.c:	card->dev = &pdev->dev;
sound/soc/aml/m6/aml_m6_rt5631.c:	if (!(pdev->dev.of_node)) {
sound/soc/aml/m6/aml_m6_rt5631.c:		dev_err(&pdev->dev, "Must be instantiated using device tree\n");
sound/soc/aml/m6/aml_m6_rt5631.c:	ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
sound/soc/aml/m6/aml_m6_rt5631.c://			pdev->dev.of_node, "aml,audio-codec", 0);
sound/soc/aml/m6/aml_m6_rt5631.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/aml/m6/aml_audio_codec_probe.c:	struct device_node* audio_codec_node = pdev->dev.of_node;
sound/soc/aml/m6/aml_m6_wm8960.c://    struct device_node *np = pdev->dev.of_node;
sound/soc/aml/m6/aml_m6_wm8960.c:    p_aml_audio = devm_kzalloc(&pdev->dev,
sound/soc/aml/m6/aml_m6_wm8960.c:        dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
sound/soc/aml/m6/aml_m6_wm8960.c:    card->dev = &pdev->dev;
sound/soc/aml/m6/aml_m6_wm8960.c:    if (!(pdev->dev.of_node)) {
sound/soc/aml/m6/aml_m6_wm8960.c:        dev_err(&pdev->dev, "Must be instantiated using device tree\n");
sound/soc/aml/m6/aml_m6_wm8960.c:    ret = of_property_read_string_index(pdev->dev.of_node, "aml,codec_dai",
sound/soc/aml/m6/aml_m6_wm8960.c:  //          pdev->dev.of_node, "aml,audio-codec", 0);
sound/soc/aml/m6/aml_m6_wm8960.c:        dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/aml/m6/aml_m6_wm8960.c://    struct device_node *np = pdev->dev.of_node;
sound/soc/aml/m6/aml_platform_pcm2bt.c:	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform_pcm2bt);
sound/soc/aml/m6/aml_platform_pcm2bt.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/aml/m6/aml_syno9629_codec.c:	return snd_soc_register_codec(&pdev->dev,
sound/soc/aml/m6/aml_syno9629_codec.c:	snd_soc_unregister_codec(&pdev->dev);
sound/soc/aml/m6/aml_pcm.c:	if(pdev->dev.platform_data){
sound/soc/aml/m6/aml_pcm.c:		audioin_mode = *(unsigned *)pdev->dev.platform_data;
sound/soc/aml/m6/aml_pcm.c:	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform);
sound/soc/aml/m6/aml_pcm.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/aml/m6/aml_platform.c:	return snd_soc_register_platform(&pdev->dev, &aml_soc_platform2);
sound/soc/aml/m6/aml_platform.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/aml/m6/aml_m_dummy.c:		if (pdev->dev.of_node) {
sound/soc/aml/m6/aml_m_dummy.c:            np = pdev->dev.of_node;
sound/soc/aml/m6/aml_m_dummy.c:		dummy_codec_dev=&pdev->dev;		
sound/soc/aml/m6/aml_m_dummy.c:		pdev->dev.platform_data = dummy_codec_pdata;
sound/soc/aml/m6/aml_m_dummy.c:    dummy_codec_snd_pdata = pdev->dev.platform_data;
sound/soc/aml/m6/aml_m6tv_audio.c:	p_aml_audio = devm_kzalloc(&pdev->dev,
sound/soc/aml/m6/aml_m6tv_audio.c:		dev_err(&pdev->dev, "Can't allocate aml_audio_private_data\n");
sound/soc/aml/m6/aml_m6tv_audio.c:	card->dev = &pdev->dev;
sound/soc/aml/m6/aml_m6tv_audio.c:	if (!(pdev->dev.of_node)) {
sound/soc/aml/m6/aml_m6tv_audio.c:		dev_err(&pdev->dev, "Must be instantiated using device tree\n");
sound/soc/aml/m6/aml_m6tv_audio.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/aml/m6/aml_m6_rt3261.c:    rt3261_snd_pdata = pdev->dev.platform_data;
sound/soc/mxs/mxs-saif.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/mxs/mxs-saif.c:	saif = devm_kzalloc(&pdev->dev, sizeof(*saif), GFP_KERNEL);
sound/soc/mxs/mxs-saif.c:		dev_err(&pdev->dev, "get wrong master id\n");
sound/soc/mxs/mxs-saif.c:	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
sound/soc/mxs/mxs-saif.c:	saif->clk = devm_clk_get(&pdev->dev, NULL);
sound/soc/mxs/mxs-saif.c:		dev_err(&pdev->dev, "Cannot get the clock: %d\n",
sound/soc/mxs/mxs-saif.c:	saif->base = devm_ioremap_resource(&pdev->dev, iores);
sound/soc/mxs/mxs-saif.c:			dev_err(&pdev->dev, "failed to get dma channel\n");
sound/soc/mxs/mxs-saif.c:		dev_err(&pdev->dev, "failed to get irq resource: %d\n",
sound/soc/mxs/mxs-saif.c:	saif->dev = &pdev->dev;
sound/soc/mxs/mxs-saif.c:	ret = devm_request_irq(&pdev->dev, saif->irq, mxs_saif_irq, 0,
sound/soc/mxs/mxs-saif.c:		dev_err(&pdev->dev, "failed to request irq\n");
sound/soc/mxs/mxs-saif.c:		dev_err(&pdev->dev, "failed to get dma irq resource: %d\n",
sound/soc/mxs/mxs-saif.c:	ret = snd_soc_register_component(&pdev->dev, &mxs_saif_component,
sound/soc/mxs/mxs-saif.c:		dev_err(&pdev->dev, "register DAI failed\n");
sound/soc/mxs/mxs-saif.c:	ret = mxs_pcm_platform_register(&pdev->dev);
sound/soc/mxs/mxs-saif.c:		dev_err(&pdev->dev, "register PCM failed: %d\n", ret);
sound/soc/mxs/mxs-saif.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/mxs/mxs-saif.c:	mxs_pcm_platform_unregister(&pdev->dev);
sound/soc/mxs/mxs-saif.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/mxs/mxs-sgtl5000.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/mxs/mxs-sgtl5000.c:		dev_err(&pdev->dev, "phandle missing or invalid\n");
sound/soc/mxs/mxs-sgtl5000.c:	card->dev = &pdev->dev;
sound/soc/mxs/mxs-sgtl5000.c:		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",
sound/soc/davinci/davinci-i2s.c:	struct snd_platform_data *pdata = pdev->dev.platform_data;
sound/soc/davinci/davinci-i2s.c:		dev_err(&pdev->dev, "no mem resource?\n");
sound/soc/davinci/davinci-i2s.c:	ioarea = devm_request_mem_region(&pdev->dev, mem->start,
sound/soc/davinci/davinci-i2s.c:					 pdev->name);
sound/soc/davinci/davinci-i2s.c:		dev_err(&pdev->dev, "McBSP region already claimed\n");
sound/soc/davinci/davinci-i2s.c:	dev = devm_kzalloc(&pdev->dev, sizeof(struct davinci_mcbsp_dev),
sound/soc/davinci/davinci-i2s.c:	dev->clk = clk_get(&pdev->dev, NULL);
sound/soc/davinci/davinci-i2s.c:	dev->base = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
sound/soc/davinci/davinci-i2s.c:		dev_err(&pdev->dev, "ioremap failed\n");
sound/soc/davinci/davinci-i2s.c:		dev_err(&pdev->dev, "no DMA resource\n");
sound/soc/davinci/davinci-i2s.c:		dev_err(&pdev->dev, "no DMA resource\n");
sound/soc/davinci/davinci-i2s.c:	dev->dev = &pdev->dev;
sound/soc/davinci/davinci-i2s.c:	dev_set_drvdata(&pdev->dev, dev);
sound/soc/davinci/davinci-i2s.c:	ret = snd_soc_register_component(&pdev->dev, &davinci_i2s_component,
sound/soc/davinci/davinci-i2s.c:	ret = davinci_soc_platform_register(&pdev->dev);
sound/soc/davinci/davinci-i2s.c:		dev_err(&pdev->dev, "register PCM failed: %d\n", ret);
sound/soc/davinci/davinci-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/davinci/davinci-i2s.c:	struct davinci_mcbsp_dev *dev = dev_get_drvdata(&pdev->dev);
sound/soc/davinci/davinci-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/davinci/davinci-i2s.c:	davinci_soc_platform_unregister(&pdev->dev);
sound/soc/davinci/davinci-vcif.c:	struct davinci_vc *davinci_vc = pdev->dev.platform_data;
sound/soc/davinci/davinci-vcif.c:	davinci_vcif_dev = devm_kzalloc(&pdev->dev,
sound/soc/davinci/davinci-vcif.c:		dev_dbg(&pdev->dev,
sound/soc/davinci/davinci-vcif.c:	dev_set_drvdata(&pdev->dev, davinci_vcif_dev);
sound/soc/davinci/davinci-vcif.c:	ret = snd_soc_register_component(&pdev->dev, &davinci_vcif_component,
sound/soc/davinci/davinci-vcif.c:		dev_err(&pdev->dev, "could not register dai\n");
sound/soc/davinci/davinci-vcif.c:	ret = davinci_soc_platform_register(&pdev->dev);
sound/soc/davinci/davinci-vcif.c:		dev_err(&pdev->dev, "register PCM failed: %d\n", ret);
sound/soc/davinci/davinci-vcif.c:		snd_soc_unregister_component(&pdev->dev);
sound/soc/davinci/davinci-vcif.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/davinci/davinci-vcif.c:	davinci_soc_platform_unregister(&pdev->dev);
sound/soc/davinci/davinci-mcasp.c:	struct device_node *np = pdev->dev.of_node;
sound/soc/davinci/davinci-mcasp.c:			of_match_device(of_match_ptr(mcasp_dt_ids), &pdev->dev);
sound/soc/davinci/davinci-mcasp.c:	if (pdev->dev.platform_data) {
sound/soc/davinci/davinci-mcasp.c:		pdata = pdev->dev.platform_data;
sound/soc/davinci/davinci-mcasp.c:		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
sound/soc/davinci/davinci-mcasp.c:			dev_err(&pdev->dev,
sound/soc/davinci/davinci-mcasp.c:		dev_err(&pdev->dev,
sound/soc/davinci/davinci-mcasp.c:		of_serial_dir = devm_kzalloc(&pdev->dev,
sound/soc/davinci/davinci-mcasp.c:		dev_err(&pdev->dev, "Error populating platform data, err %d\n",
sound/soc/davinci/davinci-mcasp.c:	if (!pdev->dev.platform_data && !pdev->dev.of_node) {
sound/soc/davinci/davinci-mcasp.c:		dev_err(&pdev->dev, "No platform data supplied\n");
sound/soc/davinci/davinci-mcasp.c:	dev = devm_kzalloc(&pdev->dev, sizeof(struct davinci_audio_dev),
sound/soc/davinci/davinci-mcasp.c:		dev_err(&pdev->dev, "no platform data\n");
sound/soc/davinci/davinci-mcasp.c:		dev_err(&pdev->dev, "no mem resource?\n");
sound/soc/davinci/davinci-mcasp.c:	ioarea = devm_request_mem_region(&pdev->dev, mem->start,
sound/soc/davinci/davinci-mcasp.c:			resource_size(mem), pdev->name);
sound/soc/davinci/davinci-mcasp.c:		dev_err(&pdev->dev, "Audio region already claimed\n");
sound/soc/davinci/davinci-mcasp.c:	pm_runtime_enable(&pdev->dev);
sound/soc/davinci/davinci-mcasp.c:	ret = pm_runtime_get_sync(&pdev->dev);
sound/soc/davinci/davinci-mcasp.c:		dev_err(&pdev->dev, "pm_runtime_get_sync() failed\n");
sound/soc/davinci/davinci-mcasp.c:	dev->base = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
sound/soc/davinci/davinci-mcasp.c:		dev_err(&pdev->dev, "ioremap failed\n");
sound/soc/davinci/davinci-mcasp.c:	dev->dev = &pdev->dev;
sound/soc/davinci/davinci-mcasp.c:		dev_err(&pdev->dev, "no DMA resource\n");
sound/soc/davinci/davinci-mcasp.c:		dev_err(&pdev->dev, "no DMA resource\n");
sound/soc/davinci/davinci-mcasp.c:	dev_set_drvdata(&pdev->dev, dev);
sound/soc/davinci/davinci-mcasp.c:	ret = snd_soc_register_component(&pdev->dev, &davinci_mcasp_component,
sound/soc/davinci/davinci-mcasp.c:	ret = davinci_soc_platform_register(&pdev->dev);
sound/soc/davinci/davinci-mcasp.c:		dev_err(&pdev->dev, "register PCM failed: %d\n", ret);
sound/soc/davinci/davinci-mcasp.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/davinci/davinci-mcasp.c:	pm_runtime_put_sync(&pdev->dev);
sound/soc/davinci/davinci-mcasp.c:	pm_runtime_disable(&pdev->dev);
sound/soc/davinci/davinci-mcasp.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/davinci/davinci-mcasp.c:	davinci_soc_platform_unregister(&pdev->dev);
sound/soc/davinci/davinci-mcasp.c:	pm_runtime_put_sync(&pdev->dev);
sound/soc/davinci/davinci-mcasp.c:	pm_runtime_disable(&pdev->dev);
sound/soc/kirkwood/kirkwood-dma.c:	return snd_soc_register_platform(&pdev->dev, &kirkwood_soc_platform);
sound/soc/kirkwood/kirkwood-dma.c:	snd_soc_unregister_platform(&pdev->dev);
sound/soc/kirkwood/kirkwood-t5325.c:	card->dev = &pdev->dev;
sound/soc/kirkwood/kirkwood-t5325.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/soc/kirkwood/kirkwood-i2s.c:	struct kirkwood_asoc_platform_data *data = pdev->dev.platform_data;
sound/soc/kirkwood/kirkwood-i2s.c:	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
sound/soc/kirkwood/kirkwood-i2s.c:		dev_err(&pdev->dev, "allocation failed\n");
sound/soc/kirkwood/kirkwood-i2s.c:	dev_set_drvdata(&pdev->dev, priv);
sound/soc/kirkwood/kirkwood-i2s.c:	priv->io = devm_ioremap_resource(&pdev->dev, mem);
sound/soc/kirkwood/kirkwood-i2s.c:		dev_err(&pdev->dev, "platform_get_irq failed\n");
sound/soc/kirkwood/kirkwood-i2s.c:		dev_err(&pdev->dev, "no platform data ?!\n");
sound/soc/kirkwood/kirkwood-i2s.c:	priv->clk = devm_clk_get(&pdev->dev, NULL);
sound/soc/kirkwood/kirkwood-i2s.c:		dev_err(&pdev->dev, "no clock\n");
sound/soc/kirkwood/kirkwood-i2s.c:	priv->extclk = clk_get(&pdev->dev, "extclk");
sound/soc/kirkwood/kirkwood-i2s.c:			dev_info(&pdev->dev, "found external clock\n");
sound/soc/kirkwood/kirkwood-i2s.c:	err = snd_soc_register_component(&pdev->dev, &kirkwood_i2s_component,
sound/soc/kirkwood/kirkwood-i2s.c:	dev_err(&pdev->dev, "snd_soc_register_component failed\n");
sound/soc/kirkwood/kirkwood-i2s.c:	struct kirkwood_dma_data *priv = dev_get_drvdata(&pdev->dev);
sound/soc/kirkwood/kirkwood-i2s.c:	snd_soc_unregister_component(&pdev->dev);
sound/soc/kirkwood/kirkwood-openrd.c:	card->dev = &pdev->dev;
sound/soc/kirkwood/kirkwood-openrd.c:		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
sound/atmel/ac97c.c:		dev_dbg(&chip->pdev->dev, "too complex transfer\n");
sound/atmel/ac97c.c:		dev_dbg(&chip->pdev->dev, "could not prepare cyclic DMA\n");
sound/atmel/ac97c.c:		dev_dbg(&chip->pdev->dev, "could not set rate %d Hz\n",
sound/atmel/ac97c.c:		dev_dbg(&chip->pdev->dev, "could not set rate %d Hz\n",
sound/atmel/ac97c.c:		dev_dbg(&chip->pdev->dev, "channel A event%s%s%s%s%s%s\n",
sound/atmel/ac97c.c:		dev_info(&chip->pdev->dev, "codec channel event%s%s%s%s%s\n",
sound/atmel/ac97c.c:		dev_err(&chip->pdev->dev, "spurious interrupt sr 0x%08x "
sound/atmel/ac97c.c:			chip->pdev->id, playback, capture, &pcm);
sound/atmel/ac97c.c:			&chip->pdev->dev, hw.periods_min * hw.period_bytes_min,
sound/atmel/ac97c.c:	dev_dbg(&chip->pdev->dev, "codec write timeout\n");
sound/atmel/ac97c.c:	dev_dbg(&chip->pdev->dev, "codec read timeout\n");
sound/atmel/ac97c.c:		dev_dbg(&pdev->dev, "no memory resource\n");
sound/atmel/ac97c.c:	pdata = pdev->dev.platform_data;
sound/atmel/ac97c.c:		dev_dbg(&pdev->dev, "no platform data\n");
sound/atmel/ac97c.c:		dev_dbg(&pdev->dev, "could not get irq\n");
sound/atmel/ac97c.c:		pclk = clk_get(&pdev->dev, "pclk");
sound/atmel/ac97c.c:		pclk = clk_get(&pdev->dev, "ac97_clk");
sound/atmel/ac97c.c:		dev_dbg(&pdev->dev, "no peripheral clock\n");
sound/atmel/ac97c.c:		dev_dbg(&pdev->dev, "could not create sound card device\n");
sound/atmel/ac97c.c:		dev_dbg(&pdev->dev, "unable to request irq %d\n", irq);
sound/atmel/ac97c.c:		dev_dbg(&pdev->dev, "could not remap register memory\n");
sound/atmel/ac97c.c:			dev_dbg(&pdev->dev, "reset pin not available\n");
sound/atmel/ac97c.c:	snd_card_set_dev(card, &pdev->dev);
sound/atmel/ac97c.c:		dev_dbg(&pdev->dev, "could not register on ac97 bus\n");
sound/atmel/ac97c.c:		dev_dbg(&pdev->dev, "could not register ac97 mixer\n");
sound/atmel/ac97c.c:			dev_info(&chip->pdev->dev, "using %s for DMA RX\n",
sound/atmel/ac97c.c:			dev_info(&chip->pdev->dev, "using %s for DMA TX\n",
sound/atmel/ac97c.c:			dev_dbg(&pdev->dev, "DMA not available\n");
sound/atmel/ac97c.c:		dev_dbg(&pdev->dev, "could not register ac97 pcm device\n");
sound/atmel/ac97c.c:		dev_dbg(&pdev->dev, "could not register sound card\n");
sound/atmel/ac97c.c:	dev_info(&pdev->dev, "Atmel AC97 controller at 0x%p, irq = %d\n",
sound/atmel/abdac.c:		dev_dbg(&dac->pdev->dev, "too complex transfer\n");
sound/atmel/abdac.c:		dev_dbg(&dac->pdev->dev, "could not prepare cyclic DMA\n");
sound/atmel/abdac.c:		dev_err(&dac->pdev->dev, "underrun detected\n");
sound/atmel/abdac.c:		dev_err(&dac->pdev->dev, "spurious interrupt (status=0x%x)\n",
sound/atmel/abdac.c:			dac->pdev->id, 1, 0, &pcm);
sound/atmel/abdac.c:			&dac->pdev->dev, hw.periods_min * hw.period_bytes_min,
sound/atmel/abdac.c:		dev_dbg(&pdev->dev, "no memory resource\n");
sound/atmel/abdac.c:		dev_dbg(&pdev->dev, "could not get IRQ number\n");
sound/atmel/abdac.c:	pdata = pdev->dev.platform_data;
sound/atmel/abdac.c:		dev_dbg(&pdev->dev, "no platform data\n");
sound/atmel/abdac.c:	pclk = clk_get(&pdev->dev, "pclk");
sound/atmel/abdac.c:		dev_dbg(&pdev->dev, "no peripheral clock\n");
sound/atmel/abdac.c:	sample_clk = clk_get(&pdev->dev, "sample_clk");
sound/atmel/abdac.c:		dev_dbg(&pdev->dev, "no sample clock\n");
sound/atmel/abdac.c:		dev_dbg(&pdev->dev, "could not create sound card device\n");
sound/atmel/abdac.c:		dev_dbg(&pdev->dev, "could not set supported rates\n");
sound/atmel/abdac.c:		dev_dbg(&pdev->dev, "could not remap register memory\n");
sound/atmel/abdac.c:		dev_dbg(&pdev->dev, "could not request irq\n");
sound/atmel/abdac.c:	snd_card_set_dev(card, &pdev->dev);
sound/atmel/abdac.c:		dev_dbg(&pdev->dev, "DMA not available\n");
sound/atmel/abdac.c:		dev_dbg(&pdev->dev, "could not register ABDAC pcm device\n");
sound/atmel/abdac.c:		dev_dbg(&pdev->dev, "could not register sound card\n");
sound/atmel/abdac.c:	dev_info(&pdev->dev, "Atmel ABDAC at 0x%p using %s\n",
sound/mips/hal2.c:	snd_card_set_dev(card, &pdev->dev);
sound/mips/sgio2audio.c:	snd_card_set_dev(card, &pdev->dev);
sound/pci/asihpi/hpios.c:		dma_alloc_coherent(&pdev->dev, size, &p_mem_area->dma_handle,
sound/pci/asihpi/hpios.c:		p_mem_area->pdev = &pdev->dev;
sound/drivers/mts64.c:	int dev = pdev->id;
sound/drivers/mts64.c:	snd_card_set_dev(card, &pdev->dev);
sound/drivers/portman2x4.c:	int dev = pdev->id;
sound/drivers/portman2x4.c:	snd_card_set_dev(card, &pdev->dev);
sound/spi/at73c213.c:			SNDRV_DMA_TYPE_DEV, &chip->ssc->pdev->dev,
sound/isa/opl3sa2.c:	snd_card_set_dev(card, &pdev->dev);
sound/isa/opl3sa2.c:	snd_card_set_dev(card, &pdev->dev);
sound/isa/es18xx.c:	snd_card_set_dev(card, &pdev->dev);
sound/isa/cs423x/cs4236.c:	strcpy(cid, pdev->id[0].id);
sound/isa/cs423x/cs4236.c:	list_for_each_entry(cdev, &(pdev->protocol->devices), protocol_list) {
sound/isa/cs423x/cs4236.c:	snd_card_set_dev(card, &pdev->dev);
sound/ppc/pmac.c:	rec->space = dma_alloc_coherent(&chip->pdev->dev, rsize,
sound/ppc/pmac.c:		dma_free_coherent(&chip->pdev->dev, rsize, rec->space, rec->dma_base);
sound/ppc/pmac.c:					      &chip->pdev->dev,
sound/ppc/beep.c:	dmabuf = dma_alloc_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,
sound/ppc/beep.c:	input_dev->dev.parent = &chip->pdev->dev;
sound/ppc/beep.c:		dma_free_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,
sound/ppc/beep.c:		dma_free_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,
arch/arm/mach-mesong9tv/pm.c:	pdev->dev.platform_data=&aml_pm_pdata;
arch/arm/mach-mesong9tv/pm.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-mesong9tv/pm.c:		dev_err(&pdev->dev, "cannot get platform data\n");
arch/arm/mach-mesong9tv/vpu.c:	vpu_np = pdev->dev.of_node;
arch/arm/mach-mesong9tv/gpio.c:	g9tv_gpio_chip.of_node = pdev->dev.of_node;
arch/arm/mach-mesong9tv/gpio.c:	dev_info(&pdev->dev, "Probed amlogic GPIO driver\n");
arch/arm/mach-davinci/time.c:	base = ioremap(pdev->resource[0].start, SZ_4K);
arch/arm/mach-davinci/time.c:	wd_clk = clk_get(&pdev->dev, NULL);
arch/arm/mach-davinci/dma.c:	for (i = 0; i < pdev->num_resources; i++) {
arch/arm/mach-davinci/dma.c:		if ((pdev->resource[i].flags & IORESOURCE_DMA) &&
arch/arm/mach-davinci/dma.c:				(int)pdev->resource[i].start >= 0) {
arch/arm/mach-davinci/dma.c:			ctlr = EDMA_CTLR(pdev->resource[i].start);
arch/arm/mach-davinci/dma.c:			clear_bit(EDMA_CHAN_SLOT(pdev->resource[i].start),
arch/arm/mach-davinci/dma.c:	struct edma_soc_info	**info = pdev->dev.platform_data;
arch/arm/mach-davinci/dma.c:			dev_name(&pdev->dev));
arch/arm/mach-davinci/dma.c:		dev_dbg(&pdev->dev, "DMA REG BASE ADDR=%p\n",
arch/arm/mach-davinci/dma.c:					&pdev->dev);
arch/arm/mach-davinci/dma.c:			dev_dbg(&pdev->dev, "request_irq %d failed --> %d\n",
arch/arm/mach-davinci/dma.c:					"edma_error", &pdev->dev);
arch/arm/mach-davinci/dma.c:			dev_dbg(&pdev->dev, "request_irq %d failed --> %d\n",
arch/arm/mach-davinci/dma.c:					"edma_tc0", &pdev->dev);
arch/arm/mach-davinci/dma.c:			dev_dbg(&pdev->dev, "request_irq %d failed --> %d\n",
arch/arm/mach-davinci/dma.c:					"edma_tc1", &pdev->dev);
arch/arm/mach-davinci/dma.c:			dev_dbg(&pdev->dev, "request_irq %d --> %d\n",
arch/arm/mach-davinci/dma.c:			free_irq(err_irq[i], &pdev->dev);
arch/arm/mach-davinci/dma.c:			free_irq(irq[i], &pdev->dev);
arch/arm/mach-davinci/pm.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-davinci/pm.c:		dev_err(&pdev->dev, "cannot get platform data\n");
arch/arm/mach-davinci/pm.c:		dev_err(&pdev->dev, "cannot allocate SRAM memory\n");
arch/arm/mach-davinci/cpuidle.c:	struct davinci_cpuidle_config *pdata = pdev->dev.platform_data;
arch/arm/mach-davinci/cpuidle.c:		dev_err(&pdev->dev, "cannot get platform data\n");
arch/arm/mach-davinci/devices-da8xx.c:	pdev->dev.platform_data = pdata;
arch/arm/mach-davinci/tnetv107x.c:	regs = ioremap(pdev->resource[0].start, SZ_4K);
arch/arm/mach-davinci/da850.c:	struct davinci_pm_config *pdata = pdev->dev.platform_data;
arch/arm/mach-davinci/devices-tnetv107x.c:	pdev->name		= "davinci_nand";
arch/arm/mach-davinci/devices-tnetv107x.c:	pdev->id		= chipsel;
arch/arm/mach-davinci/devices-tnetv107x.c:	pdev->dev.platform_data	= data;
arch/arm/mach-davinci/devices.c:	pdev->dev.platform_data = config;
arch/arm/mach-ep93xx/vision_ep9307.c:				dev_name(&pdev->dev));
arch/arm/mach-ep93xx/core.c:	if (pdev->id == 0) {
arch/arm/mach-ep93xx/core.c:	} else if (pdev->id == 1) {
arch/arm/mach-ep93xx/core.c:				   dev_name(&pdev->dev));
arch/arm/mach-ep93xx/core.c:	if (pdev->id == 1) {
arch/arm/mach-ep93xx/core.c:		err = gpio_request(EP93XX_GPIO_LINE_C(i), dev_name(&pdev->dev));
arch/arm/mach-ep93xx/core.c:		err = gpio_request(EP93XX_GPIO_LINE_D(i), dev_name(&pdev->dev));
arch/arm/mach-ep93xx/core.c:	err = gpio_request(EP93XX_GPIO_LINE_EGPIO2, dev_name(&pdev->dev));
arch/arm/mach-ep93xx/core.c:	err = gpio_request(EP93XX_GPIO_LINE_EGPIO15, dev_name(&pdev->dev));
arch/arm/mach-ep93xx/core.c:		err = gpio_request(EP93XX_GPIO_LINE_E(i), dev_name(&pdev->dev));
arch/arm/mach-ep93xx/core.c:		err = gpio_request(EP93XX_GPIO_LINE_G(i), dev_name(&pdev->dev));
arch/arm/mach-ep93xx/core.c:		err = gpio_request(EP93XX_GPIO_LINE_H(i), dev_name(&pdev->dev));
arch/arm/plat-pxa/ssp.c:		dev_err(&ssp->pdev->dev, "device already free\n");
arch/arm/plat-pxa/ssp.c:		dev_err(&pdev->dev, "failed to allocate memory");
arch/arm/plat-pxa/ssp.c:	ssp->clk = clk_get(&pdev->dev, NULL);
arch/arm/plat-pxa/ssp.c:		dev_err(&pdev->dev, "no SSP RX DRCMR defined\n");
arch/arm/plat-pxa/ssp.c:		dev_err(&pdev->dev, "no SSP TX DRCMR defined\n");
arch/arm/plat-pxa/ssp.c:		dev_err(&pdev->dev, "no memory resource defined\n");
arch/arm/plat-pxa/ssp.c:			pdev->name);
arch/arm/plat-pxa/ssp.c:		dev_err(&pdev->dev, "failed to request memory resource\n");
arch/arm/plat-pxa/ssp.c:		dev_err(&pdev->dev, "failed to ioremap() registers\n");
arch/arm/plat-pxa/ssp.c:		dev_err(&pdev->dev, "no IRQ resource defined\n");
arch/arm/plat-pxa/ssp.c:	/* PXA2xx/3xx SSP ports starts from 1 and the internal pdev->id
arch/arm/plat-pxa/ssp.c:	ssp->port_id = pdev->id + 1;
arch/arm/mach-pxa/sharpsl_pm.c:	if (!pdev->dev.platform_data)
arch/arm/mach-pxa/sharpsl_pm.c:	sharpsl_pm.dev = &pdev->dev;
arch/arm/mach-pxa/sharpsl_pm.c:	sharpsl_pm.machinfo = pdev->dev.platform_data;
arch/arm/mach-pxa/sharpsl_pm.c:	ret = device_create_file(&pdev->dev, &dev_attr_battery_percentage);
arch/arm/mach-pxa/sharpsl_pm.c:	ret |= device_create_file(&pdev->dev, &dev_attr_battery_voltage);
arch/arm/mach-pxa/sharpsl_pm.c:		dev_warn(&pdev->dev, "Failed to register attributes (%d)\n", ret);
arch/arm/mach-pxa/sharpsl_pm.c:	device_remove_file(&pdev->dev, &dev_attr_battery_percentage);
arch/arm/mach-pxa/sharpsl_pm.c:	device_remove_file(&pdev->dev, &dev_attr_battery_voltage);
arch/arm/mach-pxa/pxa3xx-ulpi.c:	struct pxa3xx_u2d_platform_data *pdata = pdev->dev.platform_data;
arch/arm/mach-pxa/pxa3xx-ulpi.c:		dev_err(&pdev->dev, "failed to allocate memory\n");
arch/arm/mach-pxa/pxa3xx-ulpi.c:	u2d->clk = clk_get(&pdev->dev, NULL);
arch/arm/mach-pxa/pxa3xx-ulpi.c:		dev_err(&pdev->dev, "failed to get u2d clock\n");
arch/arm/mach-pxa/pxa3xx-ulpi.c:		dev_err(&pdev->dev, "no IO memory resource defined\n");
arch/arm/mach-pxa/pxa3xx-ulpi.c:        r = request_mem_region(r->start, resource_size(r), pdev->name);
arch/arm/mach-pxa/pxa3xx-ulpi.c:                dev_err(&pdev->dev, "failed to request memory resource\n");
arch/arm/mach-pxa/pxa3xx-ulpi.c:		dev_err(&pdev->dev, "ioremap() failed\n");
arch/arm/mach-pxa/pxa3xx-ulpi.c:		err = pdata->init(&pdev->dev);
arch/arm/mach-pxa/pxa3xx-ulpi.c:		pdata->exit(&pdev->dev);
arch/arm/mach-pxa/pxa3xx-ulpi.c:	struct pxa3xx_u2d_platform_data *pdata = pdev->dev.platform_data;
arch/arm/mach-pxa/pxa3xx-ulpi.c:		pdata->exit(&pdev->dev);
arch/arm/mach-imx/mach-cpuimx35.c:	return mx35_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_DIFF_UNI);
arch/arm/mach-imx/mach-cpuimx35.c:	return mx35_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_SINGLE_UNI |
arch/arm/mach-imx/mach-mx31lite.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED);
arch/arm/mach-imx/mach-eukrea_cpuimx25.c:	return mx25_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_DIFF_UNI);
arch/arm/mach-imx/mach-eukrea_cpuimx25.c:	return mx25_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_SINGLE_UNI |
arch/arm/mach-imx/mach-pcm043.c:	return mx35_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_DIFF_UNI);
arch/arm/mach-imx/mach-pcm043.c:	return mx35_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_SINGLE_UNI |
arch/arm/mach-imx/mach-mx31moboard.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED);
arch/arm/mach-imx/mach-mx31moboard.c:	dma = dma_declare_coherent_memory(&pdev->dev,
arch/arm/mach-imx/mach-mx31_3ds.c:	dma = dma_declare_coherent_memory(&pdev->dev,
arch/arm/mach-imx/mach-mx31_3ds.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED);
arch/arm/mach-imx/mach-mx31_3ds.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED);
arch/arm/mach-imx/mach-mx35_3ds.c:	dma = dma_declare_coherent_memory(&pdev->dev,
arch/arm/mach-imx/mach-mx35_3ds.c:	return mx35_initialize_usb_hw(pdev->id, MXC_EHCI_INTERNAL_PHY);
arch/arm/mach-imx/mach-mx35_3ds.c:	return mx35_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_SINGLE_UNI |
arch/arm/mach-imx/mach-mx35_3ds.c:	mx35_3ds_lcd.dev.parent = &imx35_fb_pdev->dev;
arch/arm/mach-imx/mx31moboard-marxbot.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED |
arch/arm/mach-imx/mach-mx27_3ds.c:	return mx27_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_DIFF_UNI);
arch/arm/mach-imx/mach-armadillo5x0.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED |
arch/arm/mach-imx/mach-armadillo5x0.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED |
arch/arm/mach-imx/mach-cpuimx27.c:	return mx27_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_DIFF_UNI);
arch/arm/mach-imx/mach-cpuimx27.c:	return mx27_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_DIFF_UNI);
arch/arm/mach-imx/mmdc.c:	struct device_node *np = pdev->dev.of_node;
arch/arm/mach-imx/mx31moboard-smartbot.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED);
arch/arm/mach-imx/devices/platform-ipu-core.c:	pdev->dev.dma_mask = kmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);
arch/arm/mach-imx/devices/platform-ipu-core.c:	if (!pdev->dev.dma_mask)
arch/arm/mach-imx/devices/platform-ipu-core.c:	*pdev->dev.dma_mask = DMA_BIT_MASK(32);
arch/arm/mach-imx/devices/platform-ipu-core.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
arch/arm/mach-imx/devices/platform-ipu-core.c:			kfree(pdev->dev.dma_mask);
arch/arm/mach-imx/devices/platform-ipu-core.c:		copied_pdata = dev_get_platdata(&pdev->dev);
arch/arm/mach-imx/mach-pcm038.c:	return mx27_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED |
arch/arm/mach-imx/mach-pcm037.c:	dma = dma_declare_coherent_memory(&pdev->dev,
arch/arm/mach-imx/mach-pcm037.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_DIFF_UNI);
arch/arm/mach-imx/mach-pcm037.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_DIFF_UNI);
arch/arm/mach-imx/mach-mx31lilly.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED |
arch/arm/mach-imx/mach-mx31lilly.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED);
arch/arm/mach-imx/mach-pca100.c:	return mx27_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_DIFF_UNI);
arch/arm/mach-imx/mach-pca100.c:	return mx27_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_DIFF_UNI);
arch/arm/mach-imx/mach-mx25_3ds.c:	return mx25_initialize_usb_hw(pdev->id, MXC_EHCI_INTERNAL_PHY);
arch/arm/mach-imx/mx31moboard-devboard.c:	return mx31_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED |
arch/arm/mach-imx/mach-imx27_visstrim_m10.c:	dma = dma_declare_coherent_memory(&pdev->dev,
arch/arm/mach-imx/mach-imx27_visstrim_m10.c:	return mx27_initialize_usb_hw(pdev->id, MXC_EHCI_POWER_PINS_ENABLED);
arch/arm/mach-imx/mach-imx27_visstrim_m10.c:	dma = dma_declare_coherent_memory(&pdev->dev,
arch/arm/mach-imx/mach-imx27_visstrim_m10.c:	dma = dma_declare_coherent_memory(&pdev->dev,
arch/arm/mach-imx/mach-imx27_visstrim_m10.c:	dma = dma_declare_coherent_memory(&pdev->dev,
arch/arm/mach-imx/mach-vpr200.c:	return mx35_initialize_usb_hw(pdev->id,
arch/arm/mach-msm/board-qsd8x50.c:		clear_bit(pdev->id, &vreg_sts);
arch/arm/mach-msm/board-qsd8x50.c:						"%d: %d\n", pdev->id, rc);
arch/arm/mach-msm/board-qsd8x50.c:					pdev->id, rc);
arch/arm/mach-msm/board-qsd8x50.c:					pdev->id, rc);
arch/arm/mach-msm/board-qsd8x50.c:	set_bit(pdev->id, &vreg_sts);
arch/arm/mach-msm/devices-qsd8x50.c:	pdev->dev.platform_data = plat;
arch/arm/mach-msm/devices-msm7x00.c:	pdev->dev.platform_data = plat;
arch/arm/mach-s5pc100/dev-audio.c:	switch (pdev->id) {
arch/arm/mach-s5pc100/dev-audio.c:		printk(KERN_ERR "Invalid Device %d\n", pdev->id);
arch/arm/mach-s5pc100/dev-audio.c:	switch (pdev->id) {
arch/arm/mach-meson8b/pm.c:	pdev->dev.platform_data=&aml_pm_pdata;
arch/arm/mach-meson8b/pm.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-meson8b/pm.c:		dev_err(&pdev->dev, "cannot get platform data\n");
arch/arm/mach-meson8b/vpu.c:	vpu_np = pdev->dev.of_node;
arch/arm/mach-meson8b/gpio.c:		amlogic_gpio_chip.of_node = pdev->dev.of_node;
arch/arm/mach-meson8b/gpio.c:	dev_info(&pdev->dev, "Probed amlogic GPIO driver\n");
arch/arm/mach-exynos/setup-usb-phy.c:	xusbxti_clk = clk_get(&pdev->dev, "xusbxti");
arch/arm/mach-exynos/setup-usb-phy.c:	otg_clk = clk_get(&pdev->dev, "otg");
arch/arm/mach-exynos/setup-usb-phy.c:		dev_err(&pdev->dev, "Failed to get otg clock\n");
arch/arm/mach-exynos/setup-usb-phy.c:	otg_clk = clk_get(&pdev->dev, "otg");
arch/arm/mach-exynos/setup-usb-phy.c:		dev_err(&pdev->dev, "Failed to get otg clock\n");
arch/arm/mach-exynos/dev-audio.c:	switch (pdev->id) {
arch/arm/mach-exynos/dev-audio.c:		printk(KERN_ERR "Invalid Device %d\n", pdev->id);
arch/arm/mach-exynos/dev-audio.c:	switch (pdev->id) {
arch/arm/mach-exynos/pm_domains.c:	if (pdev->dev.bus) {
arch/arm/mach-exynos/pm_domains.c:		if (!pm_genpd_add_device(&pd->pd, &pdev->dev))
arch/arm/mach-exynos/pm_domains.c:			pm_genpd_dev_need_restore(&pdev->dev, true);
arch/arm/mach-exynos/pm_domains.c:				"domain\n", __func__, dev_name(&pdev->dev),
arch/arm/mach-mxs/mach-mxs.c:	pctl = pinctrl_get_select(&pdev->dev, "gpio_mode");
arch/arm/mach-omap2/gpmc.c:		dev_err(&pdev->dev, "%s has no 'reg' property\n",
arch/arm/mach-omap2/gpmc.c:	gpmc_nand_data = devm_kzalloc(&pdev->dev, sizeof(*gpmc_nand_data),
arch/arm/mach-omap2/gpmc.c:		dev_err(&pdev->dev, "%s has no 'reg' property\n",
arch/arm/mach-omap2/gpmc.c:	gpmc_onenand_data = devm_kzalloc(&pdev->dev, sizeof(*gpmc_onenand_data),
arch/arm/mach-omap2/gpmc.c:		dev_err(&pdev->dev, "%s has no 'reg' property\n",
arch/arm/mach-omap2/gpmc.c:		dev_err(&pdev->dev, "%s has malformed 'reg' property\n",
arch/arm/mach-omap2/gpmc.c:		dev_err(&pdev->dev, "cannot request GPMC CS %d\n", cs);
arch/arm/mach-omap2/gpmc.c:		dev_err(&pdev->dev, "cannot remap GPMC CS %d to 0x%x\n",
arch/arm/mach-omap2/gpmc.c:	if (of_platform_device_create(child, NULL, &pdev->dev))
arch/arm/mach-omap2/gpmc.c:	dev_err(&pdev->dev, "failed to create gpmc child %s\n", child->name);
arch/arm/mach-omap2/gpmc.c:		of_match_device(gpmc_dt_ids, &pdev->dev);
arch/arm/mach-omap2/gpmc.c:	ret = of_property_read_u32(pdev->dev.of_node, "gpmc,num-waitpins",
arch/arm/mach-omap2/gpmc.c:	for_each_child_of_node(pdev->dev.of_node, child) {
arch/arm/mach-omap2/gpmc.c:	gpmc_base = devm_ioremap_resource(&pdev->dev, res);
arch/arm/mach-omap2/gpmc.c:		dev_warn(&pdev->dev, "Failed to get resource: irq\n");
arch/arm/mach-omap2/gpmc.c:	gpmc_l3_clk = clk_get(&pdev->dev, "fck");
arch/arm/mach-omap2/gpmc.c:		dev_err(&pdev->dev, "error: clk_get\n");
arch/arm/mach-omap2/gpmc.c:	gpmc_dev = &pdev->dev;
arch/arm/mach-omap2/gpmc.c:	if (!pdev->dev.of_node)
arch/arm/mach-omap2/serial.c:		pm_runtime_set_active(&pdev->dev);
arch/arm/mach-omap2/serial.c:		device_init_wakeup(&pdev->dev, true);
arch/arm/mach-omap2/dma.c:		dev_err(&pdev->dev, "%s: no mem resource\n", __func__);
arch/arm/mach-omap2/dma.c:		dev_err(&pdev->dev, "%s: ioremap fail\n", __func__);
arch/arm/mach-omap2/dma.c:		dev_err(&pdev->dev, "%s: kzalloc fail\n", __func__);
arch/arm/mach-omap2/opp.c:			dev = &oh->od->pdev->dev;
arch/arm/mach-omap2/mailbox.c:	ret = omap_mbox_register(&pdev->dev, list);
arch/arm/mach-omap2/omap_device.c:	dev_dbg(&od->pdev->dev, "Creating %s -> %s\n", clk_alias, clk_name);
arch/arm/mach-omap2/omap_device.c:	r = clk_get_sys(dev_name(&od->pdev->dev), clk_alias);
arch/arm/mach-omap2/omap_device.c:		dev_warn(&od->pdev->dev,
arch/arm/mach-omap2/omap_device.c:		dev_err(&od->pdev->dev,
arch/arm/mach-omap2/omap_device.c:	l = clkdev_alloc(r, clk_alias, dev_name(&od->pdev->dev));
arch/arm/mach-omap2/omap_device.c:		dev_err(&od->pdev->dev,
arch/arm/mach-omap2/omap_device.c:	struct device_node *node = pdev->dev.of_node;
arch/arm/mach-omap2/omap_device.c:		dev_dbg(&pdev->dev, "No 'hwmods' to build omap_device\n");
arch/arm/mach-omap2/omap_device.c:			dev_err(&pdev->dev, "Cannot lookup hwmod '%s'\n",
arch/arm/mach-omap2/omap_device.c:		dev_err(&pdev->dev, "Cannot allocate omap_device for :%s\n",
arch/arm/mach-omap2/omap_device.c:	for (i = 0; i < pdev->num_resources; i++) {
arch/arm/mach-omap2/omap_device.c:		struct resource *r = &pdev->resource[i];
arch/arm/mach-omap2/omap_device.c:			r->name = dev_name(&pdev->dev);
arch/arm/mach-omap2/omap_device.c:	pdev->dev.pm_domain = &omap_device_pm_domain;
arch/arm/mach-omap2/omap_device.c:		if (pdev->archdata.od)
arch/arm/mach-omap2/omap_device.c:			omap_device_delete(pdev->archdata.od);
arch/arm/mach-omap2/omap_device.c:		if (pdev->dev.of_node)
arch/arm/mach-omap2/omap_device.c:		 od->pdev->name, c, od->hwmods_cnt);
arch/arm/mach-omap2/omap_device.c:	 *   Here, pdev->num_resources = 0, and we should get all the
arch/arm/mach-omap2/omap_device.c:	 *   If pdev->num_resources > 0, we assume that MEM & IRQ resources
arch/arm/mach-omap2/omap_device.c:	if (!pdev->num_resources) {
arch/arm/mach-omap2/omap_device.c:		for (i = 0; i < pdev->num_resources; i++) {
arch/arm/mach-omap2/omap_device.c:			struct resource *r = &pdev->resource[i];
arch/arm/mach-omap2/omap_device.c:		res_count += pdev->num_resources;
arch/arm/mach-omap2/omap_device.c:	if (!pdev->num_resources) {
arch/arm/mach-omap2/omap_device.c:		dev_dbg(&pdev->dev, "%s: using %d resources from hwmod\n",
arch/arm/mach-omap2/omap_device.c:		dev_dbg(&pdev->dev,
arch/arm/mach-omap2/omap_device.c:			__func__, res_count - pdev->num_resources);
arch/arm/mach-omap2/omap_device.c:		memcpy(res, pdev->resource,
arch/arm/mach-omap2/omap_device.c:		       sizeof(struct resource) * pdev->num_resources);
arch/arm/mach-omap2/omap_device.c:		_od_fill_dma_resources(od, &res[pdev->num_resources]);
arch/arm/mach-omap2/omap_device.c:	pdev->archdata.od = od;
arch/arm/mach-omap2/omap_device.c:	dev_err(&pdev->dev, "omap_device: build failed (%d)\n", ret);
arch/arm/mach-omap2/omap_device.c:	od->pdev->archdata.od = NULL;
arch/arm/mach-omap2/omap_device.c:	if (pdev->id != -1)
arch/arm/mach-omap2/omap_device.c:		dev_set_name(&pdev->dev, "%s.%d", pdev->name,  pdev->id);
arch/arm/mach-omap2/omap_device.c:		dev_set_name(&pdev->dev, "%s", pdev->name);
arch/arm/mach-omap2/omap_device.c:	pr_debug("omap_device: %s: registering\n", pdev->name);
arch/arm/mach-omap2/omap_device.c:	pdev->dev.pm_domain = &omap_device_pm_domain;
arch/arm/mach-omap2/omap_device.c:		dev_warn(&pdev->dev,
arch/arm/mach-omap2/omap_device.c:		dev_warn(&pdev->dev,
arch/arm/mach-omap2/omap_device.c:	return &oh->od->pdev->dev;
arch/arm/mach-omap2/usb-musb.c:	dev = &pdev->dev;
arch/arm/mach-omap2/omap4-common.c:	if (pdev->id == 0) {
arch/arm/mach-omap2/omap4-common.c:		omap4_twl6030_hsmmc_set_late_init(&c->pdev->dev);
arch/arm/mach-omap2/display.c:		pdev->dev.parent = &parent->dev;
arch/arm/mach-omap2/display.c:	if (pdev->id != -1)
arch/arm/mach-omap2/display.c:		dev_set_name(&pdev->dev, "%s.%d", pdev->name, pdev->id);
arch/arm/mach-omap2/display.c:		dev_set_name(&pdev->dev, "%s", pdev->name);
arch/arm/mach-omap2/display.c:		pdev->dev.parent = &parent->dev;
arch/arm/mach-omap2/display.c:	if (pdev->id != -1)
arch/arm/mach-omap2/display.c:		dev_set_name(&pdev->dev, "%s.%d", pdev->name, pdev->id);
arch/arm/mach-omap2/display.c:		dev_set_name(&pdev->dev, "%s", pdev->name);
arch/arm/mach-omap2/usb-host.c:	pdev->id = PLATFORM_DEVID_AUTO;
arch/arm/mach-omap2/usb-host.c:	pdev->name = reg_name;
arch/arm/mach-omap2/usb-host.c:	pdev->dev.platform_data = config;
arch/arm/mach-omap2/usb-host.c:		pdev->id = phy->port;
arch/arm/mach-omap2/usb-host.c:		pdev->name = nop_name;
arch/arm/mach-omap2/usb-host.c:		pdev->dev.platform_data = phy->platform_data;
arch/arm/mach-omap2/usb-host.c:					pdev->id);
arch/arm/mach-omap2/hsmmc.c:		mmc_pdata = pdev->dev.platform_data;
arch/arm/mach-omap2/hsmmc.c:	dev_set_name(&pdev->dev, "%s.%d", pdev->name, pdev->id);
arch/arm/mach-omap2/omap_device.h:	return pdev ? pdev->archdata.od : NULL;
arch/arm/mach-s5pv210/setup-usb-phy.c:	xusbxti = clk_get(&pdev->dev, "xusbxti");
arch/arm/mach-s5pv210/dev-audio.c:	switch (pdev->id) {
arch/arm/mach-s5pv210/dev-audio.c:		printk(KERN_ERR "Invalid Device %d\n", pdev->id);
arch/arm/mach-s5pv210/dev-audio.c:	switch (pdev->id) {
arch/arm/mach-s5p64x0/dev-audio.c:	switch (pdev->id) {
arch/arm/mach-s5p64x0/dev-audio.c:		printk(KERN_ERR "Invalid Device %d\n", pdev->id);
arch/arm/mach-s5p64x0/dev-audio.c:	switch (pdev->id) {
arch/arm/mach-s5p64x0/dev-audio.c:		printk(KERN_ERR "Invalid Device %d\n", pdev->id);
arch/arm/mach-s5p64x0/dev-audio.c:	switch (pdev->id) {
arch/arm/mach-s3c24xx/h1940-bluetooth.c:	ret = gpio_request(S3C2410_GPH(1), dev_name(&pdev->dev));
arch/arm/mach-s3c24xx/h1940-bluetooth.c:		dev_err(&pdev->dev, "could not get GPH1\n");
arch/arm/mach-s3c24xx/h1940-bluetooth.c:	ret = gpio_request(H1940_LATCH_BLUETOOTH_POWER, dev_name(&pdev->dev));
arch/arm/mach-s3c24xx/h1940-bluetooth.c:		dev_err(&pdev->dev, "could not get BT_POWER\n");
arch/arm/mach-s3c24xx/h1940-bluetooth.c:	rfk = rfkill_alloc(DRV_NAME, &pdev->dev, RFKILL_TYPE_BLUETOOTH,
arch/arm/mach-s3c24xx/mach-osiris-dvs.c:	dev_info(&pdev->dev, "initialising\n");
arch/arm/mach-s3c24xx/mach-osiris-dvs.c:		dev_err(&pdev->dev, "cannot claim gpio\n");
arch/arm/mach-s3c24xx/mach-osiris-dvs.c:		dev_err(&pdev->dev, "failed to register with cpufreq\n");
arch/arm/mach-s3c24xx/mach-osiris-dvs.c:	dev_info(&pdev->dev, "exiting\n");
arch/arm/mach-at91/at91sam9261_devices.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-at91/at91sam9g45_devices.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-at91/at91sam9rl_devices.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-at91/at91rm9200_devices.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-at91/at91sam9263_devices.c:	pdev->name = (data->flags & AT91_CF_TRUE_IDE) ? "pata_at91" : "at91_cf";
arch/arm/mach-at91/at91sam9263_devices.c:	pdev->name = "rtc-at91sam9";
arch/arm/mach-at91/at91sam9263_devices.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-at91/at91sam9260_devices.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-at91/at91sam9260_devices.c:		pdev->name = "pata_at91";
arch/arm/mach-at91/at91sam9260_devices.c:		pdev->name = "at91_cf";
arch/arm/common/scoop.c:	inf = pdev->dev.platform_data;
arch/arm/common/scoop.c:	reset_scoop(&pdev->dev);
arch/arm/common/scoop.c:		devptr->gpio.label = dev_name(&pdev->dev);
arch/arm/common/scoop.c:			dev_err(&pdev->dev, "Can't remove gpio chip: %d\n", ret);
arch/arm/common/fiq_debugger.c:	states[state->pdev->id] = state;
arch/arm/common/fiq_debugger.c:					   state->pdev->id, &state->pdev->dev);
arch/arm/common/fiq_debugger.c:	pr_info("Registered fiq debugger ttyFIQ%d\n", state->pdev->id);
arch/arm/common/fiq_debugger.c:	struct fiq_debugger_pdata *pdata = dev_get_platdata(&pdev->dev);
arch/arm/common/fiq_debugger.c:	if (pdev->id >= MAX_FIQ_DEBUGGER_PORTS)
arch/arm/common/fiq_debugger.c:	state->clk = clk_get(&pdev->dev, NULL);
arch/arm/common/fiq_debugger.c:	state->console.index = pdev->id;
arch/arm/common/sa1111.c:	return __sa1111_probe(&pdev->dev, mem, irq);
arch/arm/kernel/perf_event_cpu.c:	struct device_node *node = pdev->dev.of_node;
arch/arm/kernel/perf_event_cpu.c:	if (node && (of_id = of_match_node(cpu_pmu_of_device_ids, pdev->dev.of_node))) {
arch/arm/mach-mesong9bb/pm.c:	pdev->dev.platform_data=&aml_pm_pdata;
arch/arm/mach-mesong9bb/pm.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-mesong9bb/pm.c:		dev_err(&pdev->dev, "cannot get platform data\n");
arch/arm/mach-mesong9bb/vpu.c:	vpu_np = pdev->dev.of_node;
arch/arm/mach-mesong9bb/gpio.c:		amlogic_gpio_chip.of_node = pdev->dev.of_node;
arch/arm/mach-mesong9bb/gpio.c:	dev_info(&pdev->dev, "Probed amlogic GPIO driver\n");
arch/arm/mach-shmobile/board-marzen.c:	pm_runtime_enable(&pdev->dev);
arch/arm/mach-shmobile/board-marzen.c:	pm_runtime_get_sync(&pdev->dev);
arch/arm/mach-shmobile/board-marzen.c:	pm_runtime_put_sync(&pdev->dev);
arch/arm/mach-shmobile/board-marzen.c:	pm_runtime_disable(&pdev->dev);
arch/arm/mach-shmobile/board-ap4evb.c:	struct clk *pck = clk_get(&pdev->dev, "dsip_clk");
arch/arm/mach-shmobile/pm-rmobile.c:	struct device *dev = &pdev->dev;
arch/arm/mach-shmobile/board-ag5evm.c:	pck = clk_get(&pdev->dev, "dsip_clk");
arch/arm/mach-shmobile/board-ag5evm.c:	phy = clk_get(&pdev->dev, "dsiphy_clk");
arch/arm/mach-shmobile/board-kzm9g.c:			  dev_name(&pdev->dev), pdev);
arch/arm/mach-shmobile/board-kzm9g.c:		dev_err(&pdev->dev, "request_irq err\n");
arch/arm/mach-shmobile/board-armadillo800eva.c:	priv->phy	= clk_get(&pdev->dev, "phy");
arch/arm/mach-shmobile/board-armadillo800eva.c:	priv->usb24	= clk_get(&pdev->dev, "usb24");
arch/arm/mach-shmobile/board-armadillo800eva.c:	priv->pci	= clk_get(&pdev->dev, "pci");
arch/arm/mach-shmobile/board-armadillo800eva.c:	priv->func	= clk_get(&pdev->dev, "func");
arch/arm/mach-shmobile/board-armadillo800eva.c:	priv->host	= clk_get(&pdev->dev, "host");
arch/arm/mach-shmobile/board-armadillo800eva.c:		dev_err(&pdev->dev, "USB clock setting failed\n");
arch/arm/mach-shmobile/board-armadillo800eva.c:			  dev_name(&pdev->dev), pdev);
arch/arm/mach-shmobile/board-armadillo800eva.c:		dev_err(&pdev->dev, "request_irq err\n");
arch/arm/mach-shmobile/board-mackerel.c:	dev_dbg(&pdev->dev, "%s\n", __func__);
arch/arm/mach-shmobile/board-mackerel.c:			  dev_name(&pdev->dev), pdev);
arch/arm/mach-shmobile/board-mackerel.c:		dev_err(&pdev->dev, "request_irq err\n");
arch/arm/mach-omap1/dma.c:		dev_err(&pdev->dev, "%s: Unable to add resources for %s%d\n",
arch/arm/mach-omap1/dma.c:			__func__, pdev->name, pdev->id);
arch/arm/mach-omap1/dma.c:		dev_err(&pdev->dev, "%s: Unable to allocate 'p' for %s\n",
arch/arm/mach-omap1/dma.c:			__func__, pdev->name);
arch/arm/mach-omap1/dma.c:		dev_err(&pdev->dev, "%s: Unable to allocate 'd' for %s\n",
arch/arm/mach-omap1/dma.c:			__func__, pdev->name);
arch/arm/mach-omap1/dma.c:		dev_err(&pdev->dev,
arch/arm/mach-omap1/dma.c:		dev_err(&pdev->dev, "%s: Unable to add resources for %s%d\n",
arch/arm/mach-omap1/dma.c:			__func__, pdev->name, pdev->id);
arch/arm/mach-omap1/dma.c:		dev_err(&pdev->dev, "%s: Unable to add resources for %s%d\n",
arch/arm/mach-omap1/dma.c:			__func__, pdev->name, pdev->id);
arch/arm/mach-omap1/mailbox.c:	ret = omap_mbox_register(&pdev->dev, list);
arch/arm/mach-omap1/gpio16xx.c:		pdata = pdev->dev.platform_data;
arch/arm/mach-omap1/gpio16xx.c:			dev_err(&pdev->dev, "Invalid mem resource.\n");
arch/arm/mach-omap1/gpio16xx.c:			dev_err(&pdev->dev, "ioremap failed.\n");
arch/arm/mach-omap1/i2c.c:	pdev->id = bus_id;
arch/arm/mach-omap1/i2c.c:	pdev->name = name;
arch/arm/mach-omap1/i2c.c:	pdev->num_resources = ARRAY_SIZE(i2c_resources);
arch/arm/mach-omap1/i2c.c:	pdev->resource = res;
arch/arm/mach-omap1/i2c.c:	pdev->dev.platform_data = pdata;
arch/arm/mach-omap1/timer.c:	int n = (pdev->id - 1) << 1;
arch/arm/mach-omap1/timer.c:			dev_err(&pdev->dev, "%s: Failed to add resources.\n",
arch/arm/mach-omap1/timer.c:			dev_err(&pdev->dev, "%s: Failed to allocate pdata.\n",
arch/arm/mach-omap1/timer.c:			dev_err(&pdev->dev, "%s: Failed to add platform data.\n",
arch/arm/mach-omap1/timer.c:			dev_err(&pdev->dev, "%s: Failed to add platform device.\n",
arch/arm/mach-omap1/timer.c:		dev_dbg(&pdev->dev, " Registered.\n");
arch/arm/mach-omap1/devices.c:	data->dev = &pdev->dev;
arch/arm/mach-meson6tvd/pm.c:	pdev->dev.platform_data = &m6tv_pm_pdata;
arch/arm/mach-meson6tvd/pm.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-meson6tvd/pm.c:		dev_err(&pdev->dev, "cannot get platform data\n");
arch/arm/mach-meson6tvd/pm.c:		dev_err(&pdev->dev, "cannot allocate SRAM memory\n");
arch/arm/mach-meson6tvd/pm.c:		dev_err(&pdev->dev, "cannot allocate SRAM memory\n");
arch/arm/mach-meson6tvd/gpio.c:	m6tv_gpio_chip.of_node = pdev->dev.of_node;
arch/arm/mach-tegra/tegra2_emc.c:	pdata = emc_pdev->dev.platform_data;
arch/arm/mach-tegra/tegra2_emc.c:	pdata = emc_pdev->dev.platform_data;
arch/arm/mach-tegra/tegra2_emc.c:	struct device_node *np = pdev->dev.of_node;
arch/arm/mach-tegra/tegra2_emc.c:			dev_warn(&pdev->dev,
arch/arm/mach-tegra/tegra2_emc.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
arch/arm/mach-tegra/tegra2_emc.c:	pdata->tables = devm_kzalloc(&pdev->dev,
arch/arm/mach-tegra/tegra2_emc.c:			dev_err(&pdev->dev, "no clock-frequency in %s\n",
arch/arm/mach-tegra/tegra2_emc.c:			dev_err(&pdev->dev,
arch/arm/mach-tegra/tegra2_emc.c:	WARN_ON(pdev->dev.platform_data);
arch/arm/mach-tegra/tegra2_emc.c:	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
arch/arm/mach-tegra/tegra2_emc.c:	pdata->tables = devm_kzalloc(&pdev->dev, sizeof(*pdata->tables),
arch/arm/mach-tegra/tegra2_emc.c:	dev_info(&pdev->dev, "no tables provided, using %ld kHz emc, "
arch/arm/mach-tegra/tegra2_emc.c:		dev_err(&pdev->dev, "disabled per module parameter\n");
arch/arm/mach-tegra/tegra2_emc.c:	emc_regbase = devm_ioremap_resource(&pdev->dev, res);
arch/arm/mach-tegra/tegra2_emc.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-tegra/tegra2_emc.c:	pdev->dev.platform_data = pdata;
arch/arm/mach-meson8/pm.c:	pdev->dev.platform_data=&aml_pm_pdata;
arch/arm/mach-meson8/pm.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-meson8/pm.c:		dev_err(&pdev->dev, "cannot get platform data\n");
arch/arm/mach-meson8/vpu.c:	vpu_np = pdev->dev.of_node;
arch/arm/mach-meson8/gpio.c:		amlogic_gpio_chip.of_node = pdev->dev.of_node;
arch/arm/mach-meson8/gpio.c:	dev_info(&pdev->dev, "Probed amlogic GPIO driver\n");
arch/arm/mach-mmp/sram.c:	struct sram_platdata *pdata = pdev->dev.platform_data;
arch/arm/mach-mmp/sram.c:		dev_err(&pdev->dev, "no memory resource defined\n");
arch/arm/mach-mmp/sram.c:		dev_err(&pdev->dev, "create pool failed\n");
arch/arm/mach-mmp/sram.c:		dev_err(&pdev->dev, "add new chunk failed\n");
arch/arm/mach-mmp/sram.c:	dev_info(&pdev->dev, "initialized\n");
arch/arm/mach-mmp/devices.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
arch/arm/mach-meson6tv/pm.c:	pdev->dev.platform_data = &m6tv_pm_pdata;
arch/arm/mach-meson6tv/pm.c:	pdata = pdev->dev.platform_data;
arch/arm/mach-meson6tv/pm.c:		dev_err(&pdev->dev, "cannot get platform data\n");
arch/arm/mach-meson6tv/pm.c:		dev_err(&pdev->dev, "cannot allocate SRAM memory\n");
arch/arm/mach-meson6tv/pm.c:		dev_err(&pdev->dev, "cannot allocate SRAM memory\n");
arch/arm/mach-meson6tv/gpio.c:	m6tv_gpio_chip.of_node = pdev->dev.of_node;
arch/arm/plat-omap/dma.c:	p = pdev->dev.platform_data;
arch/arm/plat-omap/dma.c:		dev_err(&pdev->dev,
arch/arm/plat-omap/dma.c:			dev_err(&pdev->dev, "failed: request IRQ %d", dma_irq);
arch/arm/plat-omap/dma.c:			dev_err(&pdev->dev, "set_up failed for IRQ %d for DMA (error %d)\n",
arch/arm/plat-omap/dma.c:	dev_err(&pdev->dev, "unable to request IRQ %d for DMA (error %d)\n",
arch/arm/plat-omap/dmtimer.c:		dev_err(&timer->pdev->dev, "Timer failed to reset\n");
arch/arm/plat-omap/dmtimer.c:		timer->fclk = clk_get(&timer->pdev->dev, "fck");
arch/arm/plat-omap/dmtimer.c:			dev_err(&timer->pdev->dev, ": No fclk handle.\n");
arch/arm/plat-omap/dmtimer.c:			if (id == t->pdev->id) {
arch/arm/plat-omap/dmtimer.c:			if (np == t->pdev->dev.of_node) {
arch/arm/plat-omap/dmtimer.c:	pm_runtime_get_sync(&timer->pdev->dev);
arch/arm/plat-omap/dmtimer.c:			c = timer->get_context_loss_count(&timer->pdev->dev);
arch/arm/plat-omap/dmtimer.c:	pm_runtime_put_sync(&timer->pdev->dev);
arch/arm/plat-omap/dmtimer.c:	if (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev))) {
arch/arm/plat-omap/dmtimer.c:	pdata = timer->pdev->dev.platform_data;
arch/arm/plat-omap/dmtimer.c:	parent = clk_get(&timer->pdev->dev, parent_name);
arch/arm/plat-omap/dmtimer.c:	if (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev))) {
arch/arm/plat-omap/dmtimer.c:	if (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev)))
arch/arm/plat-omap/dmtimer.c:	if (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev))) {
arch/arm/plat-omap/dmtimer.c:	if (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev))) {
arch/arm/plat-omap/dmtimer.c:	struct device *dev = &pdev->dev;
arch/arm/plat-omap/dmtimer.c:		timer->id = pdev->id;
arch/arm/plat-omap/dmtimer.c:		if (!strcmp(dev_name(&timer->pdev->dev),
arch/arm/plat-omap/dmtimer.c:			    dev_name(&pdev->dev))) {
arch/arm/mach-s3c64xx/setup-usb-phy.c:	xusbxti = clk_get(&pdev->dev, "xusbxti");
arch/arm/mach-s3c64xx/dev-audio.c:	switch (pdev->id) {
arch/arm/mach-s3c64xx/dev-audio.c:			pdev->id);
arch/arm/mach-s3c64xx/dev-audio.c:	switch (pdev->id) {
arch/arm/mach-s3c64xx/dev-audio.c:			pdev->id);
arch/arm/plat-samsung/setup-mipiphy.c:	return __s5p_mipi_phy_control(pdev->id, on, S5P_MIPI_DPHY_MRESETN);
arch/arm/plat-samsung/adc.c:#define adc_dbg(_adc, msg...) dev_dbg(&(_adc)->pdev->dev, msg)
arch/arm/plat-samsung/adc.c:		dev_err(&pdev->dev, "no memory for adc client\n");
arch/arm/plat-samsung/adc.c:		dev_warn(&adc->pdev->dev, "%s: no adc pending\n", __func__);
arch/arm/plat-samsung/adc.c:	struct device *dev = &pdev->dev;
arch/arm/plat-samsung/platformdata.c:		printk(KERN_ERR "%s: no platform data supplied\n", pdev->name);
arch/arm/plat-samsung/platformdata.c:		printk(KERN_ERR "%s: cannot clone platform data\n", pdev->name);
arch/arm/plat-samsung/platformdata.c:	pdev->dev.platform_data = npd;
arch/arm/mach-meson6/pm.c:	pdev->dev.platform_data=&aml_pm_pdata;
arch/arm/mach-meson6/pm.c:    pdata = pdev->dev.platform_data;
arch/arm/mach-meson6/pm.c:        dev_err(&pdev->dev, "cannot get platform data\n");
arch/arm/mach-meson6/pm.c:        dev_err(&pdev->dev, "cannot allocate SRAM memory\n");
arch/arm/mach-meson6/pm.c:        dev_err(&pdev->dev, "cannot allocate SRAM memory\n");
arch/arm/mach-meson6/gpio.c:		amlogic_gpio_chip.of_node = pdev->dev.of_node;
arch/arm/mach-meson6/gpio.c:	dev_info(&pdev->dev, "Probed amlogic GPIO driver\n");
arch/x86/pci/sta2x11-fixup.c:	instance->bus0 = pdev->subordinate->number + 1;
arch/x86/pci/sta2x11-fixup.c:		dev_info(&pdev->dev, "Using SWIOTLB (size %i)\n", size);
arch/x86/pci/sta2x11-fixup.c:			dev_emerg(&pdev->dev, "init swiotlb failed\n");
arch/x86/pci/sta2x11-fixup.c:		ep = pdev->bus->number - instance->bus0;
arch/x86/pci/sta2x11-fixup.c:	return pdev->bus->number - instance->bus0;
arch/x86/pci/sta2x11-fixup.c:	pdev->dev.archdata.dma_ops = &sta2x11_dma_ops;
arch/x86/pci/sta2x11-fixup.c:	dev_info(&pdev->dev,
arch/x86/pci/fixup.c:	if ((pbus = pdev->subordinate) == NULL)
arch/x86/pci/fixup.c:	if ((pdev->device < PCI_DEVICE_ID_INTEL_MCH_PA) ||
arch/x86/pci/fixup.c:	    (pdev->device > PCI_DEVICE_ID_INTEL_MCH_PC1))
arch/x86/pci/fixup.c:		for (i = GET_INDEX(pdev->device, 0); i <= GET_INDEX(pdev->device, 7); ++i)
arch/x86/pci/fixup.c:			quirk_aspm_offset[GET_INDEX(pdev->device, dev->devfn)] = cap_base + 0x10;
arch/x86/pci/fixup.c:	bus = pdev->bus;
arch/x86/pci/fixup.c:		pdev->resource[PCI_ROM_RESOURCE].flags |= IORESOURCE_ROM_SHADOW;
arch/x86/pci/fixup.c:		dev_printk(KERN_DEBUG, &pdev->dev, "Boot video device\n");
arch/x86/include/asm/amd_nb.h:		if (pci_domain_nr(misc->bus) == pci_domain_nr(pdev->bus) &&
arch/x86/include/asm/amd_nb.h:		    PCI_SLOT(misc->devfn) == PCI_SLOT(pdev->devfn))
arch/x86/platform/olpc/olpc-xo1-pm.c:		dev_err(&pdev->dev, "can't fetch device resource info\n");
arch/x86/platform/olpc/olpc-xo1-pm.c:	if (strcmp(pdev->name, "cs5535-pms") == 0)
arch/x86/platform/olpc/olpc-xo1-pm.c:	else if (strcmp(pdev->name, "olpc-xo1-pm-acpi") == 0)
arch/x86/platform/olpc/olpc-xo1-pm.c:	if (strcmp(pdev->name, "cs5535-pms") == 0)
arch/x86/platform/olpc/olpc-xo1-pm.c:	else if (strcmp(pdev->name, "olpc-xo1-pm-acpi") == 0)
arch/x86/platform/olpc/olpc-xo1-sci.c:	dev_dbg(&pdev->dev, "sts %x gpe %x\n", sts, gpe);
arch/x86/platform/olpc/olpc-xo1-sci.c:		dev_info(&pdev->dev, "SCI is mapped to IRQ %d\n", sci_irq);
arch/x86/platform/olpc/olpc-xo1-sci.c:		dev_info(&pdev->dev, "SCI unmapped. Mapping to IRQ 3\n");
arch/x86/platform/olpc/olpc-xo1-sci.c:		dev_err(&pdev->dev, "can't request interrupt\n");
arch/x86/platform/olpc/olpc-xo1-sci.c:	power_button_idev->dev.parent = &pdev->dev;
arch/x86/platform/olpc/olpc-xo1-sci.c:		dev_err(&pdev->dev, "failed to register power button: %d\n", r);
arch/x86/platform/olpc/olpc-xo1-sci.c:	ebook_switch_idev->dev.parent = &pdev->dev;
arch/x86/platform/olpc/olpc-xo1-sci.c:		dev_err(&pdev->dev, "failed to register ebook switch: %d\n", r);
arch/x86/platform/olpc/olpc-xo1-sci.c:	lid_switch_idev->dev.parent = &pdev->dev;
arch/x86/platform/olpc/olpc-xo1-sci.c:		dev_err(&pdev->dev, "failed to register lid switch: %d\n", r);
arch/x86/platform/olpc/olpc-xo1-sci.c:		dev_err(&pdev->dev, "failed to create wake mode attr: %d\n", r);
arch/x86/platform/olpc/olpc-xo1-sci.c:		dev_err(&pdev->dev, "can't fetch device resource info\n");
arch/x86/platform/mrst/mrst.c:	pdev->dev.platform_data = pdata;
arch/x86/platform/scx200/scx200_32.c:	if (pdev->device == PCI_DEVICE_ID_NS_SCx200_BRIDGE ||
arch/x86/platform/scx200/scx200_32.c:	    pdev->device == PCI_DEVICE_ID_NS_SC1100_BRIDGE) {
arch/x86/platform/ts5500/ts5500.c:	sbc = devm_kzalloc(&pdev->dev, sizeof(struct ts5500_sbc), GFP_KERNEL);
arch/x86/platform/ts5500/ts5500.c:	err = sysfs_create_group(&pdev->dev.kobj, &ts5500_attr_group);
arch/x86/platform/ts5500/ts5500.c:	ts5500_dio1_pdev.dev.parent = &pdev->dev;
arch/x86/platform/ts5500/ts5500.c:		dev_warn(&pdev->dev, "DIO1 block registration failed\n");
arch/x86/platform/ts5500/ts5500.c:	ts5500_dio2_pdev.dev.parent = &pdev->dev;
arch/x86/platform/ts5500/ts5500.c:		dev_warn(&pdev->dev, "DIO2 block registration failed\n");
arch/x86/platform/ts5500/ts5500.c:	if (led_classdev_register(&pdev->dev, &ts5500_led_cdev))
arch/x86/platform/ts5500/ts5500.c:		dev_warn(&pdev->dev, "LED registration failed\n");
arch/x86/platform/ts5500/ts5500.c:		ts5500_adc_pdev.dev.parent = &pdev->dev;
arch/x86/platform/ts5500/ts5500.c:			dev_warn(&pdev->dev, "ADC registration failed\n");
arch/x86/kernel/cpu/perf_event_intel_uncore.c:	phys_id = pcibus_to_physid[pdev->bus->number];
arch/x86/kernel/cpu/perf_event_intel_uncore.c:		if (pmu->func_id == pdev->devfn)
arch/x86/kernel/cpu/perf_event_intel_uncore.c:			pmu->func_id = pdev->devfn;
arch/x86/kernel/cpu/perf_event_intel_uncore.c:	int cpu, phys_id = pcibus_to_physid[pdev->bus->number];
arch/x86/kernel/microcode_core.c:	ustate = microcode_ops->request_microcode_fw(cpu, &microcode_pdev->dev, true);
arch/x86/kernel/microcode_core.c:	ustate = microcode_ops->request_microcode_fw(cpu, &microcode_pdev->dev,
arch/x86/kernel/pci-calgary_64.c:	pbus = pdev->bus;
arch/x86/kernel/apic/x2apic_uv_x.c:			pdev->devfn, decode, command_bits, flags);
arch/x86/kernel/apic/x2apic_uv_x.c:	domain = pci_domain_nr(pdev->bus);
arch/x86/kernel/apic/x2apic_uv_x.c:	bus = pdev->bus->number;
arch/x86/kernel/probe_roms.c:	struct pci_driver *drv = pdev->driver;
arch/x86/kernel/probe_roms.c:	if (pdev->vendor == vendor && pdev->device == device)
arch/x86/kernel/acpi/boot.c:	number = pdev->bus->number;
arch/x86/kernel/acpi/boot.c:	devfn = pdev->devfn;
arch/x86/kernel/acpi/boot.c:	pin = pdev->pin;
arch/alpha/kernel/pci-sysfs.c:		if (res == &pdev->resource[i])
arch/alpha/kernel/pci-sysfs.c:	return hose_mmap_page_range(pdev->sysdata, vma, mmap_type, sparse);
arch/alpha/kernel/pci-sysfs.c:		res_attr = pdev->res_attr[i];
arch/alpha/kernel/pci-sysfs.c:			sysfs_remove_bin_file(&pdev->dev.kobj, res_attr);
arch/alpha/kernel/pci-sysfs.c:		res_attr = pdev->res_attr_wc[i];
arch/alpha/kernel/pci-sysfs.c:			sysfs_remove_bin_file(&pdev->dev.kobj, res_attr);
arch/alpha/kernel/pci-sysfs.c:	struct pci_controller *hose = pdev->sysdata;
arch/alpha/kernel/pci-sysfs.c:	pcibios_resource_to_bus(pdev, &bar, &pdev->resource[num]);
arch/alpha/kernel/pci-sysfs.c:	res_attr->private = &pdev->resource[num];
arch/alpha/kernel/pci-sysfs.c:	return sysfs_create_bin_file(&pdev->dev.kobj, res_attr);
arch/alpha/kernel/pci-sysfs.c:	struct pci_controller *hose = pdev->sysdata;
arch/alpha/kernel/pci-sysfs.c:	if (pdev->resource[num].flags & IORESOURCE_MEM) {
arch/alpha/kernel/pci-sysfs.c:	pdev->res_attr[num] = attr;
arch/alpha/kernel/pci-sysfs.c:	pdev->res_attr_wc[num] = attr;
arch/alpha/kernel/pci_iommu.c:	struct pci_controller *hose = pdev ? pdev->sysdata : pci_isa_hose;
arch/alpha/kernel/pci_iommu.c:	dma_addr_t max_dma = pdev ? pdev->dma_mask : ISA_DMA_MASK;
arch/alpha/kernel/pci_iommu.c:	struct device *dev = pdev ? &pdev->dev : NULL;
arch/alpha/kernel/pci_iommu.c:	dac_allowed = pdev ? pci_dac_dma_supported(pdev, pdev->dma_mask) : 0; 
arch/alpha/kernel/pci_iommu.c:	struct pci_controller *hose = pdev ? pdev->sysdata : pci_isa_hose;
arch/alpha/kernel/pci_iommu.c:	dac_allowed = dev ? pci_dac_dma_supported(pdev, pdev->dma_mask) : 0;
arch/alpha/kernel/pci_iommu.c:		hose = pdev ? pdev->sysdata : pci_isa_hose;
arch/alpha/kernel/pci_iommu.c:		max_dma = pdev ? pdev->dma_mask : ISA_DMA_MASK;
arch/alpha/kernel/pci_iommu.c:	hose = pdev ? pdev->sysdata : pci_isa_hose;
arch/alpha/kernel/pci_iommu.c:	max_dma = pdev ? pdev->dma_mask : ISA_DMA_MASK;
arch/alpha/kernel/pci_iommu.c:	hose = pdev ? pdev->sysdata : pci_isa_hose;
arch/s390/pci/pci.c:	return (struct zpci_dev *) pdev->sysdata;
arch/s390/pci/pci.c:	list_for_each_entry(msi, &pdev->msi_list, list) {
arch/s390/pci/pci.c:		dev_err(&pdev->dev, "register MSI failed with: %d\n", rc);
arch/s390/pci/pci.c:		dev_err(&pdev->dev, "deregister MSI failed with: %d\n", rc);
arch/s390/pci/pci.c:	msi = list_first_entry(&pdev->msi_list, struct msi_desc, list);
arch/s390/pci/pci.c:	list_for_each_entry(msi, &pdev->msi_list, list)
arch/s390/pci/pci.c:		pdev->resource[i].start = (resource_size_t) pci_iomap(pdev, i, 0);
arch/s390/pci/pci.c:		pdev->resource[i].end = pdev->resource[i].start + len - 1;
arch/s390/pci/pci.c:			i, pdev->resource[i].start, pdev->resource[i].end);
arch/s390/pci/pci.c:		res = &pdev->resource[i];
arch/s390/pci/pci.c:	return zpci_sysfs_add_device(&pdev->dev);
arch/s390/pci/pci_clp.c:	dev_info(&zdev->pdev->dev, "disabling fn handle: 0x%x\n", fh);
arch/s390/pci/pci_dma.c:		dev_err(&zdev->pdev->dev, "Missing DMA table\n");
arch/s390/pci/pci_event.c:	dev_err(&zdev->pdev->dev, "event code: 0x%x\n", ccdf->pec);
arch/s390/pci/pci_event.c:		(zdev) ? dev_driver_string(&zdev->pdev->dev) : "?",
arch/s390/pci/pci_event.c:		(zdev) ? dev_name(&zdev->pdev->dev) : "?",
arch/s390/pci/pci_debug.c:	zdev->debugfs_dev = debugfs_create_dir(dev_name(&zdev->pdev->dev),
arch/avr32/mach-at32ap/pio.c:	bank = 'A' + pio->pdev->id;
arch/avr32/mach-at32ap/pio.c:	int gpio_irq_base = GPIO_IRQ_BASE + pdev->id * 32;
arch/avr32/mach-at32ap/pio.c:	BUG_ON(pdev->id >= MAX_NR_PIO_DEVICES);
arch/avr32/mach-at32ap/pio.c:	pio = &pio_dev[pdev->id];
arch/avr32/mach-at32ap/pio.c:	pio->chip.base = pdev->id * 32;
arch/avr32/mach-at32ap/pio.c:	pio->chip.dev = &pdev->dev;
arch/avr32/mach-at32ap/pio.c:	if (pdev->id > MAX_NR_PIO_DEVICES) {
arch/avr32/mach-at32ap/pio.c:		dev_err(&pdev->dev, "only %d PIO devices supported\n",
arch/avr32/mach-at32ap/pio.c:	pio = &pio_dev[pdev->id];
arch/avr32/mach-at32ap/pio.c:	snprintf(pio->name, sizeof(pio->name), "pio%d", pdev->id);
arch/avr32/mach-at32ap/pio.c:		dev_err(&pdev->dev, "no mmio resource defined\n");
arch/avr32/mach-at32ap/pio.c:	pio->clk = clk_get(&pdev->dev, "mck");
arch/avr32/mach-at32ap/pio.c:		dev_err(&pdev->dev, "no mck clock defined\n");
arch/avr32/mach-at32ap/extint.c:		dev_dbg(&pdev->dev, "missing regs and/or irq resource\n");
arch/avr32/mach-at32ap/extint.c:		dev_dbg(&pdev->dev, "no memory for eic structure\n");
arch/avr32/mach-at32ap/extint.c:	eic->first_irq = EIM_IRQ_BASE + 32 * pdev->id;
arch/avr32/mach-at32ap/extint.c:		dev_dbg(&pdev->dev, "failed to map regs\n");
arch/avr32/mach-at32ap/extint.c:	if (pdev->id == 0) {
arch/avr32/mach-at32ap/extint.c:	dev_info(&pdev->dev,
arch/avr32/mach-at32ap/extint.c:	dev_info(&pdev->dev,
arch/avr32/mach-at32ap/pdc.c:	pclk = clk_get(&pdev->dev, "pclk");
arch/avr32/mach-at32ap/pdc.c:		dev_err(&pdev->dev, "no pclk defined\n");
arch/avr32/mach-at32ap/pdc.c:	hclk = clk_get(&pdev->dev, "hclk");
arch/avr32/mach-at32ap/pdc.c:		dev_err(&pdev->dev, "no hclk defined\n");
arch/avr32/mach-at32ap/pdc.c:	dev_info(&pdev->dev, "Atmel Peripheral DMA Controller enabled\n");
arch/avr32/mach-at32ap/hsmc.c:	pclk = clk_get(&pdev->dev, "pclk");
arch/avr32/mach-at32ap/hsmc.c:	mck = clk_get(&pdev->dev, "mck");
arch/avr32/mach-at32ap/hsmc.c:	dev_info(&pdev->dev, "Atmel Static Memory Controller at 0x%08lx\n",
arch/avr32/mach-at32ap/at32ap700x.c:		atmel_psif0_pclk.dev = &pdev->dev;
arch/avr32/mach-at32ap/at32ap700x.c:		atmel_psif1_pclk.dev = &pdev->dev;
arch/avr32/mach-at32ap/at32ap700x.c:	if (PXSEG(pdev->resource[0].start) == P4SEG) {
arch/avr32/mach-at32ap/at32ap700x.c:		struct atmel_uart_data *data = pdev->dev.platform_data;
arch/avr32/mach-at32ap/at32ap700x.c:		data->regs = (void __iomem *)pdev->resource[0].start;
arch/avr32/mach-at32ap/at32ap700x.c:	pdev->id = line;
arch/avr32/mach-at32ap/at32ap700x.c:	pdata = pdev->dev.platform_data;
arch/avr32/mach-at32ap/at32ap700x.c:	memcpy(pdev->dev.platform_data, data, sizeof(struct macb_platform_data));
arch/avr32/mach-at32ap/at32ap700x.c:	atmel_twi0_pclk.dev = &pdev->dev;
arch/avr32/mach-at32ap/at32ap700x.c:	atmel_mci0_pclk.dev = &pdev->dev;
arch/avr32/mach-at32ap/at32ap700x.c:		pdev->resource[2].start = fbmem_start;
arch/avr32/mach-at32ap/at32ap700x.c:		pdev->resource[2].end = fbmem_start + fbmem_len - 1;
arch/avr32/mach-at32ap/at32ap700x.c:		pdev->resource[2].flags = IORESOURCE_MEM;
arch/avr32/mach-at32ap/at32ap700x.c:	info = pdev->dev.platform_data;
arch/avr32/mach-at32ap/at32ap700x.c:	pdev->name = "at32ap-lcdfb";
arch/avr32/mach-at32ap/at32ap700x.c:	atmel_pwm0_mck.dev = &pdev->dev;
arch/avr32/mach-at32ap/at32ap700x.c:	usba0_pclk.dev = &pdev->dev;
arch/avr32/mach-at32ap/at32ap700x.c:	usba0_hclk.dev = &pdev->dev;
arch/avr32/mach-at32ap/at32ap700x.c:	pdev->resource[1].start = EIM_IRQ_BASE + extint;
arch/avr32/mach-at32ap/at32ap700x.c:	pdev->resource[1].end = pdev->resource[1].start;
arch/avr32/mach-at32ap/at32ap700x.c:	atmel_ac97c0_pclk.dev = &pdev->dev;
arch/avr32/mach-at32ap/at32ap700x.c:	abdac0_pclk.dev = &pdev->dev;
arch/avr32/mach-at32ap/at32ap700x.c:	abdac0_sample_clk.dev = &pdev->dev;
arch/avr32/boards/atstk1000/atstk1002.c:	if (pdev->id >= ARRAY_SIZE(hw_addr))
arch/avr32/boards/atstk1000/atstk1002.c:	addr = hw_addr[pdev->id].addr;
arch/avr32/boards/atstk1000/atstk1002.c:	pclk = clk_get(&pdev->dev, "pclk");
arch/avr32/boards/mimc200/setup.c:	if (pdev->id >= ARRAY_SIZE(hw_addr))
arch/avr32/boards/mimc200/setup.c:	addr = hw_addr[pdev->id].addr;
arch/avr32/boards/mimc200/setup.c:	pclk = clk_get(&pdev->dev, "pclk");
arch/avr32/boards/hammerhead/setup.c:	if (pdev->id >= ARRAY_SIZE(hw_addr))
arch/avr32/boards/hammerhead/setup.c:	addr = hw_addr[pdev->id].addr;
arch/avr32/boards/hammerhead/setup.c:	pclk = clk_get(&pdev->dev, "pclk");
arch/avr32/boards/atngw100/setup.c:	if (pdev->id >= ARRAY_SIZE(hw_addr))
arch/avr32/boards/atngw100/setup.c:	addr = hw_addr[pdev->id].addr;
arch/avr32/boards/atngw100/setup.c:	pclk = clk_get(&pdev->dev, "pclk");
arch/avr32/boards/favr-32/setup.c:	if (pdev->id >= ARRAY_SIZE(hw_addr))
arch/avr32/boards/favr-32/setup.c:	addr = hw_addr[pdev->id].addr;
arch/avr32/boards/favr-32/setup.c:	pclk = clk_get(&pdev->dev, "pclk");
arch/avr32/boards/favr-32/setup.c:	abdac = clk_get(&pdev->dev, "sample_clk");
arch/avr32/boards/merisc/setup.c:	if (pdev->id >= ARRAY_SIZE(hw_addr))
arch/avr32/boards/merisc/setup.c:	addr = hw_addr[pdev->id].addr;
arch/avr32/boards/merisc/setup.c:	pclk = clk_get(&pdev->dev, "pclk");
arch/mips/txx9/rbtx4927/setup.c:	pdev->dev.platform_data = &pdata;
arch/mips/txx9/generic/setup.c:	pdev->dev.platform_data = &iocled->pdata;
arch/mips/txx9/rbtx4939/setup.c:		rc = led_classdev_register(&pdev->dev, &led_dat->cdev);
arch/mips/mti-sead3/sead3-i2c-drv.c:	priv->adap.nr = pdev->id;
arch/mips/mti-sead3/sead3-i2c-drv.c:	priv->adap.dev.parent = &pdev->dev;
arch/mips/mti-sead3/sead3-i2c-drv.c:	dev_dbg(&pdev->dev, "i2c_platform_disable\n");
arch/mips/mti-sead3/sead3-i2c-drv.c:	dev_dbg(&pdev->dev, "sead3_i2c_platform_setup\n");
arch/mips/mti-sead3/sead3-pic32-i2c-drv.c:					  pdev->name);
arch/mips/mti-sead3/sead3-pic32-i2c-drv.c:	priv->adap.nr = pdev->id;
arch/mips/mti-sead3/sead3-pic32-i2c-drv.c:	priv->adap.dev.parent = &pdev->dev;
arch/mips/mti-sead3/sead3-pic32-i2c-drv.c:	dev_dbg(&pdev->dev, "i2c_platform_disable\n");
arch/mips/mti-sead3/sead3-pic32-i2c-drv.c:	dev_dbg(&pdev->dev, "i2c_platform_setup\n");
arch/mips/mti-sead3/leds-sead3.c:	ret = led_classdev_register(&pdev->dev, &sead3_pled);
arch/mips/mti-sead3/leds-sead3.c:	ret = led_classdev_register(&pdev->dev, &sead3_fled);
arch/mips/bcm63xx/dev-enet.c:	dpd = pdev->dev.platform_data;
arch/mips/lantiq/xway/dma.c:	ltq_dma_membase = devm_ioremap_resource(&pdev->dev, res);
arch/mips/lantiq/xway/dma.c:	clk = clk_get(&pdev->dev, NULL);
arch/mips/lantiq/xway/dma.c:	dev_info(&pdev->dev,
arch/mips/lantiq/xway/xrx200_phy_fw.c:	if (of_property_read_string(pdev->dev.of_node, "firmware", &fw_name)) {
arch/mips/lantiq/xway/xrx200_phy_fw.c:		dev_err(&pdev->dev, "failed to load firmware filename\n");
arch/mips/lantiq/xway/xrx200_phy_fw.c:	dev_info(&pdev->dev, "requesting %s\n", fw_name);
arch/mips/lantiq/xway/xrx200_phy_fw.c:	if (request_firmware(&fw, fw_name, &pdev->dev)) {
arch/mips/lantiq/xway/xrx200_phy_fw.c:		dev_err(&pdev->dev, "failed to load firmware: %s\n", fw_name);
arch/mips/lantiq/xway/xrx200_phy_fw.c:	fw_addr = dma_alloc_coherent(&pdev->dev, size, &dev_addr, GFP_KERNEL);
arch/mips/lantiq/xway/xrx200_phy_fw.c:		dev_err(&pdev->dev, "failed to alloc firmware memory\n");
arch/mips/lantiq/xway/xrx200_phy_fw.c:	pp = of_find_property(pdev->dev.of_node, "phys", NULL);
arch/mips/lantiq/xway/xrx200_phy_fw.c:		ret = xrx200_gphy_boot(&pdev->dev, phyids[i], fw_addr);
arch/mips/lantiq/xway/gptu.c:	if (of_irq_to_resource_table(pdev->dev.of_node, irqres, 6) != 6) {
arch/mips/lantiq/xway/gptu.c:		dev_err(&pdev->dev, "Failed to get IRQ list\n");
arch/mips/lantiq/xway/gptu.c:	gptu_membase = devm_ioremap_resource(&pdev->dev, res);
arch/mips/lantiq/xway/gptu.c:	clk = clk_get(&pdev->dev, NULL);
arch/mips/lantiq/xway/gptu.c:		dev_err(&pdev->dev, "Failed to get clock\n");
arch/mips/lantiq/xway/gptu.c:		dev_err(&pdev->dev, "Failed to find magic\n");
arch/mips/lantiq/xway/gptu.c:	clkdev_add_gptu(&pdev->dev, "timer1a", TIMER1A);
arch/mips/lantiq/xway/gptu.c:	clkdev_add_gptu(&pdev->dev, "timer1b", TIMER1B);
arch/mips/lantiq/xway/gptu.c:	clkdev_add_gptu(&pdev->dev, "timer2a", TIMER2A);
arch/mips/lantiq/xway/gptu.c:	clkdev_add_gptu(&pdev->dev, "timer2b", TIMER2B);
arch/mips/lantiq/xway/gptu.c:	clkdev_add_gptu(&pdev->dev, "timer3a", TIMER3A);
arch/mips/lantiq/xway/gptu.c:	clkdev_add_gptu(&pdev->dev, "timer3b", TIMER3B);
arch/mips/lantiq/xway/gptu.c:	dev_info(&pdev->dev, "gptu: 6 timers loaded\n");
arch/mips/cavium-octeon/serial.c:	up.port.dev = &pdev->dev;
arch/mips/cavium-octeon/serial.c:		dev_err(&pdev->dev, "found no memory resource\n");
arch/mips/alchemy/common/platform.c:	unit = (pdev->id == 1) ?
arch/mips/alchemy/common/platform.c:	unit = (pdev->id == 1) ?
arch/mips/alchemy/common/platform.c:	pdev->name = "ohci-platform";
arch/mips/alchemy/common/platform.c:	pdev->id = 0;
arch/mips/alchemy/common/platform.c:	pdev->dev.dma_mask = &alchemy_ohci_dmamask;
arch/mips/alchemy/common/platform.c:	pdev->dev.platform_data = &alchemy_ohci_pdata;
arch/mips/alchemy/common/platform.c:		pdev->name = "ehci-platform";
arch/mips/alchemy/common/platform.c:		pdev->id = 0;
arch/mips/alchemy/common/platform.c:		pdev->dev.dma_mask = &alchemy_ehci_dmamask;
arch/mips/alchemy/common/platform.c:		pdev->dev.platform_data = &alchemy_ehci_pdata;
arch/mips/alchemy/common/platform.c:		pdev->name = "ohci-platform";
arch/mips/alchemy/common/platform.c:		pdev->id = 1;
arch/mips/alchemy/common/platform.c:		pdev->dev.dma_mask = &alchemy_ohci_dmamask;
arch/mips/alchemy/common/platform.c:		pdev->dev.platform_data = &alchemy_ohci_pdata;
arch/mips/loongson1/common/platform.c:	clk = clk_get(NULL, pdev->name);
arch/mips/loongson1/common/platform.c:			pdev->name, PTR_ERR(clk));
arch/mips/loongson1/common/platform.c:	for (p = pdev->dev.platform_data; p->flags != 0; ++p)
arch/mips/vr41xx/common/siu.c:		pdev->dev.platform_data = siu_type1_ports;
arch/mips/vr41xx/common/siu.c:		pdev->dev.platform_data = siu_type2_ports;
arch/mips/vr41xx/common/giu.c:		pdev->id = GPIO_50PINS_PULLUPDOWN;
arch/mips/vr41xx/common/giu.c:		pdev->id = GPIO_36PINS;
arch/mips/vr41xx/common/giu.c:		pdev->id = GPIO_48PINS_EDGE_SELECT;
arch/mips/ath79/dev-usb.c:	pdev->dev.dma_mask = &ath79_usb_dmamask;
arch/mips/ath79/dev-usb.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
arch/mips/cobalt/serial.c:	pdev->id = PLAT8250_DEV_PLATFORM;
arch/mips/cobalt/serial.c:	pdev->dev.platform_data = cobalt_serial8250_port;
arch/mips/lasat/serial.c:	pdev->id = PLAT8250_DEV_PLATFORM;
arch/mips/lasat/serial.c:	pdev->dev.platform_data = lasat_serial8250_port;
arch/mips/pci/fixup-fuloong2e.c:	sb_slot = PCI_SLOT(pdev->devfn);
arch/mips/pci/pci-ar724x.c:	id = pdev->id;
arch/mips/pci/pci-ar724x.c:	apc = devm_kzalloc(&pdev->dev, sizeof(struct ar724x_pci_controller),
arch/mips/pci/pci-ar724x.c:	apc->ctrl_base = devm_ioremap_resource(&pdev->dev, res);
arch/mips/pci/pci-ar724x.c:	apc->devcfg_base = devm_ioremap_resource(&pdev->dev, res);
arch/mips/pci/pci-ar724x.c:	apc->crp_base = devm_ioremap_resource(&pdev->dev, res);
arch/mips/pci/pci-ar724x.c:		dev_warn(&pdev->dev, "PCIe link is down\n");
arch/mips/pci/pci-ar71xx.c:	apc = devm_kzalloc(&pdev->dev, sizeof(struct ar71xx_pci_controller),
arch/mips/pci/pci-ar71xx.c:	apc->cfg_base = devm_ioremap_resource(&pdev->dev, res);
arch/mips/pci/pci-lantiq.c:	struct device_node *node = pdev->dev.of_node;
arch/mips/pci/pci-lantiq.c:	clk_pci = clk_get(&pdev->dev, NULL);
arch/mips/pci/pci-lantiq.c:		dev_err(&pdev->dev, "failed to get pci clock\n");
arch/mips/pci/pci-lantiq.c:	clk_external = clk_get(&pdev->dev, "external");
arch/mips/pci/pci-lantiq.c:		dev_err(&pdev->dev, "failed to get external pci clock\n");
arch/mips/pci/pci-lantiq.c:		int ret = devm_gpio_request(&pdev->dev,
arch/mips/pci/pci-lantiq.c:			dev_err(&pdev->dev,
arch/mips/pci/pci-lantiq.c:		dev_err(&pdev->dev, "missing memory reources\n");
arch/mips/pci/pci-lantiq.c:	ltq_pci_membase = devm_ioremap_resource(&pdev->dev, res_bridge);
arch/mips/pci/pci-lantiq.c:	ltq_pci_mapped_cfg = devm_ioremap_resource(&pdev->dev, res_cfg);
arch/mips/pci/pci-lantiq.c:	pci_load_of_ranges(&pci_controller, pdev->dev.of_node);
arch/mips/pci/pci-alchemy.c:	struct alchemy_pci_platdata *pd = pdev->dev.platform_data;
arch/mips/pci/pci-alchemy.c:		dev_err(&pdev->dev, "need platform data for PCI setup\n");
arch/mips/pci/pci-alchemy.c:		dev_err(&pdev->dev, "no memory for pcictl context\n");
arch/mips/pci/pci-alchemy.c:		dev_err(&pdev->dev, "no	 pcictl ctrl regs resource\n");
arch/mips/pci/pci-alchemy.c:	if (!request_mem_region(r->start, resource_size(r), pdev->name)) {
arch/mips/pci/pci-alchemy.c:		dev_err(&pdev->dev, "cannot claim pci regs\n");
arch/mips/pci/pci-alchemy.c:		dev_err(&pdev->dev, "cannot map pci regs\n");
arch/mips/pci/pci-alchemy.c:		dev_err(&pdev->dev, "cannot remap pci io space\n");
arch/mips/pci/pci-alchemy.c:		dev_info(&pdev->dev, "non-coherent PCI on Au1500 AA/AB/AC\n");
arch/mips/pci/pci-alchemy.c:		dev_err(&pdev->dev, "unable to get vm area\n");
arch/mips/pci/fixup-malta.c:	if (PCI_SLOT(pdev->devfn) == 10) {
arch/mips/pci/fixup-malta.c:	if (PCI_SLOT(pdev->devfn) == 10) {
arch/mips/include/asm/mach-ip27/dma-coherence.h:	(BRIDGE_CONTROLLER(pdev->bus)->baddr + (addr))
arch/mips/wrppmc/serial.c:	pdev->id = PLAT8250_DEV_PLATFORM;
arch/mips/wrppmc/serial.c:	pdev->dev.platform_data = wrppmc_serial8250_port;
arch/ia64/pci/fixup.c:	if ((pdev->class >> 8) != PCI_CLASS_DISPLAY_VGA)
arch/ia64/pci/fixup.c:	bus = pdev->bus;
arch/ia64/pci/fixup.c:		pdev->resource[PCI_ROM_RESOURCE].flags |= IORESOURCE_ROM_SHADOW;
arch/ia64/pci/fixup.c:		dev_printk(KERN_DEBUG, &pdev->dev, "Boot video device\n");
arch/ia64/sn/pci/tioca_provider.c:		if (pdev->class != (PCI_CLASS_DISPLAY_VGA << 8))
arch/ia64/sn/pci/tioca_provider.c:		if (pdev->class != (PCI_CLASS_DISPLAY_VGA << 8))
arch/ia64/sn/pci/tioca_provider.c:	if (pdev->dma_mask == ~0UL)
arch/ia64/sn/pci/tioca_provider.c:	else if (pdev->dma_mask == 0xffffffffffffUL)
arch/ia64/sn/pci/pci_dma.c:	node = pcibus_to_node(pdev->bus);
arch/ia64/sn/pci/tioce_provider.c:		    (pdev->bus->number < ce_kernel->ce_port1_secondary) ? 0 : 1;
arch/ia64/sn/pci/tioce_provider.c:	dma_mask = (barrier) ? pdev->dev.coherent_dma_mask : pdev->dma_mask;
arch/ia64/sn/kernel/msi_sn.c:	pdev = sn_pdev->pdi_linux_pcidev;
arch/ia64/sn/kernel/msi_sn.c:	pdev = sn_pdev->pdi_linux_pcidev;
arch/blackfin/mach-common/dpmc.c:	if (pdev->dev.platform_data)
arch/blackfin/mach-common/dpmc.c:		pdata = pdev->dev.platform_data;
arch/sh/drivers/push-switch.c:	kobject_uevent(&pdev->dev.kobj, KOBJ_CHANGE);
arch/sh/drivers/push-switch.c:	psw_info = pdev->dev.platform_data;
arch/sh/drivers/push-switch.c:		ret = device_create_file(&pdev->dev, &dev_attr_switch);
arch/sh/drivers/push-switch.c:			dev_err(&pdev->dev, "Failed creating device attrs\n");
arch/sh/drivers/push-switch.c:	struct push_switch_platform_info *psw_info = pdev->dev.platform_data;
arch/sh/drivers/push-switch.c:		device_remove_file(&pdev->dev, &dev_attr_switch);
arch/sh/drivers/heartbeat.c:	if (unlikely(pdev->num_resources != 1)) {
arch/sh/drivers/heartbeat.c:		dev_err(&pdev->dev, "invalid number of resources\n");
arch/sh/drivers/heartbeat.c:		dev_err(&pdev->dev, "invalid resource\n");
arch/sh/drivers/heartbeat.c:	if (pdev->dev.platform_data) {
arch/sh/drivers/heartbeat.c:		hd = pdev->dev.platform_data;
arch/sh/drivers/heartbeat.c:		dev_err(&pdev->dev, "ioremap failed\n");
arch/sh/drivers/heartbeat.c:		if (!pdev->dev.platform_data)
arch/sh/drivers/heartbeat.c:	if (!pdev->dev.platform_data)
arch/sh/drivers/dma/dma-sysfs.c:		dev_err(&info->pdev->dev, "Failed creating attrs\n");
arch/sh/drivers/dma/dma-sysfs.c:	return sysfs_create_link(&info->pdev->dev.kobj, &dev->kobj, name);
arch/sh/drivers/dma/dma-sysfs.c:	sysfs_remove_link(&info->pdev->dev.kobj, name);
arch/sh/boards/mach-highlander/psw.c:	struct push_switch_platform_info *psw_info = pdev->dev.platform_data;
arch/sh/boards/mach-landisk/psw.c:	struct push_switch_platform_info *psw_info = pdev->dev.platform_data;
arch/sh/mm/consistent.c:	r = pdev->resource + pdev->num_resources - 1;
arch/parisc/kernel/drivers.c:		return pdev->id.hw_type != HPHW_FAULTY;
arch/parisc/kernel/drivers.c:		if (pdev->hpa.start == d->hpa) {
arch/parisc/kernel/drivers.c:	get_node_path(&pdev->dev, path);
arch/parisc/kernel/drivers.c:	if (pdev->hw_path == d->id) {
arch/parisc/kernel/drivers.c:		unsigned int devfn = pdev->devfn;
arch/parisc/kernel/drivers.c:	id = PCI_SLOT(pdev->devfn) | (PCI_FUNC(pdev->devfn) << 5);
arch/sparc/kernel/time_32.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
arch/sparc/kernel/time_32.c:	struct m48t59_plat_data *pdata = pdev->dev.platform_data;
arch/sparc/kernel/pcic.c:			if(devfn == pdev->devfn)
arch/sparc/kernel/pci_sabre.c:		if (pdev->vendor == PCI_VENDOR_ID_SUN &&
arch/sparc/kernel/pci_sabre.c:		    pdev->device == PCI_DEVICE_ID_SUN_SIMBA) {
arch/sparc/kernel/pci.c:	dp = pdev->dev.of_node;
arch/sparc/kernel/pci.c:	struct pci_pbm_info *pbm = pdev->dev.archdata.host_controller;
arch/sparc/kernel/pci.c:	if ((pdev->class >> 8) == PCI_CLASS_BRIDGE_HOST)
arch/sparc/kernel/pci.c:		struct resource *rp = &pdev->resource[i];
arch/sparc/kernel/pci.c:	struct pci_pbm_info *pbm = pdev->dev.archdata.host_controller;
arch/sparc/kernel/pci.c:	struct pci_pbm_info *pbm = pdev->dev.archdata.host_controller;
arch/sparc/kernel/pci.c:		struct iommu *iommu = pdev->dev.archdata.iommu;
arch/sparc/kernel/pci.c:		if (pdev->vendor == PCI_VENDOR_ID_AL &&
arch/sparc/kernel/pci.c:		    pdev->device == PCI_DEVICE_ID_AL_M5451 &&
arch/sparc/kernel/pci.c:	struct pci_pbm_info *pbm = pdev->dev.archdata.host_controller;
arch/sparc/kernel/time_64.c:	void __iomem *regs = (void __iomem *) pdev->resource[0].start;
arch/sparc/kernel/time_64.c:	void __iomem *regs = (void __iomem *) pdev->resource[0].start;
arch/sparc/kernel/pci_msi.c:	struct pci_pbm_info *pbm = pdev->dev.archdata.host_controller;
arch/sparc/kernel/pci_msi.c:	struct pci_pbm_info *pbm = pdev->dev.archdata.host_controller;
arch/microblaze/pci/pci-common.c:	return device_create_file(&pdev->dev, &dev_attr_devspec);
arch/microblaze/pci/pci-common.c:			struct resource *rp = &pdev->resource[i];
arch/powerpc/include/asm/ppc-pci.h:	return (pdev && pdev->driver) ? pdev->driver->name : "<null>";
arch/powerpc/platforms/pasemi/misc.c:			i2c_register_board_info(PCI_FUNC(pdev->devfn), &info,
arch/powerpc/platforms/pasemi/dma_lib.c:	chan->ring_virt = dma_alloc_coherent(&dma_pdev->dev,
arch/powerpc/platforms/pasemi/dma_lib.c:	dma_free_coherent(&dma_pdev->dev, chan->ring_size * sizeof(u64),
arch/powerpc/platforms/pasemi/dma_lib.c:	return dma_alloc_coherent(&dma_pdev->dev, size, handle, GFP_KERNEL);
arch/powerpc/platforms/pasemi/dma_lib.c:	dma_free_coherent(&dma_pdev->dev, size, handle, GFP_KERNEL);
arch/powerpc/platforms/pasemi/dma_lib.c:	base_hw_irq = virq_to_hw(dma_pdev->irq);
arch/powerpc/platforms/pasemi/setup.c:	parent = pdev->socket->dev.parent;
arch/powerpc/platforms/cell/cbe_powerbutton.c:	dev->dev.parent = &button_pdev->dev;
arch/powerpc/platforms/cell/beat_iommu.c:	celleb_dma_dev_setup(&pdev->dev);
arch/powerpc/platforms/wsp/wsp_pci.c:	struct dev_archdata *archdata = &pdev->dev.archdata;
arch/powerpc/platforms/wsp/wsp_pci.c:	struct pci_controller *hose = pci_bus_to_host(pdev->bus);
arch/powerpc/platforms/wsp/wsp_pci.c:	if (pdev->hdr_type == PCI_HEADER_TYPE_BRIDGE)
arch/powerpc/platforms/85xx/sgy_cts1000.c:	struct device_node *node = pdev->dev.of_node;
arch/powerpc/platforms/85xx/tqm85xx.c:	dev_info(&pdev->dev, "Using TI 1520 fixup on TQM85xx\n");
arch/powerpc/platforms/powernv/pci-p5ioc2.c:	set_iommu_table_base(&pdev->dev, &phb->p5ioc2.iommu_table);
arch/powerpc/platforms/powernv/pci.c:	struct pci_controller *hose = pci_bus_to_host(pdev->bus);
arch/powerpc/platforms/powernv/pci.c:	struct pci_controller *hose = pci_bus_to_host(pdev->bus);
arch/powerpc/platforms/powernv/pci.c:	list_for_each_entry(entry, &pdev->msi_list, list) {
arch/powerpc/platforms/powernv/pci.c:	struct pci_controller *hose = pci_bus_to_host(pdev->bus);
arch/powerpc/platforms/powernv/pci.c:	list_for_each_entry(entry, &pdev->msi_list, list) {
arch/powerpc/platforms/powernv/pci.c:	set_iommu_table_base(&pdev->dev, pdn->iommu_table);
arch/powerpc/platforms/powernv/pci.c:	struct pci_controller *hose = pci_bus_to_host(pdev->bus);
arch/powerpc/platforms/powernv/pci-ioda.c:		strlcpy(pfix, dev_name(&pe->pdev->dev),		\
arch/powerpc/platforms/powernv/pci-ioda.c:		parent = pe->pdev->bus->self;
arch/powerpc/platforms/powernv/pci-ioda.c:	set_iommu_table_base(&pdev->dev, &pe->tce32_table);
arch/powerpc/platforms/powernv/pci-ioda.c:		set_iommu_table_base(&pe->pdev->dev, tbl);
arch/powerpc/platforms/powernv/pci-ioda.c:		set_iommu_table_base(&pe->pdev->dev, tbl);
arch/powerpc/platforms/pseries/msi.c:	list_for_each_entry(entry, &pdev->msi_list, list) {
arch/powerpc/platforms/pseries/msi.c:	list_for_each_entry(entry, &pdev->msi_list, list) {
arch/powerpc/platforms/pseries/msi.c:	dev_info(&pdev->dev,
arch/powerpc/platforms/pseries/msi.c:	pci_read_config_dword(pdev, pdev->msi_cap + PCI_MSI_ADDRESS_HI, &addr_hi);
arch/powerpc/platforms/pseries/msi.c:	pci_write_config_dword(pdev, pdev->msi_cap + PCI_MSI_ADDRESS_LO, addr_lo);
arch/powerpc/platforms/pseries/msi.c:	pci_write_config_dword(pdev, pdev->msi_cap + PCI_MSI_ADDRESS_HI, 0);
arch/powerpc/platforms/pseries/msi.c:				if (pdev->bus->max_bus_speed != PCIE_SPEED_5_0GT)
arch/powerpc/platforms/pseries/msi.c:	list_for_each_entry(entry, &pdev->msi_list, list) {
arch/powerpc/platforms/pseries/msi.c:		dev_dbg(&pdev->dev, "rtas_msi: allocated virq %d\n", virq);
arch/powerpc/platforms/pseries/msi.c:	if (pdev->irq == NO_IRQ) {
arch/powerpc/platforms/pseries/msi.c:		dev_dbg(&pdev->dev, "rtas_msi: no LSI, nothing to do.\n");
arch/powerpc/platforms/pseries/msi.c:		dev_dbg(&pdev->dev, "rtas_msi: no req#msi/x, nothing to do.\n");
arch/powerpc/platforms/pseries/msi.c:	dev_dbg(&pdev->dev, "rtas_msi: disabling existing MSI.\n");
arch/powerpc/platforms/pseries/eeh_sysfs.c:	rc += device_create_file(&pdev->dev, &dev_attr_eeh_mode);
arch/powerpc/platforms/pseries/eeh_sysfs.c:	rc += device_create_file(&pdev->dev, &dev_attr_eeh_config_addr);
arch/powerpc/platforms/pseries/eeh_sysfs.c:	rc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);
arch/powerpc/platforms/pseries/eeh_sysfs.c:	device_remove_file(&pdev->dev, &dev_attr_eeh_mode);
arch/powerpc/platforms/pseries/eeh_sysfs.c:	device_remove_file(&pdev->dev, &dev_attr_eeh_config_addr);
arch/powerpc/platforms/pseries/eeh_sysfs.c:	device_remove_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);
arch/powerpc/platforms/pseries/eeh_pe.c:			pdev->error_state = pci_channel_io_frozen;
arch/powerpc/platforms/pseries/eeh_pe.c:			bus = pdev->bus;
arch/powerpc/platforms/pseries/eeh_driver.c:	if (pdev && pdev->dev.driver)
arch/powerpc/platforms/pseries/eeh_driver.c:		return pdev->dev.driver->name;
arch/powerpc/platforms/pseries/eeh_driver.c:	if (!pdev || !pdev->driver)
arch/powerpc/platforms/pseries/eeh_driver.c:	if (!try_module_get(pdev->driver->driver.owner))
arch/powerpc/platforms/pseries/eeh_driver.c:	return pdev->driver;
arch/powerpc/platforms/pseries/eeh_driver.c:	if (!pdev || !pdev->driver)
arch/powerpc/platforms/pseries/eeh_driver.c:	module_put(pdev->driver->driver.owner);
arch/powerpc/platforms/maple/pci.c:	if (pdev->vendor != PCI_VENDOR_ID_AMD ||
arch/powerpc/platforms/maple/pci.c:	    pdev->device != PCI_DEVICE_ID_AMD_8111_IDE)
arch/powerpc/kernel/pci-common.c:	return device_create_file(&pdev->dev, &dev_attr_devspec);
arch/powerpc/kernel/pci-common.c:			struct resource *rp = &pdev->resource[i];
arch/powerpc/kernel/isa-bridge.c:	struct pci_controller *hose = pci_bus_to_host(pdev->bus);
arch/powerpc/kernel/dma-swiotlb.c:	hose = pci_bus_to_host(pdev->bus);
arch/powerpc/kernel/dma-swiotlb.c:	sd = &pdev->dev.archdata;
arch/powerpc/kernel/setup-common.c:	pdev->archdata.dma_mask = DMA_BIT_MASK(32);
arch/powerpc/kernel/setup-common.c:	pdev->dev.dma_mask = &pdev->archdata.dma_mask;
arch/powerpc/kernel/setup-common.c: 	set_dma_ops(&pdev->dev, &dma_direct_ops);
arch/powerpc/sysdev/fsl_msi.c:	list_for_each_entry(entry, &pdev->msi_list, list) {
arch/powerpc/sysdev/fsl_msi.c:	struct pci_controller *hose = pci_bus_to_host(pdev->bus);
arch/powerpc/sysdev/fsl_msi.c:	struct pci_controller *hose = pci_bus_to_host(pdev->bus);
arch/powerpc/sysdev/fsl_msi.c:			dev_err(&pdev->dev,
arch/powerpc/sysdev/fsl_msi.c:	list_for_each_entry(entry, &pdev->msi_list, list) {
arch/powerpc/sysdev/fsl_msi.c:			dev_err(&pdev->dev, "could not allocate MSI interrupt\n");
arch/powerpc/sysdev/fsl_msi.c:			dev_err(&pdev->dev, "fail mapping hwirq %i\n", hwirq);
arch/powerpc/sysdev/mv64x60_dev.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
arch/powerpc/sysdev/mv64x60_dev.c:	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
arch/powerpc/sysdev/ppc4xx_msi.c:	dev_dbg(&pdev->dev, "PCIE-MSI:%s called. vec %x type %d\n",
arch/powerpc/sysdev/fsl_lbc.c:	struct fsl_lbc_ctrl *ctrl = dev_get_drvdata(&pdev->dev);
arch/powerpc/sysdev/fsl_lbc.c:	struct fsl_lbc_ctrl *ctrl = dev_get_drvdata(&pdev->dev);
arch/powerpc/sysdev/mv64x60_pci.c:	return sysfs_create_bin_file(&pdev->dev.kobj, &mv64x60_hs_reg_attr);
arch/powerpc/sysdev/mpic_pasemi_msi.c:	list_for_each_entry(entry, &pdev->msi_list, list) {
arch/powerpc/sysdev/mpic_pasemi_msi.c:	list_for_each_entry(entry, &pdev->msi_list, list) {
arch/powerpc/sysdev/mpic_u3msi.c:	for (bus = pdev->bus; bus && bus->self; bus = bus->parent) {
arch/powerpc/sysdev/mpic_u3msi.c:	struct pci_controller *hose = pci_bus_to_host(pdev->bus);
arch/powerpc/sysdev/mpic_u3msi.c:        list_for_each_entry(entry, &pdev->msi_list, list) {
arch/powerpc/sysdev/mpic_u3msi.c:	list_for_each_entry(entry, &pdev->msi_list, list) {
arch/powerpc/sysdev/fsl_pci.c:	dev = pdev->dev.of_node;
arch/powerpc/sysdev/fsl_pci.c:	hose->parent = &pdev->dev;
arch/powerpc/sysdev/fsl_pci.c:	node = pdev->dev.of_node;
arch/powerpc/sysdev/fsl_pci.c:		hose = pci_find_hose_for_OF_device(pdev->dev.of_node);
arch/tile/kernel/pci_gx.c:	set_dma_ops(&pdev->dev, gx_pci_dma_map_ops);
arch/tile/kernel/pci_gx.c:	set_dma_offset(&pdev->dev, TILE_PCI_MEM_MAP_BASE_OFFSET);
arch/tile/kernel/pci_gx.c:	pdev->dev.archdata.max_direct_dma_addr =
arch/tile/kernel/pci_gx.c:		dev_printk(KERN_INFO, &pdev->dev,
arch/tile/kernel/pci_gx.c:		dev_printk(KERN_INFO, &pdev->dev,
arch/tile/kernel/pci_gx.c:		dev_printk(KERN_INFO, &pdev->dev, "HV MSI config failed.\n");
lib/devres.c: *	base = devm_ioremap_resource(&pdev->dev, res);
lib/devres.c: *	base = devm_request_and_ioremap(&pdev->dev, res);
lib/devres.c:	dr = devres_find(&pdev->dev, pcim_iomap_release, NULL, NULL);
lib/devres.c:	dr = devres_get(&pdev->dev, new_dr, NULL, NULL);
lib/genalloc.c:	return dev_get_gen_pool(&pdev->dev);
Documentation/video4linux/soc-camera.txt:	ici->v4l2_dev.dev	= &pdev->dev;
Documentation/video4linux/soc-camera.txt:	ici->nr			= pdev->id;
Documentation/fb/ep93xx-fb.txt:		struct ep93xxfb_mach_info *mach_info = pdev->dev.platform_data;
Documentation/DocBook/drm.tmpl:		dev_printk(KERN_ERR, &dev->pdev->dev, "DDC bus registration "
Documentation/PCI/pci-error-recovery.txt:+       if (PCI_FUNC(pdev->devfn) == 0)
Documentation/PCI/pci-error-recovery.txt:+		pdev->needs_freset = 1;
Documentation/rpmsg.txt:	dev_info(&rpdev->dev, "chnl: 0x%x -> 0x%x\n", rpdev->src, rpdev->dst);
Documentation/rpmsg.txt:	dev_info(&rpdev->dev, "rpmsg sample client driver is removed\n");
Documentation/DMA-API-HOWTO.txt:your PCI device is pdev->dev (pdev is a pointer to the PCI device
Documentation/driver-model/platform.txt:calls to clk_get(&pdev->dev, clock_name) return them as needed.
Documentation/devicetree/bindings/pinctrl/samsung-pinctrl.txt:		pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
